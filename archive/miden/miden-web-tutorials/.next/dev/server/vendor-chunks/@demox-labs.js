"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@demox-labs";
exports.ids = ["vendor-chunks/@demox-labs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/Cargo-acbd8ac5.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/Cargo-acbd8ac5.js ***!
  \*******************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountArray: () => (/* binding */ AccountArray),\n/* harmony export */   AccountBuilder: () => (/* binding */ AccountBuilder),\n/* harmony export */   AccountBuilderResult: () => (/* binding */ AccountBuilderResult),\n/* harmony export */   AccountCode: () => (/* binding */ AccountCode),\n/* harmony export */   AccountComponent: () => (/* binding */ AccountComponent),\n/* harmony export */   AccountDelta: () => (/* binding */ AccountDelta),\n/* harmony export */   AccountFile: () => (/* binding */ AccountFile),\n/* harmony export */   AccountHeader: () => (/* binding */ AccountHeader),\n/* harmony export */   AccountId: () => (/* binding */ AccountId),\n/* harmony export */   AccountIdArray: () => (/* binding */ AccountIdArray),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   AccountStorage: () => (/* binding */ AccountStorage),\n/* harmony export */   AccountStorageDelta: () => (/* binding */ AccountStorageDelta),\n/* harmony export */   AccountStorageMode: () => (/* binding */ AccountStorageMode),\n/* harmony export */   AccountStorageRequirements: () => (/* binding */ AccountStorageRequirements),\n/* harmony export */   AccountType: () => (/* binding */ AccountType),\n/* harmony export */   AccountVaultDelta: () => (/* binding */ AccountVaultDelta),\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   AdviceInputs: () => (/* binding */ AdviceInputs),\n/* harmony export */   AdviceMap: () => (/* binding */ AdviceMap),\n/* harmony export */   AssetVault: () => (/* binding */ AssetVault),\n/* harmony export */   AuthSecretKey: () => (/* binding */ AuthSecretKey),\n/* harmony export */   BasicFungibleFaucetComponent: () => (/* binding */ BasicFungibleFaucetComponent),\n/* harmony export */   BlockHeader: () => (/* binding */ BlockHeader),\n/* harmony export */   ConsumableNoteRecord: () => (/* binding */ ConsumableNoteRecord),\n/* harmony export */   Endpoint: () => (/* binding */ Endpoint),\n/* harmony export */   ExecutedTransaction: () => (/* binding */ ExecutedTransaction),\n/* harmony export */   Felt: () => (/* binding */ Felt),\n/* harmony export */   FeltArray: () => (/* binding */ FeltArray),\n/* harmony export */   FetchedNote: () => (/* binding */ FetchedNote),\n/* harmony export */   FlattenedU8Vec: () => (/* binding */ FlattenedU8Vec),\n/* harmony export */   ForeignAccount: () => (/* binding */ ForeignAccount),\n/* harmony export */   ForeignAccountArray: () => (/* binding */ ForeignAccountArray),\n/* harmony export */   FungibleAsset: () => (/* binding */ FungibleAsset),\n/* harmony export */   FungibleAssetDelta: () => (/* binding */ FungibleAssetDelta),\n/* harmony export */   FungibleAssetDeltaItem: () => (/* binding */ FungibleAssetDeltaItem),\n/* harmony export */   GetProceduresResultItem: () => (/* binding */ GetProceduresResultItem),\n/* harmony export */   InputNote: () => (/* binding */ InputNote),\n/* harmony export */   InputNoteRecord: () => (/* binding */ InputNoteRecord),\n/* harmony export */   InputNoteState: () => (/* binding */ InputNoteState),\n/* harmony export */   InputNotes: () => (/* binding */ InputNotes),\n/* harmony export */   IntoUnderlyingByteSource: () => (/* binding */ IntoUnderlyingByteSource),\n/* harmony export */   IntoUnderlyingSink: () => (/* binding */ IntoUnderlyingSink),\n/* harmony export */   IntoUnderlyingSource: () => (/* binding */ IntoUnderlyingSource),\n/* harmony export */   JsAccountUpdate: () => (/* binding */ JsAccountUpdate),\n/* harmony export */   JsStateSyncUpdate: () => (/* binding */ JsStateSyncUpdate),\n/* harmony export */   JsStorageMapEntry: () => (/* binding */ JsStorageMapEntry),\n/* harmony export */   JsStorageSlot: () => (/* binding */ JsStorageSlot),\n/* harmony export */   JsVaultAsset: () => (/* binding */ JsVaultAsset),\n/* harmony export */   Library: () => (/* binding */ Library),\n/* harmony export */   MerklePath: () => (/* binding */ MerklePath),\n/* harmony export */   NetworkId: () => (/* binding */ NetworkId),\n/* harmony export */   Note: () => (/* binding */ Note),\n/* harmony export */   NoteAndArgs: () => (/* binding */ NoteAndArgs),\n/* harmony export */   NoteAndArgsArray: () => (/* binding */ NoteAndArgsArray),\n/* harmony export */   NoteAssets: () => (/* binding */ NoteAssets),\n/* harmony export */   NoteConsumability: () => (/* binding */ NoteConsumability),\n/* harmony export */   NoteDetails: () => (/* binding */ NoteDetails),\n/* harmony export */   NoteDetailsAndTag: () => (/* binding */ NoteDetailsAndTag),\n/* harmony export */   NoteDetailsAndTagArray: () => (/* binding */ NoteDetailsAndTagArray),\n/* harmony export */   NoteExecutionHint: () => (/* binding */ NoteExecutionHint),\n/* harmony export */   NoteExecutionMode: () => (/* binding */ NoteExecutionMode),\n/* harmony export */   NoteFile: () => (/* binding */ NoteFile),\n/* harmony export */   NoteFilter: () => (/* binding */ NoteFilter),\n/* harmony export */   NoteFilterTypes: () => (/* binding */ NoteFilterTypes),\n/* harmony export */   NoteHeader: () => (/* binding */ NoteHeader),\n/* harmony export */   NoteId: () => (/* binding */ NoteId),\n/* harmony export */   NoteIdAndArgs: () => (/* binding */ NoteIdAndArgs),\n/* harmony export */   NoteIdAndArgsArray: () => (/* binding */ NoteIdAndArgsArray),\n/* harmony export */   NoteInclusionProof: () => (/* binding */ NoteInclusionProof),\n/* harmony export */   NoteInputs: () => (/* binding */ NoteInputs),\n/* harmony export */   NoteLocation: () => (/* binding */ NoteLocation),\n/* harmony export */   NoteMetadata: () => (/* binding */ NoteMetadata),\n/* harmony export */   NoteRecipient: () => (/* binding */ NoteRecipient),\n/* harmony export */   NoteRecipientArray: () => (/* binding */ NoteRecipientArray),\n/* harmony export */   NoteScript: () => (/* binding */ NoteScript),\n/* harmony export */   NoteTag: () => (/* binding */ NoteTag),\n/* harmony export */   NoteType: () => (/* binding */ NoteType),\n/* harmony export */   OutputNote: () => (/* binding */ OutputNote),\n/* harmony export */   OutputNoteArray: () => (/* binding */ OutputNoteArray),\n/* harmony export */   OutputNotes: () => (/* binding */ OutputNotes),\n/* harmony export */   OutputNotesArray: () => (/* binding */ OutputNotesArray),\n/* harmony export */   Package: () => (/* binding */ Package),\n/* harmony export */   PartialNote: () => (/* binding */ PartialNote),\n/* harmony export */   ProvenTransaction: () => (/* binding */ ProvenTransaction),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   RpcClient: () => (/* binding */ RpcClient),\n/* harmony export */   Rpo256: () => (/* binding */ Rpo256),\n/* harmony export */   ScriptBuilder: () => (/* binding */ ScriptBuilder),\n/* harmony export */   SecretKey: () => (/* binding */ SecretKey),\n/* harmony export */   SerializedInputNoteData: () => (/* binding */ SerializedInputNoteData),\n/* harmony export */   SerializedOutputNoteData: () => (/* binding */ SerializedOutputNoteData),\n/* harmony export */   SerializedTransactionData: () => (/* binding */ SerializedTransactionData),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   SigningInputs: () => (/* binding */ SigningInputs),\n/* harmony export */   SigningInputsType: () => (/* binding */ SigningInputsType),\n/* harmony export */   SlotAndKeys: () => (/* binding */ SlotAndKeys),\n/* harmony export */   StorageMap: () => (/* binding */ StorageMap),\n/* harmony export */   StorageSlot: () => (/* binding */ StorageSlot),\n/* harmony export */   StorageSlotArray: () => (/* binding */ StorageSlotArray),\n/* harmony export */   SyncSummary: () => (/* binding */ SyncSummary),\n/* harmony export */   TestUtils: () => (/* binding */ TestUtils),\n/* harmony export */   TokenSymbol: () => (/* binding */ TokenSymbol),\n/* harmony export */   TransactionArgs: () => (/* binding */ TransactionArgs),\n/* harmony export */   TransactionFilter: () => (/* binding */ TransactionFilter),\n/* harmony export */   TransactionId: () => (/* binding */ TransactionId),\n/* harmony export */   TransactionProver: () => (/* binding */ TransactionProver),\n/* harmony export */   TransactionRecord: () => (/* binding */ TransactionRecord),\n/* harmony export */   TransactionRequest: () => (/* binding */ TransactionRequest),\n/* harmony export */   TransactionRequestBuilder: () => (/* binding */ TransactionRequestBuilder),\n/* harmony export */   TransactionResult: () => (/* binding */ TransactionResult),\n/* harmony export */   TransactionScript: () => (/* binding */ TransactionScript),\n/* harmony export */   TransactionScriptInputPair: () => (/* binding */ TransactionScriptInputPair),\n/* harmony export */   TransactionScriptInputPairArray: () => (/* binding */ TransactionScriptInputPairArray),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionStoreUpdate: () => (/* binding */ TransactionStoreUpdate),\n/* harmony export */   TransactionSummary: () => (/* binding */ TransactionSummary),\n/* harmony export */   WebClient: () => (/* binding */ WebClient),\n/* harmony export */   Word: () => (/* binding */ Word),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar dexie = {exports: {}};\n\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.0.8, Wed Jul 10 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n\n(function (module, exports) {\n\t(function (global, factory) {\n\t    module.exports = factory() ;\n\t})(commonjsGlobal, (function () {\n\t    /*! *****************************************************************************\n\t    Copyright (c) Microsoft Corporation.\n\t    Permission to use, copy, modify, and/or distribute this software for any\n\t    purpose with or without fee is hereby granted.\n\t    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n\t    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n\t    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n\t    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n\t    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n\t    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n\t    PERFORMANCE OF THIS SOFTWARE.\n\t    ***************************************************************************** */\n\t    var extendStatics = function(d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    function __extends(d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    }\n\t    var __assign = function() {\n\t        __assign = Object.assign || function __assign(t) {\n\t            for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t                s = arguments[i];\n\t                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n\t            }\n\t            return t;\n\t        };\n\t        return __assign.apply(this, arguments);\n\t    };\n\t    function __spreadArray(to, from, pack) {\n\t        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n\t            if (ar || !(i in from)) {\n\t                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n\t                ar[i] = from[i];\n\t            }\n\t        }\n\t        return to.concat(ar || Array.prototype.slice.call(from));\n\t    }\n\n\t    var _global = typeof globalThis !== 'undefined' ? globalThis :\n\t        typeof self !== 'undefined' ? self :\n\t            typeof window !== 'undefined' ? window :\n\t                commonjsGlobal;\n\n\t    var keys = Object.keys;\n\t    var isArray = Array.isArray;\n\t    if (typeof Promise !== 'undefined' && !_global.Promise) {\n\t        _global.Promise = Promise;\n\t    }\n\t    function extend(obj, extension) {\n\t        if (typeof extension !== 'object')\n\t            return obj;\n\t        keys(extension).forEach(function (key) {\n\t            obj[key] = extension[key];\n\t        });\n\t        return obj;\n\t    }\n\t    var getProto = Object.getPrototypeOf;\n\t    var _hasOwn = {}.hasOwnProperty;\n\t    function hasOwn(obj, prop) {\n\t        return _hasOwn.call(obj, prop);\n\t    }\n\t    function props(proto, extension) {\n\t        if (typeof extension === 'function')\n\t            extension = extension(getProto(proto));\n\t        (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n\t            setProp(proto, key, extension[key]);\n\t        });\n\t    }\n\t    var defineProperty = Object.defineProperty;\n\t    function setProp(obj, prop, functionOrGetSet, options) {\n\t        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n\t            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n\t            { value: functionOrGetSet, configurable: true, writable: true }, options));\n\t    }\n\t    function derive(Child) {\n\t        return {\n\t            from: function (Parent) {\n\t                Child.prototype = Object.create(Parent.prototype);\n\t                setProp(Child.prototype, \"constructor\", Child);\n\t                return {\n\t                    extend: props.bind(null, Child.prototype)\n\t                };\n\t            }\n\t        };\n\t    }\n\t    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\t    function getPropertyDescriptor(obj, prop) {\n\t        var pd = getOwnPropertyDescriptor(obj, prop);\n\t        var proto;\n\t        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n\t    }\n\t    var _slice = [].slice;\n\t    function slice(args, start, end) {\n\t        return _slice.call(args, start, end);\n\t    }\n\t    function override(origFunc, overridedFactory) {\n\t        return overridedFactory(origFunc);\n\t    }\n\t    function assert(b) {\n\t        if (!b)\n\t            throw new Error(\"Assertion Failed\");\n\t    }\n\t    function asap$1(fn) {\n\t        if (_global.setImmediate)\n\t            setImmediate(fn);\n\t        else\n\t            setTimeout(fn, 0);\n\t    }\n\t    function arrayToObject(array, extractor) {\n\t        return array.reduce(function (result, item, i) {\n\t            var nameAndValue = extractor(item, i);\n\t            if (nameAndValue)\n\t                result[nameAndValue[0]] = nameAndValue[1];\n\t            return result;\n\t        }, {});\n\t    }\n\t    function getByKeyPath(obj, keyPath) {\n\t        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n\t            return obj[keyPath];\n\t        if (!keyPath)\n\t            return obj;\n\t        if (typeof keyPath !== 'string') {\n\t            var rv = [];\n\t            for (var i = 0, l = keyPath.length; i < l; ++i) {\n\t                var val = getByKeyPath(obj, keyPath[i]);\n\t                rv.push(val);\n\t            }\n\t            return rv;\n\t        }\n\t        var period = keyPath.indexOf('.');\n\t        if (period !== -1) {\n\t            var innerObj = obj[keyPath.substr(0, period)];\n\t            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n\t        }\n\t        return undefined;\n\t    }\n\t    function setByKeyPath(obj, keyPath, value) {\n\t        if (!obj || keyPath === undefined)\n\t            return;\n\t        if ('isFrozen' in Object && Object.isFrozen(obj))\n\t            return;\n\t        if (typeof keyPath !== 'string' && 'length' in keyPath) {\n\t            assert(typeof value !== 'string' && 'length' in value);\n\t            for (var i = 0, l = keyPath.length; i < l; ++i) {\n\t                setByKeyPath(obj, keyPath[i], value[i]);\n\t            }\n\t        }\n\t        else {\n\t            var period = keyPath.indexOf('.');\n\t            if (period !== -1) {\n\t                var currentKeyPath = keyPath.substr(0, period);\n\t                var remainingKeyPath = keyPath.substr(period + 1);\n\t                if (remainingKeyPath === \"\")\n\t                    if (value === undefined) {\n\t                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n\t                            obj.splice(currentKeyPath, 1);\n\t                        else\n\t                            delete obj[currentKeyPath];\n\t                    }\n\t                    else\n\t                        obj[currentKeyPath] = value;\n\t                else {\n\t                    var innerObj = obj[currentKeyPath];\n\t                    if (!innerObj || !hasOwn(obj, currentKeyPath))\n\t                        innerObj = (obj[currentKeyPath] = {});\n\t                    setByKeyPath(innerObj, remainingKeyPath, value);\n\t                }\n\t            }\n\t            else {\n\t                if (value === undefined) {\n\t                    if (isArray(obj) && !isNaN(parseInt(keyPath)))\n\t                        obj.splice(keyPath, 1);\n\t                    else\n\t                        delete obj[keyPath];\n\t                }\n\t                else\n\t                    obj[keyPath] = value;\n\t            }\n\t        }\n\t    }\n\t    function delByKeyPath(obj, keyPath) {\n\t        if (typeof keyPath === 'string')\n\t            setByKeyPath(obj, keyPath, undefined);\n\t        else if ('length' in keyPath)\n\t            [].map.call(keyPath, function (kp) {\n\t                setByKeyPath(obj, kp, undefined);\n\t            });\n\t    }\n\t    function shallowClone(obj) {\n\t        var rv = {};\n\t        for (var m in obj) {\n\t            if (hasOwn(obj, m))\n\t                rv[m] = obj[m];\n\t        }\n\t        return rv;\n\t    }\n\t    var concat = [].concat;\n\t    function flatten(a) {\n\t        return concat.apply([], a);\n\t    }\n\t    var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n\t        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n\t    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n\t    function cloneSimpleObjectTree(o) {\n\t        var rv = {};\n\t        for (var k in o)\n\t            if (hasOwn(o, k)) {\n\t                var v = o[k];\n\t                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n\t            }\n\t        return rv;\n\t    }\n\t    function objectIsEmpty(o) {\n\t        for (var k in o)\n\t            if (hasOwn(o, k))\n\t                return false;\n\t        return true;\n\t    }\n\t    var circularRefs = null;\n\t    function deepClone(any) {\n\t        circularRefs = new WeakMap();\n\t        var rv = innerDeepClone(any);\n\t        circularRefs = null;\n\t        return rv;\n\t    }\n\t    function innerDeepClone(x) {\n\t        if (!x || typeof x !== 'object')\n\t            return x;\n\t        var rv = circularRefs.get(x);\n\t        if (rv)\n\t            return rv;\n\t        if (isArray(x)) {\n\t            rv = [];\n\t            circularRefs.set(x, rv);\n\t            for (var i = 0, l = x.length; i < l; ++i) {\n\t                rv.push(innerDeepClone(x[i]));\n\t            }\n\t        }\n\t        else if (intrinsicTypes.has(x.constructor)) {\n\t            rv = x;\n\t        }\n\t        else {\n\t            var proto = getProto(x);\n\t            rv = proto === Object.prototype ? {} : Object.create(proto);\n\t            circularRefs.set(x, rv);\n\t            for (var prop in x) {\n\t                if (hasOwn(x, prop)) {\n\t                    rv[prop] = innerDeepClone(x[prop]);\n\t                }\n\t            }\n\t        }\n\t        return rv;\n\t    }\n\t    var toString = {}.toString;\n\t    function toStringTag(o) {\n\t        return toString.call(o).slice(8, -1);\n\t    }\n\t    var iteratorSymbol = typeof Symbol !== 'undefined' ?\n\t        Symbol.iterator :\n\t        '@@iterator';\n\t    var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n\t        var i;\n\t        return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n\t    } : function () { return null; };\n\t    function delArrayItem(a, x) {\n\t        var i = a.indexOf(x);\n\t        if (i >= 0)\n\t            a.splice(i, 1);\n\t        return i >= 0;\n\t    }\n\t    var NO_CHAR_ARRAY = {};\n\t    function getArrayOf(arrayLike) {\n\t        var i, a, x, it;\n\t        if (arguments.length === 1) {\n\t            if (isArray(arrayLike))\n\t                return arrayLike.slice();\n\t            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n\t                return [arrayLike];\n\t            if ((it = getIteratorOf(arrayLike))) {\n\t                a = [];\n\t                while ((x = it.next()), !x.done)\n\t                    a.push(x.value);\n\t                return a;\n\t            }\n\t            if (arrayLike == null)\n\t                return [arrayLike];\n\t            i = arrayLike.length;\n\t            if (typeof i === 'number') {\n\t                a = new Array(i);\n\t                while (i--)\n\t                    a[i] = arrayLike[i];\n\t                return a;\n\t            }\n\t            return [arrayLike];\n\t        }\n\t        i = arguments.length;\n\t        a = new Array(i);\n\t        while (i--)\n\t            a[i] = arguments[i];\n\t        return a;\n\t    }\n\t    var isAsyncFunction = typeof Symbol !== 'undefined'\n\t        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n\t        : function () { return false; };\n\n\t    var dexieErrorNames = [\n\t        'Modify',\n\t        'Bulk',\n\t        'OpenFailed',\n\t        'VersionChange',\n\t        'Schema',\n\t        'Upgrade',\n\t        'InvalidTable',\n\t        'MissingAPI',\n\t        'NoSuchDatabase',\n\t        'InvalidArgument',\n\t        'SubTransaction',\n\t        'Unsupported',\n\t        'Internal',\n\t        'DatabaseClosed',\n\t        'PrematureCommit',\n\t        'ForeignAwait'\n\t    ];\n\t    var idbDomErrorNames = [\n\t        'Unknown',\n\t        'Constraint',\n\t        'Data',\n\t        'TransactionInactive',\n\t        'ReadOnly',\n\t        'Version',\n\t        'NotFound',\n\t        'InvalidState',\n\t        'InvalidAccess',\n\t        'Abort',\n\t        'Timeout',\n\t        'QuotaExceeded',\n\t        'Syntax',\n\t        'DataClone'\n\t    ];\n\t    var errorList = dexieErrorNames.concat(idbDomErrorNames);\n\t    var defaultTexts = {\n\t        VersionChanged: \"Database version changed by other database connection\",\n\t        DatabaseClosed: \"Database has been closed\",\n\t        Abort: \"Transaction aborted\",\n\t        TransactionInactive: \"Transaction has already completed or failed\",\n\t        MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n\t    };\n\t    function DexieError(name, msg) {\n\t        this.name = name;\n\t        this.message = msg;\n\t    }\n\t    derive(DexieError).from(Error).extend({\n\t        toString: function () { return this.name + \": \" + this.message; }\n\t    });\n\t    function getMultiErrorMessage(msg, failures) {\n\t        return msg + \". Errors: \" + Object.keys(failures)\n\t            .map(function (key) { return failures[key].toString(); })\n\t            .filter(function (v, i, s) { return s.indexOf(v) === i; })\n\t            .join('\\n');\n\t    }\n\t    function ModifyError(msg, failures, successCount, failedKeys) {\n\t        this.failures = failures;\n\t        this.failedKeys = failedKeys;\n\t        this.successCount = successCount;\n\t        this.message = getMultiErrorMessage(msg, failures);\n\t    }\n\t    derive(ModifyError).from(DexieError);\n\t    function BulkError(msg, failures) {\n\t        this.name = \"BulkError\";\n\t        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n\t        this.failuresByPos = failures;\n\t        this.message = getMultiErrorMessage(msg, this.failures);\n\t    }\n\t    derive(BulkError).from(DexieError);\n\t    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n\t    var BaseException = DexieError;\n\t    var exceptions = errorList.reduce(function (obj, name) {\n\t        var fullName = name + \"Error\";\n\t        function DexieError(msgOrInner, inner) {\n\t            this.name = fullName;\n\t            if (!msgOrInner) {\n\t                this.message = defaultTexts[name] || fullName;\n\t                this.inner = null;\n\t            }\n\t            else if (typeof msgOrInner === 'string') {\n\t                this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n\t                this.inner = inner || null;\n\t            }\n\t            else if (typeof msgOrInner === 'object') {\n\t                this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n\t                this.inner = msgOrInner;\n\t            }\n\t        }\n\t        derive(DexieError).from(BaseException);\n\t        obj[name] = DexieError;\n\t        return obj;\n\t    }, {});\n\t    exceptions.Syntax = SyntaxError;\n\t    exceptions.Type = TypeError;\n\t    exceptions.Range = RangeError;\n\t    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n\t        obj[name + \"Error\"] = exceptions[name];\n\t        return obj;\n\t    }, {});\n\t    function mapError(domError, message) {\n\t        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n\t            return domError;\n\t        var rv = new exceptionMap[domError.name](message || domError.message, domError);\n\t        if (\"stack\" in domError) {\n\t            setProp(rv, \"stack\", { get: function () {\n\t                    return this.inner.stack;\n\t                } });\n\t        }\n\t        return rv;\n\t    }\n\t    var fullNameExceptions = errorList.reduce(function (obj, name) {\n\t        if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n\t            obj[name + \"Error\"] = exceptions[name];\n\t        return obj;\n\t    }, {});\n\t    fullNameExceptions.ModifyError = ModifyError;\n\t    fullNameExceptions.DexieError = DexieError;\n\t    fullNameExceptions.BulkError = BulkError;\n\n\t    function nop() { }\n\t    function mirror(val) { return val; }\n\t    function pureFunctionChain(f1, f2) {\n\t        if (f1 == null || f1 === mirror)\n\t            return f2;\n\t        return function (val) {\n\t            return f2(f1(val));\n\t        };\n\t    }\n\t    function callBoth(on1, on2) {\n\t        return function () {\n\t            on1.apply(this, arguments);\n\t            on2.apply(this, arguments);\n\t        };\n\t    }\n\t    function hookCreatingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            var res = f1.apply(this, arguments);\n\t            if (res !== undefined)\n\t                arguments[0] = res;\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = null;\n\t            this.onerror = null;\n\t            var res2 = f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t            return res2 !== undefined ? res2 : res;\n\t        };\n\t    }\n\t    function hookDeletingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            f1.apply(this, arguments);\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = this.onerror = null;\n\t            f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t        };\n\t    }\n\t    function hookUpdatingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function (modifications) {\n\t            var res = f1.apply(this, arguments);\n\t            extend(modifications, res);\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = null;\n\t            this.onerror = null;\n\t            var res2 = f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t            return res === undefined ?\n\t                (res2 === undefined ? undefined : res2) :\n\t                (extend(res, res2));\n\t        };\n\t    }\n\t    function reverseStoppableEventChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            if (f2.apply(this, arguments) === false)\n\t                return false;\n\t            return f1.apply(this, arguments);\n\t        };\n\t    }\n\t    function promisableChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            var res = f1.apply(this, arguments);\n\t            if (res && typeof res.then === 'function') {\n\t                var thiz = this, i = arguments.length, args = new Array(i);\n\t                while (i--)\n\t                    args[i] = arguments[i];\n\t                return res.then(function () {\n\t                    return f2.apply(thiz, args);\n\t                });\n\t            }\n\t            return f2.apply(this, arguments);\n\t        };\n\t    }\n\n\t    var debug = typeof location !== 'undefined' &&\n\t        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\t    function setDebug(value, filter) {\n\t        debug = value;\n\t    }\n\n\t    var INTERNAL = {};\n\t    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n\t        [] :\n\t        (function () {\n\t            var globalP = Promise.resolve();\n\t            if (typeof crypto === 'undefined' || !crypto.subtle)\n\t                return [globalP, getProto(globalP), globalP];\n\t            var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n\t            return [\n\t                nativeP,\n\t                getProto(nativeP),\n\t                globalP\n\t            ];\n\t        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n\t    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n\t    var patchGlobalPromise = !!resolvedGlobalPromise;\n\t    function schedulePhysicalTick() {\n\t        queueMicrotask(physicalTick);\n\t    }\n\t    var asap = function (callback, args) {\n\t        microtickQueue.push([callback, args]);\n\t        if (needsNewPhysicalTick) {\n\t            schedulePhysicalTick();\n\t            needsNewPhysicalTick = false;\n\t        }\n\t    };\n\t    var isOutsideMicroTick = true,\n\t    needsNewPhysicalTick = true,\n\t    unhandledErrors = [],\n\t    rejectingErrors = [],\n\t    rejectionMapper = mirror;\n\t    var globalPSD = {\n\t        id: 'global',\n\t        global: true,\n\t        ref: 0,\n\t        unhandleds: [],\n\t        onunhandled: nop,\n\t        pgp: false,\n\t        env: {},\n\t        finalize: nop\n\t    };\n\t    var PSD = globalPSD;\n\t    var microtickQueue = [];\n\t    var numScheduledCalls = 0;\n\t    var tickFinalizers = [];\n\t    function DexiePromise(fn) {\n\t        if (typeof this !== 'object')\n\t            throw new TypeError('Promises must be constructed via new');\n\t        this._listeners = [];\n\t        this._lib = false;\n\t        var psd = (this._PSD = PSD);\n\t        if (typeof fn !== 'function') {\n\t            if (fn !== INTERNAL)\n\t                throw new TypeError('Not a function');\n\t            this._state = arguments[1];\n\t            this._value = arguments[2];\n\t            if (this._state === false)\n\t                handleRejection(this, this._value);\n\t            return;\n\t        }\n\t        this._state = null;\n\t        this._value = null;\n\t        ++psd.ref;\n\t        executePromiseTask(this, fn);\n\t    }\n\t    var thenProp = {\n\t        get: function () {\n\t            var psd = PSD, microTaskId = totalEchoes;\n\t            function then(onFulfilled, onRejected) {\n\t                var _this = this;\n\t                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n\t                var cleanup = possibleAwait && !decrementExpectedAwaits();\n\t                var rv = new DexiePromise(function (resolve, reject) {\n\t                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n\t                });\n\t                if (this._consoleTask)\n\t                    rv._consoleTask = this._consoleTask;\n\t                return rv;\n\t            }\n\t            then.prototype = INTERNAL;\n\t            return then;\n\t        },\n\t        set: function (value) {\n\t            setProp(this, 'then', value && value.prototype === INTERNAL ?\n\t                thenProp :\n\t                {\n\t                    get: function () {\n\t                        return value;\n\t                    },\n\t                    set: thenProp.set\n\t                });\n\t        }\n\t    };\n\t    props(DexiePromise.prototype, {\n\t        then: thenProp,\n\t        _then: function (onFulfilled, onRejected) {\n\t            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n\t        },\n\t        catch: function (onRejected) {\n\t            if (arguments.length === 1)\n\t                return this.then(null, onRejected);\n\t            var type = arguments[0], handler = arguments[1];\n\t            return typeof type === 'function' ? this.then(null, function (err) {\n\t                return err instanceof type ? handler(err) : PromiseReject(err);\n\t            })\n\t                : this.then(null, function (err) {\n\t                    return err && err.name === type ? handler(err) : PromiseReject(err);\n\t                });\n\t        },\n\t        finally: function (onFinally) {\n\t            return this.then(function (value) {\n\t                return DexiePromise.resolve(onFinally()).then(function () { return value; });\n\t            }, function (err) {\n\t                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n\t            });\n\t        },\n\t        timeout: function (ms, msg) {\n\t            var _this = this;\n\t            return ms < Infinity ?\n\t                new DexiePromise(function (resolve, reject) {\n\t                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n\t                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n\t                }) : this;\n\t        }\n\t    });\n\t    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n\t        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n\t    globalPSD.env = snapShot();\n\t    function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n\t        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t        this.resolve = resolve;\n\t        this.reject = reject;\n\t        this.psd = zone;\n\t    }\n\t    props(DexiePromise, {\n\t        all: function () {\n\t            var values = getArrayOf.apply(null, arguments)\n\t                .map(onPossibleParallellAsync);\n\t            return new DexiePromise(function (resolve, reject) {\n\t                if (values.length === 0)\n\t                    resolve([]);\n\t                var remaining = values.length;\n\t                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n\t                    values[i] = x;\n\t                    if (!--remaining)\n\t                        resolve(values);\n\t                }, reject); });\n\t            });\n\t        },\n\t        resolve: function (value) {\n\t            if (value instanceof DexiePromise)\n\t                return value;\n\t            if (value && typeof value.then === 'function')\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    value.then(resolve, reject);\n\t                });\n\t            var rv = new DexiePromise(INTERNAL, true, value);\n\t            return rv;\n\t        },\n\t        reject: PromiseReject,\n\t        race: function () {\n\t            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t            return new DexiePromise(function (resolve, reject) {\n\t                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n\t            });\n\t        },\n\t        PSD: {\n\t            get: function () { return PSD; },\n\t            set: function (value) { return PSD = value; }\n\t        },\n\t        totalEchoes: { get: function () { return totalEchoes; } },\n\t        newPSD: newScope,\n\t        usePSD: usePSD,\n\t        scheduler: {\n\t            get: function () { return asap; },\n\t            set: function (value) { asap = value; }\n\t        },\n\t        rejectionMapper: {\n\t            get: function () { return rejectionMapper; },\n\t            set: function (value) { rejectionMapper = value; }\n\t        },\n\t        follow: function (fn, zoneProps) {\n\t            return new DexiePromise(function (resolve, reject) {\n\t                return newScope(function (resolve, reject) {\n\t                    var psd = PSD;\n\t                    psd.unhandleds = [];\n\t                    psd.onunhandled = reject;\n\t                    psd.finalize = callBoth(function () {\n\t                        var _this = this;\n\t                        run_at_end_of_this_or_next_physical_tick(function () {\n\t                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n\t                        });\n\t                    }, psd.finalize);\n\t                    fn();\n\t                }, zoneProps, resolve, reject);\n\t            });\n\t        }\n\t    });\n\t    if (NativePromise) {\n\t        if (NativePromise.allSettled)\n\t            setProp(DexiePromise, \"allSettled\", function () {\n\t                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t                return new DexiePromise(function (resolve) {\n\t                    if (possiblePromises.length === 0)\n\t                        resolve([]);\n\t                    var remaining = possiblePromises.length;\n\t                    var results = new Array(remaining);\n\t                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n\t                        .then(function () { return --remaining || resolve(results); }); });\n\t                });\n\t            });\n\t        if (NativePromise.any && typeof AggregateError !== 'undefined')\n\t            setProp(DexiePromise, \"any\", function () {\n\t                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    if (possiblePromises.length === 0)\n\t                        reject(new AggregateError([]));\n\t                    var remaining = possiblePromises.length;\n\t                    var failures = new Array(remaining);\n\t                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n\t                        failures[i] = failure;\n\t                        if (!--remaining)\n\t                            reject(new AggregateError(failures));\n\t                    }); });\n\t                });\n\t            });\n\t    }\n\t    function executePromiseTask(promise, fn) {\n\t        try {\n\t            fn(function (value) {\n\t                if (promise._state !== null)\n\t                    return;\n\t                if (value === promise)\n\t                    throw new TypeError('A promise cannot be resolved with itself.');\n\t                var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\t                if (value && typeof value.then === 'function') {\n\t                    executePromiseTask(promise, function (resolve, reject) {\n\t                        value instanceof DexiePromise ?\n\t                            value._then(resolve, reject) :\n\t                            value.then(resolve, reject);\n\t                    });\n\t                }\n\t                else {\n\t                    promise._state = true;\n\t                    promise._value = value;\n\t                    propagateAllListeners(promise);\n\t                }\n\t                if (shouldExecuteTick)\n\t                    endMicroTickScope();\n\t            }, handleRejection.bind(null, promise));\n\t        }\n\t        catch (ex) {\n\t            handleRejection(promise, ex);\n\t        }\n\t    }\n\t    function handleRejection(promise, reason) {\n\t        rejectingErrors.push(reason);\n\t        if (promise._state !== null)\n\t            return;\n\t        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\t        reason = rejectionMapper(reason);\n\t        promise._state = false;\n\t        promise._value = reason;\n\t        addPossiblyUnhandledError(promise);\n\t        propagateAllListeners(promise);\n\t        if (shouldExecuteTick)\n\t            endMicroTickScope();\n\t    }\n\t    function propagateAllListeners(promise) {\n\t        var listeners = promise._listeners;\n\t        promise._listeners = [];\n\t        for (var i = 0, len = listeners.length; i < len; ++i) {\n\t            propagateToListener(promise, listeners[i]);\n\t        }\n\t        var psd = promise._PSD;\n\t        --psd.ref || psd.finalize();\n\t        if (numScheduledCalls === 0) {\n\t            ++numScheduledCalls;\n\t            asap(function () {\n\t                if (--numScheduledCalls === 0)\n\t                    finalizePhysicalTick();\n\t            }, []);\n\t        }\n\t    }\n\t    function propagateToListener(promise, listener) {\n\t        if (promise._state === null) {\n\t            promise._listeners.push(listener);\n\t            return;\n\t        }\n\t        var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n\t        if (cb === null) {\n\t            return (promise._state ? listener.resolve : listener.reject)(promise._value);\n\t        }\n\t        ++listener.psd.ref;\n\t        ++numScheduledCalls;\n\t        asap(callListener, [cb, promise, listener]);\n\t    }\n\t    function callListener(cb, promise, listener) {\n\t        try {\n\t            var ret, value = promise._value;\n\t            if (!promise._state && rejectingErrors.length)\n\t                rejectingErrors = [];\n\t            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n\t            if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n\t                markErrorAsHandled(promise);\n\t            }\n\t            listener.resolve(ret);\n\t        }\n\t        catch (e) {\n\t            listener.reject(e);\n\t        }\n\t        finally {\n\t            if (--numScheduledCalls === 0)\n\t                finalizePhysicalTick();\n\t            --listener.psd.ref || listener.psd.finalize();\n\t        }\n\t    }\n\t    function physicalTick() {\n\t        usePSD(globalPSD, function () {\n\t            beginMicroTickScope() && endMicroTickScope();\n\t        });\n\t    }\n\t    function beginMicroTickScope() {\n\t        var wasRootExec = isOutsideMicroTick;\n\t        isOutsideMicroTick = false;\n\t        needsNewPhysicalTick = false;\n\t        return wasRootExec;\n\t    }\n\t    function endMicroTickScope() {\n\t        var callbacks, i, l;\n\t        do {\n\t            while (microtickQueue.length > 0) {\n\t                callbacks = microtickQueue;\n\t                microtickQueue = [];\n\t                l = callbacks.length;\n\t                for (i = 0; i < l; ++i) {\n\t                    var item = callbacks[i];\n\t                    item[0].apply(null, item[1]);\n\t                }\n\t            }\n\t        } while (microtickQueue.length > 0);\n\t        isOutsideMicroTick = true;\n\t        needsNewPhysicalTick = true;\n\t    }\n\t    function finalizePhysicalTick() {\n\t        var unhandledErrs = unhandledErrors;\n\t        unhandledErrors = [];\n\t        unhandledErrs.forEach(function (p) {\n\t            p._PSD.onunhandled.call(null, p._value, p);\n\t        });\n\t        var finalizers = tickFinalizers.slice(0);\n\t        var i = finalizers.length;\n\t        while (i)\n\t            finalizers[--i]();\n\t    }\n\t    function run_at_end_of_this_or_next_physical_tick(fn) {\n\t        function finalizer() {\n\t            fn();\n\t            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n\t        }\n\t        tickFinalizers.push(finalizer);\n\t        ++numScheduledCalls;\n\t        asap(function () {\n\t            if (--numScheduledCalls === 0)\n\t                finalizePhysicalTick();\n\t        }, []);\n\t    }\n\t    function addPossiblyUnhandledError(promise) {\n\t        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n\t            unhandledErrors.push(promise);\n\t    }\n\t    function markErrorAsHandled(promise) {\n\t        var i = unhandledErrors.length;\n\t        while (i)\n\t            if (unhandledErrors[--i]._value === promise._value) {\n\t                unhandledErrors.splice(i, 1);\n\t                return;\n\t            }\n\t    }\n\t    function PromiseReject(reason) {\n\t        return new DexiePromise(INTERNAL, false, reason);\n\t    }\n\t    function wrap(fn, errorCatcher) {\n\t        var psd = PSD;\n\t        return function () {\n\t            var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n\t            try {\n\t                switchToZone(psd, true);\n\t                return fn.apply(this, arguments);\n\t            }\n\t            catch (e) {\n\t                errorCatcher && errorCatcher(e);\n\t            }\n\t            finally {\n\t                switchToZone(outerScope, false);\n\t                if (wasRootExec)\n\t                    endMicroTickScope();\n\t            }\n\t        };\n\t    }\n\t    var task = { awaits: 0, echoes: 0, id: 0 };\n\t    var taskCounter = 0;\n\t    var zoneStack = [];\n\t    var zoneEchoes = 0;\n\t    var totalEchoes = 0;\n\t    var zone_id_counter = 0;\n\t    function newScope(fn, props, a1, a2) {\n\t        var parent = PSD, psd = Object.create(parent);\n\t        psd.parent = parent;\n\t        psd.ref = 0;\n\t        psd.global = false;\n\t        psd.id = ++zone_id_counter;\n\t        globalPSD.env;\n\t        psd.env = patchGlobalPromise ? {\n\t            Promise: DexiePromise,\n\t            PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n\t            all: DexiePromise.all,\n\t            race: DexiePromise.race,\n\t            allSettled: DexiePromise.allSettled,\n\t            any: DexiePromise.any,\n\t            resolve: DexiePromise.resolve,\n\t            reject: DexiePromise.reject,\n\t        } : {};\n\t        if (props)\n\t            extend(psd, props);\n\t        ++parent.ref;\n\t        psd.finalize = function () {\n\t            --this.parent.ref || this.parent.finalize();\n\t        };\n\t        var rv = usePSD(psd, fn, a1, a2);\n\t        if (psd.ref === 0)\n\t            psd.finalize();\n\t        return rv;\n\t    }\n\t    function incrementExpectedAwaits() {\n\t        if (!task.id)\n\t            task.id = ++taskCounter;\n\t        ++task.awaits;\n\t        task.echoes += ZONE_ECHO_LIMIT;\n\t        return task.id;\n\t    }\n\t    function decrementExpectedAwaits() {\n\t        if (!task.awaits)\n\t            return false;\n\t        if (--task.awaits === 0)\n\t            task.id = 0;\n\t        task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n\t        return true;\n\t    }\n\t    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n\t        incrementExpectedAwaits = decrementExpectedAwaits = nop;\n\t    }\n\t    function onPossibleParallellAsync(possiblePromise) {\n\t        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n\t            incrementExpectedAwaits();\n\t            return possiblePromise.then(function (x) {\n\t                decrementExpectedAwaits();\n\t                return x;\n\t            }, function (e) {\n\t                decrementExpectedAwaits();\n\t                return rejection(e);\n\t            });\n\t        }\n\t        return possiblePromise;\n\t    }\n\t    function zoneEnterEcho(targetZone) {\n\t        ++totalEchoes;\n\t        if (!task.echoes || --task.echoes === 0) {\n\t            task.echoes = task.awaits = task.id = 0;\n\t        }\n\t        zoneStack.push(PSD);\n\t        switchToZone(targetZone, true);\n\t    }\n\t    function zoneLeaveEcho() {\n\t        var zone = zoneStack[zoneStack.length - 1];\n\t        zoneStack.pop();\n\t        switchToZone(zone, false);\n\t    }\n\t    function switchToZone(targetZone, bEnteringZone) {\n\t        var currentZone = PSD;\n\t        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n\t            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n\t        }\n\t        if (targetZone === PSD)\n\t            return;\n\t        PSD = targetZone;\n\t        if (currentZone === globalPSD)\n\t            globalPSD.env = snapShot();\n\t        if (patchGlobalPromise) {\n\t            var GlobalPromise = globalPSD.env.Promise;\n\t            var targetEnv = targetZone.env;\n\t            if (currentZone.global || targetZone.global) {\n\t                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n\t                GlobalPromise.all = targetEnv.all;\n\t                GlobalPromise.race = targetEnv.race;\n\t                GlobalPromise.resolve = targetEnv.resolve;\n\t                GlobalPromise.reject = targetEnv.reject;\n\t                if (targetEnv.allSettled)\n\t                    GlobalPromise.allSettled = targetEnv.allSettled;\n\t                if (targetEnv.any)\n\t                    GlobalPromise.any = targetEnv.any;\n\t            }\n\t        }\n\t    }\n\t    function snapShot() {\n\t        var GlobalPromise = _global.Promise;\n\t        return patchGlobalPromise ? {\n\t            Promise: GlobalPromise,\n\t            PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n\t            all: GlobalPromise.all,\n\t            race: GlobalPromise.race,\n\t            allSettled: GlobalPromise.allSettled,\n\t            any: GlobalPromise.any,\n\t            resolve: GlobalPromise.resolve,\n\t            reject: GlobalPromise.reject,\n\t        } : {};\n\t    }\n\t    function usePSD(psd, fn, a1, a2, a3) {\n\t        var outerScope = PSD;\n\t        try {\n\t            switchToZone(psd, true);\n\t            return fn(a1, a2, a3);\n\t        }\n\t        finally {\n\t            switchToZone(outerScope, false);\n\t        }\n\t    }\n\t    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n\t        return typeof fn !== 'function' ? fn : function () {\n\t            var outerZone = PSD;\n\t            if (possibleAwait)\n\t                incrementExpectedAwaits();\n\t            switchToZone(zone, true);\n\t            try {\n\t                return fn.apply(this, arguments);\n\t            }\n\t            finally {\n\t                switchToZone(outerZone, false);\n\t                if (cleanup)\n\t                    queueMicrotask(decrementExpectedAwaits);\n\t            }\n\t        };\n\t    }\n\t    function execInGlobalContext(cb) {\n\t        if (Promise === NativePromise && task.echoes === 0) {\n\t            if (zoneEchoes === 0) {\n\t                cb();\n\t            }\n\t            else {\n\t                enqueueNativeMicroTask(cb);\n\t            }\n\t        }\n\t        else {\n\t            setTimeout(cb, 0);\n\t        }\n\t    }\n\t    var rejection = DexiePromise.reject;\n\n\t    function tempTransaction(db, mode, storeNames, fn) {\n\t        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n\t            if (db._state.openComplete) {\n\t                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n\t            }\n\t            if (!db._state.isBeingOpened) {\n\t                if (!db._state.autoOpen)\n\t                    return rejection(new exceptions.DatabaseClosed());\n\t                db.open().catch(nop);\n\t            }\n\t            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n\t        }\n\t        else {\n\t            var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n\t            try {\n\t                trans.create();\n\t                db._state.PR1398_maxLoop = 3;\n\t            }\n\t            catch (ex) {\n\t                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n\t                    console.warn('Dexie: Need to reopen db');\n\t                    db.close({ disableAutoOpen: false });\n\t                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n\t                }\n\t                return rejection(ex);\n\t            }\n\t            return trans._promise(mode, function (resolve, reject) {\n\t                return newScope(function () {\n\t                    PSD.trans = trans;\n\t                    return fn(resolve, reject, trans);\n\t                });\n\t            }).then(function (result) {\n\t                if (mode === 'readwrite')\n\t                    try {\n\t                        trans.idbtrans.commit();\n\t                    }\n\t                    catch (_a) { }\n\t                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n\t            });\n\t        }\n\t    }\n\n\t    var DEXIE_VERSION = '4.0.8';\n\t    var maxString = String.fromCharCode(65535);\n\t    var minKey = -Infinity;\n\t    var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n\t    var STRING_EXPECTED = \"String expected.\";\n\t    var connections = [];\n\t    var DBNAMES_DB = '__dbnames';\n\t    var READONLY = 'readonly';\n\t    var READWRITE = 'readwrite';\n\n\t    function combine(filter1, filter2) {\n\t        return filter1 ?\n\t            filter2 ?\n\t                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n\t                filter1 :\n\t            filter2;\n\t    }\n\n\t    var AnyRange = {\n\t        type: 3 ,\n\t        lower: -Infinity,\n\t        lowerOpen: false,\n\t        upper: [[]],\n\t        upperOpen: false\n\t    };\n\n\t    function workaroundForUndefinedPrimKey(keyPath) {\n\t        return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n\t            ? function (obj) {\n\t                if (obj[keyPath] === undefined && (keyPath in obj)) {\n\t                    obj = deepClone(obj);\n\t                    delete obj[keyPath];\n\t                }\n\t                return obj;\n\t            }\n\t            : function (obj) { return obj; };\n\t    }\n\n\t    function Entity() {\n\t        throw exceptions.Type();\n\t    }\n\n\t    function cmp(a, b) {\n\t        try {\n\t            var ta = type(a);\n\t            var tb = type(b);\n\t            if (ta !== tb) {\n\t                if (ta === 'Array')\n\t                    return 1;\n\t                if (tb === 'Array')\n\t                    return -1;\n\t                if (ta === 'binary')\n\t                    return 1;\n\t                if (tb === 'binary')\n\t                    return -1;\n\t                if (ta === 'string')\n\t                    return 1;\n\t                if (tb === 'string')\n\t                    return -1;\n\t                if (ta === 'Date')\n\t                    return 1;\n\t                if (tb !== 'Date')\n\t                    return NaN;\n\t                return -1;\n\t            }\n\t            switch (ta) {\n\t                case 'number':\n\t                case 'Date':\n\t                case 'string':\n\t                    return a > b ? 1 : a < b ? -1 : 0;\n\t                case 'binary': {\n\t                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n\t                }\n\t                case 'Array':\n\t                    return compareArrays(a, b);\n\t            }\n\t        }\n\t        catch (_a) { }\n\t        return NaN;\n\t    }\n\t    function compareArrays(a, b) {\n\t        var al = a.length;\n\t        var bl = b.length;\n\t        var l = al < bl ? al : bl;\n\t        for (var i = 0; i < l; ++i) {\n\t            var res = cmp(a[i], b[i]);\n\t            if (res !== 0)\n\t                return res;\n\t        }\n\t        return al === bl ? 0 : al < bl ? -1 : 1;\n\t    }\n\t    function compareUint8Arrays(a, b) {\n\t        var al = a.length;\n\t        var bl = b.length;\n\t        var l = al < bl ? al : bl;\n\t        for (var i = 0; i < l; ++i) {\n\t            if (a[i] !== b[i])\n\t                return a[i] < b[i] ? -1 : 1;\n\t        }\n\t        return al === bl ? 0 : al < bl ? -1 : 1;\n\t    }\n\t    function type(x) {\n\t        var t = typeof x;\n\t        if (t !== 'object')\n\t            return t;\n\t        if (ArrayBuffer.isView(x))\n\t            return 'binary';\n\t        var tsTag = toStringTag(x);\n\t        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n\t    }\n\t    function getUint8Array(a) {\n\t        if (a instanceof Uint8Array)\n\t            return a;\n\t        if (ArrayBuffer.isView(a))\n\t            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n\t        return new Uint8Array(a);\n\t    }\n\n\t    var Table =  (function () {\n\t        function Table() {\n\t        }\n\t        Table.prototype._trans = function (mode, fn, writeLocked) {\n\t            var trans = this._tx || PSD.trans;\n\t            var tableName = this.name;\n\t            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n\t            function checkTableInTransaction(resolve, reject, trans) {\n\t                if (!trans.schema[tableName])\n\t                    throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n\t                return fn(trans.idbtrans, trans);\n\t            }\n\t            var wasRootExec = beginMicroTickScope();\n\t            try {\n\t                var p = trans && trans.db._novip === this.db._novip ?\n\t                    trans === PSD.trans ?\n\t                        trans._promise(mode, checkTableInTransaction, writeLocked) :\n\t                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n\t                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n\t                if (task) {\n\t                    p._consoleTask = task;\n\t                    p = p.catch(function (err) {\n\t                        console.trace(err);\n\t                        return rejection(err);\n\t                    });\n\t                }\n\t                return p;\n\t            }\n\t            finally {\n\t                if (wasRootExec)\n\t                    endMicroTickScope();\n\t            }\n\t        };\n\t        Table.prototype.get = function (keyOrCrit, cb) {\n\t            var _this = this;\n\t            if (keyOrCrit && keyOrCrit.constructor === Object)\n\t                return this.where(keyOrCrit).first(cb);\n\t            if (keyOrCrit == null)\n\t                return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n\t            return this._trans('readonly', function (trans) {\n\t                return _this.core.get({ trans: trans, key: keyOrCrit })\n\t                    .then(function (res) { return _this.hook.reading.fire(res); });\n\t            }).then(cb);\n\t        };\n\t        Table.prototype.where = function (indexOrCrit) {\n\t            if (typeof indexOrCrit === 'string')\n\t                return new this.db.WhereClause(this, indexOrCrit);\n\t            if (isArray(indexOrCrit))\n\t                return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n\t            var keyPaths = keys(indexOrCrit);\n\t            if (keyPaths.length === 1)\n\t                return this\n\t                    .where(keyPaths[0])\n\t                    .equals(indexOrCrit[keyPaths[0]]);\n\t            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n\t                if (ix.compound &&\n\t                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n\t                    for (var i = 0; i < keyPaths.length; ++i) {\n\t                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n\t                            return false;\n\t                    }\n\t                    return true;\n\t                }\n\t                return false;\n\t            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n\t            if (compoundIndex && this.db._maxKey !== maxString) {\n\t                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n\t                return this\n\t                    .where(keyPathsInValidOrder)\n\t                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n\t            }\n\t            if (!compoundIndex && debug)\n\t                console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n\t                    \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n\t            var idxByName = this.schema.idxByName;\n\t            var idb = this.db._deps.indexedDB;\n\t            function equals(a, b) {\n\t                return idb.cmp(a, b) === 0;\n\t            }\n\t            var _a = keyPaths.reduce(function (_a, keyPath) {\n\t                var prevIndex = _a[0], prevFilterFn = _a[1];\n\t                var index = idxByName[keyPath];\n\t                var value = indexOrCrit[keyPath];\n\t                return [\n\t                    prevIndex || index,\n\t                    prevIndex || !index ?\n\t                        combine(prevFilterFn, index && index.multi ?\n\t                            function (x) {\n\t                                var prop = getByKeyPath(x, keyPath);\n\t                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n\t                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n\t                        : prevFilterFn\n\t                ];\n\t            }, [null, null]), idx = _a[0], filterFunction = _a[1];\n\t            return idx ?\n\t                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n\t                    .filter(filterFunction) :\n\t                compoundIndex ?\n\t                    this.filter(filterFunction) :\n\t                    this.where(keyPaths).equals('');\n\t        };\n\t        Table.prototype.filter = function (filterFunction) {\n\t            return this.toCollection().and(filterFunction);\n\t        };\n\t        Table.prototype.count = function (thenShortcut) {\n\t            return this.toCollection().count(thenShortcut);\n\t        };\n\t        Table.prototype.offset = function (offset) {\n\t            return this.toCollection().offset(offset);\n\t        };\n\t        Table.prototype.limit = function (numRows) {\n\t            return this.toCollection().limit(numRows);\n\t        };\n\t        Table.prototype.each = function (callback) {\n\t            return this.toCollection().each(callback);\n\t        };\n\t        Table.prototype.toArray = function (thenShortcut) {\n\t            return this.toCollection().toArray(thenShortcut);\n\t        };\n\t        Table.prototype.toCollection = function () {\n\t            return new this.db.Collection(new this.db.WhereClause(this));\n\t        };\n\t        Table.prototype.orderBy = function (index) {\n\t            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n\t                \"[\".concat(index.join('+'), \"]\") :\n\t                index));\n\t        };\n\t        Table.prototype.reverse = function () {\n\t            return this.toCollection().reverse();\n\t        };\n\t        Table.prototype.mapToClass = function (constructor) {\n\t            var _a = this, db = _a.db, tableName = _a.name;\n\t            this.schema.mappedClass = constructor;\n\t            if (constructor.prototype instanceof Entity) {\n\t                constructor =  (function (_super) {\n\t                    __extends(class_1, _super);\n\t                    function class_1() {\n\t                        return _super !== null && _super.apply(this, arguments) || this;\n\t                    }\n\t                    Object.defineProperty(class_1.prototype, \"db\", {\n\t                        get: function () { return db; },\n\t                        enumerable: false,\n\t                        configurable: true\n\t                    });\n\t                    class_1.prototype.table = function () { return tableName; };\n\t                    return class_1;\n\t                }(constructor));\n\t            }\n\t            var inheritedProps = new Set();\n\t            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n\t                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n\t            }\n\t            var readHook = function (obj) {\n\t                if (!obj)\n\t                    return obj;\n\t                var res = Object.create(constructor.prototype);\n\t                for (var m in obj)\n\t                    if (!inheritedProps.has(m))\n\t                        try {\n\t                            res[m] = obj[m];\n\t                        }\n\t                        catch (_) { }\n\t                return res;\n\t            };\n\t            if (this.schema.readHook) {\n\t                this.hook.reading.unsubscribe(this.schema.readHook);\n\t            }\n\t            this.schema.readHook = readHook;\n\t            this.hook(\"reading\", readHook);\n\t            return constructor;\n\t        };\n\t        Table.prototype.defineClass = function () {\n\t            function Class(content) {\n\t                extend(this, content);\n\t            }\n\t            return this.mapToClass(Class);\n\t        };\n\t        Table.prototype.add = function (obj, key) {\n\t            var _this = this;\n\t            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t            var objToAdd = obj;\n\t            if (keyPath && auto) {\n\t                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n\t            }\n\t            return this._trans('readwrite', function (trans) {\n\t                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n\t            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n\t                .then(function (lastResult) {\n\t                if (keyPath) {\n\t                    try {\n\t                        setByKeyPath(obj, keyPath, lastResult);\n\t                    }\n\t                    catch (_) { }\n\t                }\n\t                return lastResult;\n\t            });\n\t        };\n\t        Table.prototype.update = function (keyOrObject, modifications) {\n\t            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n\t                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n\t                if (key === undefined)\n\t                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n\t                return this.where(\":id\").equals(key).modify(modifications);\n\t            }\n\t            else {\n\t                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n\t            }\n\t        };\n\t        Table.prototype.put = function (obj, key) {\n\t            var _this = this;\n\t            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t            var objToAdd = obj;\n\t            if (keyPath && auto) {\n\t                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n\t            }\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n\t                .then(function (lastResult) {\n\t                if (keyPath) {\n\t                    try {\n\t                        setByKeyPath(obj, keyPath, lastResult);\n\t                    }\n\t                    catch (_) { }\n\t                }\n\t                return lastResult;\n\t            });\n\t        };\n\t        Table.prototype.delete = function (key) {\n\t            var _this = this;\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n\t        };\n\t        Table.prototype.clear = function () {\n\t            var _this = this;\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n\t        };\n\t        Table.prototype.bulkGet = function (keys) {\n\t            var _this = this;\n\t            return this._trans('readonly', function (trans) {\n\t                return _this.core.getMany({\n\t                    keys: keys,\n\t                    trans: trans\n\t                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n\t            });\n\t        };\n\t        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n\t            var _this = this;\n\t            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n\t            options = options || (keys ? undefined : keysOrOptions);\n\t            var wantResults = options ? options.allKeys : undefined;\n\t            return this._trans('readwrite', function (trans) {\n\t                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t                if (keyPath && keys)\n\t                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n\t                if (keys && keys.length !== objects.length)\n\t                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\t                var numObjects = objects.length;\n\t                var objectsToAdd = keyPath && auto ?\n\t                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n\t                    objects;\n\t                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n\t                    .then(function (_a) {\n\t                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n\t                    var result = wantResults ? results : lastResult;\n\t                    if (numFailures === 0)\n\t                        return result;\n\t                    throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n\t            var _this = this;\n\t            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n\t            options = options || (keys ? undefined : keysOrOptions);\n\t            var wantResults = options ? options.allKeys : undefined;\n\t            return this._trans('readwrite', function (trans) {\n\t                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t                if (keyPath && keys)\n\t                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n\t                if (keys && keys.length !== objects.length)\n\t                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\t                var numObjects = objects.length;\n\t                var objectsToPut = keyPath && auto ?\n\t                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n\t                    objects;\n\t                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n\t                    .then(function (_a) {\n\t                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n\t                    var result = wantResults ? results : lastResult;\n\t                    if (numFailures === 0)\n\t                        return result;\n\t                    throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkUpdate = function (keysAndChanges) {\n\t            var _this = this;\n\t            var coreTable = this.core;\n\t            var keys = keysAndChanges.map(function (entry) { return entry.key; });\n\t            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n\t            var offsetMap = [];\n\t            return this._trans('readwrite', function (trans) {\n\t                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n\t                    var resultKeys = [];\n\t                    var resultObjs = [];\n\t                    keysAndChanges.forEach(function (_a, idx) {\n\t                        var key = _a.key, changes = _a.changes;\n\t                        var obj = objs[idx];\n\t                        if (obj) {\n\t                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n\t                                var keyPath = _b[_i];\n\t                                var value = changes[keyPath];\n\t                                if (keyPath === _this.schema.primKey.keyPath) {\n\t                                    if (cmp(value, key) !== 0) {\n\t                                        throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n\t                                    }\n\t                                }\n\t                                else {\n\t                                    setByKeyPath(obj, keyPath, value);\n\t                                }\n\t                            }\n\t                            offsetMap.push(idx);\n\t                            resultKeys.push(key);\n\t                            resultObjs.push(obj);\n\t                        }\n\t                    });\n\t                    var numEntries = resultKeys.length;\n\t                    return coreTable\n\t                        .mutate({\n\t                        trans: trans,\n\t                        type: 'put',\n\t                        keys: resultKeys,\n\t                        values: resultObjs,\n\t                        updates: {\n\t                            keys: keys,\n\t                            changeSpecs: changeSpecs\n\t                        }\n\t                    })\n\t                        .then(function (_a) {\n\t                        var numFailures = _a.numFailures, failures = _a.failures;\n\t                        if (numFailures === 0)\n\t                            return numEntries;\n\t                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n\t                            var offset = _b[_i];\n\t                            var mappedOffset = offsetMap[Number(offset)];\n\t                            if (mappedOffset != null) {\n\t                                var failure = failures[offset];\n\t                                delete failures[offset];\n\t                                failures[mappedOffset] = failure;\n\t                            }\n\t                        }\n\t                        throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n\t                    });\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkDelete = function (keys) {\n\t            var _this = this;\n\t            var numKeys = keys.length;\n\t            return this._trans('readwrite', function (trans) {\n\t                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });\n\t            }).then(function (_a) {\n\t                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n\t                if (numFailures === 0)\n\t                    return lastResult;\n\t                throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n\t            });\n\t        };\n\t        return Table;\n\t    }());\n\n\t    function Events(ctx) {\n\t        var evs = {};\n\t        var rv = function (eventName, subscriber) {\n\t            if (subscriber) {\n\t                var i = arguments.length, args = new Array(i - 1);\n\t                while (--i)\n\t                    args[i - 1] = arguments[i];\n\t                evs[eventName].subscribe.apply(null, args);\n\t                return ctx;\n\t            }\n\t            else if (typeof (eventName) === 'string') {\n\t                return evs[eventName];\n\t            }\n\t        };\n\t        rv.addEventType = add;\n\t        for (var i = 1, l = arguments.length; i < l; ++i) {\n\t            add(arguments[i]);\n\t        }\n\t        return rv;\n\t        function add(eventName, chainFunction, defaultFunction) {\n\t            if (typeof eventName === 'object')\n\t                return addConfiguredEvents(eventName);\n\t            if (!chainFunction)\n\t                chainFunction = reverseStoppableEventChain;\n\t            if (!defaultFunction)\n\t                defaultFunction = nop;\n\t            var context = {\n\t                subscribers: [],\n\t                fire: defaultFunction,\n\t                subscribe: function (cb) {\n\t                    if (context.subscribers.indexOf(cb) === -1) {\n\t                        context.subscribers.push(cb);\n\t                        context.fire = chainFunction(context.fire, cb);\n\t                    }\n\t                },\n\t                unsubscribe: function (cb) {\n\t                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n\t                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n\t                }\n\t            };\n\t            evs[eventName] = rv[eventName] = context;\n\t            return context;\n\t        }\n\t        function addConfiguredEvents(cfg) {\n\t            keys(cfg).forEach(function (eventName) {\n\t                var args = cfg[eventName];\n\t                if (isArray(args)) {\n\t                    add(eventName, cfg[eventName][0], cfg[eventName][1]);\n\t                }\n\t                else if (args === 'asap') {\n\t                    var context = add(eventName, mirror, function fire() {\n\t                        var i = arguments.length, args = new Array(i);\n\t                        while (i--)\n\t                            args[i] = arguments[i];\n\t                        context.subscribers.forEach(function (fn) {\n\t                            asap$1(function fireEvent() {\n\t                                fn.apply(null, args);\n\t                            });\n\t                        });\n\t                    });\n\t                }\n\t                else\n\t                    throw new exceptions.InvalidArgument(\"Invalid event config\");\n\t            });\n\t        }\n\t    }\n\n\t    function makeClassConstructor(prototype, constructor) {\n\t        derive(constructor).from({ prototype: prototype });\n\t        return constructor;\n\t    }\n\n\t    function createTableConstructor(db) {\n\t        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n\t            this.db = db;\n\t            this._tx = trans;\n\t            this.name = name;\n\t            this.schema = tableSchema;\n\t            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n\t                \"creating\": [hookCreatingChain, nop],\n\t                \"reading\": [pureFunctionChain, mirror],\n\t                \"updating\": [hookUpdatingChain, nop],\n\t                \"deleting\": [hookDeletingChain, nop]\n\t            });\n\t        });\n\t    }\n\n\t    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n\t        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n\t            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n\t    }\n\t    function addFilter(ctx, fn) {\n\t        ctx.filter = combine(ctx.filter, fn);\n\t    }\n\t    function addReplayFilter(ctx, factory, isLimitFilter) {\n\t        var curr = ctx.replayFilter;\n\t        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n\t        ctx.justLimit = isLimitFilter && !curr;\n\t    }\n\t    function addMatchFilter(ctx, fn) {\n\t        ctx.isMatch = combine(ctx.isMatch, fn);\n\t    }\n\t    function getIndexOrStore(ctx, coreSchema) {\n\t        if (ctx.isPrimKey)\n\t            return coreSchema.primaryKey;\n\t        var index = coreSchema.getIndexByKeyPath(ctx.index);\n\t        if (!index)\n\t            throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n\t        return index;\n\t    }\n\t    function openCursor(ctx, coreTable, trans) {\n\t        var index = getIndexOrStore(ctx, coreTable.schema);\n\t        return coreTable.openCursor({\n\t            trans: trans,\n\t            values: !ctx.keysOnly,\n\t            reverse: ctx.dir === 'prev',\n\t            unique: !!ctx.unique,\n\t            query: {\n\t                index: index,\n\t                range: ctx.range\n\t            }\n\t        });\n\t    }\n\t    function iter(ctx, fn, coreTrans, coreTable) {\n\t        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n\t        if (!ctx.or) {\n\t            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n\t        }\n\t        else {\n\t            var set_1 = {};\n\t            var union = function (item, cursor, advance) {\n\t                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n\t                    var primaryKey = cursor.primaryKey;\n\t                    var key = '' + primaryKey;\n\t                    if (key === '[object ArrayBuffer]')\n\t                        key = '' + new Uint8Array(primaryKey);\n\t                    if (!hasOwn(set_1, key)) {\n\t                        set_1[key] = true;\n\t                        fn(item, cursor, advance);\n\t                    }\n\t                }\n\t            };\n\t            return Promise.all([\n\t                ctx.or._iterate(union, coreTrans),\n\t                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n\t            ]);\n\t        }\n\t    }\n\t    function iterate(cursorPromise, filter, fn, valueMapper) {\n\t        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n\t        var wrappedFn = wrap(mappedFn);\n\t        return cursorPromise.then(function (cursor) {\n\t            if (cursor) {\n\t                return cursor.start(function () {\n\t                    var c = function () { return cursor.continue(); };\n\t                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n\t                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n\t                    c();\n\t                });\n\t            }\n\t        });\n\t    }\n\n\t    var PropModSymbol = Symbol();\n\t    var PropModification =  (function () {\n\t        function PropModification(spec) {\n\t            Object.assign(this, spec);\n\t        }\n\t        PropModification.prototype.execute = function (value) {\n\t            var _a;\n\t            if (this.add !== undefined) {\n\t                var term = this.add;\n\t                if (isArray(term)) {\n\t                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n\t                }\n\t                if (typeof term === 'number')\n\t                    return (Number(value) || 0) + term;\n\t                if (typeof term === 'bigint') {\n\t                    try {\n\t                        return BigInt(value) + term;\n\t                    }\n\t                    catch (_b) {\n\t                        return BigInt(0) + term;\n\t                    }\n\t                }\n\t                throw new TypeError(\"Invalid term \".concat(term));\n\t            }\n\t            if (this.remove !== undefined) {\n\t                var subtrahend_1 = this.remove;\n\t                if (isArray(subtrahend_1)) {\n\t                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n\t                }\n\t                if (typeof subtrahend_1 === 'number')\n\t                    return Number(value) - subtrahend_1;\n\t                if (typeof subtrahend_1 === 'bigint') {\n\t                    try {\n\t                        return BigInt(value) - subtrahend_1;\n\t                    }\n\t                    catch (_c) {\n\t                        return BigInt(0) - subtrahend_1;\n\t                    }\n\t                }\n\t                throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n\t            }\n\t            var prefixToReplace = (_a = this.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n\t            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n\t                return this.replacePrefix[1] + value.substring(prefixToReplace.length);\n\t            }\n\t            return value;\n\t        };\n\t        return PropModification;\n\t    }());\n\n\t    var Collection =  (function () {\n\t        function Collection() {\n\t        }\n\t        Collection.prototype._read = function (fn, cb) {\n\t            var ctx = this._ctx;\n\t            return ctx.error ?\n\t                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n\t                ctx.table._trans('readonly', fn).then(cb);\n\t        };\n\t        Collection.prototype._write = function (fn) {\n\t            var ctx = this._ctx;\n\t            return ctx.error ?\n\t                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n\t                ctx.table._trans('readwrite', fn, \"locked\");\n\t        };\n\t        Collection.prototype._addAlgorithm = function (fn) {\n\t            var ctx = this._ctx;\n\t            ctx.algorithm = combine(ctx.algorithm, fn);\n\t        };\n\t        Collection.prototype._iterate = function (fn, coreTrans) {\n\t            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n\t        };\n\t        Collection.prototype.clone = function (props) {\n\t            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n\t            if (props)\n\t                extend(ctx, props);\n\t            rv._ctx = ctx;\n\t            return rv;\n\t        };\n\t        Collection.prototype.raw = function () {\n\t            this._ctx.valueMapper = null;\n\t            return this;\n\t        };\n\t        Collection.prototype.each = function (fn) {\n\t            var ctx = this._ctx;\n\t            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n\t        };\n\t        Collection.prototype.count = function (cb) {\n\t            var _this = this;\n\t            return this._read(function (trans) {\n\t                var ctx = _this._ctx;\n\t                var coreTable = ctx.table.core;\n\t                if (isPlainKeyRange(ctx, true)) {\n\t                    return coreTable.count({\n\t                        trans: trans,\n\t                        query: {\n\t                            index: getIndexOrStore(ctx, coreTable.schema),\n\t                            range: ctx.range\n\t                        }\n\t                    }).then(function (count) { return Math.min(count, ctx.limit); });\n\t                }\n\t                else {\n\t                    var count = 0;\n\t                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n\t                        .then(function () { return count; });\n\t                }\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.sortBy = function (keyPath, cb) {\n\t            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n\t            function getval(obj, i) {\n\t                if (i)\n\t                    return getval(obj[parts[i]], i - 1);\n\t                return obj[lastPart];\n\t            }\n\t            var order = this._ctx.dir === \"next\" ? 1 : -1;\n\t            function sorter(a, b) {\n\t                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n\t                return aVal < bVal ? -order : aVal > bVal ? order : 0;\n\t            }\n\t            return this.toArray(function (a) {\n\t                return a.sort(sorter);\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.toArray = function (cb) {\n\t            var _this = this;\n\t            return this._read(function (trans) {\n\t                var ctx = _this._ctx;\n\t                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n\t                    var valueMapper_1 = ctx.valueMapper;\n\t                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n\t                    return ctx.table.core.query({\n\t                        trans: trans,\n\t                        limit: ctx.limit,\n\t                        values: true,\n\t                        query: {\n\t                            index: index,\n\t                            range: ctx.range\n\t                        }\n\t                    }).then(function (_a) {\n\t                        var result = _a.result;\n\t                        return valueMapper_1 ? result.map(valueMapper_1) : result;\n\t                    });\n\t                }\n\t                else {\n\t                    var a_1 = [];\n\t                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n\t                }\n\t            }, cb);\n\t        };\n\t        Collection.prototype.offset = function (offset) {\n\t            var ctx = this._ctx;\n\t            if (offset <= 0)\n\t                return this;\n\t            ctx.offset += offset;\n\t            if (isPlainKeyRange(ctx)) {\n\t                addReplayFilter(ctx, function () {\n\t                    var offsetLeft = offset;\n\t                    return function (cursor, advance) {\n\t                        if (offsetLeft === 0)\n\t                            return true;\n\t                        if (offsetLeft === 1) {\n\t                            --offsetLeft;\n\t                            return false;\n\t                        }\n\t                        advance(function () {\n\t                            cursor.advance(offsetLeft);\n\t                            offsetLeft = 0;\n\t                        });\n\t                        return false;\n\t                    };\n\t                });\n\t            }\n\t            else {\n\t                addReplayFilter(ctx, function () {\n\t                    var offsetLeft = offset;\n\t                    return function () { return (--offsetLeft < 0); };\n\t                });\n\t            }\n\t            return this;\n\t        };\n\t        Collection.prototype.limit = function (numRows) {\n\t            this._ctx.limit = Math.min(this._ctx.limit, numRows);\n\t            addReplayFilter(this._ctx, function () {\n\t                var rowsLeft = numRows;\n\t                return function (cursor, advance, resolve) {\n\t                    if (--rowsLeft <= 0)\n\t                        advance(resolve);\n\t                    return rowsLeft >= 0;\n\t                };\n\t            }, true);\n\t            return this;\n\t        };\n\t        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n\t            addFilter(this._ctx, function (cursor, advance, resolve) {\n\t                if (filterFunction(cursor.value)) {\n\t                    advance(resolve);\n\t                    return bIncludeStopEntry;\n\t                }\n\t                else {\n\t                    return true;\n\t                }\n\t            });\n\t            return this;\n\t        };\n\t        Collection.prototype.first = function (cb) {\n\t            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n\t        };\n\t        Collection.prototype.last = function (cb) {\n\t            return this.reverse().first(cb);\n\t        };\n\t        Collection.prototype.filter = function (filterFunction) {\n\t            addFilter(this._ctx, function (cursor) {\n\t                return filterFunction(cursor.value);\n\t            });\n\t            addMatchFilter(this._ctx, filterFunction);\n\t            return this;\n\t        };\n\t        Collection.prototype.and = function (filter) {\n\t            return this.filter(filter);\n\t        };\n\t        Collection.prototype.or = function (indexName) {\n\t            return new this.db.WhereClause(this._ctx.table, indexName, this);\n\t        };\n\t        Collection.prototype.reverse = function () {\n\t            this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n\t            if (this._ondirectionchange)\n\t                this._ondirectionchange(this._ctx.dir);\n\t            return this;\n\t        };\n\t        Collection.prototype.desc = function () {\n\t            return this.reverse();\n\t        };\n\t        Collection.prototype.eachKey = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n\t        };\n\t        Collection.prototype.eachUniqueKey = function (cb) {\n\t            this._ctx.unique = \"unique\";\n\t            return this.eachKey(cb);\n\t        };\n\t        Collection.prototype.eachPrimaryKey = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n\t        };\n\t        Collection.prototype.keys = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            var a = [];\n\t            return this.each(function (item, cursor) {\n\t                a.push(cursor.key);\n\t            }).then(function () {\n\t                return a;\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.primaryKeys = function (cb) {\n\t            var ctx = this._ctx;\n\t            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n\t                return this._read(function (trans) {\n\t                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n\t                    return ctx.table.core.query({\n\t                        trans: trans,\n\t                        values: false,\n\t                        limit: ctx.limit,\n\t                        query: {\n\t                            index: index,\n\t                            range: ctx.range\n\t                        }\n\t                    });\n\t                }).then(function (_a) {\n\t                    var result = _a.result;\n\t                    return result;\n\t                }).then(cb);\n\t            }\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            var a = [];\n\t            return this.each(function (item, cursor) {\n\t                a.push(cursor.primaryKey);\n\t            }).then(function () {\n\t                return a;\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.uniqueKeys = function (cb) {\n\t            this._ctx.unique = \"unique\";\n\t            return this.keys(cb);\n\t        };\n\t        Collection.prototype.firstKey = function (cb) {\n\t            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n\t        };\n\t        Collection.prototype.lastKey = function (cb) {\n\t            return this.reverse().firstKey(cb);\n\t        };\n\t        Collection.prototype.distinct = function () {\n\t            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n\t            if (!idx || !idx.multi)\n\t                return this;\n\t            var set = {};\n\t            addFilter(this._ctx, function (cursor) {\n\t                var strKey = cursor.primaryKey.toString();\n\t                var found = hasOwn(set, strKey);\n\t                set[strKey] = true;\n\t                return !found;\n\t            });\n\t            return this;\n\t        };\n\t        Collection.prototype.modify = function (changes) {\n\t            var _this = this;\n\t            var ctx = this._ctx;\n\t            return this._write(function (trans) {\n\t                var modifyer;\n\t                if (typeof changes === 'function') {\n\t                    modifyer = changes;\n\t                }\n\t                else {\n\t                    var keyPaths = keys(changes);\n\t                    var numKeys = keyPaths.length;\n\t                    modifyer = function (item) {\n\t                        var anythingModified = false;\n\t                        for (var i = 0; i < numKeys; ++i) {\n\t                            var keyPath = keyPaths[i];\n\t                            var val = changes[keyPath];\n\t                            var origVal = getByKeyPath(item, keyPath);\n\t                            if (val instanceof PropModification) {\n\t                                setByKeyPath(item, keyPath, val.execute(origVal));\n\t                                anythingModified = true;\n\t                            }\n\t                            else if (origVal !== val) {\n\t                                setByKeyPath(item, keyPath, val);\n\t                                anythingModified = true;\n\t                            }\n\t                        }\n\t                        return anythingModified;\n\t                    };\n\t                }\n\t                var coreTable = ctx.table.core;\n\t                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n\t                var limit = _this.db._options.modifyChunkSize || 200;\n\t                var totalFailures = [];\n\t                var successCount = 0;\n\t                var failedKeys = [];\n\t                var applyMutateResult = function (expectedCount, res) {\n\t                    var failures = res.failures, numFailures = res.numFailures;\n\t                    successCount += expectedCount - numFailures;\n\t                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n\t                        var pos = _a[_i];\n\t                        totalFailures.push(failures[pos]);\n\t                    }\n\t                };\n\t                return _this.clone().primaryKeys().then(function (keys) {\n\t                    var criteria = isPlainKeyRange(ctx) &&\n\t                        ctx.limit === Infinity &&\n\t                        (typeof changes !== 'function' || changes === deleteCallback) && {\n\t                        index: ctx.index,\n\t                        range: ctx.range\n\t                    };\n\t                    var nextChunk = function (offset) {\n\t                        var count = Math.min(limit, keys.length - offset);\n\t                        return coreTable.getMany({\n\t                            trans: trans,\n\t                            keys: keys.slice(offset, offset + count),\n\t                            cache: \"immutable\"\n\t                        }).then(function (values) {\n\t                            var addValues = [];\n\t                            var putValues = [];\n\t                            var putKeys = outbound ? [] : null;\n\t                            var deleteKeys = [];\n\t                            for (var i = 0; i < count; ++i) {\n\t                                var origValue = values[i];\n\t                                var ctx_1 = {\n\t                                    value: deepClone(origValue),\n\t                                    primKey: keys[offset + i]\n\t                                };\n\t                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n\t                                    if (ctx_1.value == null) {\n\t                                        deleteKeys.push(keys[offset + i]);\n\t                                    }\n\t                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n\t                                        deleteKeys.push(keys[offset + i]);\n\t                                        addValues.push(ctx_1.value);\n\t                                    }\n\t                                    else {\n\t                                        putValues.push(ctx_1.value);\n\t                                        if (outbound)\n\t                                            putKeys.push(keys[offset + i]);\n\t                                    }\n\t                                }\n\t                            }\n\t                            return Promise.resolve(addValues.length > 0 &&\n\t                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n\t                                    .then(function (res) {\n\t                                    for (var pos in res.failures) {\n\t                                        deleteKeys.splice(parseInt(pos), 1);\n\t                                    }\n\t                                    applyMutateResult(addValues.length, res);\n\t                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n\t                                coreTable.mutate({\n\t                                    trans: trans,\n\t                                    type: 'put',\n\t                                    keys: putKeys,\n\t                                    values: putValues,\n\t                                    criteria: criteria,\n\t                                    changeSpec: typeof changes !== 'function'\n\t                                        && changes,\n\t                                    isAdditionalChunk: offset > 0\n\t                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n\t                                coreTable.mutate({\n\t                                    trans: trans,\n\t                                    type: 'delete',\n\t                                    keys: deleteKeys,\n\t                                    criteria: criteria,\n\t                                    isAdditionalChunk: offset > 0\n\t                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n\t                                return keys.length > offset + count && nextChunk(offset + limit);\n\t                            });\n\t                        });\n\t                    };\n\t                    return nextChunk(0).then(function () {\n\t                        if (totalFailures.length > 0)\n\t                            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n\t                        return keys.length;\n\t                    });\n\t                });\n\t            });\n\t        };\n\t        Collection.prototype.delete = function () {\n\t            var ctx = this._ctx, range = ctx.range;\n\t            if (isPlainKeyRange(ctx) &&\n\t                (ctx.isPrimKey || range.type === 3 ))\n\t             {\n\t                return this._write(function (trans) {\n\t                    var primaryKey = ctx.table.core.schema.primaryKey;\n\t                    var coreRange = range;\n\t                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n\t                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n\t                            .then(function (_a) {\n\t                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;\n\t                            if (numFailures)\n\t                                throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n\t                            return count - numFailures;\n\t                        });\n\t                    });\n\t                });\n\t            }\n\t            return this.modify(deleteCallback);\n\t        };\n\t        return Collection;\n\t    }());\n\t    var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n\t    function createCollectionConstructor(db) {\n\t        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n\t            this.db = db;\n\t            var keyRange = AnyRange, error = null;\n\t            if (keyRangeGenerator)\n\t                try {\n\t                    keyRange = keyRangeGenerator();\n\t                }\n\t                catch (ex) {\n\t                    error = ex;\n\t                }\n\t            var whereCtx = whereClause._ctx;\n\t            var table = whereCtx.table;\n\t            var readingHook = table.hook.reading.fire;\n\t            this._ctx = {\n\t                table: table,\n\t                index: whereCtx.index,\n\t                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n\t                range: keyRange,\n\t                keysOnly: false,\n\t                dir: \"next\",\n\t                unique: \"\",\n\t                algorithm: null,\n\t                filter: null,\n\t                replayFilter: null,\n\t                justLimit: true,\n\t                isMatch: null,\n\t                offset: 0,\n\t                limit: Infinity,\n\t                error: error,\n\t                or: whereCtx.or,\n\t                valueMapper: readingHook !== mirror ? readingHook : null\n\t            };\n\t        });\n\t    }\n\n\t    function simpleCompare(a, b) {\n\t        return a < b ? -1 : a === b ? 0 : 1;\n\t    }\n\t    function simpleCompareReverse(a, b) {\n\t        return a > b ? -1 : a === b ? 0 : 1;\n\t    }\n\n\t    function fail(collectionOrWhereClause, err, T) {\n\t        var collection = collectionOrWhereClause instanceof WhereClause ?\n\t            new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n\t            collectionOrWhereClause;\n\t        collection._ctx.error = T ? new T(err) : new TypeError(err);\n\t        return collection;\n\t    }\n\t    function emptyCollection(whereClause) {\n\t        return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n\t    }\n\t    function upperFactory(dir) {\n\t        return dir === \"next\" ?\n\t            function (s) { return s.toUpperCase(); } :\n\t            function (s) { return s.toLowerCase(); };\n\t    }\n\t    function lowerFactory(dir) {\n\t        return dir === \"next\" ?\n\t            function (s) { return s.toLowerCase(); } :\n\t            function (s) { return s.toUpperCase(); };\n\t    }\n\t    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n\t        var length = Math.min(key.length, lowerNeedle.length);\n\t        var llp = -1;\n\t        for (var i = 0; i < length; ++i) {\n\t            var lwrKeyChar = lowerKey[i];\n\t            if (lwrKeyChar !== lowerNeedle[i]) {\n\t                if (cmp(key[i], upperNeedle[i]) < 0)\n\t                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n\t                if (cmp(key[i], lowerNeedle[i]) < 0)\n\t                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n\t                if (llp >= 0)\n\t                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n\t                return null;\n\t            }\n\t            if (cmp(key[i], lwrKeyChar) < 0)\n\t                llp = i;\n\t        }\n\t        if (length < lowerNeedle.length && dir === \"next\")\n\t            return key + upperNeedle.substr(key.length);\n\t        if (length < key.length && dir === \"prev\")\n\t            return key.substr(0, upperNeedle.length);\n\t        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n\t    }\n\t    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n\t        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n\t        if (!needles.every(function (s) { return typeof s === 'string'; })) {\n\t            return fail(whereClause, STRING_EXPECTED);\n\t        }\n\t        function initDirection(dir) {\n\t            upper = upperFactory(dir);\n\t            lower = lowerFactory(dir);\n\t            compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n\t            var needleBounds = needles.map(function (needle) {\n\t                return { lower: lower(needle), upper: upper(needle) };\n\t            }).sort(function (a, b) {\n\t                return compare(a.lower, b.lower);\n\t            });\n\t            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n\t            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n\t            direction = dir;\n\t            nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n\t        }\n\t        initDirection(\"next\");\n\t        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n\t        c._ondirectionchange = function (direction) {\n\t            initDirection(direction);\n\t        };\n\t        var firstPossibleNeedle = 0;\n\t        c._addAlgorithm(function (cursor, advance, resolve) {\n\t            var key = cursor.key;\n\t            if (typeof key !== 'string')\n\t                return false;\n\t            var lowerKey = lower(key);\n\t            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n\t                return true;\n\t            }\n\t            else {\n\t                var lowestPossibleCasing = null;\n\t                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n\t                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n\t                    if (casing === null && lowestPossibleCasing === null)\n\t                        firstPossibleNeedle = i + 1;\n\t                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n\t                        lowestPossibleCasing = casing;\n\t                    }\n\t                }\n\t                if (lowestPossibleCasing !== null) {\n\t                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n\t                }\n\t                else {\n\t                    advance(resolve);\n\t                }\n\t                return false;\n\t            }\n\t        });\n\t        return c;\n\t    }\n\t    function createRange(lower, upper, lowerOpen, upperOpen) {\n\t        return {\n\t            type: 2 ,\n\t            lower: lower,\n\t            upper: upper,\n\t            lowerOpen: lowerOpen,\n\t            upperOpen: upperOpen\n\t        };\n\t    }\n\t    function rangeEqual(value) {\n\t        return {\n\t            type: 1 ,\n\t            lower: value,\n\t            upper: value\n\t        };\n\t    }\n\n\t    var WhereClause =  (function () {\n\t        function WhereClause() {\n\t        }\n\t        Object.defineProperty(WhereClause.prototype, \"Collection\", {\n\t            get: function () {\n\t                return this._ctx.table.db.Collection;\n\t            },\n\t            enumerable: false,\n\t            configurable: true\n\t        });\n\t        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n\t            includeLower = includeLower !== false;\n\t            includeUpper = includeUpper === true;\n\t            try {\n\t                if ((this._cmp(lower, upper) > 0) ||\n\t                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n\t                    return emptyCollection(this);\n\t                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t        };\n\t        WhereClause.prototype.equals = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return rangeEqual(value); });\n\t        };\n\t        WhereClause.prototype.above = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(value, undefined, true); });\n\t        };\n\t        WhereClause.prototype.aboveOrEqual = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(value, undefined, false); });\n\t        };\n\t        WhereClause.prototype.below = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n\t        };\n\t        WhereClause.prototype.belowOrEqual = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(undefined, value); });\n\t        };\n\t        WhereClause.prototype.startsWith = function (str) {\n\t            if (typeof str !== 'string')\n\t                return fail(this, STRING_EXPECTED);\n\t            return this.between(str, str + maxString, true, true);\n\t        };\n\t        WhereClause.prototype.startsWithIgnoreCase = function (str) {\n\t            if (str === \"\")\n\t                return this.startsWith(str);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n\t        };\n\t        WhereClause.prototype.equalsIgnoreCase = function (str) {\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n\t        };\n\t        WhereClause.prototype.anyOfIgnoreCase = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n\t        };\n\t        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n\t        };\n\t        WhereClause.prototype.anyOf = function () {\n\t            var _this = this;\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            var compare = this._cmp;\n\t            try {\n\t                set.sort(compare);\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n\t            c._ondirectionchange = function (direction) {\n\t                compare = (direction === \"next\" ?\n\t                    _this._ascending :\n\t                    _this._descending);\n\t                set.sort(compare);\n\t            };\n\t            var i = 0;\n\t            c._addAlgorithm(function (cursor, advance, resolve) {\n\t                var key = cursor.key;\n\t                while (compare(key, set[i]) > 0) {\n\t                    ++i;\n\t                    if (i === set.length) {\n\t                        advance(resolve);\n\t                        return false;\n\t                    }\n\t                }\n\t                if (compare(key, set[i]) === 0) {\n\t                    return true;\n\t                }\n\t                else {\n\t                    advance(function () { cursor.continue(set[i]); });\n\t                    return false;\n\t                }\n\t            });\n\t            return c;\n\t        };\n\t        WhereClause.prototype.notEqual = function (value) {\n\t            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n\t        };\n\t        WhereClause.prototype.noneOf = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return new this.Collection(this);\n\t            try {\n\t                set.sort(this._ascending);\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            var ranges = set.reduce(function (res, val) { return res ?\n\t                res.concat([[res[res.length - 1][1], val]]) :\n\t                [[minKey, val]]; }, null);\n\t            ranges.push([set[set.length - 1], this.db._maxKey]);\n\t            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n\t        };\n\t        WhereClause.prototype.inAnyRange = function (ranges, options) {\n\t            var _this = this;\n\t            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n\t            if (ranges.length === 0)\n\t                return emptyCollection(this);\n\t            if (!ranges.every(function (range) {\n\t                return range[0] !== undefined &&\n\t                    range[1] !== undefined &&\n\t                    ascending(range[0], range[1]) <= 0;\n\t            })) {\n\t                return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n\t            }\n\t            var includeLowers = !options || options.includeLowers !== false;\n\t            var includeUppers = options && options.includeUppers === true;\n\t            function addRange(ranges, newRange) {\n\t                var i = 0, l = ranges.length;\n\t                for (; i < l; ++i) {\n\t                    var range = ranges[i];\n\t                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n\t                        range[0] = min(range[0], newRange[0]);\n\t                        range[1] = max(range[1], newRange[1]);\n\t                        break;\n\t                    }\n\t                }\n\t                if (i === l)\n\t                    ranges.push(newRange);\n\t                return ranges;\n\t            }\n\t            var sortDirection = ascending;\n\t            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n\t            var set;\n\t            try {\n\t                set = ranges.reduce(addRange, []);\n\t                set.sort(rangeSorter);\n\t            }\n\t            catch (ex) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            var rangePos = 0;\n\t            var keyIsBeyondCurrentEntry = includeUppers ?\n\t                function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n\t                function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n\t            var keyIsBeforeCurrentEntry = includeLowers ?\n\t                function (key) { return descending(key, set[rangePos][0]) > 0; } :\n\t                function (key) { return descending(key, set[rangePos][0]) >= 0; };\n\t            function keyWithinCurrentRange(key) {\n\t                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n\t            }\n\t            var checkKey = keyIsBeyondCurrentEntry;\n\t            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n\t            c._ondirectionchange = function (direction) {\n\t                if (direction === \"next\") {\n\t                    checkKey = keyIsBeyondCurrentEntry;\n\t                    sortDirection = ascending;\n\t                }\n\t                else {\n\t                    checkKey = keyIsBeforeCurrentEntry;\n\t                    sortDirection = descending;\n\t                }\n\t                set.sort(rangeSorter);\n\t            };\n\t            c._addAlgorithm(function (cursor, advance, resolve) {\n\t                var key = cursor.key;\n\t                while (checkKey(key)) {\n\t                    ++rangePos;\n\t                    if (rangePos === set.length) {\n\t                        advance(resolve);\n\t                        return false;\n\t                    }\n\t                }\n\t                if (keyWithinCurrentRange(key)) {\n\t                    return true;\n\t                }\n\t                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n\t                    return false;\n\t                }\n\t                else {\n\t                    advance(function () {\n\t                        if (sortDirection === ascending)\n\t                            cursor.continue(set[rangePos][0]);\n\t                        else\n\t                            cursor.continue(set[rangePos][1]);\n\t                    });\n\t                    return false;\n\t                }\n\t            });\n\t            return c;\n\t        };\n\t        WhereClause.prototype.startsWithAnyOf = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (!set.every(function (s) { return typeof s === 'string'; })) {\n\t                return fail(this, \"startsWithAnyOf() only works with strings\");\n\t            }\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n\t        };\n\t        return WhereClause;\n\t    }());\n\n\t    function createWhereClauseConstructor(db) {\n\t        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n\t            this.db = db;\n\t            this._ctx = {\n\t                table: table,\n\t                index: index === \":id\" ? null : index,\n\t                or: orCollection\n\t            };\n\t            this._cmp = this._ascending = cmp;\n\t            this._descending = function (a, b) { return cmp(b, a); };\n\t            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n\t            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n\t            this._IDBKeyRange = db._deps.IDBKeyRange;\n\t            if (!this._IDBKeyRange)\n\t                throw new exceptions.MissingAPI();\n\t        });\n\t    }\n\n\t    function eventRejectHandler(reject) {\n\t        return wrap(function (event) {\n\t            preventDefault(event);\n\t            reject(event.target.error);\n\t            return false;\n\t        });\n\t    }\n\t    function preventDefault(event) {\n\t        if (event.stopPropagation)\n\t            event.stopPropagation();\n\t        if (event.preventDefault)\n\t            event.preventDefault();\n\t    }\n\n\t    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n\t    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n\t    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n\t    var Transaction =  (function () {\n\t        function Transaction() {\n\t        }\n\t        Transaction.prototype._lock = function () {\n\t            assert(!PSD.global);\n\t            ++this._reculock;\n\t            if (this._reculock === 1 && !PSD.global)\n\t                PSD.lockOwnerFor = this;\n\t            return this;\n\t        };\n\t        Transaction.prototype._unlock = function () {\n\t            assert(!PSD.global);\n\t            if (--this._reculock === 0) {\n\t                if (!PSD.global)\n\t                    PSD.lockOwnerFor = null;\n\t                while (this._blockedFuncs.length > 0 && !this._locked()) {\n\t                    var fnAndPSD = this._blockedFuncs.shift();\n\t                    try {\n\t                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n\t                    }\n\t                    catch (e) { }\n\t                }\n\t            }\n\t            return this;\n\t        };\n\t        Transaction.prototype._locked = function () {\n\t            return this._reculock && PSD.lockOwnerFor !== this;\n\t        };\n\t        Transaction.prototype.create = function (idbtrans) {\n\t            var _this = this;\n\t            if (!this.mode)\n\t                return this;\n\t            var idbdb = this.db.idbdb;\n\t            var dbOpenError = this.db._state.dbOpenError;\n\t            assert(!this.idbtrans);\n\t            if (!idbtrans && !idbdb) {\n\t                switch (dbOpenError && dbOpenError.name) {\n\t                    case \"DatabaseClosedError\":\n\t                        throw new exceptions.DatabaseClosed(dbOpenError);\n\t                    case \"MissingAPIError\":\n\t                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n\t                    default:\n\t                        throw new exceptions.OpenFailed(dbOpenError);\n\t                }\n\t            }\n\t            if (!this.active)\n\t                throw new exceptions.TransactionInactive();\n\t            assert(this._completion._state === null);\n\t            idbtrans = this.idbtrans = idbtrans ||\n\t                (this.db.core\n\t                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n\t                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n\t            idbtrans.onerror = wrap(function (ev) {\n\t                preventDefault(ev);\n\t                _this._reject(idbtrans.error);\n\t            });\n\t            idbtrans.onabort = wrap(function (ev) {\n\t                preventDefault(ev);\n\t                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n\t                _this.active = false;\n\t                _this.on(\"abort\").fire(ev);\n\t            });\n\t            idbtrans.oncomplete = wrap(function () {\n\t                _this.active = false;\n\t                _this._resolve();\n\t                if ('mutatedParts' in idbtrans) {\n\t                    globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n\t                }\n\t            });\n\t            return this;\n\t        };\n\t        Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n\t            var _this = this;\n\t            if (mode === 'readwrite' && this.mode !== 'readwrite')\n\t                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n\t            if (!this.active)\n\t                return rejection(new exceptions.TransactionInactive());\n\t            if (this._locked()) {\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    _this._blockedFuncs.push([function () {\n\t                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n\t                        }, PSD]);\n\t                });\n\t            }\n\t            else if (bWriteLock) {\n\t                return newScope(function () {\n\t                    var p = new DexiePromise(function (resolve, reject) {\n\t                        _this._lock();\n\t                        var rv = fn(resolve, reject, _this);\n\t                        if (rv && rv.then)\n\t                            rv.then(resolve, reject);\n\t                    });\n\t                    p.finally(function () { return _this._unlock(); });\n\t                    p._lib = true;\n\t                    return p;\n\t                });\n\t            }\n\t            else {\n\t                var p = new DexiePromise(function (resolve, reject) {\n\t                    var rv = fn(resolve, reject, _this);\n\t                    if (rv && rv.then)\n\t                        rv.then(resolve, reject);\n\t                });\n\t                p._lib = true;\n\t                return p;\n\t            }\n\t        };\n\t        Transaction.prototype._root = function () {\n\t            return this.parent ? this.parent._root() : this;\n\t        };\n\t        Transaction.prototype.waitFor = function (promiseLike) {\n\t            var root = this._root();\n\t            var promise = DexiePromise.resolve(promiseLike);\n\t            if (root._waitingFor) {\n\t                root._waitingFor = root._waitingFor.then(function () { return promise; });\n\t            }\n\t            else {\n\t                root._waitingFor = promise;\n\t                root._waitingQueue = [];\n\t                var store = root.idbtrans.objectStore(root.storeNames[0]);\n\t                (function spin() {\n\t                    ++root._spinCount;\n\t                    while (root._waitingQueue.length)\n\t                        (root._waitingQueue.shift())();\n\t                    if (root._waitingFor)\n\t                        store.get(-Infinity).onsuccess = spin;\n\t                }());\n\t            }\n\t            var currentWaitPromise = root._waitingFor;\n\t            return new DexiePromise(function (resolve, reject) {\n\t                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n\t                    if (root._waitingFor === currentWaitPromise) {\n\t                        root._waitingFor = null;\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        Transaction.prototype.abort = function () {\n\t            if (this.active) {\n\t                this.active = false;\n\t                if (this.idbtrans)\n\t                    this.idbtrans.abort();\n\t                this._reject(new exceptions.Abort());\n\t            }\n\t        };\n\t        Transaction.prototype.table = function (tableName) {\n\t            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n\t            if (hasOwn(memoizedTables, tableName))\n\t                return memoizedTables[tableName];\n\t            var tableSchema = this.schema[tableName];\n\t            if (!tableSchema) {\n\t                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n\t            }\n\t            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n\t            transactionBoundTable.core = this.db.core.table(tableName);\n\t            memoizedTables[tableName] = transactionBoundTable;\n\t            return transactionBoundTable;\n\t        };\n\t        return Transaction;\n\t    }());\n\n\t    function createTransactionConstructor(db) {\n\t        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n\t            var _this = this;\n\t            this.db = db;\n\t            this.mode = mode;\n\t            this.storeNames = storeNames;\n\t            this.schema = dbschema;\n\t            this.chromeTransactionDurability = chromeTransactionDurability;\n\t            this.idbtrans = null;\n\t            this.on = Events(this, \"complete\", \"error\", \"abort\");\n\t            this.parent = parent || null;\n\t            this.active = true;\n\t            this._reculock = 0;\n\t            this._blockedFuncs = [];\n\t            this._resolve = null;\n\t            this._reject = null;\n\t            this._waitingFor = null;\n\t            this._waitingQueue = null;\n\t            this._spinCount = 0;\n\t            this._completion = new DexiePromise(function (resolve, reject) {\n\t                _this._resolve = resolve;\n\t                _this._reject = reject;\n\t            });\n\t            this._completion.then(function () {\n\t                _this.active = false;\n\t                _this.on.complete.fire();\n\t            }, function (e) {\n\t                var wasActive = _this.active;\n\t                _this.active = false;\n\t                _this.on.error.fire(e);\n\t                _this.parent ?\n\t                    _this.parent._reject(e) :\n\t                    wasActive && _this.idbtrans && _this.idbtrans.abort();\n\t                return rejection(e);\n\t            });\n\t        });\n\t    }\n\n\t    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n\t        return {\n\t            name: name,\n\t            keyPath: keyPath,\n\t            unique: unique,\n\t            multi: multi,\n\t            auto: auto,\n\t            compound: compound,\n\t            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n\t        };\n\t    }\n\t    function nameFromKeyPath(keyPath) {\n\t        return typeof keyPath === 'string' ?\n\t            keyPath :\n\t            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n\t    }\n\n\t    function createTableSchema(name, primKey, indexes) {\n\t        return {\n\t            name: name,\n\t            primKey: primKey,\n\t            indexes: indexes,\n\t            mappedClass: null,\n\t            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })\n\t        };\n\t    }\n\n\t    function safariMultiStoreFix(storeNames) {\n\t        return storeNames.length === 1 ? storeNames[0] : storeNames;\n\t    }\n\t    var getMaxKey = function (IdbKeyRange) {\n\t        try {\n\t            IdbKeyRange.only([[]]);\n\t            getMaxKey = function () { return [[]]; };\n\t            return [[]];\n\t        }\n\t        catch (e) {\n\t            getMaxKey = function () { return maxString; };\n\t            return maxString;\n\t        }\n\t    };\n\n\t    function getKeyExtractor(keyPath) {\n\t        if (keyPath == null) {\n\t            return function () { return undefined; };\n\t        }\n\t        else if (typeof keyPath === 'string') {\n\t            return getSinglePathKeyExtractor(keyPath);\n\t        }\n\t        else {\n\t            return function (obj) { return getByKeyPath(obj, keyPath); };\n\t        }\n\t    }\n\t    function getSinglePathKeyExtractor(keyPath) {\n\t        var split = keyPath.split('.');\n\t        if (split.length === 1) {\n\t            return function (obj) { return obj[keyPath]; };\n\t        }\n\t        else {\n\t            return function (obj) { return getByKeyPath(obj, keyPath); };\n\t        }\n\t    }\n\n\t    function arrayify(arrayLike) {\n\t        return [].slice.call(arrayLike);\n\t    }\n\t    var _id_counter = 0;\n\t    function getKeyPathAlias(keyPath) {\n\t        return keyPath == null ?\n\t            \":id\" :\n\t            typeof keyPath === 'string' ?\n\t                keyPath :\n\t                \"[\".concat(keyPath.join('+'), \"]\");\n\t    }\n\t    function createDBCore(db, IdbKeyRange, tmpTrans) {\n\t        function extractSchema(db, trans) {\n\t            var tables = arrayify(db.objectStoreNames);\n\t            return {\n\t                schema: {\n\t                    name: db.name,\n\t                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n\t                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n\t                        var compound = isArray(keyPath);\n\t                        var outbound = keyPath == null;\n\t                        var indexByKeyPath = {};\n\t                        var result = {\n\t                            name: store.name,\n\t                            primaryKey: {\n\t                                name: null,\n\t                                isPrimaryKey: true,\n\t                                outbound: outbound,\n\t                                compound: compound,\n\t                                keyPath: keyPath,\n\t                                autoIncrement: autoIncrement,\n\t                                unique: true,\n\t                                extractKey: getKeyExtractor(keyPath)\n\t                            },\n\t                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n\t                                .map(function (index) {\n\t                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n\t                                var compound = isArray(keyPath);\n\t                                var result = {\n\t                                    name: name,\n\t                                    compound: compound,\n\t                                    keyPath: keyPath,\n\t                                    unique: unique,\n\t                                    multiEntry: multiEntry,\n\t                                    extractKey: getKeyExtractor(keyPath)\n\t                                };\n\t                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n\t                                return result;\n\t                            }),\n\t                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n\t                        };\n\t                        indexByKeyPath[\":id\"] = result.primaryKey;\n\t                        if (keyPath != null) {\n\t                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n\t                        }\n\t                        return result;\n\t                    })\n\t                },\n\t                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n\t                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n\t                        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n\t                        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n\t            };\n\t        }\n\t        function makeIDBKeyRange(range) {\n\t            if (range.type === 3 )\n\t                return null;\n\t            if (range.type === 4 )\n\t                throw new Error(\"Cannot convert never type to IDBKeyRange\");\n\t            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n\t            var idbRange = lower === undefined ?\n\t                upper === undefined ?\n\t                    null :\n\t                    IdbKeyRange.upperBound(upper, !!upperOpen) :\n\t                upper === undefined ?\n\t                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n\t                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n\t            return idbRange;\n\t        }\n\t        function createDbCoreTable(tableSchema) {\n\t            var tableName = tableSchema.name;\n\t            function mutate(_a) {\n\t                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n\t                return new Promise(function (resolve, reject) {\n\t                    resolve = wrap(resolve);\n\t                    var store = trans.objectStore(tableName);\n\t                    var outbound = store.keyPath == null;\n\t                    var isAddOrPut = type === \"put\" || type === \"add\";\n\t                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n\t                        throw new Error(\"Invalid operation type: \" + type);\n\t                    var length = (keys || values || { length: 1 }).length;\n\t                    if (keys && values && keys.length !== values.length) {\n\t                        throw new Error(\"Given keys array must have same length as given values array.\");\n\t                    }\n\t                    if (length === 0)\n\t                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n\t                    var req;\n\t                    var reqs = [];\n\t                    var failures = [];\n\t                    var numFailures = 0;\n\t                    var errorHandler = function (event) {\n\t                        ++numFailures;\n\t                        preventDefault(event);\n\t                    };\n\t                    if (type === 'deleteRange') {\n\t                        if (range.type === 4 )\n\t                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n\t                        if (range.type === 3 )\n\t                            reqs.push(req = store.clear());\n\t                        else\n\t                            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n\t                    }\n\t                    else {\n\t                        var _a = isAddOrPut ?\n\t                            outbound ?\n\t                                [values, keys] :\n\t                                [values, null] :\n\t                            [keys, null], args1 = _a[0], args2 = _a[1];\n\t                        if (isAddOrPut) {\n\t                            for (var i = 0; i < length; ++i) {\n\t                                reqs.push(req = (args2 && args2[i] !== undefined ?\n\t                                    store[type](args1[i], args2[i]) :\n\t                                    store[type](args1[i])));\n\t                                req.onerror = errorHandler;\n\t                            }\n\t                        }\n\t                        else {\n\t                            for (var i = 0; i < length; ++i) {\n\t                                reqs.push(req = store[type](args1[i]));\n\t                                req.onerror = errorHandler;\n\t                            }\n\t                        }\n\t                    }\n\t                    var done = function (event) {\n\t                        var lastResult = event.target.result;\n\t                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n\t                        resolve({\n\t                            numFailures: numFailures,\n\t                            failures: failures,\n\t                            results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n\t                            lastResult: lastResult\n\t                        });\n\t                    };\n\t                    req.onerror = function (event) {\n\t                        errorHandler(event);\n\t                        done(event);\n\t                    };\n\t                    req.onsuccess = done;\n\t                });\n\t            }\n\t            function openCursor(_a) {\n\t                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n\t                return new Promise(function (resolve, reject) {\n\t                    resolve = wrap(resolve);\n\t                    var index = query.index, range = query.range;\n\t                    var store = trans.objectStore(tableName);\n\t                    var source = index.isPrimaryKey ?\n\t                        store :\n\t                        store.index(index.name);\n\t                    var direction = reverse ?\n\t                        unique ?\n\t                            \"prevunique\" :\n\t                            \"prev\" :\n\t                        unique ?\n\t                            \"nextunique\" :\n\t                            \"next\";\n\t                    var req = values || !('openKeyCursor' in source) ?\n\t                        source.openCursor(makeIDBKeyRange(range), direction) :\n\t                        source.openKeyCursor(makeIDBKeyRange(range), direction);\n\t                    req.onerror = eventRejectHandler(reject);\n\t                    req.onsuccess = wrap(function (ev) {\n\t                        var cursor = req.result;\n\t                        if (!cursor) {\n\t                            resolve(null);\n\t                            return;\n\t                        }\n\t                        cursor.___id = ++_id_counter;\n\t                        cursor.done = false;\n\t                        var _cursorContinue = cursor.continue.bind(cursor);\n\t                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n\t                        if (_cursorContinuePrimaryKey)\n\t                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n\t                        var _cursorAdvance = cursor.advance.bind(cursor);\n\t                        var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n\t                        var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n\t                        cursor.trans = trans;\n\t                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n\t                        cursor.fail = wrap(reject);\n\t                        cursor.next = function () {\n\t                            var _this = this;\n\t                            var gotOne = 1;\n\t                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n\t                        };\n\t                        cursor.start = function (callback) {\n\t                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n\t                                resolveIteration = wrap(resolveIteration);\n\t                                req.onerror = eventRejectHandler(rejectIteration);\n\t                                cursor.fail = rejectIteration;\n\t                                cursor.stop = function (value) {\n\t                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n\t                                    resolveIteration(value);\n\t                                };\n\t                            });\n\t                            var guardedCallback = function () {\n\t                                if (req.result) {\n\t                                    try {\n\t                                        callback();\n\t                                    }\n\t                                    catch (err) {\n\t                                        cursor.fail(err);\n\t                                    }\n\t                                }\n\t                                else {\n\t                                    cursor.done = true;\n\t                                    cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n\t                                    cursor.stop();\n\t                                }\n\t                            };\n\t                            req.onsuccess = wrap(function (ev) {\n\t                                req.onsuccess = guardedCallback;\n\t                                guardedCallback();\n\t                            });\n\t                            cursor.continue = _cursorContinue;\n\t                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n\t                            cursor.advance = _cursorAdvance;\n\t                            guardedCallback();\n\t                            return iterationPromise;\n\t                        };\n\t                        resolve(cursor);\n\t                    }, reject);\n\t                });\n\t            }\n\t            function query(hasGetAll) {\n\t                return function (request) {\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n\t                        var nonInfinitLimit = limit === Infinity ? undefined : limit;\n\t                        var index = query.index, range = query.range;\n\t                        var store = trans.objectStore(tableName);\n\t                        var source = index.isPrimaryKey ? store : store.index(index.name);\n\t                        var idbKeyRange = makeIDBKeyRange(range);\n\t                        if (limit === 0)\n\t                            return resolve({ result: [] });\n\t                        if (hasGetAll) {\n\t                            var req = values ?\n\t                                source.getAll(idbKeyRange, nonInfinitLimit) :\n\t                                source.getAllKeys(idbKeyRange, nonInfinitLimit);\n\t                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n\t                            req.onerror = eventRejectHandler(reject);\n\t                        }\n\t                        else {\n\t                            var count_1 = 0;\n\t                            var req_1 = values || !('openKeyCursor' in source) ?\n\t                                source.openCursor(idbKeyRange) :\n\t                                source.openKeyCursor(idbKeyRange);\n\t                            var result_1 = [];\n\t                            req_1.onsuccess = function (event) {\n\t                                var cursor = req_1.result;\n\t                                if (!cursor)\n\t                                    return resolve({ result: result_1 });\n\t                                result_1.push(values ? cursor.value : cursor.primaryKey);\n\t                                if (++count_1 === limit)\n\t                                    return resolve({ result: result_1 });\n\t                                cursor.continue();\n\t                            };\n\t                            req_1.onerror = eventRejectHandler(reject);\n\t                        }\n\t                    });\n\t                };\n\t            }\n\t            return {\n\t                name: tableName,\n\t                schema: tableSchema,\n\t                mutate: mutate,\n\t                getMany: function (_a) {\n\t                    var trans = _a.trans, keys = _a.keys;\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var store = trans.objectStore(tableName);\n\t                        var length = keys.length;\n\t                        var result = new Array(length);\n\t                        var keyCount = 0;\n\t                        var callbackCount = 0;\n\t                        var req;\n\t                        var successHandler = function (event) {\n\t                            var req = event.target;\n\t                            if ((result[req._pos] = req.result) != null)\n\t                                ;\n\t                            if (++callbackCount === keyCount)\n\t                                resolve(result);\n\t                        };\n\t                        var errorHandler = eventRejectHandler(reject);\n\t                        for (var i = 0; i < length; ++i) {\n\t                            var key = keys[i];\n\t                            if (key != null) {\n\t                                req = store.get(keys[i]);\n\t                                req._pos = i;\n\t                                req.onsuccess = successHandler;\n\t                                req.onerror = errorHandler;\n\t                                ++keyCount;\n\t                            }\n\t                        }\n\t                        if (keyCount === 0)\n\t                            resolve(result);\n\t                    });\n\t                },\n\t                get: function (_a) {\n\t                    var trans = _a.trans, key = _a.key;\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var store = trans.objectStore(tableName);\n\t                        var req = store.get(key);\n\t                        req.onsuccess = function (event) { return resolve(event.target.result); };\n\t                        req.onerror = eventRejectHandler(reject);\n\t                    });\n\t                },\n\t                query: query(hasGetAll),\n\t                openCursor: openCursor,\n\t                count: function (_a) {\n\t                    var query = _a.query, trans = _a.trans;\n\t                    var index = query.index, range = query.range;\n\t                    return new Promise(function (resolve, reject) {\n\t                        var store = trans.objectStore(tableName);\n\t                        var source = index.isPrimaryKey ? store : store.index(index.name);\n\t                        var idbKeyRange = makeIDBKeyRange(range);\n\t                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n\t                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n\t                        req.onerror = eventRejectHandler(reject);\n\t                    });\n\t                }\n\t            };\n\t        }\n\t        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n\t        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n\t        var tableMap = {};\n\t        tables.forEach(function (table) { return tableMap[table.name] = table; });\n\t        return {\n\t            stack: \"dbcore\",\n\t            transaction: db.transaction.bind(db),\n\t            table: function (name) {\n\t                var result = tableMap[name];\n\t                if (!result)\n\t                    throw new Error(\"Table '\".concat(name, \"' not found\"));\n\t                return tableMap[name];\n\t            },\n\t            MIN_KEY: -Infinity,\n\t            MAX_KEY: getMaxKey(IdbKeyRange),\n\t            schema: schema\n\t        };\n\t    }\n\n\t    function createMiddlewareStack(stackImpl, middlewares) {\n\t        return middlewares.reduce(function (down, _a) {\n\t            var create = _a.create;\n\t            return (__assign(__assign({}, down), create(down)));\n\t        }, stackImpl);\n\t    }\n\t    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n\t        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n\t        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n\t        return {\n\t            dbcore: dbcore\n\t        };\n\t    }\n\t    function generateMiddlewareStacks(db, tmpTrans) {\n\t        var idbdb = tmpTrans.db;\n\t        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n\t        db.core = stacks.dbcore;\n\t        db.tables.forEach(function (table) {\n\t            var tableName = table.name;\n\t            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n\t                table.core = db.core.table(tableName);\n\t                if (db[tableName] instanceof db.Table) {\n\t                    db[tableName].core = table.core;\n\t                }\n\t            }\n\t        });\n\t    }\n\n\t    function setApiOnPlace(db, objs, tableNames, dbschema) {\n\t        tableNames.forEach(function (tableName) {\n\t            var schema = dbschema[tableName];\n\t            objs.forEach(function (obj) {\n\t                var propDesc = getPropertyDescriptor(obj, tableName);\n\t                if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n\t                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n\t                        setProp(obj, tableName, {\n\t                            get: function () { return this.table(tableName); },\n\t                            set: function (value) {\n\t                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n\t                            }\n\t                        });\n\t                    }\n\t                    else {\n\t                        obj[tableName] = new db.Table(tableName, schema);\n\t                    }\n\t                }\n\t            });\n\t        });\n\t    }\n\t    function removeTablesApi(db, objs) {\n\t        objs.forEach(function (obj) {\n\t            for (var key in obj) {\n\t                if (obj[key] instanceof db.Table)\n\t                    delete obj[key];\n\t            }\n\t        });\n\t    }\n\t    function lowerVersionFirst(a, b) {\n\t        return a._cfg.version - b._cfg.version;\n\t    }\n\t    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n\t        var globalSchema = db._dbSchema;\n\t        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n\t            globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n\t            db._storeNames.push('$meta');\n\t        }\n\t        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n\t        trans.create(idbUpgradeTrans);\n\t        trans._completion.catch(reject);\n\t        var rejectTransaction = trans._reject.bind(trans);\n\t        var transless = PSD.transless || PSD;\n\t        newScope(function () {\n\t            PSD.trans = trans;\n\t            PSD.transless = transless;\n\t            if (oldVersion === 0) {\n\t                keys(globalSchema).forEach(function (tableName) {\n\t                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n\t                });\n\t                generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n\t            }\n\t            else {\n\t                generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                return getExistingVersion(db, trans, oldVersion)\n\t                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n\t                    .catch(rejectTransaction);\n\t            }\n\t        });\n\t    }\n\t    function patchCurrentVersion(db, idbUpgradeTrans) {\n\t        createMissingTables(db._dbSchema, idbUpgradeTrans);\n\t        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n\t            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n\t        }\n\t        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n\t        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n\t        var diff = getSchemaDiff(globalSchema, db._dbSchema);\n\t        var _loop_1 = function (tableChange) {\n\t            if (tableChange.change.length || tableChange.recreate) {\n\t                console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n\t                return { value: void 0 };\n\t            }\n\t            var store = idbUpgradeTrans.objectStore(tableChange.name);\n\t            tableChange.add.forEach(function (idx) {\n\t                if (debug)\n\t                    console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n\t                addIndex(store, idx);\n\t            });\n\t        };\n\t        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n\t            var tableChange = _a[_i];\n\t            var state_1 = _loop_1(tableChange);\n\t            if (typeof state_1 === \"object\")\n\t                return state_1.value;\n\t        }\n\t    }\n\t    function getExistingVersion(db, trans, oldVersion) {\n\t        if (trans.storeNames.includes('$meta')) {\n\t            return trans.table('$meta').get('version').then(function (metaVersion) {\n\t                return metaVersion != null ? metaVersion : oldVersion;\n\t            });\n\t        }\n\t        else {\n\t            return DexiePromise.resolve(oldVersion);\n\t        }\n\t    }\n\t    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n\t        var queue = [];\n\t        var versions = db._versions;\n\t        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n\t        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n\t        if (versToRun.length === 0) {\n\t            return DexiePromise.resolve();\n\t        }\n\t        versToRun.forEach(function (version) {\n\t            queue.push(function () {\n\t                var oldSchema = globalSchema;\n\t                var newSchema = version._cfg.dbschema;\n\t                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n\t                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n\t                globalSchema = db._dbSchema = newSchema;\n\t                var diff = getSchemaDiff(oldSchema, newSchema);\n\t                diff.add.forEach(function (tuple) {\n\t                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n\t                });\n\t                diff.change.forEach(function (change) {\n\t                    if (change.recreate) {\n\t                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n\t                    }\n\t                    else {\n\t                        var store_1 = idbUpgradeTrans.objectStore(change.name);\n\t                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n\t                        change.change.forEach(function (idx) {\n\t                            store_1.deleteIndex(idx.name);\n\t                            addIndex(store_1, idx);\n\t                        });\n\t                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n\t                    }\n\t                });\n\t                var contentUpgrade = version._cfg.contentUpgrade;\n\t                if (contentUpgrade && version._cfg.version > oldVersion) {\n\t                    generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                    trans._memoizedTables = {};\n\t                    var upgradeSchema_1 = shallowClone(newSchema);\n\t                    diff.del.forEach(function (table) {\n\t                        upgradeSchema_1[table] = oldSchema[table];\n\t                    });\n\t                    removeTablesApi(db, [db.Transaction.prototype]);\n\t                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n\t                    trans.schema = upgradeSchema_1;\n\t                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n\t                    if (contentUpgradeIsAsync_1) {\n\t                        incrementExpectedAwaits();\n\t                    }\n\t                    var returnValue_1;\n\t                    var promiseFollowed = DexiePromise.follow(function () {\n\t                        returnValue_1 = contentUpgrade(trans);\n\t                        if (returnValue_1) {\n\t                            if (contentUpgradeIsAsync_1) {\n\t                                var decrementor = decrementExpectedAwaits.bind(null, null);\n\t                                returnValue_1.then(decrementor, decrementor);\n\t                            }\n\t                        }\n\t                    });\n\t                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n\t                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n\t                }\n\t            });\n\t            queue.push(function (idbtrans) {\n\t                var newSchema = version._cfg.dbschema;\n\t                deleteRemovedTables(newSchema, idbtrans);\n\t                removeTablesApi(db, [db.Transaction.prototype]);\n\t                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n\t                trans.schema = db._dbSchema;\n\t            });\n\t            queue.push(function (idbtrans) {\n\t                if (db.idbdb.objectStoreNames.contains('$meta')) {\n\t                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n\t                        db.idbdb.deleteObjectStore('$meta');\n\t                        delete db._dbSchema.$meta;\n\t                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n\t                    }\n\t                    else {\n\t                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n\t                    }\n\t                }\n\t            });\n\t        });\n\t        function runQueue() {\n\t            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n\t                DexiePromise.resolve();\n\t        }\n\t        return runQueue().then(function () {\n\t            createMissingTables(globalSchema, idbUpgradeTrans);\n\t        });\n\t    }\n\t    function getSchemaDiff(oldSchema, newSchema) {\n\t        var diff = {\n\t            del: [],\n\t            add: [],\n\t            change: []\n\t        };\n\t        var table;\n\t        for (table in oldSchema) {\n\t            if (!newSchema[table])\n\t                diff.del.push(table);\n\t        }\n\t        for (table in newSchema) {\n\t            var oldDef = oldSchema[table], newDef = newSchema[table];\n\t            if (!oldDef) {\n\t                diff.add.push([table, newDef]);\n\t            }\n\t            else {\n\t                var change = {\n\t                    name: table,\n\t                    def: newDef,\n\t                    recreate: false,\n\t                    del: [],\n\t                    add: [],\n\t                    change: []\n\t                };\n\t                if ((\n\t                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n\t                    (oldDef.primKey.auto !== newDef.primKey.auto)) {\n\t                    change.recreate = true;\n\t                    diff.change.push(change);\n\t                }\n\t                else {\n\t                    var oldIndexes = oldDef.idxByName;\n\t                    var newIndexes = newDef.idxByName;\n\t                    var idxName = void 0;\n\t                    for (idxName in oldIndexes) {\n\t                        if (!newIndexes[idxName])\n\t                            change.del.push(idxName);\n\t                    }\n\t                    for (idxName in newIndexes) {\n\t                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n\t                        if (!oldIdx)\n\t                            change.add.push(newIdx);\n\t                        else if (oldIdx.src !== newIdx.src)\n\t                            change.change.push(newIdx);\n\t                    }\n\t                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n\t                        diff.change.push(change);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return diff;\n\t    }\n\t    function createTable(idbtrans, tableName, primKey, indexes) {\n\t        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n\t            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n\t            { autoIncrement: primKey.auto });\n\t        indexes.forEach(function (idx) { return addIndex(store, idx); });\n\t        return store;\n\t    }\n\t    function createMissingTables(newSchema, idbtrans) {\n\t        keys(newSchema).forEach(function (tableName) {\n\t            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n\t                if (debug)\n\t                    console.debug('Dexie: Creating missing table', tableName);\n\t                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n\t            }\n\t        });\n\t    }\n\t    function deleteRemovedTables(newSchema, idbtrans) {\n\t        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n\t            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n\t        });\n\t    }\n\t    function addIndex(store, idx) {\n\t        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n\t    }\n\t    function buildGlobalSchema(db, idbdb, tmpTrans) {\n\t        var globalSchema = {};\n\t        var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n\t        dbStoreNames.forEach(function (storeName) {\n\t            var store = tmpTrans.objectStore(storeName);\n\t            var keyPath = store.keyPath;\n\t            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n\t            var indexes = [];\n\t            for (var j = 0; j < store.indexNames.length; ++j) {\n\t                var idbindex = store.index(store.indexNames[j]);\n\t                keyPath = idbindex.keyPath;\n\t                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n\t                indexes.push(index);\n\t            }\n\t            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n\t        });\n\t        return globalSchema;\n\t    }\n\t    function readGlobalSchema(db, idbdb, tmpTrans) {\n\t        db.verno = idbdb.version / 10;\n\t        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n\t        db._storeNames = slice(idbdb.objectStoreNames, 0);\n\t        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n\t    }\n\t    function verifyInstalledSchema(db, tmpTrans) {\n\t        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n\t        var diff = getSchemaDiff(installedSchema, db._dbSchema);\n\t        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n\t    }\n\t    function adjustToExistingIndexNames(db, schema, idbtrans) {\n\t        var storeNames = idbtrans.db.objectStoreNames;\n\t        for (var i = 0; i < storeNames.length; ++i) {\n\t            var storeName = storeNames[i];\n\t            var store = idbtrans.objectStore(storeName);\n\t            db._hasGetAll = 'getAll' in store;\n\t            for (var j = 0; j < store.indexNames.length; ++j) {\n\t                var indexName = store.indexNames[j];\n\t                var keyPath = store.index(indexName).keyPath;\n\t                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n\t                if (schema[storeName]) {\n\t                    var indexSpec = schema[storeName].idxByName[dexieName];\n\t                    if (indexSpec) {\n\t                        indexSpec.name = indexName;\n\t                        delete schema[storeName].idxByName[dexieName];\n\t                        schema[storeName].idxByName[indexName] = indexSpec;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n\t            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n\t            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n\t            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n\t            db._hasGetAll = false;\n\t        }\n\t    }\n\t    function parseIndexSyntax(primKeyAndIndexes) {\n\t        return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n\t            index = index.trim();\n\t            var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n\t            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n\t            return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n\t        });\n\t    }\n\n\t    var Version =  (function () {\n\t        function Version() {\n\t        }\n\t        Version.prototype._parseStoresSpec = function (stores, outSchema) {\n\t            keys(stores).forEach(function (tableName) {\n\t                if (stores[tableName] !== null) {\n\t                    var indexes = parseIndexSyntax(stores[tableName]);\n\t                    var primKey = indexes.shift();\n\t                    primKey.unique = true;\n\t                    if (primKey.multi)\n\t                        throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n\t                    indexes.forEach(function (idx) {\n\t                        if (idx.auto)\n\t                            throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n\t                        if (!idx.keyPath)\n\t                            throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n\t                    });\n\t                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n\t                }\n\t            });\n\t        };\n\t        Version.prototype.stores = function (stores) {\n\t            var db = this.db;\n\t            this._cfg.storesSource = this._cfg.storesSource ?\n\t                extend(this._cfg.storesSource, stores) :\n\t                stores;\n\t            var versions = db._versions;\n\t            var storesSpec = {};\n\t            var dbschema = {};\n\t            versions.forEach(function (version) {\n\t                extend(storesSpec, version._cfg.storesSource);\n\t                dbschema = (version._cfg.dbschema = {});\n\t                version._parseStoresSpec(storesSpec, dbschema);\n\t            });\n\t            db._dbSchema = dbschema;\n\t            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n\t            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n\t            db._storeNames = keys(dbschema);\n\t            return this;\n\t        };\n\t        Version.prototype.upgrade = function (upgradeFunction) {\n\t            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n\t            return this;\n\t        };\n\t        return Version;\n\t    }());\n\n\t    function createVersionConstructor(db) {\n\t        return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n\t            this.db = db;\n\t            this._cfg = {\n\t                version: versionNumber,\n\t                storesSource: null,\n\t                dbschema: {},\n\t                tables: {},\n\t                contentUpgrade: null\n\t            };\n\t        });\n\t    }\n\n\t    function getDbNamesTable(indexedDB, IDBKeyRange) {\n\t        var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n\t        if (!dbNamesDB) {\n\t            dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n\t                addons: [],\n\t                indexedDB: indexedDB,\n\t                IDBKeyRange: IDBKeyRange,\n\t            });\n\t            dbNamesDB.version(1).stores({ dbnames: \"name\" });\n\t        }\n\t        return dbNamesDB.table(\"dbnames\");\n\t    }\n\t    function hasDatabasesNative(indexedDB) {\n\t        return indexedDB && typeof indexedDB.databases === \"function\";\n\t    }\n\t    function getDatabaseNames(_a) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        return hasDatabasesNative(indexedDB)\n\t            ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n\t                return infos\n\t                    .map(function (info) { return info.name; })\n\t                    .filter(function (name) { return name !== DBNAMES_DB; });\n\t            })\n\t            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n\t    }\n\t    function _onDatabaseCreated(_a, name) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        !hasDatabasesNative(indexedDB) &&\n\t            name !== DBNAMES_DB &&\n\t            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n\t    }\n\t    function _onDatabaseDeleted(_a, name) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        !hasDatabasesNative(indexedDB) &&\n\t            name !== DBNAMES_DB &&\n\t            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n\t    }\n\n\t    function vip(fn) {\n\t        return newScope(function () {\n\t            PSD.letThrough = true;\n\t            return fn();\n\t        });\n\t    }\n\n\t    function idbReady() {\n\t        var isSafari = !navigator.userAgentData &&\n\t            /Safari\\//.test(navigator.userAgent) &&\n\t            !/Chrom(e|ium)\\//.test(navigator.userAgent);\n\t        if (!isSafari || !indexedDB.databases)\n\t            return Promise.resolve();\n\t        var intervalId;\n\t        return new Promise(function (resolve) {\n\t            var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n\t            intervalId = setInterval(tryIdb, 100);\n\t            tryIdb();\n\t        }).finally(function () { return clearInterval(intervalId); });\n\t    }\n\n\t    var _a;\n\t    function isEmptyRange(node) {\n\t        return !(\"from\" in node);\n\t    }\n\t    var RangeSet = function (fromOrTree, to) {\n\t        if (this) {\n\t            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n\t        }\n\t        else {\n\t            var rv = new RangeSet();\n\t            if (fromOrTree && (\"d\" in fromOrTree)) {\n\t                extend(rv, fromOrTree);\n\t            }\n\t            return rv;\n\t        }\n\t    };\n\t    props(RangeSet.prototype, (_a = {\n\t            add: function (rangeSet) {\n\t                mergeRanges(this, rangeSet);\n\t                return this;\n\t            },\n\t            addKey: function (key) {\n\t                addRange(this, key, key);\n\t                return this;\n\t            },\n\t            addKeys: function (keys) {\n\t                var _this = this;\n\t                keys.forEach(function (key) { return addRange(_this, key, key); });\n\t                return this;\n\t            },\n\t            hasKey: function (key) {\n\t                var node = getRangeSetIterator(this).next(key).value;\n\t                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n\t            }\n\t        },\n\t        _a[iteratorSymbol] = function () {\n\t            return getRangeSetIterator(this);\n\t        },\n\t        _a));\n\t    function addRange(target, from, to) {\n\t        var diff = cmp(from, to);\n\t        if (isNaN(diff))\n\t            return;\n\t        if (diff > 0)\n\t            throw RangeError();\n\t        if (isEmptyRange(target))\n\t            return extend(target, { from: from, to: to, d: 1 });\n\t        var left = target.l;\n\t        var right = target.r;\n\t        if (cmp(to, target.from) < 0) {\n\t            left\n\t                ? addRange(left, from, to)\n\t                : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n\t            return rebalance(target);\n\t        }\n\t        if (cmp(from, target.to) > 0) {\n\t            right\n\t                ? addRange(right, from, to)\n\t                : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n\t            return rebalance(target);\n\t        }\n\t        if (cmp(from, target.from) < 0) {\n\t            target.from = from;\n\t            target.l = null;\n\t            target.d = right ? right.d + 1 : 1;\n\t        }\n\t        if (cmp(to, target.to) > 0) {\n\t            target.to = to;\n\t            target.r = null;\n\t            target.d = target.l ? target.l.d + 1 : 1;\n\t        }\n\t        var rightWasCutOff = !target.r;\n\t        if (left && !target.l) {\n\t            mergeRanges(target, left);\n\t        }\n\t        if (right && rightWasCutOff) {\n\t            mergeRanges(target, right);\n\t        }\n\t    }\n\t    function mergeRanges(target, newSet) {\n\t        function _addRangeSet(target, _a) {\n\t            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n\t            addRange(target, from, to);\n\t            if (l)\n\t                _addRangeSet(target, l);\n\t            if (r)\n\t                _addRangeSet(target, r);\n\t        }\n\t        if (!isEmptyRange(newSet))\n\t            _addRangeSet(target, newSet);\n\t    }\n\t    function rangesOverlap(rangeSet1, rangeSet2) {\n\t        var i1 = getRangeSetIterator(rangeSet2);\n\t        var nextResult1 = i1.next();\n\t        if (nextResult1.done)\n\t            return false;\n\t        var a = nextResult1.value;\n\t        var i2 = getRangeSetIterator(rangeSet1);\n\t        var nextResult2 = i2.next(a.from);\n\t        var b = nextResult2.value;\n\t        while (!nextResult1.done && !nextResult2.done) {\n\t            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n\t                return true;\n\t            cmp(a.from, b.from) < 0\n\t                ? (a = (nextResult1 = i1.next(b.from)).value)\n\t                : (b = (nextResult2 = i2.next(a.from)).value);\n\t        }\n\t        return false;\n\t    }\n\t    function getRangeSetIterator(node) {\n\t        var state = isEmptyRange(node) ? null : { s: 0, n: node };\n\t        return {\n\t            next: function (key) {\n\t                var keyProvided = arguments.length > 0;\n\t                while (state) {\n\t                    switch (state.s) {\n\t                        case 0:\n\t                            state.s = 1;\n\t                            if (keyProvided) {\n\t                                while (state.n.l && cmp(key, state.n.from) < 0)\n\t                                    state = { up: state, n: state.n.l, s: 1 };\n\t                            }\n\t                            else {\n\t                                while (state.n.l)\n\t                                    state = { up: state, n: state.n.l, s: 1 };\n\t                            }\n\t                        case 1:\n\t                            state.s = 2;\n\t                            if (!keyProvided || cmp(key, state.n.to) <= 0)\n\t                                return { value: state.n, done: false };\n\t                        case 2:\n\t                            if (state.n.r) {\n\t                                state.s = 3;\n\t                                state = { up: state, n: state.n.r, s: 0 };\n\t                                continue;\n\t                            }\n\t                        case 3:\n\t                            state = state.up;\n\t                    }\n\t                }\n\t                return { done: true };\n\t            },\n\t        };\n\t    }\n\t    function rebalance(target) {\n\t        var _a, _b;\n\t        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n\t        var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n\t        if (r) {\n\t            var l = r === \"r\" ? \"l\" : \"r\";\n\t            var rootClone = __assign({}, target);\n\t            var oldRootRight = target[r];\n\t            target.from = oldRootRight.from;\n\t            target.to = oldRootRight.to;\n\t            target[r] = oldRootRight[r];\n\t            rootClone[r] = oldRootRight[l];\n\t            target[l] = rootClone;\n\t            rootClone.d = computeDepth(rootClone);\n\t        }\n\t        target.d = computeDepth(target);\n\t    }\n\t    function computeDepth(_a) {\n\t        var r = _a.r, l = _a.l;\n\t        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n\t    }\n\n\t    function extendObservabilitySet(target, newSet) {\n\t        keys(newSet).forEach(function (part) {\n\t            if (target[part])\n\t                mergeRanges(target[part], newSet[part]);\n\t            else\n\t                target[part] = cloneSimpleObjectTree(newSet[part]);\n\t        });\n\t        return target;\n\t    }\n\n\t    function obsSetsOverlap(os1, os2) {\n\t        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n\t    }\n\n\t    var cache = {};\n\n\t    var unsignaledParts = {};\n\t    var isTaskEnqueued = false;\n\t    function signalSubscribersLazily(part, optimistic) {\n\t        extendObservabilitySet(unsignaledParts, part);\n\t        if (!isTaskEnqueued) {\n\t            isTaskEnqueued = true;\n\t            setTimeout(function () {\n\t                isTaskEnqueued = false;\n\t                var parts = unsignaledParts;\n\t                unsignaledParts = {};\n\t                signalSubscribersNow(parts, false);\n\t            }, 0);\n\t        }\n\t    }\n\t    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n\t        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n\t        var queriesToSignal = new Set();\n\t        if (updatedParts.all) {\n\t            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n\t                var tblCache = _a[_i];\n\t                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in updatedParts) {\n\t                var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n\t                if (parts) {\n\t                    var dbName = parts[1], tableName = parts[2];\n\t                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t                    if (tblCache)\n\t                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n\t                }\n\t            }\n\t        }\n\t        queriesToSignal.forEach(function (requery) { return requery(); });\n\t    }\n\t    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n\t        var updatedEntryLists = [];\n\t        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n\t            var _b = _a[_i], indexName = _b[0], entries = _b[1];\n\t            var filteredEntries = [];\n\t            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n\t                var entry = entries_1[_c];\n\t                if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n\t                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n\t                }\n\t                else if (deleteAffectedCacheEntries) {\n\t                    filteredEntries.push(entry);\n\t                }\n\t            }\n\t            if (deleteAffectedCacheEntries)\n\t                updatedEntryLists.push([indexName, filteredEntries]);\n\t        }\n\t        if (deleteAffectedCacheEntries) {\n\t            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n\t                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n\t                tblCache.queries.query[indexName] = filteredEntries;\n\t            }\n\t        }\n\t    }\n\n\t    function dexieOpen(db) {\n\t        var state = db._state;\n\t        var indexedDB = db._deps.indexedDB;\n\t        if (state.isBeingOpened || db.idbdb)\n\t            return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n\t                rejection(state.dbOpenError) :\n\t                db; });\n\t        state.isBeingOpened = true;\n\t        state.dbOpenError = null;\n\t        state.openComplete = false;\n\t        var openCanceller = state.openCanceller;\n\t        var nativeVerToOpen = Math.round(db.verno * 10);\n\t        var schemaPatchMode = false;\n\t        function throwIfCancelled() {\n\t            if (state.openCanceller !== openCanceller)\n\t                throw new exceptions.DatabaseClosed('db.open() was cancelled');\n\t        }\n\t        var resolveDbReady = state.dbReadyResolve,\n\t        upgradeTransaction = null, wasCreated = false;\n\t        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n\t            throwIfCancelled();\n\t            if (!indexedDB)\n\t                throw new exceptions.MissingAPI();\n\t            var dbName = db.name;\n\t            var req = state.autoSchema || !nativeVerToOpen ?\n\t                indexedDB.open(dbName) :\n\t                indexedDB.open(dbName, nativeVerToOpen);\n\t            if (!req)\n\t                throw new exceptions.MissingAPI();\n\t            req.onerror = eventRejectHandler(reject);\n\t            req.onblocked = wrap(db._fireOnBlocked);\n\t            req.onupgradeneeded = wrap(function (e) {\n\t                upgradeTransaction = req.transaction;\n\t                if (state.autoSchema && !db._options.allowEmptyDB) {\n\t                    req.onerror = preventDefault;\n\t                    upgradeTransaction.abort();\n\t                    req.result.close();\n\t                    var delreq = indexedDB.deleteDatabase(dbName);\n\t                    delreq.onsuccess = delreq.onerror = wrap(function () {\n\t                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n\t                    });\n\t                }\n\t                else {\n\t                    upgradeTransaction.onerror = eventRejectHandler(reject);\n\t                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n\t                    wasCreated = oldVer < 1;\n\t                    db.idbdb = req.result;\n\t                    if (schemaPatchMode) {\n\t                        patchCurrentVersion(db, upgradeTransaction);\n\t                    }\n\t                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n\t                }\n\t            }, reject);\n\t            req.onsuccess = wrap(function () {\n\t                upgradeTransaction = null;\n\t                var idbdb = db.idbdb = req.result;\n\t                var objectStoreNames = slice(idbdb.objectStoreNames);\n\t                if (objectStoreNames.length > 0)\n\t                    try {\n\t                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n\t                        if (state.autoSchema)\n\t                            readGlobalSchema(db, idbdb, tmpTrans);\n\t                        else {\n\t                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n\t                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n\t                                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n\t                                idbdb.close();\n\t                                nativeVerToOpen = idbdb.version + 1;\n\t                                schemaPatchMode = true;\n\t                                return resolve(tryOpenDB());\n\t                            }\n\t                        }\n\t                        generateMiddlewareStacks(db, tmpTrans);\n\t                    }\n\t                    catch (e) {\n\t                    }\n\t                connections.push(db);\n\t                idbdb.onversionchange = wrap(function (ev) {\n\t                    state.vcFired = true;\n\t                    db.on(\"versionchange\").fire(ev);\n\t                });\n\t                idbdb.onclose = wrap(function (ev) {\n\t                    db.on(\"close\").fire(ev);\n\t                });\n\t                if (wasCreated)\n\t                    _onDatabaseCreated(db._deps, dbName);\n\t                resolve();\n\t            }, reject);\n\t        }).catch(function (err) {\n\t            switch (err === null || err === void 0 ? void 0 : err.name) {\n\t                case \"UnknownError\":\n\t                    if (state.PR1398_maxLoop > 0) {\n\t                        state.PR1398_maxLoop--;\n\t                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n\t                        return tryOpenDB();\n\t                    }\n\t                    break;\n\t                case \"VersionError\":\n\t                    if (nativeVerToOpen > 0) {\n\t                        nativeVerToOpen = 0;\n\t                        return tryOpenDB();\n\t                    }\n\t                    break;\n\t            }\n\t            return DexiePromise.reject(err);\n\t        }); };\n\t        return DexiePromise.race([\n\t            openCanceller,\n\t            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n\t        ]).then(function () {\n\t            throwIfCancelled();\n\t            state.onReadyBeingFired = [];\n\t            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n\t                if (state.onReadyBeingFired.length > 0) {\n\t                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n\t                    state.onReadyBeingFired = [];\n\t                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n\t                }\n\t            });\n\t        }).finally(function () {\n\t            if (state.openCanceller === openCanceller) {\n\t                state.onReadyBeingFired = null;\n\t                state.isBeingOpened = false;\n\t            }\n\t        }).catch(function (err) {\n\t            state.dbOpenError = err;\n\t            try {\n\t                upgradeTransaction && upgradeTransaction.abort();\n\t            }\n\t            catch (_a) { }\n\t            if (openCanceller === state.openCanceller) {\n\t                db._close();\n\t            }\n\t            return rejection(err);\n\t        }).finally(function () {\n\t            state.openComplete = true;\n\t            resolveDbReady();\n\t        }).then(function () {\n\t            if (wasCreated) {\n\t                var everything_1 = {};\n\t                db.tables.forEach(function (table) {\n\t                    table.schema.indexes.forEach(function (idx) {\n\t                        if (idx.name)\n\t                            everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n\t                    });\n\t                    everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n\t                });\n\t                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n\t                signalSubscribersNow(everything_1, true);\n\t            }\n\t            return db;\n\t        });\n\t    }\n\n\t    function awaitIterator(iterator) {\n\t        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n\t        function step(getNext) {\n\t            return function (val) {\n\t                var next = getNext(val), value = next.value;\n\t                return next.done ? value :\n\t                    (!value || typeof value.then !== 'function' ?\n\t                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n\t                        value.then(onSuccess, onError));\n\t            };\n\t        }\n\t        return step(callNext)();\n\t    }\n\n\t    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n\t        var i = arguments.length;\n\t        if (i < 2)\n\t            throw new exceptions.InvalidArgument(\"Too few arguments\");\n\t        var args = new Array(i - 1);\n\t        while (--i)\n\t            args[i - 1] = arguments[i];\n\t        scopeFunc = args.pop();\n\t        var tables = flatten(args);\n\t        return [mode, tables, scopeFunc];\n\t    }\n\t    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n\t        return DexiePromise.resolve().then(function () {\n\t            var transless = PSD.transless || PSD;\n\t            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n\t            trans.explicit = true;\n\t            var zoneProps = {\n\t                trans: trans,\n\t                transless: transless\n\t            };\n\t            if (parentTransaction) {\n\t                trans.idbtrans = parentTransaction.idbtrans;\n\t            }\n\t            else {\n\t                try {\n\t                    trans.create();\n\t                    trans.idbtrans._explicit = true;\n\t                    db._state.PR1398_maxLoop = 3;\n\t                }\n\t                catch (ex) {\n\t                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n\t                        console.warn('Dexie: Need to reopen db');\n\t                        db.close({ disableAutoOpen: false });\n\t                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n\t                    }\n\t                    return rejection(ex);\n\t                }\n\t            }\n\t            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n\t            if (scopeFuncIsAsync) {\n\t                incrementExpectedAwaits();\n\t            }\n\t            var returnValue;\n\t            var promiseFollowed = DexiePromise.follow(function () {\n\t                returnValue = scopeFunc.call(trans, trans);\n\t                if (returnValue) {\n\t                    if (scopeFuncIsAsync) {\n\t                        var decrementor = decrementExpectedAwaits.bind(null, null);\n\t                        returnValue.then(decrementor, decrementor);\n\t                    }\n\t                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n\t                        returnValue = awaitIterator(returnValue);\n\t                    }\n\t                }\n\t            }, zoneProps);\n\t            return (returnValue && typeof returnValue.then === 'function' ?\n\t                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n\t                    x\n\t                    : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n\t                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n\t                if (parentTransaction)\n\t                    trans._resolve();\n\t                return trans._completion.then(function () { return x; });\n\t            }).catch(function (e) {\n\t                trans._reject(e);\n\t                return rejection(e);\n\t            });\n\t        });\n\t    }\n\n\t    function pad(a, value, count) {\n\t        var result = isArray(a) ? a.slice() : [a];\n\t        for (var i = 0; i < count; ++i)\n\t            result.push(value);\n\t        return result;\n\t    }\n\t    function createVirtualIndexMiddleware(down) {\n\t        return __assign(__assign({}, down), { table: function (tableName) {\n\t                var table = down.table(tableName);\n\t                var schema = table.schema;\n\t                var indexLookup = {};\n\t                var allVirtualIndexes = [];\n\t                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n\t                    var keyPathAlias = getKeyPathAlias(keyPath);\n\t                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n\t                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n\t                    var isVirtual = keyTail > 0;\n\t                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n\t                            ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n\t                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n\t                    indexList.push(virtualIndex);\n\t                    if (!virtualIndex.isPrimaryKey) {\n\t                        allVirtualIndexes.push(virtualIndex);\n\t                    }\n\t                    if (keyLength > 1) {\n\t                        var virtualKeyPath = keyLength === 2 ?\n\t                            keyPath[0] :\n\t                            keyPath.slice(0, keyLength - 1);\n\t                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n\t                    }\n\t                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n\t                    return virtualIndex;\n\t                }\n\t                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n\t                indexLookup[\":id\"] = [primaryKey];\n\t                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n\t                    var index = _a[_i];\n\t                    addVirtualIndexes(index.keyPath, 0, index);\n\t                }\n\t                function findBestIndex(keyPath) {\n\t                    var result = indexLookup[getKeyPathAlias(keyPath)];\n\t                    return result && result[0];\n\t                }\n\t                function translateRange(range, keyTail) {\n\t                    return {\n\t                        type: range.type === 1  ?\n\t                            2  :\n\t                            range.type,\n\t                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n\t                        lowerOpen: true,\n\t                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n\t                        upperOpen: true\n\t                    };\n\t                }\n\t                function translateRequest(req) {\n\t                    var index = req.query.index;\n\t                    return index.isVirtual ? __assign(__assign({}, req), { query: {\n\t                            index: index.lowLevelIndex,\n\t                            range: translateRange(req.query.range, index.keyTail)\n\t                        } }) : req;\n\t                }\n\t                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n\t                        return table.count(translateRequest(req));\n\t                    }, query: function (req) {\n\t                        return table.query(translateRequest(req));\n\t                    }, openCursor: function (req) {\n\t                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n\t                        if (!isVirtual)\n\t                            return table.openCursor(req);\n\t                        function createVirtualCursor(cursor) {\n\t                            function _continue(key) {\n\t                                key != null ?\n\t                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n\t                                    req.unique ?\n\t                                        cursor.continue(cursor.key.slice(0, keyLength)\n\t                                            .concat(req.reverse\n\t                                            ? down.MIN_KEY\n\t                                            : down.MAX_KEY, keyTail)) :\n\t                                        cursor.continue();\n\t                            }\n\t                            var virtualCursor = Object.create(cursor, {\n\t                                continue: { value: _continue },\n\t                                continuePrimaryKey: {\n\t                                    value: function (key, primaryKey) {\n\t                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n\t                                    }\n\t                                },\n\t                                primaryKey: {\n\t                                    get: function () {\n\t                                        return cursor.primaryKey;\n\t                                    }\n\t                                },\n\t                                key: {\n\t                                    get: function () {\n\t                                        var key = cursor.key;\n\t                                        return keyLength === 1 ?\n\t                                            key[0] :\n\t                                            key.slice(0, keyLength);\n\t                                    }\n\t                                },\n\t                                value: {\n\t                                    get: function () {\n\t                                        return cursor.value;\n\t                                    }\n\t                                }\n\t                            });\n\t                            return virtualCursor;\n\t                        }\n\t                        return table.openCursor(translateRequest(req))\n\t                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n\t                    } });\n\t                return result;\n\t            } });\n\t    }\n\t    var virtualIndexMiddleware = {\n\t        stack: \"dbcore\",\n\t        name: \"VirtualIndexMiddleware\",\n\t        level: 1,\n\t        create: createVirtualIndexMiddleware\n\t    };\n\n\t    function getObjectDiff(a, b, rv, prfx) {\n\t        rv = rv || {};\n\t        prfx = prfx || '';\n\t        keys(a).forEach(function (prop) {\n\t            if (!hasOwn(b, prop)) {\n\t                rv[prfx + prop] = undefined;\n\t            }\n\t            else {\n\t                var ap = a[prop], bp = b[prop];\n\t                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n\t                    var apTypeName = toStringTag(ap);\n\t                    var bpTypeName = toStringTag(bp);\n\t                    if (apTypeName !== bpTypeName) {\n\t                        rv[prfx + prop] = b[prop];\n\t                    }\n\t                    else if (apTypeName === 'Object') {\n\t                        getObjectDiff(ap, bp, rv, prfx + prop + '.');\n\t                    }\n\t                    else if (ap !== bp) {\n\t                        rv[prfx + prop] = b[prop];\n\t                    }\n\t                }\n\t                else if (ap !== bp)\n\t                    rv[prfx + prop] = b[prop];\n\t            }\n\t        });\n\t        keys(b).forEach(function (prop) {\n\t            if (!hasOwn(a, prop)) {\n\t                rv[prfx + prop] = b[prop];\n\t            }\n\t        });\n\t        return rv;\n\t    }\n\n\t    function getEffectiveKeys(primaryKey, req) {\n\t        if (req.type === 'delete')\n\t            return req.keys;\n\t        return req.keys || req.values.map(primaryKey.extractKey);\n\t    }\n\n\t    var hooksMiddleware = {\n\t        stack: \"dbcore\",\n\t        name: \"HooksMiddleware\",\n\t        level: 2,\n\t        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n\t                var downTable = downCore.table(tableName);\n\t                var primaryKey = downTable.schema.primaryKey;\n\t                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n\t                        var dxTrans = PSD.trans;\n\t                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n\t                        switch (req.type) {\n\t                            case 'add':\n\t                                if (creating.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'put':\n\t                                if (creating.fire === nop && updating.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'delete':\n\t                                if (deleting.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'deleteRange':\n\t                                if (deleting.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n\t                        }\n\t                        return downTable.mutate(req);\n\t                        function addPutOrDelete(req) {\n\t                            var dxTrans = PSD.trans;\n\t                            var keys = req.keys || getEffectiveKeys(primaryKey, req);\n\t                            if (!keys)\n\t                                throw new Error(\"Keys missing\");\n\t                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n\t                            if (req.type !== 'delete')\n\t                                req.values = __spreadArray([], req.values, true);\n\t                            if (req.keys)\n\t                                req.keys = __spreadArray([], req.keys, true);\n\t                            return getExistingValues(downTable, req, keys).then(function (existingValues) {\n\t                                var contexts = keys.map(function (key, i) {\n\t                                    var existingValue = existingValues[i];\n\t                                    var ctx = { onerror: null, onsuccess: null };\n\t                                    if (req.type === 'delete') {\n\t                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n\t                                    }\n\t                                    else if (req.type === 'add' || existingValue === undefined) {\n\t                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n\t                                        if (key == null && generatedPrimaryKey != null) {\n\t                                            key = generatedPrimaryKey;\n\t                                            req.keys[i] = key;\n\t                                            if (!primaryKey.outbound) {\n\t                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                    else {\n\t                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);\n\t                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n\t                                        if (additionalChanges_1) {\n\t                                            var requestedValue_1 = req.values[i];\n\t                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {\n\t                                                if (hasOwn(requestedValue_1, keyPath)) {\n\t                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n\t                                                }\n\t                                                else {\n\t                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n\t                                                }\n\t                                            });\n\t                                        }\n\t                                    }\n\t                                    return ctx;\n\t                                });\n\t                                return downTable.mutate(req).then(function (_a) {\n\t                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n\t                                    for (var i = 0; i < keys.length; ++i) {\n\t                                        var primKey = results ? results[i] : keys[i];\n\t                                        var ctx = contexts[i];\n\t                                        if (primKey == null) {\n\t                                            ctx.onerror && ctx.onerror(failures[i]);\n\t                                        }\n\t                                        else {\n\t                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n\t                                                req.values[i] :\n\t                                                primKey\n\t                                            );\n\t                                        }\n\t                                    }\n\t                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n\t                                }).catch(function (error) {\n\t                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n\t                                    return Promise.reject(error);\n\t                                });\n\t                            });\n\t                        }\n\t                        function deleteRange(req) {\n\t                            return deleteNextChunk(req.trans, req.range, 10000);\n\t                        }\n\t                        function deleteNextChunk(trans, range, limit) {\n\t                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n\t                                .then(function (_a) {\n\t                                var result = _a.result;\n\t                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n\t                                    if (res.numFailures > 0)\n\t                                        return Promise.reject(res.failures[0]);\n\t                                    if (result.length < limit) {\n\t                                        return { failures: [], numFailures: 0, lastResult: undefined };\n\t                                    }\n\t                                    else {\n\t                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n\t                                    }\n\t                                });\n\t                            });\n\t                        }\n\t                    } });\n\t                return tableMiddleware;\n\t            } })); }\n\t    };\n\t    function getExistingValues(table, req, effectiveKeys) {\n\t        return req.type === \"add\"\n\t            ? Promise.resolve([])\n\t            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n\t    }\n\n\t    function getFromTransactionCache(keys, cache, clone) {\n\t        try {\n\t            if (!cache)\n\t                return null;\n\t            if (cache.keys.length < keys.length)\n\t                return null;\n\t            var result = [];\n\t            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n\t                if (cmp(cache.keys[i], keys[j]) !== 0)\n\t                    continue;\n\t                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n\t                ++j;\n\t            }\n\t            return result.length === keys.length ? result : null;\n\t        }\n\t        catch (_a) {\n\t            return null;\n\t        }\n\t    }\n\t    var cacheExistingValuesMiddleware = {\n\t        stack: \"dbcore\",\n\t        level: -1,\n\t        create: function (core) {\n\t            return {\n\t                table: function (tableName) {\n\t                    var table = core.table(tableName);\n\t                    return __assign(__assign({}, table), { getMany: function (req) {\n\t                            if (!req.cache) {\n\t                                return table.getMany(req);\n\t                            }\n\t                            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n\t                            if (cachedResult) {\n\t                                return DexiePromise.resolve(cachedResult);\n\t                            }\n\t                            return table.getMany(req).then(function (res) {\n\t                                req.trans[\"_cache\"] = {\n\t                                    keys: req.keys,\n\t                                    values: req.cache === \"clone\" ? deepClone(res) : res,\n\t                                };\n\t                                return res;\n\t                            });\n\t                        }, mutate: function (req) {\n\t                            if (req.type !== \"add\")\n\t                                req.trans[\"_cache\"] = null;\n\t                            return table.mutate(req);\n\t                        } });\n\t                },\n\t            };\n\t        },\n\t    };\n\n\t    function isCachableContext(ctx, table) {\n\t        return (ctx.trans.mode === 'readonly' &&\n\t            !!ctx.subscr &&\n\t            !ctx.trans.explicit &&\n\t            ctx.trans.db._options.cache !== 'disabled' &&\n\t            !table.schema.primaryKey.outbound);\n\t    }\n\n\t    function isCachableRequest(type, req) {\n\t        switch (type) {\n\t            case 'query':\n\t                return req.values && !req.unique;\n\t            case 'get':\n\t                return false;\n\t            case 'getMany':\n\t                return false;\n\t            case 'count':\n\t                return false;\n\t            case 'openCursor':\n\t                return false;\n\t        }\n\t    }\n\n\t    var observabilityMiddleware = {\n\t        stack: \"dbcore\",\n\t        level: 0,\n\t        name: \"Observability\",\n\t        create: function (core) {\n\t            var dbName = core.schema.name;\n\t            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n\t            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n\t                    if (PSD.subscr && mode !== 'readonly') {\n\t                        throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n\t                    }\n\t                    return core.transaction(stores, mode, options);\n\t                }, table: function (tableName) {\n\t                    var table = core.table(tableName);\n\t                    var schema = table.schema;\n\t                    var primaryKey = schema.primaryKey, indexes = schema.indexes;\n\t                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n\t                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n\t                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n\t                            var trans = req.trans;\n\t                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n\t                            var getRangeSet = function (indexName) {\n\t                                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n\t                                return (mutatedParts[part] ||\n\t                                    (mutatedParts[part] = new RangeSet()));\n\t                            };\n\t                            var pkRangeSet = getRangeSet(\"\");\n\t                            var delsRangeSet = getRangeSet(\":dels\");\n\t                            var type = req.type;\n\t                            var _a = req.type === \"deleteRange\"\n\t                                ? [req.range]\n\t                                : req.type === \"delete\"\n\t                                    ? [req.keys]\n\t                                    : req.values.length < 50\n\t                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n\t                                        : [], keys = _a[0], newObjs = _a[1];\n\t                            var oldCache = req.trans[\"_cache\"];\n\t                            if (isArray(keys)) {\n\t                                pkRangeSet.addKeys(keys);\n\t                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n\t                                if (!oldObjs) {\n\t                                    delsRangeSet.addKeys(keys);\n\t                                }\n\t                                if (oldObjs || newObjs) {\n\t                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n\t                                }\n\t                            }\n\t                            else if (keys) {\n\t                                var range = { from: keys.lower, to: keys.upper };\n\t                                delsRangeSet.add(range);\n\t                                pkRangeSet.add(range);\n\t                            }\n\t                            else {\n\t                                pkRangeSet.add(FULL_RANGE);\n\t                                delsRangeSet.add(FULL_RANGE);\n\t                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n\t                            }\n\t                            return table.mutate(req).then(function (res) {\n\t                                if (keys && (req.type === 'add' || req.type === 'put')) {\n\t                                    pkRangeSet.addKeys(res.results);\n\t                                    if (indexesWithAutoIncPK) {\n\t                                        indexesWithAutoIncPK.forEach(function (idx) {\n\t                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n\t                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n\t                                            res.results.forEach(function (pk) { return idxVals[pkPos] = pk; });\n\t                                            getRangeSet(idx.name).addKeys(idxVals);\n\t                                        });\n\t                                    }\n\t                                }\n\t                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n\t                                return res;\n\t                            });\n\t                        } });\n\t                    var getRange = function (_a) {\n\t                        var _b, _c;\n\t                        var _d = _a.query, index = _d.index, range = _d.range;\n\t                        return [\n\t                            index,\n\t                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n\t                        ];\n\t                    };\n\t                    var readSubscribers = {\n\t                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n\t                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n\t                        count: getRange,\n\t                        query: getRange,\n\t                        openCursor: getRange,\n\t                    };\n\t                    keys(readSubscribers).forEach(function (method) {\n\t                        tableClone[method] = function (req) {\n\t                            var subscr = PSD.subscr;\n\t                            var isLiveQuery = !!subscr;\n\t                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n\t                            var obsSet = cachable\n\t                                ? req.obsSet = {}\n\t                                : subscr;\n\t                            if (isLiveQuery) {\n\t                                var getRangeSet = function (indexName) {\n\t                                    var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n\t                                    return (obsSet[part] ||\n\t                                        (obsSet[part] = new RangeSet()));\n\t                                };\n\t                                var pkRangeSet_1 = getRangeSet(\"\");\n\t                                var delsRangeSet_1 = getRangeSet(\":dels\");\n\t                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n\t                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n\t                                    delsRangeSet_1.add(queriedRanges);\n\t                                }\n\t                                else {\n\t                                    getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n\t                                }\n\t                                if (!queriedIndex.isPrimaryKey) {\n\t                                    if (method === \"count\") {\n\t                                        delsRangeSet_1.add(FULL_RANGE);\n\t                                    }\n\t                                    else {\n\t                                        var keysPromise_1 = method === \"query\" &&\n\t                                            outbound &&\n\t                                            req.values &&\n\t                                            table.query(__assign(__assign({}, req), { values: false }));\n\t                                        return table[method].apply(this, arguments).then(function (res) {\n\t                                            if (method === \"query\") {\n\t                                                if (outbound && req.values) {\n\t                                                    return keysPromise_1.then(function (_a) {\n\t                                                        var resultingKeys = _a.result;\n\t                                                        pkRangeSet_1.addKeys(resultingKeys);\n\t                                                        return res;\n\t                                                    });\n\t                                                }\n\t                                                var pKeys = req.values\n\t                                                    ? res.result.map(extractKey)\n\t                                                    : res.result;\n\t                                                if (req.values) {\n\t                                                    pkRangeSet_1.addKeys(pKeys);\n\t                                                }\n\t                                                else {\n\t                                                    delsRangeSet_1.addKeys(pKeys);\n\t                                                }\n\t                                            }\n\t                                            else if (method === \"openCursor\") {\n\t                                                var cursor_1 = res;\n\t                                                var wantValues_1 = req.values;\n\t                                                return (cursor_1 &&\n\t                                                    Object.create(cursor_1, {\n\t                                                        key: {\n\t                                                            get: function () {\n\t                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);\n\t                                                                return cursor_1.key;\n\t                                                            },\n\t                                                        },\n\t                                                        primaryKey: {\n\t                                                            get: function () {\n\t                                                                var pkey = cursor_1.primaryKey;\n\t                                                                delsRangeSet_1.addKey(pkey);\n\t                                                                return pkey;\n\t                                                            },\n\t                                                        },\n\t                                                        value: {\n\t                                                            get: function () {\n\t                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n\t                                                                return cursor_1.value;\n\t                                                            },\n\t                                                        },\n\t                                                    }));\n\t                                            }\n\t                                            return res;\n\t                                        });\n\t                                    }\n\t                                }\n\t                            }\n\t                            return table[method].apply(this, arguments);\n\t                        };\n\t                    });\n\t                    return tableClone;\n\t                } });\n\t        },\n\t    };\n\t    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n\t        function addAffectedIndex(ix) {\n\t            var rangeSet = getRangeSet(ix.name || \"\");\n\t            function extractKey(obj) {\n\t                return obj != null ? ix.extractKey(obj) : null;\n\t            }\n\t            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n\t                ? key.forEach(function (key) { return rangeSet.addKey(key); })\n\t                : rangeSet.addKey(key); };\n\t            (oldObjs || newObjs).forEach(function (_, i) {\n\t                var oldKey = oldObjs && extractKey(oldObjs[i]);\n\t                var newKey = newObjs && extractKey(newObjs[i]);\n\t                if (cmp(oldKey, newKey) !== 0) {\n\t                    if (oldKey != null)\n\t                        addKeyOrKeys(oldKey);\n\t                    if (newKey != null)\n\t                        addKeyOrKeys(newKey);\n\t                }\n\t            });\n\t        }\n\t        schema.indexes.forEach(addAffectedIndex);\n\t    }\n\n\t    function adjustOptimisticFromFailures(tblCache, req, res) {\n\t        if (res.numFailures === 0)\n\t            return req;\n\t        if (req.type === 'deleteRange') {\n\t            return null;\n\t        }\n\t        var numBulkOps = req.keys\n\t            ? req.keys.length\n\t            : 'values' in req && req.values\n\t                ? req.values.length\n\t                : 1;\n\t        if (res.numFailures === numBulkOps) {\n\t            return null;\n\t        }\n\t        var clone = __assign({}, req);\n\t        if (isArray(clone.keys)) {\n\t            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n\t        }\n\t        if ('values' in clone && isArray(clone.values)) {\n\t            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n\t        }\n\t        return clone;\n\t    }\n\n\t    function isAboveLower(key, range) {\n\t        return range.lower === undefined\n\t            ? true\n\t            : range.lowerOpen\n\t                ? cmp(key, range.lower) > 0\n\t                : cmp(key, range.lower) >= 0;\n\t    }\n\t    function isBelowUpper(key, range) {\n\t        return range.upper === undefined\n\t            ? true\n\t            : range.upperOpen\n\t                ? cmp(key, range.upper) < 0\n\t                : cmp(key, range.upper) <= 0;\n\t    }\n\t    function isWithinRange(key, range) {\n\t        return isAboveLower(key, range) && isBelowUpper(key, range);\n\t    }\n\n\t    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n\t        if (!ops || ops.length === 0)\n\t            return result;\n\t        var index = req.query.index;\n\t        var multiEntry = index.multiEntry;\n\t        var queryRange = req.query.range;\n\t        var primaryKey = table.schema.primaryKey;\n\t        var extractPrimKey = primaryKey.extractKey;\n\t        var extractIndex = index.extractKey;\n\t        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n\t        var finalResult = ops.reduce(function (result, op) {\n\t            var modifedResult = result;\n\t            var includedValues = [];\n\t            if (op.type === 'add' || op.type === 'put') {\n\t                var includedPKs = new RangeSet();\n\t                for (var i = op.values.length - 1; i >= 0; --i) {\n\t                    var value = op.values[i];\n\t                    var pk = extractPrimKey(value);\n\t                    if (includedPKs.hasKey(pk))\n\t                        continue;\n\t                    var key = extractIndex(value);\n\t                    if (multiEntry && isArray(key)\n\t                        ? key.some(function (k) { return isWithinRange(k, queryRange); })\n\t                        : isWithinRange(key, queryRange)) {\n\t                        includedPKs.addKey(pk);\n\t                        includedValues.push(value);\n\t                    }\n\t                }\n\t            }\n\t            switch (op.type) {\n\t                case 'add':\n\t                    modifedResult = result.concat(req.values\n\t                        ? includedValues\n\t                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n\t                    break;\n\t                case 'put':\n\t                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n\t                    modifedResult = result\n\t                        .filter(\n\t                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n\t                        .concat(\n\t                    req.values\n\t                        ? includedValues\n\t                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n\t                    break;\n\t                case 'delete':\n\t                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n\t                    modifedResult = result.filter(function (item) { return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item); });\n\t                    break;\n\t                case 'deleteRange':\n\t                    var range_1 = op.range;\n\t                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n\t                    break;\n\t            }\n\t            return modifedResult;\n\t        }, result);\n\t        if (finalResult === result)\n\t            return result;\n\t        finalResult.sort(function (a, b) {\n\t            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n\t                cmp(extractPrimKey(a), extractPrimKey(b));\n\t        });\n\t        if (req.limit && req.limit < Infinity) {\n\t            if (finalResult.length > req.limit) {\n\t                finalResult.length = req.limit;\n\t            }\n\t            else if (result.length === req.limit && finalResult.length < req.limit) {\n\t                cacheEntry.dirty = true;\n\t            }\n\t        }\n\t        return immutable ? Object.freeze(finalResult) : finalResult;\n\t    }\n\n\t    function areRangesEqual(r1, r2) {\n\t        return (cmp(r1.lower, r2.lower) === 0 &&\n\t            cmp(r1.upper, r2.upper) === 0 &&\n\t            !!r1.lowerOpen === !!r2.lowerOpen &&\n\t            !!r1.upperOpen === !!r2.upperOpen);\n\t    }\n\n\t    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n\t        if (lower1 === undefined)\n\t            return lower2 !== undefined ? -1 : 0;\n\t        if (lower2 === undefined)\n\t            return 1;\n\t        var c = cmp(lower1, lower2);\n\t        if (c === 0) {\n\t            if (lowerOpen1 && lowerOpen2)\n\t                return 0;\n\t            if (lowerOpen1)\n\t                return 1;\n\t            if (lowerOpen2)\n\t                return -1;\n\t        }\n\t        return c;\n\t    }\n\t    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n\t        if (upper1 === undefined)\n\t            return upper2 !== undefined ? 1 : 0;\n\t        if (upper2 === undefined)\n\t            return -1;\n\t        var c = cmp(upper1, upper2);\n\t        if (c === 0) {\n\t            if (upperOpen1 && upperOpen2)\n\t                return 0;\n\t            if (upperOpen1)\n\t                return -1;\n\t            if (upperOpen2)\n\t                return 1;\n\t        }\n\t        return c;\n\t    }\n\t    function isSuperRange(r1, r2) {\n\t        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n\t            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n\t    }\n\n\t    function findCompatibleQuery(dbName, tableName, type, req) {\n\t        var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t        if (!tblCache)\n\t            return [];\n\t        var queries = tblCache.queries[type];\n\t        if (!queries)\n\t            return [null, false, tblCache, null];\n\t        var indexName = req.query ? req.query.index.name : null;\n\t        var entries = queries[indexName || ''];\n\t        if (!entries)\n\t            return [null, false, tblCache, null];\n\t        switch (type) {\n\t            case 'query':\n\t                var equalEntry = entries.find(function (entry) {\n\t                    return entry.req.limit === req.limit &&\n\t                        entry.req.values === req.values &&\n\t                        areRangesEqual(entry.req.query.range, req.query.range);\n\t                });\n\t                if (equalEntry)\n\t                    return [\n\t                        equalEntry,\n\t                        true,\n\t                        tblCache,\n\t                        entries,\n\t                    ];\n\t                var superEntry = entries.find(function (entry) {\n\t                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n\t                    return (limit >= req.limit &&\n\t                        (req.values ? entry.req.values : true) &&\n\t                        isSuperRange(entry.req.query.range, req.query.range));\n\t                });\n\t                return [superEntry, false, tblCache, entries];\n\t            case 'count':\n\t                var countQuery = entries.find(function (entry) {\n\t                    return areRangesEqual(entry.req.query.range, req.query.range);\n\t                });\n\t                return [countQuery, !!countQuery, tblCache, entries];\n\t        }\n\t    }\n\n\t    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n\t        cacheEntry.subscribers.add(requery);\n\t        signal.addEventListener(\"abort\", function () {\n\t            cacheEntry.subscribers.delete(requery);\n\t            if (cacheEntry.subscribers.size === 0) {\n\t                enqueForDeletion(cacheEntry, container);\n\t            }\n\t        });\n\t    }\n\t    function enqueForDeletion(cacheEntry, container) {\n\t        setTimeout(function () {\n\t            if (cacheEntry.subscribers.size === 0) {\n\t                delArrayItem(container, cacheEntry);\n\t            }\n\t        }, 3000);\n\t    }\n\n\t    var cacheMiddleware = {\n\t        stack: 'dbcore',\n\t        level: 0,\n\t        name: 'Cache',\n\t        create: function (core) {\n\t            var dbName = core.schema.name;\n\t            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n\t                    var idbtrans = core.transaction(stores, mode, options);\n\t                    if (mode === 'readwrite') {\n\t                        var ac_1 = new AbortController();\n\t                        var signal = ac_1.signal;\n\t                        var endTransaction = function (wasCommitted) { return function () {\n\t                            ac_1.abort();\n\t                            if (mode === 'readwrite') {\n\t                                var affectedSubscribers_1 = new Set();\n\t                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n\t                                    var storeName = stores_1[_i];\n\t                                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n\t                                    if (tblCache) {\n\t                                        var table = core.table(storeName);\n\t                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n\t                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n\t                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n\t                                                var entries = _b[_a];\n\t                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n\t                                                    var entry = _d[_c];\n\t                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n\t                                                        delArrayItem(entries, entry);\n\t                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                    }\n\t                                                }\n\t                                            }\n\t                                        }\n\t                                        else if (ops.length > 0) {\n\t                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n\t                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n\t                                                var entries = _f[_e];\n\t                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n\t                                                    var entry = _h[_g];\n\t                                                    if (entry.res != null &&\n\t                                                        idbtrans.mutatedParts\n\t    ) {\n\t                                                        if (wasCommitted && !entry.dirty) {\n\t                                                            var freezeResults = Object.isFrozen(entry.res);\n\t                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n\t                                                            if (entry.dirty) {\n\t                                                                delArrayItem(entries, entry);\n\t                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                            }\n\t                                                            else if (modRes !== entry.res) {\n\t                                                                entry.res = modRes;\n\t                                                                entry.promise = DexiePromise.resolve({ result: modRes });\n\t                                                            }\n\t                                                        }\n\t                                                        else {\n\t                                                            if (entry.dirty) {\n\t                                                                delArrayItem(entries, entry);\n\t                                                            }\n\t                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                        }\n\t                                                    }\n\t                                                }\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                }\n\t                                affectedSubscribers_1.forEach(function (requery) { return requery(); });\n\t                            }\n\t                        }; };\n\t                        idbtrans.addEventListener('abort', endTransaction(false), {\n\t                            signal: signal,\n\t                        });\n\t                        idbtrans.addEventListener('error', endTransaction(false), {\n\t                            signal: signal,\n\t                        });\n\t                        idbtrans.addEventListener('complete', endTransaction(true), {\n\t                            signal: signal,\n\t                        });\n\t                    }\n\t                    return idbtrans;\n\t                }, table: function (tableName) {\n\t                    var downTable = core.table(tableName);\n\t                    var primKey = downTable.schema.primaryKey;\n\t                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n\t                            var trans = PSD.trans;\n\t                            if (primKey.outbound ||\n\t                                trans.db._options.cache === 'disabled' ||\n\t                                trans.explicit\n\t                            ) {\n\t                                return downTable.mutate(req);\n\t                            }\n\t                            var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t                            if (!tblCache)\n\t                                return downTable.mutate(req);\n\t                            var promise = downTable.mutate(req);\n\t                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n\t                                promise.then(function (res) {\n\t                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n\t                                            var _a;\n\t                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n\t                                                ? deepClone(value)\n\t                                                : __assign({}, value);\n\t                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n\t                                            return valueWithKey;\n\t                                        }) });\n\t                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n\t                                    tblCache.optimisticOps.push(adjustedReq);\n\t                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n\t                                });\n\t                            }\n\t                            else {\n\t                                tblCache.optimisticOps.push(req);\n\t                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                promise.then(function (res) {\n\t                                    if (res.numFailures > 0) {\n\t                                        delArrayItem(tblCache.optimisticOps, req);\n\t                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n\t                                        if (adjustedReq) {\n\t                                            tblCache.optimisticOps.push(adjustedReq);\n\t                                        }\n\t                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                    }\n\t                                });\n\t                                promise.catch(function () {\n\t                                    delArrayItem(tblCache.optimisticOps, req);\n\t                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                });\n\t                            }\n\t                            return promise;\n\t                        }, query: function (req) {\n\t                            var _a;\n\t                            if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n\t                                return downTable.query(req);\n\t                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n\t                            var _b = PSD, requery = _b.requery, signal = _b.signal;\n\t                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n\t                            if (cacheEntry && exactMatch) {\n\t                                cacheEntry.obsSet = req.obsSet;\n\t                            }\n\t                            else {\n\t                                var promise = downTable.query(req).then(function (res) {\n\t                                    var result = res.result;\n\t                                    if (cacheEntry)\n\t                                        cacheEntry.res = result;\n\t                                    if (freezeResults) {\n\t                                        for (var i = 0, l = result.length; i < l; ++i) {\n\t                                            Object.freeze(result[i]);\n\t                                        }\n\t                                        Object.freeze(result);\n\t                                    }\n\t                                    else {\n\t                                        res.result = deepClone(result);\n\t                                    }\n\t                                    return res;\n\t                                }).catch(function (error) {\n\t                                    if (container && cacheEntry)\n\t                                        delArrayItem(container, cacheEntry);\n\t                                    return Promise.reject(error);\n\t                                });\n\t                                cacheEntry = {\n\t                                    obsSet: req.obsSet,\n\t                                    promise: promise,\n\t                                    subscribers: new Set(),\n\t                                    type: 'query',\n\t                                    req: req,\n\t                                    dirty: false,\n\t                                };\n\t                                if (container) {\n\t                                    container.push(cacheEntry);\n\t                                }\n\t                                else {\n\t                                    container = [cacheEntry];\n\t                                    if (!tblCache) {\n\t                                        tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n\t                                            queries: {\n\t                                                query: {},\n\t                                                count: {},\n\t                                            },\n\t                                            objs: new Map(),\n\t                                            optimisticOps: [],\n\t                                            unsignaledParts: {}\n\t                                        };\n\t                                    }\n\t                                    tblCache.queries.query[req.query.index.name || ''] = container;\n\t                                }\n\t                            }\n\t                            subscribeToCacheEntry(cacheEntry, container, requery, signal);\n\t                            return cacheEntry.promise.then(function (res) {\n\t                                return {\n\t                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n\t                                };\n\t                            });\n\t                        } });\n\t                    return tableMW;\n\t                } });\n\t            return coreMW;\n\t        },\n\t    };\n\n\t    function vipify(target, vipDb) {\n\t        return new Proxy(target, {\n\t            get: function (target, prop, receiver) {\n\t                if (prop === 'db')\n\t                    return vipDb;\n\t                return Reflect.get(target, prop, receiver);\n\t            }\n\t        });\n\t    }\n\n\t    var Dexie$1 =  (function () {\n\t        function Dexie(name, options) {\n\t            var _this = this;\n\t            this._middlewares = {};\n\t            this.verno = 0;\n\t            var deps = Dexie.dependencies;\n\t            this._options = options = __assign({\n\t                addons: Dexie.addons, autoOpen: true,\n\t                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n\t            this._deps = {\n\t                indexedDB: options.indexedDB,\n\t                IDBKeyRange: options.IDBKeyRange\n\t            };\n\t            var addons = options.addons;\n\t            this._dbSchema = {};\n\t            this._versions = [];\n\t            this._storeNames = [];\n\t            this._allTables = {};\n\t            this.idbdb = null;\n\t            this._novip = this;\n\t            var state = {\n\t                dbOpenError: null,\n\t                isBeingOpened: false,\n\t                onReadyBeingFired: null,\n\t                openComplete: false,\n\t                dbReadyResolve: nop,\n\t                dbReadyPromise: null,\n\t                cancelOpen: nop,\n\t                openCanceller: null,\n\t                autoSchema: true,\n\t                PR1398_maxLoop: 3,\n\t                autoOpen: options.autoOpen,\n\t            };\n\t            state.dbReadyPromise = new DexiePromise(function (resolve) {\n\t                state.dbReadyResolve = resolve;\n\t            });\n\t            state.openCanceller = new DexiePromise(function (_, reject) {\n\t                state.cancelOpen = reject;\n\t            });\n\t            this._state = state;\n\t            this.name = name;\n\t            this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n\t            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n\t                return function (subscriber, bSticky) {\n\t                    Dexie.vip(function () {\n\t                        var state = _this._state;\n\t                        if (state.openComplete) {\n\t                            if (!state.dbOpenError)\n\t                                DexiePromise.resolve().then(subscriber);\n\t                            if (bSticky)\n\t                                subscribe(subscriber);\n\t                        }\n\t                        else if (state.onReadyBeingFired) {\n\t                            state.onReadyBeingFired.push(subscriber);\n\t                            if (bSticky)\n\t                                subscribe(subscriber);\n\t                        }\n\t                        else {\n\t                            subscribe(subscriber);\n\t                            var db_1 = _this;\n\t                            if (!bSticky)\n\t                                subscribe(function unsubscribe() {\n\t                                    db_1.on.ready.unsubscribe(subscriber);\n\t                                    db_1.on.ready.unsubscribe(unsubscribe);\n\t                                });\n\t                        }\n\t                    });\n\t                };\n\t            });\n\t            this.Collection = createCollectionConstructor(this);\n\t            this.Table = createTableConstructor(this);\n\t            this.Transaction = createTransactionConstructor(this);\n\t            this.Version = createVersionConstructor(this);\n\t            this.WhereClause = createWhereClauseConstructor(this);\n\t            this.on(\"versionchange\", function (ev) {\n\t                if (ev.newVersion > 0)\n\t                    console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n\t                else\n\t                    console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n\t                _this.close({ disableAutoOpen: false });\n\t            });\n\t            this.on(\"blocked\", function (ev) {\n\t                if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n\t                    console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n\t                else\n\t                    console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n\t            });\n\t            this._maxKey = getMaxKey(options.IDBKeyRange);\n\t            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n\t            this._fireOnBlocked = function (ev) {\n\t                _this.on(\"blocked\").fire(ev);\n\t                connections\n\t                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n\t                    .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n\t            };\n\t            this.use(cacheExistingValuesMiddleware);\n\t            this.use(cacheMiddleware);\n\t            this.use(observabilityMiddleware);\n\t            this.use(virtualIndexMiddleware);\n\t            this.use(hooksMiddleware);\n\t            var vipDB = new Proxy(this, {\n\t                get: function (_, prop, receiver) {\n\t                    if (prop === '_vip')\n\t                        return true;\n\t                    if (prop === 'table')\n\t                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n\t                    var rv = Reflect.get(_, prop, receiver);\n\t                    if (rv instanceof Table)\n\t                        return vipify(rv, vipDB);\n\t                    if (prop === 'tables')\n\t                        return rv.map(function (t) { return vipify(t, vipDB); });\n\t                    if (prop === '_createTransaction')\n\t                        return function () {\n\t                            var tx = rv.apply(this, arguments);\n\t                            return vipify(tx, vipDB);\n\t                        };\n\t                    return rv;\n\t                }\n\t            });\n\t            this.vip = vipDB;\n\t            addons.forEach(function (addon) { return addon(_this); });\n\t        }\n\t        Dexie.prototype.version = function (versionNumber) {\n\t            if (isNaN(versionNumber) || versionNumber < 0.1)\n\t                throw new exceptions.Type(\"Given version is not a positive number\");\n\t            versionNumber = Math.round(versionNumber * 10) / 10;\n\t            if (this.idbdb || this._state.isBeingOpened)\n\t                throw new exceptions.Schema(\"Cannot add version when database is open\");\n\t            this.verno = Math.max(this.verno, versionNumber);\n\t            var versions = this._versions;\n\t            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n\t            if (versionInstance)\n\t                return versionInstance;\n\t            versionInstance = new this.Version(versionNumber);\n\t            versions.push(versionInstance);\n\t            versions.sort(lowerVersionFirst);\n\t            versionInstance.stores({});\n\t            this._state.autoSchema = false;\n\t            return versionInstance;\n\t        };\n\t        Dexie.prototype._whenReady = function (fn) {\n\t            var _this = this;\n\t            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n\t                if (_this._state.openComplete) {\n\t                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n\t                }\n\t                if (!_this._state.isBeingOpened) {\n\t                    if (!_this._state.autoOpen) {\n\t                        reject(new exceptions.DatabaseClosed());\n\t                        return;\n\t                    }\n\t                    _this.open().catch(nop);\n\t                }\n\t                _this._state.dbReadyPromise.then(resolve, reject);\n\t            }).then(fn);\n\t        };\n\t        Dexie.prototype.use = function (_a) {\n\t            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n\t            if (name)\n\t                this.unuse({ stack: stack, name: name });\n\t            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n\t            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n\t            middlewares.sort(function (a, b) { return a.level - b.level; });\n\t            return this;\n\t        };\n\t        Dexie.prototype.unuse = function (_a) {\n\t            var stack = _a.stack, name = _a.name, create = _a.create;\n\t            if (stack && this._middlewares[stack]) {\n\t                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n\t                    return create ? mw.create !== create :\n\t                        name ? mw.name !== name :\n\t                            false;\n\t                });\n\t            }\n\t            return this;\n\t        };\n\t        Dexie.prototype.open = function () {\n\t            var _this = this;\n\t            return usePSD(globalPSD,\n\t            function () { return dexieOpen(_this); });\n\t        };\n\t        Dexie.prototype._close = function () {\n\t            var state = this._state;\n\t            var idx = connections.indexOf(this);\n\t            if (idx >= 0)\n\t                connections.splice(idx, 1);\n\t            if (this.idbdb) {\n\t                try {\n\t                    this.idbdb.close();\n\t                }\n\t                catch (e) { }\n\t                this.idbdb = null;\n\t            }\n\t            if (!state.isBeingOpened) {\n\t                state.dbReadyPromise = new DexiePromise(function (resolve) {\n\t                    state.dbReadyResolve = resolve;\n\t                });\n\t                state.openCanceller = new DexiePromise(function (_, reject) {\n\t                    state.cancelOpen = reject;\n\t                });\n\t            }\n\t        };\n\t        Dexie.prototype.close = function (_a) {\n\t            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n\t            var state = this._state;\n\t            if (disableAutoOpen) {\n\t                if (state.isBeingOpened) {\n\t                    state.cancelOpen(new exceptions.DatabaseClosed());\n\t                }\n\t                this._close();\n\t                state.autoOpen = false;\n\t                state.dbOpenError = new exceptions.DatabaseClosed();\n\t            }\n\t            else {\n\t                this._close();\n\t                state.autoOpen = this._options.autoOpen ||\n\t                    state.isBeingOpened;\n\t                state.openComplete = false;\n\t                state.dbOpenError = null;\n\t            }\n\t        };\n\t        Dexie.prototype.delete = function (closeOptions) {\n\t            var _this = this;\n\t            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n\t            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n\t            var state = this._state;\n\t            return new DexiePromise(function (resolve, reject) {\n\t                var doDelete = function () {\n\t                    _this.close(closeOptions);\n\t                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n\t                    req.onsuccess = wrap(function () {\n\t                        _onDatabaseDeleted(_this._deps, _this.name);\n\t                        resolve();\n\t                    });\n\t                    req.onerror = eventRejectHandler(reject);\n\t                    req.onblocked = _this._fireOnBlocked;\n\t                };\n\t                if (hasInvalidArguments)\n\t                    throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n\t                if (state.isBeingOpened) {\n\t                    state.dbReadyPromise.then(doDelete);\n\t                }\n\t                else {\n\t                    doDelete();\n\t                }\n\t            });\n\t        };\n\t        Dexie.prototype.backendDB = function () {\n\t            return this.idbdb;\n\t        };\n\t        Dexie.prototype.isOpen = function () {\n\t            return this.idbdb !== null;\n\t        };\n\t        Dexie.prototype.hasBeenClosed = function () {\n\t            var dbOpenError = this._state.dbOpenError;\n\t            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n\t        };\n\t        Dexie.prototype.hasFailed = function () {\n\t            return this._state.dbOpenError !== null;\n\t        };\n\t        Dexie.prototype.dynamicallyOpened = function () {\n\t            return this._state.autoSchema;\n\t        };\n\t        Object.defineProperty(Dexie.prototype, \"tables\", {\n\t            get: function () {\n\t                var _this = this;\n\t                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n\t            },\n\t            enumerable: false,\n\t            configurable: true\n\t        });\n\t        Dexie.prototype.transaction = function () {\n\t            var args = extractTransactionArgs.apply(this, arguments);\n\t            return this._transaction.apply(this, args);\n\t        };\n\t        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n\t            var _this = this;\n\t            var parentTransaction = PSD.trans;\n\t            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n\t                parentTransaction = null;\n\t            var onlyIfCompatible = mode.indexOf('?') !== -1;\n\t            mode = mode.replace('!', '').replace('?', '');\n\t            var idbMode, storeNames;\n\t            try {\n\t                storeNames = tables.map(function (table) {\n\t                    var storeName = table instanceof _this.Table ? table.name : table;\n\t                    if (typeof storeName !== 'string')\n\t                        throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n\t                    return storeName;\n\t                });\n\t                if (mode == \"r\" || mode === READONLY)\n\t                    idbMode = READONLY;\n\t                else if (mode == \"rw\" || mode == READWRITE)\n\t                    idbMode = READWRITE;\n\t                else\n\t                    throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\t                if (parentTransaction) {\n\t                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n\t                        if (onlyIfCompatible) {\n\t                            parentTransaction = null;\n\t                        }\n\t                        else\n\t                            throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n\t                    }\n\t                    if (parentTransaction) {\n\t                        storeNames.forEach(function (storeName) {\n\t                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n\t                                if (onlyIfCompatible) {\n\t                                    parentTransaction = null;\n\t                                }\n\t                                else\n\t                                    throw new exceptions.SubTransaction(\"Table \" + storeName +\n\t                                        \" not included in parent transaction.\");\n\t                            }\n\t                        });\n\t                    }\n\t                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n\t                        parentTransaction = null;\n\t                    }\n\t                }\n\t            }\n\t            catch (e) {\n\t                return parentTransaction ?\n\t                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n\t                    rejection(e);\n\t            }\n\t            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n\t            return (parentTransaction ?\n\t                parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n\t                PSD.trans ?\n\t                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n\t                    this._whenReady(enterTransaction));\n\t        };\n\t        Dexie.prototype.table = function (tableName) {\n\t            if (!hasOwn(this._allTables, tableName)) {\n\t                throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n\t            }\n\t            return this._allTables[tableName];\n\t        };\n\t        return Dexie;\n\t    }());\n\n\t    var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n\t        ? Symbol.observable\n\t        : \"@@observable\";\n\t    var Observable =  (function () {\n\t        function Observable(subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t        Observable.prototype.subscribe = function (x, error, complete) {\n\t            return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n\t        };\n\t        Observable.prototype[symbolObservable] = function () {\n\t            return this;\n\t        };\n\t        return Observable;\n\t    }());\n\n\t    var domDeps;\n\t    try {\n\t        domDeps = {\n\t            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n\t            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n\t        };\n\t    }\n\t    catch (e) {\n\t        domDeps = { indexedDB: null, IDBKeyRange: null };\n\t    }\n\n\t    function liveQuery(querier) {\n\t        var hasValue = false;\n\t        var currentValue;\n\t        var observable = new Observable(function (observer) {\n\t            var scopeFuncIsAsync = isAsyncFunction(querier);\n\t            function execute(ctx) {\n\t                var wasRootExec = beginMicroTickScope();\n\t                try {\n\t                    if (scopeFuncIsAsync) {\n\t                        incrementExpectedAwaits();\n\t                    }\n\t                    var rv = newScope(querier, ctx);\n\t                    if (scopeFuncIsAsync) {\n\t                        rv = rv.finally(decrementExpectedAwaits);\n\t                    }\n\t                    return rv;\n\t                }\n\t                finally {\n\t                    wasRootExec && endMicroTickScope();\n\t                }\n\t            }\n\t            var closed = false;\n\t            var abortController;\n\t            var accumMuts = {};\n\t            var currentObs = {};\n\t            var subscription = {\n\t                get closed() {\n\t                    return closed;\n\t                },\n\t                unsubscribe: function () {\n\t                    if (closed)\n\t                        return;\n\t                    closed = true;\n\t                    if (abortController)\n\t                        abortController.abort();\n\t                    if (startedListening)\n\t                        globalEvents.storagemutated.unsubscribe(mutationListener);\n\t                },\n\t            };\n\t            observer.start && observer.start(subscription);\n\t            var startedListening = false;\n\t            var doQuery = function () { return execInGlobalContext(_doQuery); };\n\t            function shouldNotify() {\n\t                return obsSetsOverlap(currentObs, accumMuts);\n\t            }\n\t            var mutationListener = function (parts) {\n\t                extendObservabilitySet(accumMuts, parts);\n\t                if (shouldNotify()) {\n\t                    doQuery();\n\t                }\n\t            };\n\t            var _doQuery = function () {\n\t                if (closed ||\n\t                    !domDeps.indexedDB)\n\t                 {\n\t                    return;\n\t                }\n\t                accumMuts = {};\n\t                var subscr = {};\n\t                if (abortController)\n\t                    abortController.abort();\n\t                abortController = new AbortController();\n\t                var ctx = {\n\t                    subscr: subscr,\n\t                    signal: abortController.signal,\n\t                    requery: doQuery,\n\t                    querier: querier,\n\t                    trans: null\n\t                };\n\t                var ret = execute(ctx);\n\t                Promise.resolve(ret).then(function (result) {\n\t                    hasValue = true;\n\t                    currentValue = result;\n\t                    if (closed || ctx.signal.aborted) {\n\t                        return;\n\t                    }\n\t                    accumMuts = {};\n\t                    currentObs = subscr;\n\t                    if (!objectIsEmpty(currentObs) && !startedListening) {\n\t                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n\t                        startedListening = true;\n\t                    }\n\t                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n\t                }, function (err) {\n\t                    hasValue = false;\n\t                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n\t                        if (!closed)\n\t                            execInGlobalContext(function () {\n\t                                if (closed)\n\t                                    return;\n\t                                observer.error && observer.error(err);\n\t                            });\n\t                    }\n\t                });\n\t            };\n\t            setTimeout(doQuery, 0);\n\t            return subscription;\n\t        });\n\t        observable.hasValue = function () { return hasValue; };\n\t        observable.getValue = function () { return currentValue; };\n\t        return observable;\n\t    }\n\n\t    var Dexie = Dexie$1;\n\t    props(Dexie, __assign(__assign({}, fullNameExceptions), {\n\t        delete: function (databaseName) {\n\t            var db = new Dexie(databaseName, { addons: [] });\n\t            return db.delete();\n\t        },\n\t        exists: function (name) {\n\t            return new Dexie(name, { addons: [] }).open().then(function (db) {\n\t                db.close();\n\t                return true;\n\t            }).catch('NoSuchDatabaseError', function () { return false; });\n\t        },\n\t        getDatabaseNames: function (cb) {\n\t            try {\n\t                return getDatabaseNames(Dexie.dependencies).then(cb);\n\t            }\n\t            catch (_a) {\n\t                return rejection(new exceptions.MissingAPI());\n\t            }\n\t        },\n\t        defineClass: function () {\n\t            function Class(content) {\n\t                extend(this, content);\n\t            }\n\t            return Class;\n\t        }, ignoreTransaction: function (scopeFunc) {\n\t            return PSD.trans ?\n\t                usePSD(PSD.transless, scopeFunc) :\n\t                scopeFunc();\n\t        }, vip: vip, async: function (generatorFn) {\n\t            return function () {\n\t                try {\n\t                    var rv = awaitIterator(generatorFn.apply(this, arguments));\n\t                    if (!rv || typeof rv.then !== 'function')\n\t                        return DexiePromise.resolve(rv);\n\t                    return rv;\n\t                }\n\t                catch (e) {\n\t                    return rejection(e);\n\t                }\n\t            };\n\t        }, spawn: function (generatorFn, args, thiz) {\n\t            try {\n\t                var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n\t                if (!rv || typeof rv.then !== 'function')\n\t                    return DexiePromise.resolve(rv);\n\t                return rv;\n\t            }\n\t            catch (e) {\n\t                return rejection(e);\n\t            }\n\t        },\n\t        currentTransaction: {\n\t            get: function () { return PSD.trans || null; }\n\t        }, waitFor: function (promiseOrFunction, optionalTimeout) {\n\t            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n\t                Dexie.ignoreTransaction(promiseOrFunction) :\n\t                promiseOrFunction)\n\t                .timeout(optionalTimeout || 60000);\n\t            return PSD.trans ?\n\t                PSD.trans.waitFor(promise) :\n\t                promise;\n\t        },\n\t        Promise: DexiePromise,\n\t        debug: {\n\t            get: function () { return debug; },\n\t            set: function (value) {\n\t                setDebug(value);\n\t            }\n\t        },\n\t        derive: derive, extend: extend, props: props, override: override,\n\t        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n\t        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n\t        minKey: minKey,\n\t        addons: [],\n\t        connections: connections,\n\t        errnames: errnames,\n\t        dependencies: domDeps, cache: cache,\n\t        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n\t            .map(function (n) { return parseInt(n); })\n\t            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n\t    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n\t    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n\t        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n\t            if (!propagatingLocally) {\n\t                var event_1;\n\t                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n\t                    detail: updatedParts\n\t                });\n\t                propagatingLocally = true;\n\t                dispatchEvent(event_1);\n\t                propagatingLocally = false;\n\t            }\n\t        });\n\t        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n\t            var detail = _a.detail;\n\t            if (!propagatingLocally) {\n\t                propagateLocally(detail);\n\t            }\n\t        });\n\t    }\n\t    function propagateLocally(updateParts) {\n\t        var wasMe = propagatingLocally;\n\t        try {\n\t            propagatingLocally = true;\n\t            globalEvents.storagemutated.fire(updateParts);\n\t            signalSubscribersNow(updateParts, true);\n\t        }\n\t        finally {\n\t            propagatingLocally = wasMe;\n\t        }\n\t    }\n\t    var propagatingLocally = false;\n\n\t    var bc;\n\t    var createBC = function () { };\n\t    if (typeof BroadcastChannel !== 'undefined') {\n\t        createBC = function () {\n\t            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n\t            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n\t        };\n\t        createBC();\n\t        if (typeof bc.unref === 'function') {\n\t            bc.unref();\n\t        }\n\t        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n\t            if (!propagatingLocally) {\n\t                bc.postMessage(changedParts);\n\t            }\n\t        });\n\t    }\n\n\t    if (typeof addEventListener !== 'undefined') {\n\t        addEventListener('pagehide', function (event) {\n\t            if (!Dexie$1.disableBfCache && event.persisted) {\n\t                if (debug)\n\t                    console.debug('Dexie: handling persisted pagehide');\n\t                bc === null || bc === void 0 ? void 0 : bc.close();\n\t                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n\t                    var db = connections_1[_i];\n\t                    db.close({ disableAutoOpen: false });\n\t                }\n\t            }\n\t        });\n\t        addEventListener('pageshow', function (event) {\n\t            if (!Dexie$1.disableBfCache && event.persisted) {\n\t                if (debug)\n\t                    console.debug('Dexie: handling persisted pageshow');\n\t                createBC();\n\t                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n\t            }\n\t        });\n\t    }\n\n\t    function add(value) {\n\t        return new PropModification({ add: value });\n\t    }\n\n\t    function remove(value) {\n\t        return new PropModification({ remove: value });\n\t    }\n\n\t    function replacePrefix(a, b) {\n\t        return new PropModification({ replacePrefix: [a, b] });\n\t    }\n\n\t    DexiePromise.rejectionMapper = mapError;\n\t    setDebug(debug);\n\n\t    var namedExports = /*#__PURE__*/Object.freeze({\n\t        __proto__: null,\n\t        Dexie: Dexie$1,\n\t        liveQuery: liveQuery,\n\t        Entity: Entity,\n\t        cmp: cmp,\n\t        PropModSymbol: PropModSymbol,\n\t        PropModification: PropModification,\n\t        replacePrefix: replacePrefix,\n\t        add: add,\n\t        remove: remove,\n\t        'default': Dexie$1,\n\t        RangeSet: RangeSet,\n\t        mergeRanges: mergeRanges,\n\t        rangesOverlap: rangesOverlap\n\t    });\n\n\t    __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n\t    return Dexie$1;\n\n\t}));\n\t\n} (dexie));\n\nvar dexieExports = dexie.exports;\nvar _Dexie = /*@__PURE__*/getDefaultExportFromCjs(dexieExports);\n\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);\nif (_Dexie.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);\n}\n\n// Helper for undefined values, like map for Option<T> in Rust.\n// A better name for this is welcome.\nconst mapOption = (value, func) => {\n    return value != undefined ? func(value) : undefined;\n};\n// Anything can be thrown as an error in raw JS (also the TS compiler can't type-check exceptions),\n// so we allow it here.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst logWebStoreError = (error, errorContext) => {\n    if (error instanceof Dexie.DexieError) {\n        if (errorContext) {\n            console.error(`${errorContext}: Indexdb error (${error.name}): ${error.message}`);\n        }\n        else {\n            console.error(`Indexdb error: (${error.name}): ${error.message}`);\n        }\n        mapOption(error.stack, (stack) => {\n            console.error(`Stacktrace: \\n ${stack}`);\n        });\n        mapOption(error.inner, (innerException) => logWebStoreError(innerException));\n    }\n    else if (error instanceof Error) {\n        console.error(`Unexpected error while accessing indexdb: ${error.toString()}`);\n        mapOption(error.stack, (stack) => {\n            console.error(`Stacktrace: ${stack}`);\n        });\n    }\n    else {\n        console.error(`Got an exception with a non-error value, as JSON: \\n ${JSON.stringify(error)}. As String \\n ${String(error)} `);\n        console.trace();\n    }\n    throw error;\n};\nconst uint8ArrayToBase64 = (bytes) => {\n    const binary = bytes.reduce((acc, byte) => acc + String.fromCharCode(byte), \"\");\n    return btoa(binary);\n};\n\nconst DATABASE_NAME = \"MidenClientDB\";\nasync function openDatabase() {\n    console.log(\"Opening database...\");\n    try {\n        await db.open();\n        console.log(\"Database opened successfully\");\n        return true;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to open database\");\n        return false;\n    }\n}\nvar Table;\n(function (Table) {\n    Table[\"AccountCode\"] = \"accountCode\";\n    Table[\"AccountStorage\"] = \"accountStorage\";\n    Table[\"AccountAssets\"] = \"accountAssets\";\n    Table[\"StorageMapEntries\"] = \"storageMapEntries\";\n    Table[\"AccountAuth\"] = \"accountAuth\";\n    Table[\"Accounts\"] = \"accounts\";\n    Table[\"Addresses\"] = \"addresses\";\n    Table[\"Transactions\"] = \"transactions\";\n    Table[\"TransactionScripts\"] = \"transactionScripts\";\n    Table[\"InputNotes\"] = \"inputNotes\";\n    Table[\"OutputNotes\"] = \"outputNotes\";\n    Table[\"NotesScripts\"] = \"notesScripts\";\n    Table[\"StateSync\"] = \"stateSync\";\n    Table[\"BlockHeaders\"] = \"blockHeaders\";\n    Table[\"PartialBlockchainNodes\"] = \"partialBlockchainNodes\";\n    Table[\"Tags\"] = \"tags\";\n    Table[\"ForeignAccountCode\"] = \"foreignAccountCode\";\n    Table[\"Settings\"] = \"settings\";\n    Table[\"TrackedAccounts\"] = \"trackedAccounts\";\n})(Table || (Table = {}));\nconst db = new Dexie(DATABASE_NAME);\ndb.version(1).stores({\n    [Table.AccountCode]: indexes(\"root\"),\n    [Table.AccountStorage]: indexes(\"[commitment+slotIndex]\", \"commitment\"),\n    [Table.StorageMapEntries]: indexes(\"[root+key]\", \"root\"),\n    [Table.AccountAssets]: indexes(\"[root+vaultKey]\", \"root\", \"faucetIdPrefix\"),\n    [Table.AccountAuth]: indexes(\"pubKey\"),\n    [Table.Accounts]: indexes(\"&accountCommitment\", \"id\", \"[id+nonce]\", \"codeRoot\", \"storageRoot\", \"vaultRoot\"),\n    [Table.Addresses]: indexes(\"address\", \"id\"),\n    [Table.Transactions]: indexes(\"id\", \"statusVariant\"),\n    [Table.TransactionScripts]: indexes(\"scriptRoot\"),\n    [Table.InputNotes]: indexes(\"noteId\", \"nullifier\", \"stateDiscriminant\"),\n    [Table.OutputNotes]: indexes(\"noteId\", \"recipientDigest\", \"stateDiscriminant\", \"nullifier\"),\n    [Table.NotesScripts]: indexes(\"scriptRoot\"),\n    [Table.StateSync]: indexes(\"id\"),\n    [Table.BlockHeaders]: indexes(\"blockNum\", \"hasClientNotes\"),\n    [Table.PartialBlockchainNodes]: indexes(\"id\"),\n    [Table.Tags]: indexes(\"id++\", \"tag\", \"source_note_id\", \"source_account_id\"),\n    [Table.ForeignAccountCode]: indexes(\"accountId\"),\n    [Table.Settings]: indexes(\"key\"),\n    [Table.TrackedAccounts]: indexes(\"&id\"),\n});\nfunction indexes(...items) {\n    return items.join(\",\");\n}\ndb.on(\"populate\", () => {\n    // Populate the stateSync table with default values\n    stateSync\n        .put({ id: 1, blockNum: \"0\" })\n        .catch((err) => logWebStoreError(err, \"Failed to populate DB\"));\n});\nconst accountCodes = db.table(Table.AccountCode);\nconst accountStorages = db.table(Table.AccountStorage);\nconst storageMapEntries = db.table(Table.StorageMapEntries);\nconst accountAssets = db.table(Table.AccountAssets);\nconst accountAuths = db.table(Table.AccountAuth);\nconst accounts = db.table(Table.Accounts);\nconst addresses = db.table(Table.Addresses);\nconst transactions = db.table(Table.Transactions);\nconst transactionScripts = db.table(Table.TransactionScripts);\nconst inputNotes = db.table(Table.InputNotes);\nconst outputNotes = db.table(Table.OutputNotes);\nconst notesScripts = db.table(Table.NotesScripts);\nconst stateSync = db.table(Table.StateSync);\nconst blockHeaders = db.table(Table.BlockHeaders);\nconst partialBlockchainNodes = db.table(Table.PartialBlockchainNodes);\nconst tags = db.table(Table.Tags);\nconst foreignAccountCode = db.table(Table.ForeignAccountCode);\nconst settings = db.table(Table.Settings);\nconst trackedAccounts = db.table(Table.TrackedAccounts);\n\n// GET FUNCTIONS\nasync function getAccountIds() {\n    try {\n        const tracked = await trackedAccounts.toArray();\n        return tracked.map((entry) => entry.id);\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error while fetching account IDs\");\n    }\n    return [];\n}\nasync function getAllAccountHeaders() {\n    try {\n        // Use a Map to track the latest record for each id based on nonce\n        const latestRecordsMap = new Map();\n        await accounts.each((record) => {\n            const existingRecord = latestRecordsMap.get(record.id);\n            if (!existingRecord ||\n                BigInt(record.nonce) > BigInt(existingRecord.nonce)) {\n                latestRecordsMap.set(record.id, record);\n            }\n        });\n        // Extract the latest records from the Map\n        const latestRecords = Array.from(latestRecordsMap.values());\n        const resultObject = await Promise.all(latestRecords.map((record) => {\n            let accountSeedBase64 = undefined;\n            if (record.accountSeed) {\n                const seedAsBytes = new Uint8Array(record.accountSeed);\n                if (seedAsBytes.length > 0) {\n                    accountSeedBase64 = uint8ArrayToBase64(seedAsBytes);\n                }\n            }\n            return {\n                id: record.id,\n                nonce: record.nonce,\n                vaultRoot: record.vaultRoot, // Fallback if missing\n                storageRoot: record.storageRoot || \"\",\n                codeRoot: record.codeRoot || \"\",\n                accountSeed: accountSeedBase64, // null or base64 string\n                locked: record.locked,\n                committed: record.committed, // Use actual value or default\n                accountCommitment: record.accountCommitment || \"\", // Keep original field name\n            };\n        }));\n        return resultObject;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error while fetching account headers\");\n    }\n}\nasync function getAccountHeader(accountId) {\n    try {\n        // Fetch all records matching the given id\n        const allMatchingRecords = await accounts\n            .where(\"id\")\n            .equals(accountId)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No account header record found for given ID.\");\n            return null;\n        }\n        // Convert nonce to BigInt and sort\n        // Note: This assumes all nonces are valid BigInt strings.\n        const sortedRecords = allMatchingRecords.sort((a, b) => {\n            const bigIntA = BigInt(a.nonce);\n            const bigIntB = BigInt(b.nonce);\n            return bigIntA > bigIntB ? -1 : bigIntA < bigIntB ? 1 : 0;\n        });\n        // The first record is the most recent one due to the sorting\n        const mostRecentRecord = sortedRecords[0];\n        if (mostRecentRecord === undefined) {\n            return null;\n        }\n        let accountSeedBase64 = undefined;\n        if (mostRecentRecord.accountSeed) {\n            // Ensure accountSeed is processed as a Uint8Array and converted to Base64\n            if (mostRecentRecord.accountSeed.length > 0) {\n                accountSeedBase64 = uint8ArrayToBase64(mostRecentRecord.accountSeed);\n            }\n        }\n        const AccountHeader = {\n            id: mostRecentRecord.id,\n            nonce: mostRecentRecord.nonce,\n            vaultRoot: mostRecentRecord.vaultRoot,\n            storageRoot: mostRecentRecord.storageRoot,\n            codeRoot: mostRecentRecord.codeRoot,\n            accountSeed: accountSeedBase64,\n            locked: mostRecentRecord.locked,\n        };\n        return AccountHeader;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching account header for id: ${accountId}`);\n    }\n}\nasync function getAccountHeaderByCommitment(accountCommitment) {\n    try {\n        // Fetch all records matching the given commitment\n        const allMatchingRecords = await accounts\n            .where(\"accountCommitment\")\n            .equals(accountCommitment)\n            .toArray();\n        if (allMatchingRecords.length == 0) {\n            return undefined;\n        }\n        // There should be only one match\n        const matchingRecord = allMatchingRecords[0];\n        if (matchingRecord === undefined) {\n            console.log(\"No account header record found for given commitment.\");\n            return null;\n        }\n        let accountSeedBase64 = undefined;\n        if (matchingRecord.accountSeed) {\n            accountSeedBase64 = uint8ArrayToBase64(matchingRecord.accountSeed);\n        }\n        const AccountHeader = {\n            id: matchingRecord.id,\n            nonce: matchingRecord.nonce,\n            vaultRoot: matchingRecord.vaultRoot,\n            storageRoot: matchingRecord.storageRoot,\n            codeRoot: matchingRecord.codeRoot,\n            accountSeed: accountSeedBase64,\n            locked: matchingRecord.locked,\n        };\n        return AccountHeader;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account header for commitment ${accountCommitment}`);\n    }\n}\nasync function getAccountCode(codeRoot) {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await accountCodes\n            .where(\"root\")\n            .equals(codeRoot)\n            .toArray();\n        // The first record is the only one due to the uniqueness constraint\n        const codeRecord = allMatchingRecords[0];\n        if (codeRecord === undefined) {\n            console.log(\"No records found for given code root.\");\n            return null;\n        }\n        // Convert the code Blob to an ArrayBuffer\n        const codeBase64 = uint8ArrayToBase64(codeRecord.code);\n        return {\n            root: codeRecord.root,\n            code: codeBase64,\n        };\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account code for root ${codeRoot}`);\n    }\n}\nasync function getAccountStorage(storageCommitment) {\n    try {\n        const allMatchingRecords = await accountStorages\n            .where(\"commitment\")\n            .equals(storageCommitment)\n            .toArray();\n        const slots = allMatchingRecords.map((record) => {\n            return {\n                slotIndex: record.slotIndex,\n                slotValue: record.slotValue,\n                slotType: record.slotType,\n            };\n        });\n        return slots;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account storage for commitment ${storageCommitment}`);\n    }\n}\nasync function getAccountStorageMaps(roots) {\n    try {\n        const allMatchingRecords = await storageMapEntries\n            .where(\"root\")\n            .anyOf(roots)\n            .toArray();\n        return allMatchingRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account storage maps for roots ${roots.join(\", \")}`);\n    }\n}\nasync function getAccountVaultAssets(vaultRoot) {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await accountAssets\n            .where(\"root\")\n            .equals(vaultRoot)\n            .toArray();\n        // Map the records to their asset values\n        const assets = allMatchingRecords.map((record) => {\n            return {\n                asset: record.asset,\n            };\n        });\n        return assets;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account vault for root ${vaultRoot}`);\n    }\n}\nasync function getAccountAuthByPubKey(pubKey) {\n    // Try to get the account auth from the store\n    const accountSecretKey = await accountAuths\n        .where(\"pubKey\")\n        .equals(pubKey)\n        .first();\n    // If it's not in the cache, throw an error\n    if (!accountSecretKey) {\n        throw new Error(\"Account auth not found in cache.\");\n    }\n    const data = {\n        secretKey: accountSecretKey.secretKey,\n    };\n    return data;\n}\nasync function getAccountAddresses(accountId) {\n    try {\n        // Fetch all records matching the given accountId\n        const allMatchingRecords = await addresses\n            .where(\"id\")\n            .equals(accountId)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No address records found for given account ID.\");\n            return [];\n        }\n        return allMatchingRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching account addresses for id: ${accountId}`);\n    }\n}\n// INSERT FUNCTIONS\nasync function upsertAccountCode(codeRoot, code) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            root: codeRoot, // Using codeRoot as the key\n            code,\n        };\n        // Perform the insert using Dexie\n        await accountCodes.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting code with root: ${codeRoot}`);\n    }\n}\nasync function upsertAccountStorage(storageSlots) {\n    try {\n        let processedSlots = storageSlots.map((slot) => {\n            return {\n                commitment: slot.commitment,\n                slotIndex: slot.slotIndex,\n                slotValue: slot.slotValue,\n                slotType: slot.slotType,\n            };\n        });\n        await accountStorages.bulkPut(processedSlots);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting storage slots`);\n    }\n}\nasync function upsertStorageMapEntries(entries) {\n    try {\n        let processedEntries = entries.map((entry) => {\n            return {\n                root: entry.root,\n                key: entry.key,\n                value: entry.value,\n            };\n        });\n        await storageMapEntries.bulkPut(processedEntries);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting storage map entries`);\n    }\n}\nasync function upsertVaultAssets(assets) {\n    try {\n        let processedAssets = assets.map((asset) => {\n            return {\n                root: asset.root,\n                vaultKey: asset.vaultKey,\n                faucetIdPrefix: asset.faucetIdPrefix,\n                asset: asset.asset,\n            };\n        });\n        await accountAssets.bulkPut(processedAssets);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting assets`);\n    }\n}\nasync function upsertAccountRecord(accountId, codeRoot, storageRoot, vaultRoot, nonce, committed, commitment, accountSeed) {\n    try {\n        const data = {\n            id: accountId,\n            codeRoot,\n            storageRoot,\n            vaultRoot,\n            nonce,\n            committed,\n            accountSeed,\n            accountCommitment: commitment,\n            locked: false,\n        };\n        await accounts.put(data);\n        await trackedAccounts.put({ id: accountId });\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting account: ${accountId}`);\n    }\n}\nasync function insertAccountAuth(pubKey, secretKey) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            pubKey: pubKey,\n            secretKey: secretKey,\n        };\n        // Perform the insert using Dexie\n        await accountAuths.add(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting account auth for pubKey: ${pubKey}`);\n    }\n}\nasync function insertAccountAddress(address, accountId) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            address,\n            id: accountId,\n        };\n        // Perform the insert using Dexie\n        await addresses.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting address with value: ${String(address)} for the account ID ${accountId}`);\n    }\n}\nasync function removeAccountAddress(address) {\n    try {\n        // Perform the delete using Dexie\n        await addresses.where(\"address\").equals(address).delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error removing address with value: ${String(address)}`);\n    }\n}\nasync function upsertForeignAccountCode(accountId, code, codeRoot) {\n    try {\n        await upsertAccountCode(codeRoot, code);\n        const data = {\n            accountId,\n            codeRoot,\n        };\n        await foreignAccountCode.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error upserting foreign account code for account: ${accountId}`);\n    }\n}\nasync function getForeignAccountCode(accountIds) {\n    try {\n        const foreignAccounts = await foreignAccountCode\n            .where(\"accountId\")\n            .anyOf(accountIds)\n            .toArray();\n        if (foreignAccounts.length === 0) {\n            console.log(\"No records found for the given account IDs.\");\n            return null; // No records found\n        }\n        const codeRoots = foreignAccounts.map((account) => account.codeRoot);\n        const accountCode = await accountCodes\n            .where(\"root\")\n            .anyOf(codeRoots)\n            .toArray();\n        const processedCode = foreignAccounts\n            .map((foreignAccount) => {\n            const matchingCode = accountCode.find((code) => code.root === foreignAccount.codeRoot);\n            if (matchingCode === undefined) {\n                return undefined;\n            }\n            const codeBase64 = uint8ArrayToBase64(matchingCode.code);\n            return {\n                accountId: foreignAccount.accountId,\n                code: codeBase64,\n            };\n        })\n            .filter((matchingCode) => matchingCode !== undefined);\n        return processedCode;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetching foreign account code\");\n    }\n}\nasync function lockAccount(accountId) {\n    try {\n        await accounts.where(\"id\").equals(accountId).modify({ locked: true });\n    }\n    catch (error) {\n        logWebStoreError(error, `Error locking account: ${accountId}`);\n    }\n}\n// Delete functions\nasync function undoAccountStates(accountCommitments) {\n    try {\n        await accounts\n            .where(\"accountCommitment\")\n            .anyOf(accountCommitments)\n            .delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error undoing account states: ${accountCommitments.join(\",\")}`);\n    }\n}\n\n// INSERT FUNCTIONS\nasync function insertBlockHeader(blockNum, header, partialBlockchainPeaks, hasClientNotes) {\n    try {\n        const data = {\n            blockNum: blockNum,\n            header,\n            partialBlockchainPeaks,\n            hasClientNotes: hasClientNotes.toString(),\n        };\n        const existingBlockHeader = await blockHeaders.get(blockNum);\n        if (!existingBlockHeader) {\n            await blockHeaders.add(data);\n        }\n        else {\n            console.log(\"Block header already exists, checking for update.\");\n            // Update the hasClientNotes if the existing value is false\n            if (existingBlockHeader.hasClientNotes === \"false\" && hasClientNotes) {\n                await blockHeaders.update(blockNum, {\n                    hasClientNotes: hasClientNotes.toString(),\n                });\n                console.log(\"Updated hasClientNotes to true.\");\n            }\n            else {\n                console.log(\"No update needed for hasClientNotes.\");\n            }\n        }\n    }\n    catch (err) {\n        logWebStoreError(err);\n    }\n}\nasync function insertPartialBlockchainNodes(ids, nodes) {\n    try {\n        // Check if the arrays are not of the same length\n        if (ids.length !== nodes.length) {\n            throw new Error(\"ids and nodes arrays must be of the same length\");\n        }\n        if (ids.length === 0) {\n            return;\n        }\n        // Create array of objects with id and node\n        const data = nodes.map((node, index) => ({\n            id: ids[index],\n            node: node,\n        }));\n        // Use bulkPut to add/overwrite the entries\n        await partialBlockchainNodes.bulkPut(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert partial blockchain nodes\");\n    }\n}\n// GET FUNCTIONS\nasync function getBlockHeaders(blockNumbers) {\n    try {\n        const results = await blockHeaders.bulkGet(blockNumbers);\n        const processedResults = await Promise.all(results.map((result) => {\n            if (result === undefined) {\n                return null;\n            }\n            else {\n                const headerBase64 = uint8ArrayToBase64(result.header);\n                const partialBlockchainPeaksBase64 = uint8ArrayToBase64(result.partialBlockchainPeaks);\n                return {\n                    blockNum: result.blockNum,\n                    header: headerBase64,\n                    partialBlockchainPeaks: partialBlockchainPeaksBase64,\n                    hasClientNotes: result.hasClientNotes === \"true\",\n                };\n            }\n        }));\n        return processedResults;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get block headers\");\n    }\n}\nasync function getTrackedBlockHeaders() {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await blockHeaders\n            .where(\"hasClientNotes\")\n            .equals(\"true\")\n            .toArray();\n        // Process all records with async operations\n        const processedRecords = await Promise.all(allMatchingRecords.map((record) => {\n            const headerBase64 = uint8ArrayToBase64(record.header);\n            const partialBlockchainPeaksBase64 = uint8ArrayToBase64(record.partialBlockchainPeaks);\n            return {\n                blockNum: record.blockNum,\n                header: headerBase64,\n                partialBlockchainPeaks: partialBlockchainPeaksBase64,\n                hasClientNotes: record.hasClientNotes === \"true\",\n            };\n        }));\n        return processedRecords;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get tracked block headers\");\n    }\n}\nasync function getPartialBlockchainPeaksByBlockNum(blockNum) {\n    try {\n        const blockHeader = await blockHeaders.get(blockNum);\n        if (blockHeader == undefined) {\n            return {\n                peaks: undefined,\n            };\n        }\n        const partialBlockchainPeaksBase64 = uint8ArrayToBase64(blockHeader.partialBlockchainPeaks);\n        return {\n            peaks: partialBlockchainPeaksBase64,\n        };\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain peaks\");\n    }\n}\nasync function getPartialBlockchainNodesAll() {\n    try {\n        const partialBlockchainNodesAll = await partialBlockchainNodes.toArray();\n        return partialBlockchainNodesAll;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain nodes\");\n    }\n}\nasync function getPartialBlockchainNodes(ids) {\n    try {\n        const results = await partialBlockchainNodes.bulkGet(ids);\n        return results;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain nodes\");\n    }\n}\nasync function pruneIrrelevantBlocks() {\n    try {\n        const syncHeight = await stateSync.get(1);\n        if (syncHeight == undefined) {\n            throw Error(\"SyncHeight is undefined -- is the state sync table empty?\");\n        }\n        const allMatchingRecords = await blockHeaders\n            .where(\"hasClientNotes\")\n            .equals(\"false\")\n            .and((record) => record.blockNum !== \"0\" && record.blockNum !== syncHeight.blockNum)\n            .toArray();\n        await blockHeaders.bulkDelete(allMatchingRecords.map((r) => r.blockNum));\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to prune irrelevant blocks\");\n    }\n}\n\n// Disabling `any` checks since this file mostly deals with exporting DB types.\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n/* eslint-disable  @typescript-eslint/no-unsafe-return */\n/* eslint-disable  @typescript-eslint/no-unsafe-assignment */\nasync function recursivelyTransformForExport(obj) {\n    switch (obj.type) {\n        case \"Uint8Array\":\n            return Array.from(obj.value);\n        case \"Blob\":\n            return {\n                __type: \"Blob\",\n                data: uint8ArrayToBase64(new Uint8Array(await obj.value.arrayBuffer())),\n            };\n        case \"Array\":\n            return await Promise.all(obj.value.map((v) => recursivelyTransformForExport({ type: getInputType(v), value: v })));\n        case \"Record\":\n            return Object.fromEntries(await Promise.all(Object.entries(obj.value).map(async ([key, value]) => [\n                key,\n                await recursivelyTransformForExport({\n                    type: getInputType(value),\n                    value,\n                }),\n            ])));\n        case \"Primitive\":\n            return obj.value;\n    }\n}\nfunction getInputType(value) {\n    if (value instanceof Uint8Array)\n        return \"Uint8Array\";\n    if (value instanceof Blob)\n        return \"Blob\";\n    if (Array.isArray(value))\n        return \"Array\";\n    if (value && typeof value === \"object\")\n        return \"Record\";\n    return \"Primitive\";\n}\nasync function transformForExport(obj) {\n    return recursivelyTransformForExport({ type: getInputType(obj), value: obj });\n}\nasync function exportStore() {\n    const dbJson = {};\n    for (const table of db.tables) {\n        const records = await table.toArray();\n        dbJson[table.name] = await Promise.all(records.map(transformForExport));\n    }\n    return JSON.stringify(dbJson);\n}\n\n// Disabling `any` checks since this file mostly deals\n// with importing DB types and we're testing this which\n// should be enough + the TS compiler.\n/* eslint-disable */\nasync function recursivelyTransformForImport(obj) {\n    switch (obj.type) {\n        case \"Blob\":\n            return new Blob([base64ToUint8Array(obj.value.data)]);\n        case \"Array\":\n            return await Promise.all(obj.value.map((v) => recursivelyTransformForImport({ type: getImportType(v), value: v })));\n        case \"Object\":\n            return Object.fromEntries(await Promise.all(Object.entries(obj.value).map(async ([key, value]) => [\n                key,\n                await recursivelyTransformForImport({\n                    type: getImportType(value),\n                    value,\n                }),\n            ])));\n        case \"Primitive\":\n            return obj.value;\n    }\n}\nfunction getImportType(value) {\n    if (value && typeof value === \"object\" && value.__type === \"Blob\") {\n        return \"Blob\";\n    }\n    if (Array.isArray(value))\n        return \"Array\";\n    if (value && typeof value === \"object\")\n        return \"Object\";\n    return \"Primitive\";\n}\nasync function transformForImport(obj) {\n    return recursivelyTransformForImport({\n        type: getImportType(obj),\n        value: obj,\n    });\n}\nasync function forceImportStore(jsonStr) {\n    try {\n        if (!db.isOpen) {\n            await openDatabase();\n        }\n        let dbJson = JSON.parse(jsonStr);\n        if (typeof dbJson === \"string\") {\n            dbJson = JSON.parse(dbJson);\n        }\n        const jsonTableNames = Object.keys(dbJson);\n        const dbTableNames = db.tables.map((t) => t.name);\n        if (jsonTableNames.length === 0) {\n            throw new Error(\"No tables found in the provided JSON.\");\n        }\n        await db.transaction(\"rw\", dbTableNames, async () => {\n            await Promise.all(db.tables.map((t) => t.clear()));\n            for (const tableName of jsonTableNames) {\n                const table = db.table(tableName);\n                if (!dbTableNames.includes(tableName)) {\n                    console.warn(`Table \"${tableName}\" does not exist in the database schema. Skipping.`);\n                    continue;\n                }\n                const records = dbJson[tableName];\n                const transformedRecords = await Promise.all(records.map(transformForImport));\n                await table.bulkPut(transformedRecords);\n            }\n        });\n        console.log(\"Store imported successfully.\");\n    }\n    catch (err) {\n        logWebStoreError(err);\n    }\n}\nfunction base64ToUint8Array(base64) {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n\nasync function getOutputNotes(states) {\n    try {\n        let notes = states.length == 0\n            ? await outputNotes.toArray()\n            : await outputNotes.where(\"stateDiscriminant\").anyOf(states).toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes\");\n    }\n}\nasync function getInputNotes(states) {\n    try {\n        let notes;\n        if (states.length === 0) {\n            notes = await inputNotes.toArray();\n        }\n        else {\n            notes = await inputNotes\n                .where(\"stateDiscriminant\")\n                .anyOf(states)\n                .toArray();\n        }\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes\");\n    }\n}\nasync function getInputNotesFromIds(noteIds) {\n    try {\n        let notes = await inputNotes.where(\"noteId\").anyOf(noteIds).toArray();\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes from IDs\");\n    }\n}\nasync function getInputNotesFromNullifiers(nullifiers) {\n    try {\n        let notes = await inputNotes.where(\"nullifier\").anyOf(nullifiers).toArray();\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes from nullifiers\");\n    }\n}\nasync function getOutputNotesFromNullifiers(nullifiers) {\n    try {\n        let notes = await outputNotes\n            .where(\"nullifier\")\n            .anyOf(nullifiers)\n            .toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes from nullifiers\");\n    }\n}\nasync function getOutputNotesFromIds(noteIds) {\n    try {\n        let notes = await outputNotes.where(\"noteId\").anyOf(noteIds).toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes from IDs\");\n    }\n}\nasync function getUnspentInputNoteNullifiers() {\n    try {\n        const notes = await inputNotes\n            .where(\"stateDiscriminant\")\n            .anyOf([2, 4, 5])\n            .toArray();\n        return notes.map((note) => note.nullifier);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get unspent input note nullifiers\");\n    }\n}\nasync function getNoteScript(scriptRoot) {\n    try {\n        const noteScript = await notesScripts\n            .where(\"scriptRoot\")\n            .equals(scriptRoot)\n            .first();\n        return noteScript;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get note script from root\");\n    }\n}\nasync function upsertInputNote(noteId, assets, serialNumber, inputs, scriptRoot, serializedNoteScript, nullifier, serializedCreatedAt, stateDiscriminant, state) {\n    return db.transaction(\"rw\", inputNotes, notesScripts, async (tx) => {\n        try {\n            const data = {\n                noteId,\n                assets,\n                serialNumber,\n                inputs,\n                scriptRoot,\n                nullifier,\n                state,\n                stateDiscriminant,\n                serializedCreatedAt,\n            };\n            await tx.inputNotes.put(data);\n            const noteScriptData = {\n                scriptRoot,\n                serializedNoteScript,\n            };\n            await tx.notesScripts.put(noteScriptData);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note: ${noteId}`);\n        }\n    });\n}\nasync function upsertOutputNote(noteId, assets, recipientDigest, metadata, nullifier, expectedHeight, stateDiscriminant, state) {\n    return db.transaction(\"rw\", outputNotes, notesScripts, async (tx) => {\n        try {\n            const data = {\n                noteId,\n                assets,\n                recipientDigest,\n                metadata,\n                nullifier: nullifier ? nullifier : undefined,\n                expectedHeight,\n                stateDiscriminant,\n                state,\n            };\n            await tx.outputNotes.put(data);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note: ${noteId}`);\n        }\n    });\n}\nasync function processInputNotes(notes) {\n    return await Promise.all(notes.map(async (note) => {\n        const assetsBase64 = uint8ArrayToBase64(note.assets);\n        const serialNumberBase64 = uint8ArrayToBase64(note.serialNumber);\n        const inputsBase64 = uint8ArrayToBase64(note.inputs);\n        let serializedNoteScriptBase64 = undefined;\n        if (note.scriptRoot) {\n            let record = await notesScripts.get(note.scriptRoot);\n            if (record) {\n                serializedNoteScriptBase64 = uint8ArrayToBase64(record.serializedNoteScript);\n            }\n        }\n        const stateBase64 = uint8ArrayToBase64(note.state);\n        return {\n            assets: assetsBase64,\n            serialNumber: serialNumberBase64,\n            inputs: inputsBase64,\n            createdAt: note.serializedCreatedAt,\n            serializedNoteScript: serializedNoteScriptBase64,\n            state: stateBase64,\n        };\n    }));\n}\nasync function processOutputNotes(notes) {\n    return await Promise.all(notes.map((note) => {\n        const assetsBase64 = uint8ArrayToBase64(note.assets);\n        const metadataBase64 = uint8ArrayToBase64(note.metadata);\n        const stateBase64 = uint8ArrayToBase64(note.state);\n        return {\n            assets: assetsBase64,\n            recipientDigest: note.recipientDigest,\n            metadata: metadataBase64,\n            expectedHeight: note.expectedHeight,\n            state: stateBase64,\n        };\n    }));\n}\nasync function upsertNoteScript(scriptRoot, serializedNoteScript) {\n    return db.transaction(\"rw\", outputNotes, notesScripts, async (tx) => {\n        try {\n            const noteScriptData = {\n                scriptRoot,\n                serializedNoteScript,\n            };\n            await tx.notesScripts.put(noteScriptData);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note script: ${scriptRoot}`);\n        }\n    });\n}\n\nasync function getSetting(key) {\n    try {\n        // Fetch all records matching the given key\n        const allMatchingRecords = await settings\n            .where(\"key\")\n            .equals(key)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No setting record found for given key.\");\n            return null;\n        }\n        // There should be only one match\n        const matchingRecord = allMatchingRecords[0];\n        // Convert the setting value to base64\n        const valueBase64 = uint8ArrayToBase64(matchingRecord.value);\n        return {\n            key: matchingRecord.key,\n            value: valueBase64,\n        };\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching setting key: ${key}`);\n    }\n}\nasync function insertSetting(key, value) {\n    try {\n        const setting = {\n            key,\n            value,\n        };\n        await settings.put(setting);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting setting with key: ${key} and value(base64): ${uint8ArrayToBase64(value)}`);\n    }\n}\nasync function removeSetting(key) {\n    try {\n        await settings.where(\"key\").equals(key).delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error deleting setting with key: ${key}`);\n    }\n}\nasync function listSettingKeys() {\n    try {\n        const keys = await settings\n            .toArray()\n            .then((settings) => settings.map((setting) => setting.key));\n        return keys;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error listing setting keys`);\n    }\n}\n\nconst IDS_FILTER_PREFIX = \"Ids:\";\nconst EXPIRED_BEFORE_FILTER_PREFIX = \"ExpiredPending:\";\nconst STATUS_COMMITTED_VARIANT = 1;\nconst STATUS_DISCARDED_VARIANT = 2;\nasync function getTransactions(filter) {\n    let transactionRecords = [];\n    try {\n        if (filter === \"Uncommitted\") {\n            transactionRecords = await transactions\n                .filter((tx) => tx.statusVariant !== STATUS_COMMITTED_VARIANT)\n                .toArray();\n        }\n        else if (filter.startsWith(IDS_FILTER_PREFIX)) {\n            const idsString = filter.substring(IDS_FILTER_PREFIX.length);\n            const ids = idsString.split(\",\");\n            if (ids.length > 0) {\n                transactionRecords = await transactions\n                    .where(\"id\")\n                    .anyOf(ids)\n                    .toArray();\n            }\n            else {\n                transactionRecords = [];\n            }\n        }\n        else if (filter.startsWith(EXPIRED_BEFORE_FILTER_PREFIX)) {\n            const blockNumString = filter.substring(EXPIRED_BEFORE_FILTER_PREFIX.length);\n            const blockNum = parseInt(blockNumString);\n            transactionRecords = await transactions\n                .filter((tx) => tx.blockNum < blockNum &&\n                tx.statusVariant !== STATUS_COMMITTED_VARIANT &&\n                tx.statusVariant !== STATUS_DISCARDED_VARIANT)\n                .toArray();\n        }\n        else {\n            transactionRecords = await transactions.toArray();\n        }\n        if (transactionRecords.length === 0) {\n            return [];\n        }\n        const scriptRoots = transactionRecords\n            .map((transactionRecord) => {\n            return transactionRecord.scriptRoot;\n        })\n            .filter((scriptRoot) => scriptRoot != undefined);\n        const scripts = await transactionScripts\n            .where(\"scriptRoot\")\n            .anyOf(scriptRoots)\n            .toArray();\n        // Create a map of scriptRoot to script for quick lookup\n        const scriptMap = new Map();\n        scripts.forEach((script) => {\n            if (script.txScript) {\n                scriptMap.set(script.scriptRoot, script.txScript);\n            }\n        });\n        const processedTransactions = await Promise.all(transactionRecords.map((transactionRecord) => {\n            let txScriptBase64 = undefined;\n            if (transactionRecord.scriptRoot) {\n                const txScript = scriptMap.get(transactionRecord.scriptRoot);\n                if (txScript) {\n                    txScriptBase64 = uint8ArrayToBase64(txScript);\n                }\n            }\n            const detailsBase64 = uint8ArrayToBase64(transactionRecord.details);\n            const statusBase64 = uint8ArrayToBase64(transactionRecord.status);\n            const data = {\n                id: transactionRecord.id,\n                details: detailsBase64,\n                scriptRoot: transactionRecord.scriptRoot,\n                txScript: txScriptBase64,\n                blockNum: transactionRecord.blockNum.toString(),\n                statusVariant: transactionRecord.statusVariant,\n                status: statusBase64,\n            };\n            return data;\n        }));\n        return processedTransactions;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get transactions\");\n    }\n}\nasync function insertTransactionScript(scriptRoot, txScript) {\n    try {\n        const scriptRootArray = new Uint8Array(scriptRoot);\n        const scriptRootBase64 = uint8ArrayToBase64(scriptRootArray);\n        const data = {\n            scriptRoot: scriptRootBase64,\n            txScript: mapOption(txScript, (txScript) => new Uint8Array(txScript)),\n        };\n        await transactionScripts.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to insert transaction script\");\n    }\n}\nasync function upsertTransactionRecord(transactionId, details, blockNum, statusVariant, status, scriptRoot) {\n    try {\n        const data = {\n            id: transactionId,\n            details,\n            scriptRoot: mapOption(scriptRoot, (root) => uint8ArrayToBase64(root)),\n            blockNum: parseInt(blockNum, 10),\n            statusVariant,\n            status,\n        };\n        await transactions.put(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert proven transaction data\");\n    }\n}\n\nasync function getNoteTags() {\n    try {\n        let records = await tags.toArray();\n        let processedRecords = records.map((record) => {\n            record.sourceNoteId =\n                record.sourceNoteId == \"\" ? undefined : record.sourceNoteId;\n            record.sourceAccountId =\n                record.sourceAccountId == \"\" ? undefined : record.sourceAccountId;\n            return record;\n        });\n        return processedRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetch tag record\");\n    }\n}\nasync function getSyncHeight() {\n    try {\n        const record = await stateSync.get(1); // Since id is the primary key and always 1\n        if (record) {\n            let data = {\n                blockNum: record.blockNum,\n            };\n            return data;\n        }\n        else {\n            return null;\n        }\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetching sync height\");\n    }\n}\nasync function addNoteTag(tag, sourceNoteId, sourceAccountId) {\n    try {\n        let tagArray = new Uint8Array(tag);\n        let tagBase64 = uint8ArrayToBase64(tagArray);\n        await tags.add({\n            tag: tagBase64,\n            sourceNoteId: sourceNoteId ? sourceNoteId : \"\",\n            sourceAccountId: sourceAccountId ? sourceAccountId : \"\",\n        });\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to add note tag\");\n    }\n}\nasync function removeNoteTag(tag, sourceNoteId, sourceAccountId) {\n    try {\n        let tagArray = new Uint8Array(tag);\n        let tagBase64 = uint8ArrayToBase64(tagArray);\n        return await tags\n            .where({\n            tag: tagBase64,\n            sourceNoteId: sourceNoteId ? sourceNoteId : \"\",\n            sourceAccountId: sourceAccountId ? sourceAccountId : \"\",\n        })\n            .delete();\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to remove note tag\");\n    }\n}\n/*\n * Takes a `JsStateSyncUpdate` object and writes the state update into the store.\n * @param {JsStateSyncUpdate}\n */\nasync function applyStateSync(stateUpdate) {\n    const { blockNum, // Target block number for this sync\n    flattenedNewBlockHeaders, // Serialized block headers to be reconstructed\n    flattenedPartialBlockChainPeaks, // Serialized blockchain peaks for verification\n    newBlockNums, // Block numbers corresponding to new headers\n    blockHasRelevantNotes, // Flags indicating which blocks have relevant notes\n    serializedNodeIds, // IDs for new authentication nodes\n    serializedNodes, // Authentication node data for merkle proofs\n    committedNoteIds, // Note tags to be cleaned up/removed\n    serializedInputNotes, // Input notes consumed in transactions\n    serializedOutputNotes, // Output notes created in transactions\n    accountUpdates, // Account state changes\n    transactionUpdates, // Transaction records and scripts\n     } = stateUpdate;\n    // Block headers and Blockchain peaks are flattened before calling\n    // this function, here we rebuild them.\n    const newBlockHeaders = reconstructFlattenedVec(flattenedNewBlockHeaders);\n    const partialBlockchainPeaks = reconstructFlattenedVec(flattenedPartialBlockChainPeaks);\n    // Create promises to insert each input note. Each note will have its own transaction,\n    // and therefore, nested inside the final transaction inside this function.\n    let inputNotesWriteOp = Promise.all(serializedInputNotes.map((note) => {\n        return upsertInputNote(note.noteId, note.noteAssets, note.serialNumber, note.inputs, note.noteScriptRoot, note.noteScript, note.nullifier, note.createdAt, note.stateDiscriminant, note.state);\n    }));\n    // See comment above, the same thing applies here, but for Output Notes.\n    let outputNotesWriteOp = Promise.all(serializedOutputNotes.map((note) => {\n        return upsertOutputNote(note.noteId, note.noteAssets, note.recipientDigest, note.metadata, note.nullifier, note.expectedHeight, note.stateDiscriminant, note.state);\n    }));\n    // Promises to insert each transaction update.\n    let transactionWriteOp = Promise.all(transactionUpdates.map((transactionRecord) => {\n        let promises = [\n            upsertTransactionRecord(transactionRecord.id, transactionRecord.details, transactionRecord.blockNum, transactionRecord.statusVariant, transactionRecord.status, transactionRecord.scriptRoot),\n        ];\n        if (transactionRecord.scriptRoot && transactionRecord.txScript) {\n            promises.push(insertTransactionScript(transactionRecord.scriptRoot, transactionRecord.txScript));\n        }\n        return Promise.all(promises);\n    }));\n    // Promises to insert each account update.\n    let accountUpdatesWriteOp = Promise.all(accountUpdates.flatMap((accountUpdate) => {\n        return [\n            upsertAccountStorage(accountUpdate.storageSlots),\n            upsertStorageMapEntries(accountUpdate.storageMapEntries),\n            upsertVaultAssets(accountUpdate.assets),\n            upsertAccountRecord(accountUpdate.accountId, accountUpdate.codeRoot, accountUpdate.storageRoot, accountUpdate.assetVaultRoot, accountUpdate.nonce, accountUpdate.committed, accountUpdate.accountCommitment, accountUpdate.accountSeed),\n        ];\n    }));\n    const tablesToAccess = [\n        stateSync,\n        inputNotes,\n        outputNotes,\n        transactions,\n        blockHeaders,\n        partialBlockchainNodes,\n        tags,\n    ];\n    // Write everything in a single transaction, this transaction will atomically do the operations\n    // below, since every operation here (or at least, most of them), is done in a nested transaction.\n    // For more information on this, check: https://dexie.org/docs/Dexie/Dexie.transaction()\n    return await db.transaction(\"rw\", tablesToAccess, async (tx) => {\n        // Everything is under a single promise since otherwise the tx expires.\n        await Promise.all([\n            inputNotesWriteOp,\n            outputNotesWriteOp,\n            transactionWriteOp,\n            accountUpdatesWriteOp,\n            updateSyncHeight(tx, blockNum),\n            updatePartialBlockchainNodes(tx, serializedNodeIds, serializedNodes),\n            updateCommittedNoteTags(tx, committedNoteIds),\n            Promise.all(newBlockHeaders.map((newBlockHeader, i) => {\n                return updateBlockHeader(tx, newBlockNums[i], newBlockHeader, partialBlockchainPeaks[i], blockHasRelevantNotes[i] == 1);\n            })),\n        ]);\n    });\n}\nasync function updateSyncHeight(tx, blockNum) {\n    try {\n        await tx.stateSync.update(1, { blockNum: blockNum });\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to update sync height\");\n    }\n}\nasync function updateBlockHeader(tx, blockNum, blockHeader, partialBlockchainPeaks, hasClientNotes) {\n    try {\n        const data = {\n            blockNum: blockNum,\n            header: blockHeader,\n            partialBlockchainPeaks,\n            hasClientNotes: hasClientNotes.toString(),\n        };\n        const existingBlockHeader = await tx.blockHeaders.get(blockNum);\n        if (!existingBlockHeader) {\n            await tx.blockHeaders.add(data);\n        }\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert block header\");\n    }\n}\nasync function updatePartialBlockchainNodes(tx, nodeIndexes, nodes) {\n    try {\n        // Check if the arrays are not of the same length\n        if (nodeIndexes.length !== nodes.length) {\n            throw new Error(\"nodeIndexes and nodes arrays must be of the same length\");\n        }\n        if (nodeIndexes.length === 0) {\n            return;\n        }\n        // Create array of objects with id and node\n        const data = nodes.map((node, index) => ({\n            id: nodeIndexes[index],\n            node: node,\n        }));\n        // Use bulkPut to add/overwrite the entries\n        await tx.partialBlockchainNodes.bulkPut(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to update partial blockchain nodes\");\n    }\n}\nasync function updateCommittedNoteTags(tx, inputNoteIds) {\n    try {\n        for (let i = 0; i < inputNoteIds.length; i++) {\n            const noteId = inputNoteIds[i];\n            // Remove note tags\n            await tx.tags.where(\"source_note_id\").equals(noteId).delete();\n        }\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to pudate committed note tags\");\n    }\n}\n// Helper function to reconstruct arrays from flattened data\nfunction reconstructFlattenedVec(flattenedVec) {\n    const data = flattenedVec.data();\n    const lengths = flattenedVec.lengths();\n    let index = 0;\n    const result = [];\n    lengths.forEach((length) => {\n        result.push(data.slice(index, index + length));\n        index += length;\n    });\n    return result;\n}\n\nlet wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export4(addHeapObject(e));\n    }\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getDataViewMemory0();\n    const result = [];\n    for (let i = ptr; i < ptr + 4 * len; i += 4) {\n        result.push(takeObject(mem.getUint32(i, true)));\n    }\n    return result;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => state.dtor(state.a, state.b));\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            state.a = a;\n            real._wbg_cb_unref();\n        }\n    };\n    real._wbg_cb_unref = () => {\n        if (--state.cnt === 0) {\n            state.dtor(state.a, state.b);\n            state.a = 0;\n            CLOSURE_DTORS.unregister(state);\n        }\n    };\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    const mem = getDataViewMemory0();\n    for (let i = 0; i < array.length; i++) {\n        mem.setUint32(ptr + 4 * i, addHeapObject(array[i]), true);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nlet cachedBigUint64ArrayMemory0 = null;\n\nfunction getBigUint64ArrayMemory0() {\n    if (cachedBigUint64ArrayMemory0 === null || cachedBigUint64ArrayMemory0.byteLength === 0) {\n        cachedBigUint64ArrayMemory0 = new BigUint64Array(wasm.memory.buffer);\n    }\n    return cachedBigUint64ArrayMemory0;\n}\n\nfunction passArray64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8, 8) >>> 0;\n    getBigUint64ArrayMemory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU64FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getBigUint64ArrayMemory0().subarray(ptr / 8, ptr / 8 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\nfunction __wasm_bindgen_func_elem_9375(arg0, arg1, arg2) {\n    wasm.__wasm_bindgen_func_elem_9375(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wasm_bindgen_func_elem_9309(arg0, arg1) {\n    wasm.__wasm_bindgen_func_elem_9309(arg0, arg1);\n}\n\nfunction __wasm_bindgen_func_elem_3677(arg0, arg1, arg2, arg3) {\n    wasm.__wasm_bindgen_func_elem_3677(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n * @enum {0}\n */\nconst AccountInterface = Object.freeze({\n    BasicWallet: 0, \"0\": \"BasicWallet\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nconst AccountType = Object.freeze({\n    FungibleFaucet: 0, \"0\": \"FungibleFaucet\",\n    NonFungibleFaucet: 1, \"1\": \"NonFungibleFaucet\",\n    RegularAccountImmutableCode: 2, \"2\": \"RegularAccountImmutableCode\",\n    RegularAccountUpdatableCode: 3, \"3\": \"RegularAccountUpdatableCode\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8}\n */\nconst InputNoteState = Object.freeze({\n    Expected: 0, \"0\": \"Expected\",\n    Unverified: 1, \"1\": \"Unverified\",\n    Committed: 2, \"2\": \"Committed\",\n    Invalid: 3, \"3\": \"Invalid\",\n    ProcessingAuthenticated: 4, \"4\": \"ProcessingAuthenticated\",\n    ProcessingUnauthenticated: 5, \"5\": \"ProcessingUnauthenticated\",\n    ConsumedAuthenticatedLocal: 6, \"6\": \"ConsumedAuthenticatedLocal\",\n    ConsumedUnauthenticatedLocal: 7, \"7\": \"ConsumedUnauthenticatedLocal\",\n    ConsumedExternal: 8, \"8\": \"ConsumedExternal\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst NetworkId = Object.freeze({\n    Mainnet: 0, \"0\": \"Mainnet\",\n    Testnet: 1, \"1\": \"Testnet\",\n    Devnet: 2, \"2\": \"Devnet\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8}\n */\nconst NoteFilterTypes = Object.freeze({\n    All: 0, \"0\": \"All\",\n    Consumed: 1, \"1\": \"Consumed\",\n    Committed: 2, \"2\": \"Committed\",\n    Expected: 3, \"3\": \"Expected\",\n    Processing: 4, \"4\": \"Processing\",\n    List: 5, \"5\": \"List\",\n    Unique: 6, \"6\": \"Unique\",\n    Nullifiers: 7, \"7\": \"Nullifiers\",\n    Unverified: 8, \"8\": \"Unverified\",\n});\n/**\n * @enum {2 | 3 | 1}\n */\nconst NoteType = Object.freeze({\n    /**\n     * Notes with this type have only their hash published to the network.\n     */\n    Private: 2, \"2\": \"Private\",\n    /**\n     * Notes with this type are shared with the network encrypted.\n     */\n    Encrypted: 3, \"3\": \"Encrypted\",\n    /**\n     * Notes with this type are fully shared with the network.\n     */\n    Public: 1, \"1\": \"Public\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst SigningInputsType = Object.freeze({\n    TransactionSummary: 0, \"0\": \"TransactionSummary\",\n    Arbitrary: 1, \"1\": \"Arbitrary\",\n    Blind: 2, \"2\": \"Blind\",\n});\n\nconst __wbindgen_enum_AddressInterface = [\"BasicWallet\"];\n\nconst __wbindgen_enum_ReadableStreamType = [\"bytes\"];\n\nconst __wbindgen_enum_ReferrerPolicy = [\"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"origin\", \"origin-when-cross-origin\", \"unsafe-url\", \"same-origin\", \"strict-origin\", \"strict-origin-when-cross-origin\"];\n\nconst __wbindgen_enum_RequestCache = [\"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\"];\n\nconst __wbindgen_enum_RequestCredentials = [\"omit\", \"same-origin\", \"include\"];\n\nconst __wbindgen_enum_RequestMode = [\"same-origin\", \"no-cors\", \"cors\", \"navigate\"];\n\nconst __wbindgen_enum_RequestRedirect = [\"follow\", \"error\", \"manual\"];\n\nconst AccountFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_account_free(ptr >>> 0, 1));\n\nclass Account {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Account.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Account)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_account_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.account_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.account_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonce() {\n        const ret = wasm.account_nonce(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {AssetVault}\n     */\n    vault() {\n        const ret = wasm.account_vault(this.__wbg_ptr);\n        return AssetVault.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorage}\n     */\n    storage() {\n        const ret = wasm.account_storage(this.__wbg_ptr);\n        return AccountStorage.__wrap(ret);\n    }\n    /**\n     * @returns {AccountCode}\n     */\n    code() {\n        const ret = wasm.account_code(this.__wbg_ptr);\n        return AccountCode.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFaucet() {\n        const ret = wasm.account_isFaucet(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isRegularAccount() {\n        const ret = wasm.account_isRegularAccount(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isUpdatable() {\n        const ret = wasm.account_isUpdatable(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPublic() {\n        const ret = wasm.account_isPublic(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPrivate() {\n        const ret = wasm.account_isPrivate(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNetwork() {\n        const ret = wasm.account_isNetwork(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNew() {\n        const ret = wasm.account_isNew(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.account_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Account}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.account_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Account.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {Word[]}\n     */\n    getPublicKeys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.account_getPublicKeys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Account.prototype[Symbol.dispose] = Account.prototype.free;\n\nconst AccountArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountarray_free(ptr >>> 0, 1));\n\nclass AccountArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountarray_free(ptr, 0);\n    }\n    /**\n     * @param {Account[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        AccountArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {Account}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Account.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {Account} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Account);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.accountarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Account} element\n     */\n    push(element) {\n        _assertClass(element, Account);\n        wasm.accountarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.accountarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) AccountArray.prototype[Symbol.dispose] = AccountArray.prototype.free;\n\nconst AccountBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountbuilder_free(ptr >>> 0, 1));\n\nclass AccountBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountbuilder_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array} init_seed\n     */\n    constructor(init_seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountbuilder_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            AccountBuilderFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountType} account_type\n     * @returns {AccountBuilder}\n     */\n    accountType(account_type) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountbuilder_accountType(ptr, account_type);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @returns {AccountBuilder}\n     */\n    storageMode(storage_mode) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(storage_mode, AccountStorageMode);\n        const ret = wasm.accountbuilder_storageMode(ptr, storage_mode.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountComponent} account_component\n     * @returns {AccountBuilder}\n     */\n    withComponent(account_component) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(account_component, AccountComponent);\n        const ret = wasm.accountbuilder_withComponent(ptr, account_component.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountComponent} account_component\n     * @returns {AccountBuilder}\n     */\n    withAuthComponent(account_component) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(account_component, AccountComponent);\n        const ret = wasm.accountbuilder_withAuthComponent(ptr, account_component.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {AccountBuilder}\n     */\n    withNoAuthComponent() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountbuilder_withNoAuthComponent(ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {AccountBuilderResult}\n     */\n    build() {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountbuilder_build(retptr, ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountBuilderResult.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountBuilder.prototype[Symbol.dispose] = AccountBuilder.prototype.free;\n\nconst AccountBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountbuilderresult_free(ptr >>> 0, 1));\n\nclass AccountBuilderResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountBuilderResult.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountBuilderResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountbuilderresult_free(ptr, 0);\n    }\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        const ret = wasm.accountbuilderresult_account(this.__wbg_ptr);\n        return Account.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    get seed() {\n        const ret = wasm.accountbuilderresult_seed(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountBuilderResult.prototype[Symbol.dispose] = AccountBuilderResult.prototype.free;\n\nconst AccountCodeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountcode_free(ptr >>> 0, 1));\n\nclass AccountCode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountCode.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountCodeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountCodeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountcode_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {Word} mast_root\n     * @returns {boolean}\n     */\n    hasProcedure(mast_root) {\n        _assertClass(mast_root, Word);\n        var ptr0 = mast_root.__destroy_into_raw();\n        const ret = wasm.accountcode_hasProcedure(this.__wbg_ptr, ptr0);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) AccountCode.prototype[Symbol.dispose] = AccountCode.prototype.free;\n\nconst AccountComponentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountcomponent_free(ptr >>> 0, 1));\n\nclass AccountComponent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountComponent.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountComponentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountComponentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountcomponent_free(ptr, 0);\n    }\n    /**\n     * @param {string} account_code\n     * @param {ScriptBuilder} builder\n     * @param {StorageSlot[]} storage_slots\n     * @returns {AccountComponent}\n     */\n    static compile(account_code, builder, storage_slots) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(account_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            _assertClass(builder, ScriptBuilder);\n            const ptr1 = passArrayJsValueToWasm0(storage_slots, wasm.__wbindgen_export);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.accountcomponent_compile(retptr, ptr0, len0, builder.__wbg_ptr, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountComponent}\n     */\n    withSupportsAllTypes() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountcomponent_withSupportsAllTypes(ptr);\n        return AccountComponent.__wrap(ret);\n    }\n    /**\n     * @param {string} procedure_name\n     * @returns {string}\n     */\n    getProcedureHash(procedure_name) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(procedure_name, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountcomponent_getProcedureHash(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @returns {GetProceduresResultItem[]}\n     */\n    getProcedures() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountcomponent_getProcedures(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {SecretKey} secret_key\n     * @returns {AccountComponent}\n     */\n    static createAuthComponent(secret_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(secret_key, SecretKey);\n            wasm.accountcomponent_createAuthComponent(retptr, secret_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Package} _package\n     * @param {StorageSlotArray} storage_slots\n     * @returns {AccountComponent}\n     */\n    static fromPackage(_package, storage_slots) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_package, Package);\n            _assertClass(storage_slots, StorageSlotArray);\n            wasm.accountcomponent_fromPackage(retptr, _package.__wbg_ptr, storage_slots.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountComponent.prototype[Symbol.dispose] = AccountComponent.prototype.free;\n\nconst AccountDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountdelta_free(ptr >>> 0, 1));\n\nclass AccountDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountdelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {AccountStorageDelta}\n     */\n    storage() {\n        const ret = wasm.accountdelta_storage(this.__wbg_ptr);\n        return AccountStorageDelta.__wrap(ret);\n    }\n    /**\n     * @returns {AccountVaultDelta}\n     */\n    vault() {\n        const ret = wasm.accountdelta_vault(this.__wbg_ptr);\n        return AccountVaultDelta.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonceDelta() {\n        const ret = wasm.accountdelta_nonceDelta(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountDelta.prototype[Symbol.dispose] = AccountDelta.prototype.free;\n\nconst AccountFileFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountfile_free(ptr >>> 0, 1));\n\nclass AccountFile {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountFile.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountFileFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountFileFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountfile_free(ptr, 0);\n    }\n    /**\n     * Serializes the `AccountFile` into a byte array\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountfile_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a byte array into an `AccountFile`\n     * @param {Uint8Array} bytes\n     * @returns {AccountFile}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountfile_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountFile.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) AccountFile.prototype[Symbol.dispose] = AccountFile.prototype.free;\n\nconst AccountHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountheader_free(ptr >>> 0, 1));\n\nclass AccountHeader {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountHeader.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountHeaderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountheader_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.accountheader_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonce() {\n        const ret = wasm.accountheader_nonce(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    vaultCommitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    storageCommitment() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    codeCommitment() {\n        const ret = wasm.accountheader_codeCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountHeader.prototype[Symbol.dispose] = AccountHeader.prototype.free;\n\nconst AccountIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountid_free(ptr >>> 0, 1));\n\nclass AccountId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountId.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof AccountId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountid_free(ptr, 0);\n    }\n    /**\n     * @param {string} hex\n     * @returns {AccountId}\n     */\n    static fromHex(hex) {\n        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountid_fromHex(ptr0, len0);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFaucet() {\n        const ret = wasm.accountid_isFaucet(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isRegularAccount() {\n        const ret = wasm.accountid_isRegularAccount(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPublic() {\n        const ret = wasm.accountid_isPublic(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPrivate() {\n        const ret = wasm.accountid_isPrivate(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNetwork() {\n        const ret = wasm.accountid_isNetwork(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountid_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Will turn the Account ID into its bech32 string representation. To avoid a potential\n     * wrongful encoding, this function will expect only IDs for either mainnet (\"mm\"),\n     * testnet (\"mtst\") or devnet (\"mdev\"). To use a custom bech32 prefix, see\n     * `Self::to_bech_32_custom`.\n     * @param {NetworkId} network_id\n     * @param {AccountInterface} account_interface\n     * @returns {string}\n     */\n    toBech32(network_id, account_interface) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountid_toBech32(retptr, this.__wbg_ptr, network_id, account_interface);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Turn this Account ID into its bech32 string representation. This method accepts a custom\n     * network ID.\n     * @param {string} custom_network_id\n     * @param {AccountInterface} account_interface\n     * @returns {string}\n     */\n    toBech32Custom(custom_network_id, account_interface) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(custom_network_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountid_toBech32Custom(retptr, this.__wbg_ptr, ptr0, len0, account_interface);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @returns {Felt}\n     */\n    prefix() {\n        const ret = wasm.accountid_prefix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    suffix() {\n        const ret = wasm.accountid_suffix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountId.prototype[Symbol.dispose] = AccountId.prototype.free;\n\nconst AccountIdArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountidarray_free(ptr >>> 0, 1));\n\nclass AccountIdArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountIdArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountidarray_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountidarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        AccountIdArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {AccountId}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountidarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {AccountId} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, AccountId);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.accountidarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} element\n     */\n    push(element) {\n        _assertClass(element, AccountId);\n        wasm.accountidarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.accountidarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) AccountIdArray.prototype[Symbol.dispose] = AccountIdArray.prototype.free;\n\nconst AccountStorageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstorage_free(ptr >>> 0, 1));\n\nclass AccountStorage {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorage.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstorage_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountstorage_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @returns {Word | undefined}\n     */\n    getItem(index) {\n        const ret = wasm.accountstorage_getItem(this.__wbg_ptr, index);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @param {Word} key\n     * @returns {Word | undefined}\n     */\n    getMapItem(index, key) {\n        _assertClass(key, Word);\n        const ret = wasm.accountstorage_getMapItem(this.__wbg_ptr, index, key.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * Get all key-value pairs from the map slot at `index`.\n     * Returns `undefined` if the slot isn't a map or `index` is out of bounds (0-255).\n     * Returns `[]` if the map exists but is empty.\n     * @param {number} index\n     * @returns {JsStorageMapEntry[] | undefined}\n     */\n    getMapEntries(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstorage_getMapEntries(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorage.prototype[Symbol.dispose] = AccountStorage.prototype.free;\n\nconst AccountStorageDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragedelta_free(ptr >>> 0, 1));\n\nclass AccountStorageDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragedelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountstoragedelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountStorageDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragedelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountstoragedelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    values() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragedelta_values(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageDelta.prototype[Symbol.dispose] = AccountStorageDelta.prototype.free;\n\nconst AccountStorageModeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragemode_free(ptr >>> 0, 1));\n\nclass AccountStorageMode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageMode.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageModeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageModeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragemode_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static private() {\n        const ret = wasm.accountstoragemode_private();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static public() {\n        const ret = wasm.accountstoragemode_public();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static network() {\n        const ret = wasm.accountstoragemode_network();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @param {string} s\n     * @returns {AccountStorageMode}\n     */\n    static tryFromStr(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountstoragemode_tryFromStr(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageMode.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    asStr() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragemode_asStr(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageMode.prototype[Symbol.dispose] = AccountStorageMode.prototype.free;\n\nconst AccountStorageRequirementsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragerequirements_free(ptr >>> 0, 1));\n\nclass AccountStorageRequirements {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageRequirements.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageRequirementsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageRequirementsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragerequirements_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.accountstoragerequirements_new();\n        this.__wbg_ptr = ret >>> 0;\n        AccountStorageRequirementsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {SlotAndKeys[]} slots_and_keys\n     * @returns {AccountStorageRequirements}\n     */\n    static fromSlotAndKeysArray(slots_and_keys) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(slots_and_keys, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountstoragerequirements_fromSlotAndKeysArray(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageRequirements.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageRequirements.prototype[Symbol.dispose] = AccountStorageRequirements.prototype.free;\n\nconst AccountVaultDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountvaultdelta_free(ptr >>> 0, 1));\n\nclass AccountVaultDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountVaultDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountVaultDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountVaultDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountvaultdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountvaultdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountVaultDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountVaultDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountstoragedelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {FungibleAssetDelta}\n     */\n    fungible() {\n        const ret = wasm.accountvaultdelta_fungible(this.__wbg_ptr);\n        return FungibleAssetDelta.__wrap(ret);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    addedFungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_addedFungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    removedFungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_removedFungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountVaultDelta.prototype[Symbol.dispose] = AccountVaultDelta.prototype.free;\n\nconst AddressFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr >>> 0, 1));\n\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n        AddressFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AddressFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {string | null} [_interface]\n     * @returns {Address}\n     */\n    static fromAccountId(account_id, _interface) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account_id, AccountId);\n            var ptr0 = isLikeNone(_interface) ? 0 : passStringToWasm0(_interface, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_fromAccountId(retptr, account_id.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} bech32\n     * @returns {Address}\n     */\n    static fromBech32(bech32) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_fromBech32(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AddressInterface}\n     */\n    interface() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_interface(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return __wbindgen_enum_AddressInterface[r0];\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_accountId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    toNoteTag() {\n        const ret = wasm.address_toNoteTag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {NetworkId} network_id\n     * @returns {string}\n     */\n    toBech32(network_id) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_toBech32(retptr, this.__wbg_ptr, network_id);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Address.prototype[Symbol.dispose] = Address.prototype.free;\n\nconst AdviceInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_adviceinputs_free(ptr >>> 0, 1));\n\nclass AdviceInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AdviceInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        AdviceInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AdviceInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_adviceinputs_free(ptr, 0);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    stack() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.adviceinputs_stack(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Word} key\n     * @returns {Felt[] | undefined}\n     */\n    mappedValues(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, Word);\n            wasm.adviceinputs_mappedValues(retptr, this.__wbg_ptr, key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AdviceInputs.prototype[Symbol.dispose] = AdviceInputs.prototype.free;\n\nconst AdviceMapFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_advicemap_free(ptr >>> 0, 1));\n\nclass AdviceMap {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AdviceMapFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_advicemap_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.accountstoragerequirements_new();\n        this.__wbg_ptr = ret >>> 0;\n        AdviceMapFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {Word} key\n     * @param {FeltArray} value\n     * @returns {Felt[] | undefined}\n     */\n    insert(key, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, Word);\n            _assertClass(value, FeltArray);\n            wasm.advicemap_insert(retptr, this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AdviceMap.prototype[Symbol.dispose] = AdviceMap.prototype.free;\n\nconst AssetVaultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_assetvault_free(ptr >>> 0, 1));\n\nclass AssetVault {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AssetVault.prototype);\n        obj.__wbg_ptr = ptr;\n        AssetVaultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AssetVaultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetvault_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @returns {bigint}\n     */\n    getBalance(faucet_id) {\n        _assertClass(faucet_id, AccountId);\n        const ret = wasm.assetvault_getBalance(this.__wbg_ptr, faucet_id.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    fungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetvault_fungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AssetVault.prototype[Symbol.dispose] = AssetVault.prototype.free;\n\nconst AuthSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_authsecretkey_free(ptr >>> 0, 1));\n\nclass AuthSecretKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AuthSecretKey.prototype);\n        obj.__wbg_ptr = ptr;\n        AuthSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AuthSecretKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_authsecretkey_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    getRpoFalcon512PublicKeyAsWord() {\n        const ret = wasm.authsecretkey_getRpoFalcon512PublicKeyAsWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    getRpoFalcon512SecretKeyAsFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.authsecretkey_getRpoFalcon512SecretKeyAsFelts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    getEcdsaK256KeccakPublicKeyAsWord() {\n        const ret = wasm.authsecretkey_getEcdsaK256KeccakPublicKeyAsWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    getEcdsaK256KeccakSecretKeyAsFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.authsecretkey_getEcdsaK256KeccakSecretKeyAsFelts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AuthSecretKey.prototype[Symbol.dispose] = AuthSecretKey.prototype.free;\n\nconst BasicFungibleFaucetComponentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_basicfungiblefaucetcomponent_free(ptr >>> 0, 1));\n\nclass BasicFungibleFaucetComponent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BasicFungibleFaucetComponent.prototype);\n        obj.__wbg_ptr = ptr;\n        BasicFungibleFaucetComponentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BasicFungibleFaucetComponentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_basicfungiblefaucetcomponent_free(ptr, 0);\n    }\n    /**\n     * @param {Account} account\n     * @returns {BasicFungibleFaucetComponent}\n     */\n    static fromAccount(account) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account, Account);\n            var ptr0 = account.__destroy_into_raw();\n            wasm.basicfungiblefaucetcomponent_fromAccount(retptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BasicFungibleFaucetComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {TokenSymbol}\n     */\n    symbol() {\n        const ret = wasm.accountid_prefix(this.__wbg_ptr);\n        return TokenSymbol.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    decimals() {\n        const ret = wasm.basicfungiblefaucetcomponent_decimals(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Felt}\n     */\n    maxSupply() {\n        const ret = wasm.accountid_suffix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) BasicFungibleFaucetComponent.prototype[Symbol.dispose] = BasicFungibleFaucetComponent.prototype.free;\n\nconst BlockHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_blockheader_free(ptr >>> 0, 1));\n\nclass BlockHeader {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BlockHeader.prototype);\n        obj.__wbg_ptr = ptr;\n        BlockHeaderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BlockHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    version() {\n        const ret = wasm.blockheader_version(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.blockheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    subCommitment() {\n        const ret = wasm.blockheader_subCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    prevBlockCommitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.blockheader_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    chainCommitment() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    accountRoot() {\n        const ret = wasm.accountheader_codeCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    nullifierRoot() {\n        const ret = wasm.blockheader_nullifierRoot(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    noteRoot() {\n        const ret = wasm.blockheader_noteRoot(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    txCommitment() {\n        const ret = wasm.blockheader_txCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    txKernelCommitment() {\n        const ret = wasm.accountbuilderresult_seed(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    proofCommitment() {\n        const ret = wasm.blockheader_proofCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    timestamp() {\n        const ret = wasm.blockheader_timestamp(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) BlockHeader.prototype[Symbol.dispose] = BlockHeader.prototype.free;\n\nconst ConsumableNoteRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_consumablenoterecord_free(ptr >>> 0, 1));\n\nclass ConsumableNoteRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ConsumableNoteRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        ConsumableNoteRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ConsumableNoteRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_consumablenoterecord_free(ptr, 0);\n    }\n    /**\n     * @param {InputNoteRecord} input_note_record\n     * @param {NoteConsumability[]} note_consumability\n     */\n    constructor(input_note_record, note_consumability) {\n        _assertClass(input_note_record, InputNoteRecord);\n        var ptr0 = input_note_record.__destroy_into_raw();\n        const ptr1 = passArrayJsValueToWasm0(note_consumability, wasm.__wbindgen_export);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.consumablenoterecord_new(ptr0, ptr1, len1);\n        this.__wbg_ptr = ret >>> 0;\n        ConsumableNoteRecordFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {InputNoteRecord}\n     */\n    inputNoteRecord() {\n        const ret = wasm.consumablenoterecord_inputNoteRecord(this.__wbg_ptr);\n        return InputNoteRecord.__wrap(ret);\n    }\n    /**\n     * @returns {NoteConsumability[]}\n     */\n    noteConsumability() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.consumablenoterecord_noteConsumability(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ConsumableNoteRecord.prototype[Symbol.dispose] = ConsumableNoteRecord.prototype.free;\n\nconst EndpointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_endpoint_free(ptr >>> 0, 1));\n/**\n * Represents a network endpoint for connecting to Miden nodes.\n *\n * An endpoint consists of a protocol (http/https), host, and optional port.\n * Provides convenient constructors for common network configurations.\n */\nclass Endpoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Endpoint.prototype);\n        obj.__wbg_ptr = ptr;\n        EndpointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EndpointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_endpoint_free(ptr, 0);\n    }\n    /**\n     * Creates an endpoint from a URL string.\n     *\n     * @param url - The URL string (e.g., <https://localhost:57291>)\n     * @throws throws an error if the URL is invalid\n     * @param {string} url\n     */\n    constructor(url) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.endpoint_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            EndpointFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the endpoint for the Miden testnet.\n     * @returns {Endpoint}\n     */\n    static testnet() {\n        const ret = wasm.endpoint_testnet();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the endpoint for the Miden devnet.\n     * @returns {Endpoint}\n     */\n    static devnet() {\n        const ret = wasm.endpoint_devnet();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the endpoint for a local Miden node.\n     *\n     * Uses <http://localhost:57291>\n     * @returns {Endpoint}\n     */\n    static localhost() {\n        const ret = wasm.endpoint_localhost();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the protocol of the endpoint.\n     * @returns {string}\n     */\n    get protocol() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_protocol(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the host of the endpoint.\n     * @returns {string}\n     */\n    get host() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_host(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the port of the endpoint.\n     * @returns {number | undefined}\n     */\n    get port() {\n        const ret = wasm.endpoint_port(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n     * Returns the string representation of the endpoint.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Endpoint.prototype[Symbol.dispose] = Endpoint.prototype.free;\n\nconst ExecutedTransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_executedtransaction_free(ptr >>> 0, 1));\n\nclass ExecutedTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutedTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutedTransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutedTransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executedtransaction_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.executedtransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.executedtransaction_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountHeader}\n     */\n    initialAccountHeader() {\n        const ret = wasm.executedtransaction_initialAccountHeader(this.__wbg_ptr);\n        return AccountHeader.__wrap(ret);\n    }\n    /**\n     * @returns {AccountHeader}\n     */\n    finalAccountHeader() {\n        const ret = wasm.executedtransaction_finalAccountHeader(this.__wbg_ptr);\n        return AccountHeader.__wrap(ret);\n    }\n    /**\n     * @returns {InputNotes}\n     */\n    inputNotes() {\n        const ret = wasm.executedtransaction_inputNotes(this.__wbg_ptr);\n        return InputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.executedtransaction_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionArgs}\n     */\n    txArgs() {\n        const ret = wasm.executedtransaction_txArgs(this.__wbg_ptr);\n        return TransactionArgs.__wrap(ret);\n    }\n    /**\n     * @returns {BlockHeader}\n     */\n    blockHeader() {\n        const ret = wasm.executedtransaction_blockHeader(this.__wbg_ptr);\n        return BlockHeader.__wrap(ret);\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        const ret = wasm.executedtransaction_accountDelta(this.__wbg_ptr);\n        return AccountDelta.__wrap(ret);\n    }\n}\nif (Symbol.dispose) ExecutedTransaction.prototype[Symbol.dispose] = ExecutedTransaction.prototype.free;\n\nconst FeltFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_felt_free(ptr >>> 0, 1));\n\nclass Felt {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Felt.prototype);\n        obj.__wbg_ptr = ptr;\n        FeltFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Felt)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FeltFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_felt_free(ptr, 0);\n    }\n    /**\n     * @param {bigint} value\n     */\n    constructor(value) {\n        const ret = wasm.felt_new(value);\n        this.__wbg_ptr = ret >>> 0;\n        FeltFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {bigint}\n     */\n    asInt() {\n        const ret = wasm.felt_asInt(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.felt_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Felt.prototype[Symbol.dispose] = Felt.prototype.free;\n\nconst FeltArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_feltarray_free(ptr >>> 0, 1));\n\nclass FeltArray {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FeltArray.prototype);\n        obj.__wbg_ptr = ptr;\n        FeltArrayFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FeltArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_feltarray_free(ptr, 0);\n    }\n    /**\n     * @param {Felt[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.feltarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        FeltArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {Felt}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.feltarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Felt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {Felt} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Felt);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.feltarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Felt} element\n     */\n    push(element) {\n        _assertClass(element, Felt);\n        wasm.feltarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.feltarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) FeltArray.prototype[Symbol.dispose] = FeltArray.prototype.free;\n\nconst FetchedNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fetchednote_free(ptr >>> 0, 1));\n/**\n * Represents a note fetched from a Miden node via RPC.\n */\nclass FetchedNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FetchedNote.prototype);\n        obj.__wbg_ptr = ptr;\n        FetchedNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FetchedNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fetchednote_free(ptr, 0);\n    }\n    /**\n     * Create a note with an optional `InputNote`.\n     * @param {NoteId} note_id\n     * @param {NoteMetadata} metadata\n     * @param {InputNote | null} [input_note]\n     */\n    constructor(note_id, metadata, input_note) {\n        _assertClass(note_id, NoteId);\n        var ptr0 = note_id.__destroy_into_raw();\n        _assertClass(metadata, NoteMetadata);\n        var ptr1 = metadata.__destroy_into_raw();\n        let ptr2 = 0;\n        if (!isLikeNone(input_note)) {\n            _assertClass(input_note, InputNote);\n            ptr2 = input_note.__destroy_into_raw();\n        }\n        const ret = wasm.fetchednote_new(ptr0, ptr1, ptr2);\n        this.__wbg_ptr = ret >>> 0;\n        FetchedNoteFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The unique identifier of the note.\n     * @returns {NoteId}\n     */\n    get noteId() {\n        const ret = wasm.fetchednote_noteId(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * The note's metadata, including sender, tag, and other properties.\n     * Available for both private and public notes.\n     * @returns {NoteMetadata}\n     */\n    get metadata() {\n        const ret = wasm.fetchednote_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * The full [`InputNote`] with inclusion proof.\n     *\n     * For public notes, it contains the complete note data and inclusion proof.\n     * For private notes, it will be ``None`.\n     * @returns {InputNote | undefined}\n     */\n    get inputNote() {\n        const ret = wasm.fetchednote_inputNote(this.__wbg_ptr);\n        return ret === 0 ? undefined : InputNote.__wrap(ret);\n    }\n    /**\n     * @returns {NoteType}\n     */\n    get noteType() {\n        const ret = wasm.fetchednote_noteType(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) FetchedNote.prototype[Symbol.dispose] = FetchedNote.prototype.free;\n\nconst FlattenedU8VecFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_flattenedu8vec_free(ptr >>> 0, 1));\n\nclass FlattenedU8Vec {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FlattenedU8Vec.prototype);\n        obj.__wbg_ptr = ptr;\n        FlattenedU8VecFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FlattenedU8VecFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_flattenedu8vec_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    data() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.flattenedu8vec_data(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint32Array}\n     */\n    lengths() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.flattenedu8vec_lengths(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    num_inner_vecs() {\n        const ret = wasm.flattenedu8vec_num_inner_vecs(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) FlattenedU8Vec.prototype[Symbol.dispose] = FlattenedU8Vec.prototype.free;\n\nconst ForeignAccountFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_foreignaccount_free(ptr >>> 0, 1));\n\nclass ForeignAccount {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ForeignAccount.prototype);\n        obj.__wbg_ptr = ptr;\n        ForeignAccountFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof ForeignAccount)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ForeignAccountFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_foreignaccount_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {AccountStorageRequirements} storage_requirements\n     * @returns {ForeignAccount}\n     */\n    static public(account_id, storage_requirements) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account_id, AccountId);\n            var ptr0 = account_id.__destroy_into_raw();\n            _assertClass(storage_requirements, AccountStorageRequirements);\n            var ptr1 = storage_requirements.__destroy_into_raw();\n            wasm.foreignaccount_public(retptr, ptr0, ptr1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ForeignAccount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountStorageRequirements}\n     */\n    storage_slot_requirements() {\n        const ret = wasm.foreignaccount_storage_slot_requirements(this.__wbg_ptr);\n        return AccountStorageRequirements.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    account_id() {\n        const ret = wasm.foreignaccount_account_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n}\nif (Symbol.dispose) ForeignAccount.prototype[Symbol.dispose] = ForeignAccount.prototype.free;\n\nconst ForeignAccountArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_foreignaccountarray_free(ptr >>> 0, 1));\n\nclass ForeignAccountArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ForeignAccountArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_foreignaccountarray_free(ptr, 0);\n    }\n    /**\n     * @param {ForeignAccount[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.foreignaccountarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        ForeignAccountArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {ForeignAccount}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.foreignaccountarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ForeignAccount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {ForeignAccount} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, ForeignAccount);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.foreignaccountarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {ForeignAccount} element\n     */\n    push(element) {\n        _assertClass(element, ForeignAccount);\n        wasm.foreignaccountarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.foreignaccountarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) ForeignAccountArray.prototype[Symbol.dispose] = ForeignAccountArray.prototype.free;\n\nconst FungibleAssetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleasset_free(ptr >>> 0, 1));\n\nclass FungibleAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAsset.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof FungibleAsset)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleasset_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @param {bigint} amount\n     */\n    constructor(faucet_id, amount) {\n        _assertClass(faucet_id, AccountId);\n        const ret = wasm.fungibleasset_new(faucet_id.__wbg_ptr, amount);\n        this.__wbg_ptr = ret >>> 0;\n        FungibleAssetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {AccountId}\n     */\n    faucetId() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    amount() {\n        const ret = wasm.fungibleasset_amount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    intoWord() {\n        const ret = wasm.fungibleasset_intoWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) FungibleAsset.prototype[Symbol.dispose] = FungibleAsset.prototype.free;\n\nconst FungibleAssetDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleassetdelta_free(ptr >>> 0, 1));\n\nclass FungibleAssetDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAssetDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleassetdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.fungibleassetdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {FungibleAssetDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fungibleassetdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FungibleAssetDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.fungibleassetdelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @returns {bigint | undefined}\n     */\n    amount(faucet_id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(faucet_id, AccountId);\n            wasm.fungibleassetdelta_amount(retptr, this.__wbg_ptr, faucet_id.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    numAssets() {\n        const ret = wasm.fungibleassetdelta_numAssets(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {FungibleAssetDeltaItem[]}\n     */\n    assets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fungibleassetdelta_assets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) FungibleAssetDelta.prototype[Symbol.dispose] = FungibleAssetDelta.prototype.free;\n\nconst FungibleAssetDeltaItemFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleassetdeltaitem_free(ptr >>> 0, 1));\n\nclass FungibleAssetDeltaItem {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAssetDeltaItem.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetDeltaItemFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetDeltaItemFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleassetdeltaitem_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    get faucetId() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    get amount() {\n        const ret = wasm.fungibleasset_amount(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) FungibleAssetDeltaItem.prototype[Symbol.dispose] = FungibleAssetDeltaItem.prototype.free;\n\nconst GetProceduresResultItemFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_getproceduresresultitem_free(ptr >>> 0, 1));\n\nclass GetProceduresResultItem {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GetProceduresResultItem.prototype);\n        obj.__wbg_ptr = ptr;\n        GetProceduresResultItemFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GetProceduresResultItemFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_getproceduresresultitem_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    get digest() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    get isAuth() {\n        const ret = wasm.getproceduresresultitem_isAuth(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) GetProceduresResultItem.prototype[Symbol.dispose] = GetProceduresResultItem.prototype.free;\n\nconst InputNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnote_free(ptr >>> 0, 1));\n\nclass InputNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNote.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnote_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.inputnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Note}\n     */\n    note() {\n        const ret = wasm.inputnote_note(this.__wbg_ptr);\n        return Note.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.inputnote_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInclusionProof | undefined}\n     */\n    proof() {\n        const ret = wasm.inputnote_proof(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteInclusionProof.__wrap(ret);\n    }\n    /**\n     * @returns {NoteLocation | undefined}\n     */\n    location() {\n        const ret = wasm.inputnote_location(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteLocation.__wrap(ret);\n    }\n}\nif (Symbol.dispose) InputNote.prototype[Symbol.dispose] = InputNote.prototype.free;\n\nconst InputNoteRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnoterecord_free(ptr >>> 0, 1));\n\nclass InputNoteRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNoteRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNoteRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNoteRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnoterecord_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.inputnoterecord_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {InputNoteState}\n     */\n    state() {\n        const ret = wasm.inputnoterecord_state(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {NoteDetails}\n     */\n    details() {\n        const ret = wasm.inputnoterecord_details(this.__wbg_ptr);\n        return NoteDetails.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata | undefined}\n     */\n    metadata() {\n        const ret = wasm.inputnoterecord_metadata(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    commitment() {\n        const ret = wasm.inputnoterecord_commitment(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInclusionProof | undefined}\n     */\n    inclusionProof() {\n        const ret = wasm.inputnoterecord_inclusionProof(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteInclusionProof.__wrap(ret);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    consumerTransactionId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_consumerTransactionId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    nullifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_nullifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isAuthenticated() {\n        const ret = wasm.inputnoterecord_isAuthenticated(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isConsumed() {\n        const ret = wasm.inputnoterecord_isConsumed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isProcessing() {\n        const ret = wasm.inputnoterecord_isProcessing(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {InputNote}\n     */\n    toInputNote() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_toInputNote(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return InputNote.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) InputNoteRecord.prototype[Symbol.dispose] = InputNoteRecord.prototype.free;\n\nconst InputNotesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnotes_free(ptr >>> 0, 1));\n\nclass InputNotes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNotes.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNotesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNotesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnotes_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    numNotes() {\n        const ret = wasm.inputnotes_numNotes(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.inputnotes_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {InputNote}\n     */\n    getNote(index) {\n        const ret = wasm.inputnotes_getNote(this.__wbg_ptr, index);\n        return InputNote.__wrap(ret);\n    }\n    /**\n     * @returns {InputNote[]}\n     */\n    notes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnotes_notes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) InputNotes.prototype[Symbol.dispose] = InputNotes.prototype.free;\n\nconst IntoUnderlyingByteSourceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingByteSource {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingByteSourceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingbytesource_free(ptr, 0);\n    }\n    /**\n     * @returns {ReadableStreamType}\n     */\n    get type() {\n        const ret = wasm.intounderlyingbytesource_type(this.__wbg_ptr);\n        return __wbindgen_enum_ReadableStreamType[ret];\n    }\n    /**\n     * @returns {number}\n     */\n    get autoAllocateChunkSize() {\n        const ret = wasm.intounderlyingbytesource_autoAllocateChunkSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {ReadableByteStreamController} controller\n     */\n    start(controller) {\n        wasm.intounderlyingbytesource_start(this.__wbg_ptr, addHeapObject(controller));\n    }\n    /**\n     * @param {ReadableByteStreamController} controller\n     * @returns {Promise<any>}\n     */\n    pull(controller) {\n        const ret = wasm.intounderlyingbytesource_pull(this.__wbg_ptr, addHeapObject(controller));\n        return takeObject(ret);\n    }\n    cancel() {\n        const ptr = this.__destroy_into_raw();\n        wasm.intounderlyingbytesource_cancel(ptr);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingByteSource.prototype[Symbol.dispose] = IntoUnderlyingByteSource.prototype.free;\n\nconst IntoUnderlyingSinkFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsink_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingSink {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingSinkFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingsink_free(ptr, 0);\n    }\n    /**\n     * @param {any} chunk\n     * @returns {Promise<any>}\n     */\n    write(chunk) {\n        const ret = wasm.intounderlyingsink_write(this.__wbg_ptr, addHeapObject(chunk));\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<any>}\n     */\n    close() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.intounderlyingsink_close(ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {any} reason\n     * @returns {Promise<any>}\n     */\n    abort(reason) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.intounderlyingsink_abort(ptr, addHeapObject(reason));\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingSink.prototype[Symbol.dispose] = IntoUnderlyingSink.prototype.free;\n\nconst IntoUnderlyingSourceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsource_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingSource {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingSourceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingsource_free(ptr, 0);\n    }\n    /**\n     * @param {ReadableStreamDefaultController} controller\n     * @returns {Promise<any>}\n     */\n    pull(controller) {\n        const ret = wasm.intounderlyingsource_pull(this.__wbg_ptr, addHeapObject(controller));\n        return takeObject(ret);\n    }\n    cancel() {\n        const ptr = this.__destroy_into_raw();\n        wasm.intounderlyingsource_cancel(ptr);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingSource.prototype[Symbol.dispose] = IntoUnderlyingSource.prototype.free;\n\nconst JsAccountUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsaccountupdate_free(ptr >>> 0, 1));\n/**\n * Represents an update to a single account's state.\n */\nclass JsAccountUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsAccountUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        JsAccountUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsAccountUpdate)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            storageRoot: this.storageRoot,\n            storageSlots: this.storageSlots,\n            storageMapEntries: this.storageMapEntries,\n            assetVaultRoot: this.assetVaultRoot,\n            assets: this.assets,\n            accountId: this.accountId,\n            codeRoot: this.codeRoot,\n            committed: this.committed,\n            nonce: this.nonce,\n            accountCommitment: this.accountCommitment,\n            accountSeed: this.accountSeed,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsAccountUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsaccountupdate_free(ptr, 0);\n    }\n    /**\n     * The merkle root of the account's storage trie.\n     * @returns {string}\n     */\n    get storageRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's storage trie.\n     * @param {string} arg0\n     */\n    set storageRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized storage slot data for this account.\n     * @returns {JsStorageSlot[]}\n     */\n    get storageSlots() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageSlots(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized storage slot data for this account.\n     * @param {JsStorageSlot[]} arg0\n     */\n    set storageSlots(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageSlots(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized storage map entries for this account.\n     * @returns {JsStorageMapEntry[]}\n     */\n    get storageMapEntries() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageMapEntries(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized storage map entries for this account.\n     * @param {JsStorageMapEntry[]} arg0\n     */\n    set storageMapEntries(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageMapEntries(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The merkle root of the account's asset vault.\n     * @returns {string}\n     */\n    get assetVaultRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assetVaultRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's asset vault.\n     * @param {string} arg0\n     */\n    set assetVaultRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assetVaultRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The account's asset vault.\n     * @returns {JsVaultAsset[]}\n     */\n    get assets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The account's asset vault.\n     * @param {JsVaultAsset[]} arg0\n     */\n    set assets(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * ID for this account.\n     * @returns {string}\n     */\n    get accountId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * ID for this account.\n     * @param {string} arg0\n     */\n    set accountId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountId(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The merkle root of the account's executable code.\n     * @returns {string}\n     */\n    get codeRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_codeRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's executable code.\n     * @param {string} arg0\n     */\n    set codeRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_codeRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Whether this account update has been committed.\n     * @returns {boolean}\n     */\n    get committed() {\n        const ret = wasm.__wbg_get_jsaccountupdate_committed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Whether this account update has been committed.\n     * @param {boolean} arg0\n     */\n    set committed(arg0) {\n        wasm.__wbg_set_jsaccountupdate_committed(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The account's transaction nonce as a string.\n     * @returns {string}\n     */\n    get nonce() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_nonce(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The account's transaction nonce as a string.\n     * @param {string} arg0\n     */\n    set nonce(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_nonce(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The cryptographic commitment representing this account's current state.\n     * @returns {string}\n     */\n    get accountCommitment() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountCommitment(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The cryptographic commitment representing this account's current state.\n     * @param {string} arg0\n     */\n    set accountCommitment(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountCommitment(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Optional seed data for the account.\n     * @returns {Uint8Array | undefined}\n     */\n    get accountSeed() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountSeed(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Optional seed data for the account.\n     * @param {Uint8Array | null} [arg0]\n     */\n    set accountSeed(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountSeed(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsAccountUpdate.prototype[Symbol.dispose] = JsAccountUpdate.prototype.free;\n\nconst JsStateSyncUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstatesyncupdate_free(ptr >>> 0, 1));\n/**\n * An object that contains data for a sync update,\n * which will be received by the applyStateSync JS function.\n * under sync.js\n */\nclass JsStateSyncUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStateSyncUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStateSyncUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStateSyncUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstatesyncupdate_free(ptr, 0);\n    }\n    /**\n     * The block number for this update, stored as a string since it will be\n     * persisted in `IndexedDB`.\n     * @returns {string}\n     */\n    get blockNum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The block number for this update, stored as a string since it will be\n     * persisted in `IndexedDB`.\n     * @param {string} arg0\n     */\n    set blockNum(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The new block headers for this state update, serialized into a flattened byte array.\n     * @returns {FlattenedU8Vec}\n     */\n    get flattenedNewBlockHeaders() {\n        const ret = wasm.__wbg_get_jsstatesyncupdate_flattenedNewBlockHeaders(this.__wbg_ptr);\n        return FlattenedU8Vec.__wrap(ret);\n    }\n    /**\n     * The new block headers for this state update, serialized into a flattened byte array.\n     * @param {FlattenedU8Vec} arg0\n     */\n    set flattenedNewBlockHeaders(arg0) {\n        _assertClass(arg0, FlattenedU8Vec);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_jsstatesyncupdate_flattenedNewBlockHeaders(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The block numbers corresponding to each header in `flattened_new_block_headers`.\n     * This vec should have the same length as the number of headers, with each index\n     * representing the block number for the header at that same index.\n     * @returns {string[]}\n     */\n    get newBlockNums() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_newBlockNums(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The block numbers corresponding to each header in `flattened_new_block_headers`.\n     * This vec should have the same length as the number of headers, with each index\n     * representing the block number for the header at that same index.\n     * @param {string[]} arg0\n     */\n    set newBlockNums(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_newBlockNums(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Flattened byte array containing partial blockchain peaks used for merkle tree\n     * verification.\n     * @returns {FlattenedU8Vec}\n     */\n    get flattenedPartialBlockChainPeaks() {\n        const ret = wasm.__wbg_get_jsstatesyncupdate_flattenedPartialBlockChainPeaks(this.__wbg_ptr);\n        return FlattenedU8Vec.__wrap(ret);\n    }\n    /**\n     * Flattened byte array containing partial blockchain peaks used for merkle tree\n     * verification.\n     * @param {FlattenedU8Vec} arg0\n     */\n    set flattenedPartialBlockChainPeaks(arg0) {\n        _assertClass(arg0, FlattenedU8Vec);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_jsstatesyncupdate_flattenedPartialBlockChainPeaks(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * For each block in this update, stores a boolean (as u8) indicating whether\n     * that block contains notes relevant to this client. Index i corresponds to\n     * the ith block, with 1 meaning relevant and 0 meaning not relevant.\n     * @returns {Uint8Array}\n     */\n    get blockHasRelevantNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_blockHasRelevantNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * For each block in this update, stores a boolean (as u8) indicating whether\n     * that block contains notes relevant to this client. Index i corresponds to\n     * the ith block, with 1 meaning relevant and 0 meaning not relevant.\n     * @param {Uint8Array} arg0\n     */\n    set blockHasRelevantNotes(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_blockHasRelevantNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized IDs for new authentication nodes required to verify block headers.\n     * @returns {string[]}\n     */\n    get serializedNodeIds() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedNodeIds(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized IDs for new authentication nodes required to verify block headers.\n     * @param {string[]} arg0\n     */\n    set serializedNodeIds(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedNodeIds(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The actual authentication node data corresponding to the IDs above.\n     * @returns {string[]}\n     */\n    get serializedNodes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedNodes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The actual authentication node data corresponding to the IDs above.\n     * @param {string[]} arg0\n     */\n    set serializedNodes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedNodes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * IDs of note tags that should be removed from the client's local state.\n     * @returns {string[]}\n     */\n    get committedNoteIds() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_committedNoteIds(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * IDs of note tags that should be removed from the client's local state.\n     * @param {string[]} arg0\n     */\n    set committedNoteIds(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_committedNoteIds(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Input notes for this state update in serialized form.\n     * @returns {SerializedInputNoteData[]}\n     */\n    get serializedInputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedInputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Input notes for this state update in serialized form.\n     * @param {SerializedInputNoteData[]} arg0\n     */\n    set serializedInputNotes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedInputNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Output notes created in this state update in serialized form.\n     * @returns {SerializedOutputNoteData[]}\n     */\n    get serializedOutputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedOutputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Output notes created in this state update in serialized form.\n     * @param {SerializedOutputNoteData[]} arg0\n     */\n    set serializedOutputNotes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedOutputNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Account state updates included in this sync.\n     * @returns {JsAccountUpdate[]}\n     */\n    get accountUpdates() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_accountUpdates(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Account state updates included in this sync.\n     * @param {JsAccountUpdate[]} arg0\n     */\n    set accountUpdates(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_accountUpdates(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Transaction data for transactions included in this update.\n     * @returns {SerializedTransactionData[]}\n     */\n    get transactionUpdates() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_transactionUpdates(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Transaction data for transactions included in this update.\n     * @param {SerializedTransactionData[]} arg0\n     */\n    set transactionUpdates(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_transactionUpdates(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsStateSyncUpdate.prototype[Symbol.dispose] = JsStateSyncUpdate.prototype.free;\n\nconst JsStorageMapEntryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstoragemapentry_free(ptr >>> 0, 1));\n/**\n * A JavaScript representation of a storage map entry in an account.\n */\nclass JsStorageMapEntry {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStorageMapEntry.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStorageMapEntryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsStorageMapEntry)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            root: this.root,\n            key: this.key,\n            value: this.value,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStorageMapEntryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstoragemapentry_free(ptr, 0);\n    }\n    /**\n     * The root of the storage map entry.\n     * @returns {string}\n     */\n    get root() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The root of the storage map entry.\n     * @param {string} arg0\n     */\n    set root(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The key of the storage map entry.\n     * @returns {string}\n     */\n    get key() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The key of the storage map entry.\n     * @param {string} arg0\n     */\n    set key(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The value of the storage map entry.\n     * @returns {string}\n     */\n    get value() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The value of the storage map entry.\n     * @param {string} arg0\n     */\n    set value(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsStorageMapEntry.prototype[Symbol.dispose] = JsStorageMapEntry.prototype.free;\n\nconst JsStorageSlotFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstorageslot_free(ptr >>> 0, 1));\n/**\n * A JavaScript representation of a storage slot in an account.\n */\nclass JsStorageSlot {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStorageSlot.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStorageSlotFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsStorageSlot)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            commitment: this.commitment,\n            slotIndex: this.slotIndex,\n            slotValue: this.slotValue,\n            slotType: this.slotType,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStorageSlotFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstorageslot_free(ptr, 0);\n    }\n    /**\n     * Commitment of the whole account storage\n     * @returns {string}\n     */\n    get commitment() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Commitment of the whole account storage\n     * @param {string} arg0\n     */\n    set commitment(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The index of the storage slot.\n     * @returns {number}\n     */\n    get slotIndex() {\n        const ret = wasm.__wbg_get_jsstorageslot_slotIndex(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The index of the storage slot.\n     * @param {number} arg0\n     */\n    set slotIndex(arg0) {\n        wasm.__wbg_set_jsstorageslot_slotIndex(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The value stored in the storage slot.\n     * @returns {string}\n     */\n    get slotValue() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The value stored in the storage slot.\n     * @param {string} arg0\n     */\n    set slotValue(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The type of the storage slot.\n     * @returns {number}\n     */\n    get slotType() {\n        const ret = wasm.__wbg_get_jsstorageslot_slotType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The type of the storage slot.\n     * @param {number} arg0\n     */\n    set slotType(arg0) {\n        wasm.__wbg_set_jsstorageslot_slotType(this.__wbg_ptr, arg0);\n    }\n}\nif (Symbol.dispose) JsStorageSlot.prototype[Symbol.dispose] = JsStorageSlot.prototype.free;\n\nconst JsVaultAssetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsvaultasset_free(ptr >>> 0, 1));\n/**\n * An object that contains a serialized vault asset\n */\nclass JsVaultAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsVaultAsset.prototype);\n        obj.__wbg_ptr = ptr;\n        JsVaultAssetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsVaultAsset)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            root: this.root,\n            vaultKey: this.vaultKey,\n            faucetIdPrefix: this.faucetIdPrefix,\n            asset: this.asset,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsVaultAssetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsvaultasset_free(ptr, 0);\n    }\n    /**\n     * The merkle root of the vault's assets.\n     * @returns {string}\n     */\n    get root() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the vault's assets.\n     * @param {string} arg0\n     */\n    set root(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The vault key associated with the asset.\n     * @returns {string}\n     */\n    get vaultKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The vault key associated with the asset.\n     * @param {string} arg0\n     */\n    set vaultKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Asset's faucet ID prefix.\n     * @returns {string}\n     */\n    get faucetIdPrefix() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Asset's faucet ID prefix.\n     * @param {string} arg0\n     */\n    set faucetIdPrefix(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Word representing the asset.\n     * @returns {string}\n     */\n    get asset() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assetVaultRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Word representing the asset.\n     * @param {string} arg0\n     */\n    set asset(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assetVaultRoot(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsVaultAsset.prototype[Symbol.dispose] = JsVaultAsset.prototype.free;\n\nconst LibraryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_library_free(ptr >>> 0, 1));\n\nclass Library {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Library.prototype);\n        obj.__wbg_ptr = ptr;\n        LibraryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        LibraryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_library_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Library.prototype[Symbol.dispose] = Library.prototype.free;\n\nconst MerklePathFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_merklepath_free(ptr >>> 0, 1));\n\nclass MerklePath {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MerklePath.prototype);\n        obj.__wbg_ptr = ptr;\n        MerklePathFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MerklePathFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merklepath_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    depth() {\n        const ret = wasm.merklepath_depth(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    nodes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.merklepath_nodes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {bigint} index\n     * @param {Word} node\n     * @returns {Word}\n     */\n    computeRoot(index, node) {\n        _assertClass(node, Word);\n        const ret = wasm.merklepath_computeRoot(this.__wbg_ptr, index, node.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {bigint} index\n     * @param {Word} node\n     * @param {Word} root\n     * @returns {boolean}\n     */\n    verify(index, node, root) {\n        _assertClass(node, Word);\n        _assertClass(root, Word);\n        const ret = wasm.merklepath_verify(this.__wbg_ptr, index, node.__wbg_ptr, root.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) MerklePath.prototype[Symbol.dispose] = MerklePath.prototype.free;\n\nconst NoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_note_free(ptr >>> 0, 1));\n\nclass Note {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Note.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_note_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAssets} note_assets\n     * @param {NoteMetadata} note_metadata\n     * @param {NoteRecipient} note_recipient\n     */\n    constructor(note_assets, note_metadata, note_recipient) {\n        _assertClass(note_assets, NoteAssets);\n        _assertClass(note_metadata, NoteMetadata);\n        _assertClass(note_recipient, NoteRecipient);\n        const ret = wasm.note_new(note_assets.__wbg_ptr, note_metadata.__wbg_ptr, note_recipient.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.note_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Note}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.note_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.note_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.note_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.note_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {NoteRecipient}\n     */\n    recipient() {\n        const ret = wasm.note_recipient(this.__wbg_ptr);\n        return NoteRecipient.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.note_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    script() {\n        const ret = wasm.note_script(this.__wbg_ptr);\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {AccountId} target\n     * @param {NoteAssets} assets\n     * @param {NoteType} note_type\n     * @param {Felt} aux\n     * @returns {Note}\n     */\n    static createP2IDNote(sender, target, assets, note_type, aux) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender, AccountId);\n            _assertClass(target, AccountId);\n            _assertClass(assets, NoteAssets);\n            _assertClass(aux, Felt);\n            wasm.note_createP2IDNote(retptr, sender.__wbg_ptr, target.__wbg_ptr, assets.__wbg_ptr, note_type, aux.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {AccountId} target\n     * @param {NoteAssets} assets\n     * @param {number | null | undefined} reclaim_height\n     * @param {number | null | undefined} timelock_height\n     * @param {NoteType} note_type\n     * @param {Felt} aux\n     * @returns {Note}\n     */\n    static createP2IDENote(sender, target, assets, reclaim_height, timelock_height, note_type, aux) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender, AccountId);\n            _assertClass(target, AccountId);\n            _assertClass(assets, NoteAssets);\n            _assertClass(aux, Felt);\n            wasm.note_createP2IDENote(retptr, sender.__wbg_ptr, target.__wbg_ptr, assets.__wbg_ptr, isLikeNone(reclaim_height) ? 0x100000001 : (reclaim_height) >>> 0, isLikeNone(timelock_height) ? 0x100000001 : (timelock_height) >>> 0, note_type, aux.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Note.prototype[Symbol.dispose] = Note.prototype.free;\n\nconst NoteAndArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteandargs_free(ptr >>> 0, 1));\n\nclass NoteAndArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteAndArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteAndArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteAndArgs)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAndArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteandargs_free(ptr, 0);\n    }\n    /**\n     * @param {Note} note\n     * @param {Word | null} [args]\n     */\n    constructor(note, args) {\n        _assertClass(note, Note);\n        var ptr0 = note.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(args)) {\n            _assertClass(args, Word);\n            ptr1 = args.__destroy_into_raw();\n        }\n        const ret = wasm.noteandargs_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAndArgsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteAndArgs.prototype[Symbol.dispose] = NoteAndArgs.prototype.free;\n\nconst NoteAndArgsArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteandargsarray_free(ptr >>> 0, 1));\n\nclass NoteAndArgsArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAndArgsArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteandargsarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAndArgs[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteandargsarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAndArgsArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteAndArgs}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteandargsarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteAndArgs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteAndArgs} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteAndArgs);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noteandargsarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteAndArgs} element\n     */\n    push(element) {\n        _assertClass(element, NoteAndArgs);\n        wasm.noteandargsarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noteandargsarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteAndArgsArray.prototype[Symbol.dispose] = NoteAndArgsArray.prototype.free;\n\nconst NoteAssetsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteassets_free(ptr >>> 0, 1));\n\nclass NoteAssets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteAssets.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteAssetsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAssetsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteassets_free(ptr, 0);\n    }\n    /**\n     * @param {FungibleAsset[] | null} [assets_array]\n     */\n    constructor(assets_array) {\n        var ptr0 = isLikeNone(assets_array) ? 0 : passArrayJsValueToWasm0(assets_array, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteassets_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAssetsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {FungibleAsset} asset\n     */\n    push(asset) {\n        _assertClass(asset, FungibleAsset);\n        wasm.noteassets_push(this.__wbg_ptr, asset.__wbg_ptr);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    fungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteassets_fungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) NoteAssets.prototype[Symbol.dispose] = NoteAssets.prototype.free;\n\nconst NoteConsumabilityFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteconsumability_free(ptr >>> 0, 1));\n\nclass NoteConsumability {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteConsumability.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteConsumabilityFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteConsumability)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteConsumabilityFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteconsumability_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.noteconsumability_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    consumableAfterBlock() {\n        const ret = wasm.noteconsumability_consumableAfterBlock(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\nif (Symbol.dispose) NoteConsumability.prototype[Symbol.dispose] = NoteConsumability.prototype.free;\n\nconst NoteDetailsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetails_free(ptr >>> 0, 1));\n\nclass NoteDetails {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteDetails.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteDetailsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetails_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAssets} note_assets\n     * @param {NoteRecipient} note_recipient\n     */\n    constructor(note_assets, note_recipient) {\n        _assertClass(note_assets, NoteAssets);\n        _assertClass(note_recipient, NoteRecipient);\n        const ret = wasm.notedetails_new(note_assets.__wbg_ptr, note_recipient.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.notedetails_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.notedetails_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteRecipient}\n     */\n    recipient() {\n        const ret = wasm.notedetails_recipient(this.__wbg_ptr);\n        return NoteRecipient.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteDetails.prototype[Symbol.dispose] = NoteDetails.prototype.free;\n\nconst NoteDetailsAndTagFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetailsandtag_free(ptr >>> 0, 1));\n\nclass NoteDetailsAndTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteDetailsAndTag.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteDetailsAndTagFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteDetailsAndTag)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsAndTagFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetailsandtag_free(ptr, 0);\n    }\n    /**\n     * @param {NoteDetails} note_details\n     * @param {NoteTag} tag\n     */\n    constructor(note_details, tag) {\n        _assertClass(note_details, NoteDetails);\n        var ptr0 = note_details.__destroy_into_raw();\n        _assertClass(tag, NoteTag);\n        var ptr1 = tag.__destroy_into_raw();\n        const ret = wasm.notedetailsandtag_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsAndTagFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {NoteDetails}\n     */\n    get noteDetails() {\n        const ret = wasm.notedetailsandtag_noteDetails(this.__wbg_ptr);\n        return NoteDetails.__wrap(ret);\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    get tag() {\n        const ret = wasm.notedetailsandtag_tag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteDetailsAndTag.prototype[Symbol.dispose] = NoteDetailsAndTag.prototype.free;\n\nconst NoteDetailsAndTagArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetailsandtagarray_free(ptr >>> 0, 1));\n\nclass NoteDetailsAndTagArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsAndTagArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetailsandtagarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteDetailsAndTag[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.notedetailsandtagarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsAndTagArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteDetailsAndTag}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notedetailsandtagarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteDetailsAndTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteDetailsAndTag} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteDetailsAndTag);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.notedetailsandtagarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteDetailsAndTag} element\n     */\n    push(element) {\n        _assertClass(element, NoteDetailsAndTag);\n        wasm.notedetailsandtagarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.notedetailsandtagarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteDetailsAndTagArray.prototype[Symbol.dispose] = NoteDetailsAndTagArray.prototype.free;\n\nconst NoteExecutionHintFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteexecutionhint_free(ptr >>> 0, 1));\n\nclass NoteExecutionHint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteExecutionHint.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteExecutionHintFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteExecutionHintFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteexecutionhint_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteExecutionHint}\n     */\n    static none() {\n        const ret = wasm.noteexecutionhint_none();\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @returns {NoteExecutionHint}\n     */\n    static always() {\n        const ret = wasm.noteexecutionhint_always();\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {NoteExecutionHint}\n     */\n    static afterBlock(block_num) {\n        const ret = wasm.noteexecutionhint_afterBlock(block_num);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} epoch_len\n     * @param {number} slot_len\n     * @param {number} slot_offset\n     * @returns {NoteExecutionHint}\n     */\n    static onBlockSlot(epoch_len, slot_len, slot_offset) {\n        const ret = wasm.noteexecutionhint_onBlockSlot(epoch_len, slot_len, slot_offset);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} payload\n     * @returns {NoteExecutionHint}\n     */\n    static fromParts(tag, payload) {\n        const ret = wasm.noteexecutionhint_fromParts(tag, payload);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {boolean}\n     */\n    canBeConsumed(block_num) {\n        const ret = wasm.noteexecutionhint_canBeConsumed(this.__wbg_ptr, block_num);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) NoteExecutionHint.prototype[Symbol.dispose] = NoteExecutionHint.prototype.free;\n\nconst NoteExecutionModeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteexecutionmode_free(ptr >>> 0, 1));\n\nclass NoteExecutionMode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteExecutionMode.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteExecutionModeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteExecutionModeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteexecutionmode_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    static newLocal() {\n        const ret = wasm.accountstoragemode_network();\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    static newNetwork() {\n        const ret = wasm.accountstoragemode_public();\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteexecutionmode_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) NoteExecutionMode.prototype[Symbol.dispose] = NoteExecutionMode.prototype.free;\n\nconst NoteFileFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notefile_free(ptr >>> 0, 1));\n/**\n * A serialized representation of a note.\n */\nclass NoteFile {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteFile.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteFileFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFileFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notefile_free(ptr, 0);\n    }\n    /**\n     * Returns this `NoteFile`'s types.\n     * @returns {string}\n     */\n    noteType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notefile_noteType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Turn a notefile into its byte representation.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notefile_serialize(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a valid byte representation of a `NoteFile`,\n     * return it as a struct.\n     * @param {Uint8Array} bytes\n     * @returns {NoteFile}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.notefile_deserialize(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteFile.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {InputNote} note\n     * @returns {NoteFile}\n     */\n    static fromInputNote(note) {\n        _assertClass(note, InputNote);\n        const ret = wasm.notefile_fromInputNote(note.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {OutputNote} note\n     * @returns {NoteFile}\n     */\n    static fromOutputNote(note) {\n        _assertClass(note, OutputNote);\n        const ret = wasm.notefile_fromOutputNote(note.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {NoteDetails} note_details\n     * @returns {NoteFile}\n     */\n    static fromNoteDetails(note_details) {\n        _assertClass(note_details, NoteDetails);\n        const ret = wasm.notefile_fromNoteDetails(note_details.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {NoteId} note_details\n     * @returns {NoteFile}\n     */\n    static fromNoteId(note_details) {\n        _assertClass(note_details, NoteId);\n        const ret = wasm.notefile_fromNoteId(note_details.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteFile.prototype[Symbol.dispose] = NoteFile.prototype.free;\n\nconst NoteFilterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notefilter_free(ptr >>> 0, 1));\n\nclass NoteFilter {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFilterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notefilter_free(ptr, 0);\n    }\n    /**\n     * @param {NoteFilterTypes} note_type\n     * @param {NoteId[] | null} [note_ids]\n     */\n    constructor(note_type, note_ids) {\n        var ptr0 = isLikeNone(note_ids) ? 0 : passArrayJsValueToWasm0(note_ids, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.notefilter_new(note_type, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteFilterFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteFilter.prototype[Symbol.dispose] = NoteFilter.prototype.free;\n\nconst NoteHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteheader_free(ptr >>> 0, 1));\n\nclass NoteHeader {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteheader_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.noteheader_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.noteheader_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.noteheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteHeader.prototype[Symbol.dispose] = NoteHeader.prototype.free;\n\nconst NoteIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteid_free(ptr >>> 0, 1));\n\nclass NoteId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteId.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteid_free(ptr, 0);\n    }\n    /**\n     * @param {Word} recipient_digest\n     * @param {Word} asset_commitment_digest\n     */\n    constructor(recipient_digest, asset_commitment_digest) {\n        _assertClass(recipient_digest, Word);\n        _assertClass(asset_commitment_digest, Word);\n        const ret = wasm.noteid_new(recipient_digest.__wbg_ptr, asset_commitment_digest.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {string} hex\n     * @returns {NoteId}\n     */\n    static fromHex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.noteid_fromHex(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteid_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) NoteId.prototype[Symbol.dispose] = NoteId.prototype.free;\n\nconst NoteIdAndArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteidandargs_free(ptr >>> 0, 1));\n\nclass NoteIdAndArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteIdAndArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteIdAndArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteIdAndArgs)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdAndArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteidandargs_free(ptr, 0);\n    }\n    /**\n     * @param {NoteId} note_id\n     * @param {Word | null} [args]\n     */\n    constructor(note_id, args) {\n        _assertClass(note_id, NoteId);\n        var ptr0 = note_id.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(args)) {\n            _assertClass(args, Word);\n            ptr1 = args.__destroy_into_raw();\n        }\n        const ret = wasm.noteidandargs_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdAndArgsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteIdAndArgs.prototype[Symbol.dispose] = NoteIdAndArgs.prototype.free;\n\nconst NoteIdAndArgsArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteidandargsarray_free(ptr >>> 0, 1));\n\nclass NoteIdAndArgsArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdAndArgsArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteidandargsarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteIdAndArgs[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteidandargsarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdAndArgsArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteIdAndArgs}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteidandargsarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteIdAndArgs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteIdAndArgs} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteIdAndArgs);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noteidandargsarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteIdAndArgs} element\n     */\n    push(element) {\n        _assertClass(element, NoteIdAndArgs);\n        wasm.noteidandargsarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noteidandargsarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteIdAndArgsArray.prototype[Symbol.dispose] = NoteIdAndArgsArray.prototype.free;\n\nconst NoteInclusionProofFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteinclusionproof_free(ptr >>> 0, 1));\n\nclass NoteInclusionProof {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteInclusionProof.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteInclusionProofFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteInclusionProofFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteinclusionproof_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteLocation}\n     */\n    location() {\n        const ret = wasm.noteinclusionproof_location(this.__wbg_ptr);\n        return NoteLocation.__wrap(ret);\n    }\n    /**\n     * @returns {MerklePath}\n     */\n    notePath() {\n        const ret = wasm.noteinclusionproof_notePath(this.__wbg_ptr);\n        return MerklePath.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteInclusionProof.prototype[Symbol.dispose] = NoteInclusionProof.prototype.free;\n\nconst NoteInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteinputs_free(ptr >>> 0, 1));\n\nclass NoteInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteinputs_free(ptr, 0);\n    }\n    /**\n     * @param {FeltArray} felt_array\n     */\n    constructor(felt_array) {\n        _assertClass(felt_array, FeltArray);\n        const ret = wasm.noteinputs_new(felt_array.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteInputsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    values() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteinputs_values(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) NoteInputs.prototype[Symbol.dispose] = NoteInputs.prototype.free;\n\nconst NoteLocationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notelocation_free(ptr >>> 0, 1));\n\nclass NoteLocation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteLocation.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteLocationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteLocationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notelocation_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.notelocation_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    nodeIndexInBlock() {\n        const ret = wasm.notelocation_nodeIndexInBlock(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) NoteLocation.prototype[Symbol.dispose] = NoteLocation.prototype.free;\n\nconst NoteMetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notemetadata_free(ptr >>> 0, 1));\n\nclass NoteMetadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteMetadata.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteMetadataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteMetadataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notemetadata_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {NoteType} note_type\n     * @param {NoteTag} note_tag\n     * @param {NoteExecutionHint} note_execution_hint\n     * @param {Felt | null} [aux]\n     */\n    constructor(sender, note_type, note_tag, note_execution_hint, aux) {\n        _assertClass(sender, AccountId);\n        _assertClass(note_tag, NoteTag);\n        _assertClass(note_execution_hint, NoteExecutionHint);\n        let ptr0 = 0;\n        if (!isLikeNone(aux)) {\n            _assertClass(aux, Felt);\n            ptr0 = aux.__destroy_into_raw();\n        }\n        const ret = wasm.notemetadata_new(sender.__wbg_ptr, note_type, note_tag.__wbg_ptr, note_execution_hint.__wbg_ptr, ptr0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteMetadataFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {AccountId}\n     */\n    sender() {\n        const ret = wasm.notemetadata_sender(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    tag() {\n        const ret = wasm.notedetailsandtag_tag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @returns {NoteType}\n     */\n    noteType() {\n        const ret = wasm.notemetadata_noteType(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) NoteMetadata.prototype[Symbol.dispose] = NoteMetadata.prototype.free;\n\nconst NoteRecipientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noterecipient_free(ptr >>> 0, 1));\n\nclass NoteRecipient {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteRecipient.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteRecipientFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteRecipient)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteRecipientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noterecipient_free(ptr, 0);\n    }\n    /**\n     * @param {Word} serial_num\n     * @param {NoteScript} note_script\n     * @param {NoteInputs} inputs\n     */\n    constructor(serial_num, note_script, inputs) {\n        _assertClass(serial_num, Word);\n        _assertClass(note_script, NoteScript);\n        _assertClass(inputs, NoteInputs);\n        const ret = wasm.noterecipient_new(serial_num.__wbg_ptr, note_script.__wbg_ptr, inputs.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteRecipientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Word}\n     */\n    digest() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    serialNum() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    script() {\n        const ret = wasm.noterecipient_script(this.__wbg_ptr);\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInputs}\n     */\n    inputs() {\n        const ret = wasm.noterecipient_inputs(this.__wbg_ptr);\n        return NoteInputs.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteRecipient.prototype[Symbol.dispose] = NoteRecipient.prototype.free;\n\nconst NoteRecipientArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noterecipientarray_free(ptr >>> 0, 1));\n\nclass NoteRecipientArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteRecipientArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noterecipientarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteRecipient[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noterecipientarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteRecipientArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteRecipient}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noterecipientarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteRecipient.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteRecipient} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteRecipient);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noterecipientarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteRecipient} element\n     */\n    push(element) {\n        _assertClass(element, NoteRecipient);\n        wasm.noterecipientarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noterecipientarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteRecipientArray.prototype[Symbol.dispose] = NoteRecipientArray.prototype.free;\n\nconst NoteScriptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notescript_free(ptr >>> 0, 1));\n\nclass NoteScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteScript.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteScriptFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteScriptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notescript_free(ptr, 0);\n    }\n    /**\n     * Print the MAST source for this script.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notescript_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.notescript_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {NoteScript}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notescript_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static p2id() {\n        const ret = wasm.notescript_p2id();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static p2ide() {\n        const ret = wasm.notescript_p2ide();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static swap() {\n        const ret = wasm.notescript_swap();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.notescript_root(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteScript.prototype[Symbol.dispose] = NoteScript.prototype.free;\n\nconst NoteTagFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notetag_free(ptr >>> 0, 1));\n\nclass NoteTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteTag.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteTagFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteTagFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notetag_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {NoteTag}\n     */\n    static fromAccountId(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.notetag_fromAccountId(account_id.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {number} use_case_id\n     * @param {number} payload\n     * @param {NoteExecutionMode} execution\n     * @returns {NoteTag}\n     */\n    static forPublicUseCase(use_case_id, payload, execution) {\n        _assertClass(execution, NoteExecutionMode);\n        const ret = wasm.notetag_forPublicUseCase(use_case_id, payload, execution.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {number} use_case_id\n     * @param {number} payload\n     * @returns {NoteTag}\n     */\n    static forLocalUseCase(use_case_id, payload) {\n        const ret = wasm.notetag_forLocalUseCase(use_case_id, payload);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isSingleTarget() {\n        const ret = wasm.notetag_isSingleTarget(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    executionMode() {\n        const ret = wasm.notetag_executionMode(this.__wbg_ptr);\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    asU32() {\n        const ret = wasm.notetag_asU32(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteTag.prototype[Symbol.dispose] = NoteTag.prototype.free;\n\nconst OutputNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnote_free(ptr >>> 0, 1));\n\nclass OutputNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputNote.prototype);\n        obj.__wbg_ptr = ptr;\n        OutputNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof OutputNote)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnote_free(ptr, 0);\n    }\n    /**\n     * @param {Note} note\n     * @returns {OutputNote}\n     */\n    static full(note) {\n        _assertClass(note, Note);\n        const ret = wasm.outputnote_full(note.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @param {PartialNote} partial_note\n     * @returns {OutputNote}\n     */\n    static partial(partial_note) {\n        _assertClass(partial_note, PartialNote);\n        const ret = wasm.outputnote_partial(partial_note.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @param {NoteHeader} note_header\n     * @returns {OutputNote}\n     */\n    static header(note_header) {\n        _assertClass(note_header, NoteHeader);\n        const ret = wasm.outputnote_header(note_header.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets | undefined}\n     */\n    assets() {\n        const ret = wasm.outputnote_assets(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.outputnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    recipientDigest() {\n        const ret = wasm.outputnote_recipientDigest(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.outputnote_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNote}\n     */\n    shrink() {\n        const ret = wasm.outputnote_shrink(this.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {Note | undefined}\n     */\n    intoFull() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.outputnote_intoFull(ptr);\n        return ret === 0 ? undefined : Note.__wrap(ret);\n    }\n}\nif (Symbol.dispose) OutputNote.prototype[Symbol.dispose] = OutputNote.prototype.free;\n\nconst OutputNoteArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotearray_free(ptr >>> 0, 1));\n\nclass OutputNoteArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNoteArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotearray_free(ptr, 0);\n    }\n    /**\n     * @param {OutputNote[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.outputnotearray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        OutputNoteArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {OutputNote}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotearray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNote.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {OutputNote} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, OutputNote);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.outputnotearray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {OutputNote} element\n     */\n    push(element) {\n        _assertClass(element, OutputNote);\n        wasm.outputnotearray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotearray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) OutputNoteArray.prototype[Symbol.dispose] = OutputNoteArray.prototype.free;\n\nconst OutputNotesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotes_free(ptr >>> 0, 1));\n\nclass OutputNotes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputNotes.prototype);\n        obj.__wbg_ptr = ptr;\n        OutputNotesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof OutputNotes)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNotesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotes_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    numNotes() {\n        const ret = wasm.outputnotes_numNotes(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.outputnotes_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {OutputNote}\n     */\n    getNote(index) {\n        const ret = wasm.outputnotes_getNote(this.__wbg_ptr, index);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNote[]}\n     */\n    notes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotes_notes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) OutputNotes.prototype[Symbol.dispose] = OutputNotes.prototype.free;\n\nconst OutputNotesArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotesarray_free(ptr >>> 0, 1));\n\nclass OutputNotesArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNotesArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotesarray_free(ptr, 0);\n    }\n    /**\n     * @param {OutputNotes[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.outputnotesarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        OutputNotesArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {OutputNotes}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotesarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {OutputNotes} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, OutputNotes);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.outputnotesarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {OutputNotes} element\n     */\n    push(element) {\n        _assertClass(element, OutputNotes);\n        wasm.outputnotesarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotesarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) OutputNotesArray.prototype[Symbol.dispose] = OutputNotesArray.prototype.free;\n\nconst PackageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_package_free(ptr >>> 0, 1));\n\nclass Package {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Package.prototype);\n        obj.__wbg_ptr = ptr;\n        PackageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PackageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_package_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.package_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Package}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.package_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Package.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) Package.prototype[Symbol.dispose] = Package.prototype.free;\n\nconst PartialNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_partialnote_free(ptr >>> 0, 1));\n\nclass PartialNote {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PartialNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_partialnote_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.partialnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.note_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    recipientDigest() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.partialnote_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n}\nif (Symbol.dispose) PartialNote.prototype[Symbol.dispose] = PartialNote.prototype.free;\n\nconst ProvenTransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_proventransaction_free(ptr >>> 0, 1));\n/**\n * WASM wrapper around the native [`ProvenTransaction`].\n */\nclass ProvenTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvenTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n        ProvenTransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProvenTransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proventransaction_free(ptr, 0);\n    }\n    /**\n     * Serializes the proven transaction into bytes.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.proventransaction_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a proven transaction from bytes.\n     * @param {Uint8Array} bytes\n     * @returns {ProvenTransaction}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proventransaction_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvenTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Returns the transaction ID.\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.proventransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * Returns the account ID the transaction was executed against.\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.proventransaction_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * Returns the reference block number used during execution.\n     * @returns {number}\n     */\n    refBlockNumber() {\n        const ret = wasm.proventransaction_refBlockNumber(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Returns the block number at which the transaction expires.\n     * @returns {number}\n     */\n    expirationBlockNumber() {\n        const ret = wasm.proventransaction_expirationBlockNumber(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Returns notes created by this transaction.\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.proventransaction_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * Returns the commitment of the reference block.\n     * @returns {Word}\n     */\n    refBlockCommitment() {\n        const ret = wasm.proventransaction_refBlockCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * Returns the nullifiers of the consumed input notes.\n     * @returns {Word[]}\n     */\n    nullifiers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proventransaction_nullifiers(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ProvenTransaction.prototype[Symbol.dispose] = ProvenTransaction.prototype.free;\n\nconst PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0, 1));\n\nclass PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PublicKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.publickey_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PublicKey}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Word} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        _assertClass(message, Word);\n        _assertClass(signature, Signature);\n        const ret = wasm.publickey_verify(this.__wbg_ptr, message.__wbg_ptr, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    toCommitment() {\n        const ret = wasm.publickey_toCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {Word} message\n     * @param {Signature} signature\n     * @returns {PublicKey}\n     */\n    static recoverFrom(message, signature) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(message, Word);\n            _assertClass(signature, Signature);\n            wasm.publickey_recoverFrom(retptr, message.__wbg_ptr, signature.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {SigningInputs} signing_inputs\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verifyData(signing_inputs, signature) {\n        _assertClass(signing_inputs, SigningInputs);\n        _assertClass(signature, Signature);\n        const ret = wasm.publickey_verifyData(this.__wbg_ptr, signing_inputs.__wbg_ptr, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) PublicKey.prototype[Symbol.dispose] = PublicKey.prototype.free;\n\nconst RpcClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rpcclient_free(ptr >>> 0, 1));\n/**\n * RPC Client for interacting with Miden nodes directly.\n */\nclass RpcClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RpcClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rpcclient_free(ptr, 0);\n    }\n    /**\n     * Creates a new RPC client instance.\n     *\n     * @param endpoint - Endpoint to connect to.\n     * @param {Endpoint} endpoint\n     */\n    constructor(endpoint) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(endpoint, Endpoint);\n            var ptr0 = endpoint.__destroy_into_raw();\n            wasm.rpcclient_new(retptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            RpcClientFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Fetches notes by their IDs from the connected Miden node.\n     *\n     * @param note_ids - Array of [`NoteId`] objects to fetch\n     * @returns Promise that resolves to  different data depending on the note type:\n     * - Private notes: Returns only `note_id` and `metadata`. The `input_note` field will be\n     *   `null`.\n     * - Public notes: Returns the full `input_note` with inclusion proof, alongside metadata and\n     *   ID.\n     * @param {NoteId[]} note_ids\n     * @returns {Promise<FetchedNote[]>}\n     */\n    getNotesById(note_ids) {\n        const ptr0 = passArrayJsValueToWasm0(note_ids, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rpcclient_getNotesById(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Fetches a note script by its root hash from the connected Miden node.\n     *\n     * @param `script_root` The root hash of the note script to fetch\n     * @returns Promise that resolves to the `NoteScript`\n     * @param {Word} script_root\n     * @returns {Promise<NoteScript>}\n     */\n    getNoteScriptByRoot(script_root) {\n        _assertClass(script_root, Word);\n        var ptr0 = script_root.__destroy_into_raw();\n        const ret = wasm.rpcclient_getNoteScriptByRoot(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) RpcClient.prototype[Symbol.dispose] = RpcClient.prototype.free;\n\nconst Rpo256Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rpo256_free(ptr >>> 0, 1));\n\nclass Rpo256 {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Rpo256Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rpo256_free(ptr, 0);\n    }\n    /**\n     * @param {FeltArray} felt_array\n     * @returns {Word}\n     */\n    static hashElements(felt_array) {\n        _assertClass(felt_array, FeltArray);\n        const ret = wasm.rpo256_hashElements(felt_array.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) Rpo256.prototype[Symbol.dispose] = Rpo256.prototype.free;\n\nconst ScriptBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_scriptbuilder_free(ptr >>> 0, 1));\n\nclass ScriptBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        ScriptBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ScriptBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptbuilder_free(ptr, 0);\n    }\n    /**\n     * Given a module path (something like `my_lib::module`) and source code, this will\n     * statically link it for use with scripts to be built with this builder.\n     * @param {string} module_path\n     * @param {string} module_code\n     */\n    linkModule(module_path, module_code) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(module_path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(module_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_linkModule(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Statically links the given library.\n     *\n     * Static linking means the library code is copied into the script code.\n     * Use this for most libraries that are not available on-chain.\n     *\n     * Receives as argument the library to link.\n     * @param {Library} library\n     */\n    linkStaticLibrary(library) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(library, Library);\n            wasm.scriptbuilder_linkStaticLibrary(retptr, this.__wbg_ptr, library.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * This is useful to dynamically link the [`Library`] of a foreign account\n     * that is invoked using foreign procedure invocation (FPI). Its code is available\n     * on-chain and so it does not have to be copied into the script code.\n     *\n     * For all other use cases not involving FPI, link the library statically.\n     * Receives as argument the library to be linked.\n     * @param {Library} library\n     */\n    linkDynamicLibrary(library) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(library, Library);\n            wasm.scriptbuilder_linkDynamicLibrary(retptr, this.__wbg_ptr, library.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Transaction Script's source code, compiles it with the available\n     * modules under this builder. Returns the compiled script.\n     * @param {string} tx_script\n     * @returns {TransactionScript}\n     */\n    compileTxScript(tx_script) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(tx_script, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_compileTxScript(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Note Script's source code, compiles it with the available\n     * modules under this builder. Returns the compiled script.\n     * @param {string} program\n     * @returns {NoteScript}\n     */\n    compileNoteScript(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_compileNoteScript(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Library Path, and a source code, turn it into a Library.\n     * E.g. A path library can be `miden::my_contract`. When turned into a library,\n     * this can be used from another script with an import statement, following the\n     * previous example: `use.miden::my_contract'.\n     * @param {string} library_path\n     * @param {string} source_code\n     * @returns {Library}\n     */\n    buildLibrary(library_path, source_code) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(library_path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(source_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_buildLibrary(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Library.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ScriptBuilder.prototype[Symbol.dispose] = ScriptBuilder.prototype.free;\n\nconst SecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_secretkey_free(ptr >>> 0, 1));\n\nclass SecretKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SecretKey.prototype);\n        obj.__wbg_ptr = ptr;\n        SecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SecretKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array | null} [seed]\n     * @returns {SecretKey}\n     */\n    static rpoFalconWithRNG(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_rpoFalconWithRNG(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [seed]\n     * @returns {SecretKey}\n     */\n    static ecdsaWithRNG(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_ecdsaWithRNG(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {PublicKey}\n     */\n    publicKey() {\n        const ret = wasm.secretkey_publicKey(this.__wbg_ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n     * @param {Word} message\n     * @returns {Signature}\n     */\n    sign(message) {\n        _assertClass(message, Word);\n        const ret = wasm.secretkey_sign(this.__wbg_ptr, message.__wbg_ptr);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * @param {SigningInputs} signing_inputs\n     * @returns {Signature}\n     */\n    signData(signing_inputs) {\n        _assertClass(signing_inputs, SigningInputs);\n        const ret = wasm.secretkey_signData(this.__wbg_ptr, signing_inputs.__wbg_ptr);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.secretkey_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SecretKey}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SecretKey.prototype[Symbol.dispose] = SecretKey.prototype.free;\n\nconst SerializedInputNoteDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedinputnotedata_free(ptr >>> 0, 1));\n\nclass SerializedInputNoteData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedInputNoteData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedInputNoteDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedInputNoteData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedInputNoteDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedinputnotedata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteAssets(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get serialNumber() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_serialNumber(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set serialNumber(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_serialNumber(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get inputs() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set inputs(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteScriptRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteScriptRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteScriptRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteScriptRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteScript() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteScript(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteScript(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteScript(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get nullifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_codeRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set nullifier(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_codeRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get stateDiscriminant() {\n        const ret = wasm.__wbg_get_serializedinputnotedata_stateDiscriminant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set stateDiscriminant(arg0) {\n        wasm.__wbg_set_serializedinputnotedata_stateDiscriminant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set state(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_state(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get createdAt() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountCommitment(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set createdAt(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountCommitment(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedInputNoteData.prototype[Symbol.dispose] = SerializedInputNoteData.prototype.free;\n\nconst SerializedOutputNoteDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedoutputnotedata_free(ptr >>> 0, 1));\n\nclass SerializedOutputNoteData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedOutputNoteData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedOutputNoteDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedOutputNoteData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedOutputNoteDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedoutputnotedata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteAssets(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get recipientDigest() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set recipientDigest(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get metadata() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set metadata(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    get nullifier() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedoutputnotedata_nullifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string | null} [arg0]\n     */\n    set nullifier(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedoutputnotedata_nullifier(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get expectedHeight() {\n        const ret = wasm.__wbg_get_serializedoutputnotedata_expectedHeight(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set expectedHeight(arg0) {\n        wasm.__wbg_set_serializedoutputnotedata_expectedHeight(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get stateDiscriminant() {\n        const ret = wasm.__wbg_get_serializedoutputnotedata_stateDiscriminant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set stateDiscriminant(arg0) {\n        wasm.__wbg_set_serializedoutputnotedata_stateDiscriminant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedoutputnotedata_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set state(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedoutputnotedata_state(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedOutputNoteData.prototype[Symbol.dispose] = SerializedOutputNoteData.prototype.free;\n\nconst SerializedTransactionDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedtransactiondata_free(ptr >>> 0, 1));\n\nclass SerializedTransactionData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedTransactionData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedTransactionDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedTransactionData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedTransactionDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedtransactiondata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set id(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get details() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set details(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    get scriptRoot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedtransactiondata_scriptRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [arg0]\n     */\n    set scriptRoot(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedtransactiondata_scriptRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    get txScript() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedtransactiondata_txScript(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [arg0]\n     */\n    set txScript(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedtransactiondata_txScript(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get blockNum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set blockNum(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get statusVariant() {\n        const ret = wasm.__wbg_get_serializedtransactiondata_statusVariant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set statusVariant(arg0) {\n        wasm.__wbg_set_serializedtransactiondata_statusVariant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get status() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set status(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedTransactionData.prototype[Symbol.dispose] = SerializedTransactionData.prototype.free;\n\nconst SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr >>> 0, 1));\n\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.signature_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Signature}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Word} message\n     * @returns {Felt[]}\n     */\n    toPreparedSignature(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(message, Word);\n            var ptr0 = message.__destroy_into_raw();\n            wasm.signature_toPreparedSignature(retptr, this.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v2 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Signature.prototype[Symbol.dispose] = Signature.prototype.free;\n\nconst SigningInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signinginputs_free(ptr >>> 0, 1));\n\nclass SigningInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SigningInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        SigningInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SigningInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signinginputs_free(ptr, 0);\n    }\n    /**\n     * @param {TransactionSummary} summary\n     * @returns {SigningInputs}\n     */\n    static newTransactionSummary(summary) {\n        _assertClass(summary, TransactionSummary);\n        var ptr0 = summary.__destroy_into_raw();\n        const ret = wasm.signinginputs_newTransactionSummary(ptr0);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @param {Felt[]} felts\n     * @returns {SigningInputs}\n     */\n    static newArbitrary(felts) {\n        const ptr0 = passArrayJsValueToWasm0(felts, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signinginputs_newArbitrary(ptr0, len0);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @param {Word} word\n     * @returns {SigningInputs}\n     */\n    static newBlind(word) {\n        _assertClass(word, Word);\n        const ret = wasm.signinginputs_newBlind(word.__wbg_ptr);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionSummary}\n     */\n    transactionSummaryPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_transactionSummaryPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    arbitraryPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_arbitraryPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FeltArray.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    blindPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_blindPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {SigningInputsType}\n     */\n    get variantType() {\n        const ret = wasm.signinginputs_variantType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word}\n     */\n    toCommitment() {\n        const ret = wasm.signinginputs_toCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    toElements() {\n        const ret = wasm.signinginputs_toElements(this.__wbg_ptr);\n        return FeltArray.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.signinginputs_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SigningInputs}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SigningInputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SigningInputs.prototype[Symbol.dispose] = SigningInputs.prototype.free;\n\nconst SlotAndKeysFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_slotandkeys_free(ptr >>> 0, 1));\n\nclass SlotAndKeys {\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SlotAndKeys)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SlotAndKeysFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_slotandkeys_free(ptr, 0);\n    }\n    /**\n     * @param {number} storage_slot_index\n     * @param {Word[]} storage_map_keys\n     */\n    constructor(storage_slot_index, storage_map_keys) {\n        const ptr0 = passArrayJsValueToWasm0(storage_map_keys, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.slotandkeys_new(storage_slot_index, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        SlotAndKeysFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    storage_slot_index() {\n        const ret = wasm.slotandkeys_storage_slot_index(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    storage_map_keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.slotandkeys_storage_map_keys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) SlotAndKeys.prototype[Symbol.dispose] = SlotAndKeys.prototype.free;\n\nconst StorageMapFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storagemap_free(ptr >>> 0, 1));\n\nclass StorageMap {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageMapFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storagemap_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.storagemap_new();\n        this.__wbg_ptr = ret >>> 0;\n        StorageMapFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {Word} key\n     * @param {Word} value\n     * @returns {Word}\n     */\n    insert(key, value) {\n        _assertClass(key, Word);\n        _assertClass(value, Word);\n        const ret = wasm.storagemap_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) StorageMap.prototype[Symbol.dispose] = StorageMap.prototype.free;\n\nconst StorageSlotFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storageslot_free(ptr >>> 0, 1));\n\nclass StorageSlot {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StorageSlot.prototype);\n        obj.__wbg_ptr = ptr;\n        StorageSlotFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof StorageSlot)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageSlotFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storageslot_free(ptr, 0);\n    }\n    /**\n     * @param {Word} value\n     * @returns {StorageSlot}\n     */\n    static fromValue(value) {\n        _assertClass(value, Word);\n        const ret = wasm.storageslot_fromValue(value.__wbg_ptr);\n        return StorageSlot.__wrap(ret);\n    }\n    /**\n     * @returns {StorageSlot}\n     */\n    static emptyValue() {\n        const ret = wasm.storageslot_emptyValue();\n        return StorageSlot.__wrap(ret);\n    }\n    /**\n     * @param {StorageMap} storage_map\n     * @returns {StorageSlot}\n     */\n    static map(storage_map) {\n        _assertClass(storage_map, StorageMap);\n        const ret = wasm.storageslot_map(storage_map.__wbg_ptr);\n        return StorageSlot.__wrap(ret);\n    }\n}\nif (Symbol.dispose) StorageSlot.prototype[Symbol.dispose] = StorageSlot.prototype.free;\n\nconst StorageSlotArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storageslotarray_free(ptr >>> 0, 1));\n\nclass StorageSlotArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageSlotArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storageslotarray_free(ptr, 0);\n    }\n    /**\n     * @param {StorageSlot[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.storageslotarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        StorageSlotArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {StorageSlot}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.storageslotarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StorageSlot.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {StorageSlot} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, StorageSlot);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.storageslotarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {StorageSlot} element\n     */\n    push(element) {\n        _assertClass(element, StorageSlot);\n        wasm.storageslotarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.storageslotarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) StorageSlotArray.prototype[Symbol.dispose] = StorageSlotArray.prototype.free;\n\nconst SyncSummaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_syncsummary_free(ptr >>> 0, 1));\n\nclass SyncSummary {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SyncSummary.prototype);\n        obj.__wbg_ptr = ptr;\n        SyncSummaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SyncSummaryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncsummary_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.syncsummary_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {NoteId[]}\n     */\n    committedNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_committedNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteId[]}\n     */\n    consumedNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_consumedNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountId[]}\n     */\n    updatedAccounts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_updatedAccounts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {TransactionId[]}\n     */\n    committedTransactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_committedTransactions(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.syncsummary_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SyncSummary}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SyncSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SyncSummary.prototype[Symbol.dispose] = SyncSummary.prototype.free;\n\nconst TestUtilsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_testutils_free(ptr >>> 0, 1));\n\nclass TestUtils {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TestUtilsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_testutils_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    static createMockAccountId() {\n        const ret = wasm.testutils_createMockAccountId();\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    static createMockSerializedPackage() {\n        const ret = wasm.testutils_createMockSerializedPackage();\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) TestUtils.prototype[Symbol.dispose] = TestUtils.prototype.free;\n\nconst TokenSymbolFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokensymbol_free(ptr >>> 0, 1));\n\nclass TokenSymbol {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TokenSymbol.prototype);\n        obj.__wbg_ptr = ptr;\n        TokenSymbolFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenSymbolFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokensymbol_free(ptr, 0);\n    }\n    /**\n     * @param {string} symbol\n     */\n    constructor(symbol) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(symbol, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.tokensymbol_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            TokenSymbolFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokensymbol_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) TokenSymbol.prototype[Symbol.dispose] = TokenSymbol.prototype.free;\n\nconst TransactionArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionargs_free(ptr >>> 0, 1));\n\nclass TransactionArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionargs_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionScript | undefined}\n     */\n    txScript() {\n        const ret = wasm.transactionargs_txScript(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionScript.__wrap(ret);\n    }\n    /**\n     * @param {NoteId} note_id\n     * @returns {Word | undefined}\n     */\n    getNoteArgs(note_id) {\n        _assertClass(note_id, NoteId);\n        const ret = wasm.transactionargs_getNoteArgs(this.__wbg_ptr, note_id.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {AdviceInputs}\n     */\n    adviceInputs() {\n        const ret = wasm.transactionargs_adviceInputs(this.__wbg_ptr);\n        return AdviceInputs.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionArgs.prototype[Symbol.dispose] = TransactionArgs.prototype.free;\n\nconst TransactionFilterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionfilter_free(ptr >>> 0, 1));\n\nclass TransactionFilter {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionFilter.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionFilterFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionFilterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionfilter_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionFilter}\n     */\n    static all() {\n        const ret = wasm.transactionfilter_all();\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @param {TransactionId[]} ids\n     * @returns {TransactionFilter}\n     */\n    static ids(ids) {\n        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionfilter_ids(ptr0, len0);\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionFilter}\n     */\n    static uncommitted() {\n        const ret = wasm.transactionfilter_uncommitted();\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {TransactionFilter}\n     */\n    static expiredBefore(block_num) {\n        const ret = wasm.transactionfilter_expiredBefore(block_num);\n        return TransactionFilter.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionFilter.prototype[Symbol.dispose] = TransactionFilter.prototype.free;\n\nconst TransactionIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionid_free(ptr >>> 0, 1));\n\nclass TransactionId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionId.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof TransactionId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionid_free(ptr, 0);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    asElements() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asElements(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    asBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toHex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_toHex(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    inner() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionId.prototype[Symbol.dispose] = TransactionId.prototype.free;\n\nconst TransactionProverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionprover_free(ptr >>> 0, 1));\n\nclass TransactionProver {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionProver.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionProverFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionProverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionprover_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionProver}\n     */\n    static newLocalProver() {\n        const ret = wasm.transactionprover_newLocalProver();\n        return TransactionProver.__wrap(ret);\n    }\n    /**\n     * @param {string} endpoint\n     * @returns {TransactionProver}\n     */\n    static newRemoteProver(endpoint) {\n        const ptr0 = passStringToWasm0(endpoint, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionprover_newRemoteProver(ptr0, len0);\n        return TransactionProver.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    serialize() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionprover_serialize(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} prover_type\n     * @param {string | null} [endpoint]\n     * @returns {TransactionProver}\n     */\n    static deserialize(prover_type, endpoint) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prover_type, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(endpoint) ? 0 : passStringToWasm0(endpoint, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transactionprover_deserialize(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionProver.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    endpoint() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionprover_endpoint(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionProver.prototype[Symbol.dispose] = TransactionProver.prototype.free;\n\nconst TransactionRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrecord_free(ptr >>> 0, 1));\n\nclass TransactionRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrecord_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.transactionrecord_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    initAccountState() {\n        const ret = wasm.transactionrecord_initAccountState(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    finalAccountState() {\n        const ret = wasm.transactionrecord_finalAccountState(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word[]}\n     */\n    inputNoteNullifiers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrecord_inputNoteNullifiers(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.transactionrecord_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.transactionrecord_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {TransactionStatus}\n     */\n    transactionStatus() {\n        const ret = wasm.transactionrecord_transactionStatus(this.__wbg_ptr);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    creationTimestamp() {\n        const ret = wasm.transactionrecord_creationTimestamp(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n}\nif (Symbol.dispose) TransactionRecord.prototype[Symbol.dispose] = TransactionRecord.prototype.free;\n\nconst TransactionRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrequest_free(ptr >>> 0, 1));\n\nclass TransactionRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrequest_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionrequest_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionRequest}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {Note[]}\n     */\n    expectedOutputOwnNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_expectedOutputOwnNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteDetailsAndTag[]}\n     */\n    expectedFutureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_expectedFutureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    scriptArg() {\n        const ret = wasm.transactionrequest_scriptArg(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    authArg() {\n        const ret = wasm.transactionrequest_authArg(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionRequest.prototype[Symbol.dispose] = TransactionRequest.prototype.free;\n\nconst TransactionRequestBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrequestbuilder_free(ptr >>> 0, 1));\n\nclass TransactionRequestBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRequestBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRequestBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRequestBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrequestbuilder_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.transactionrequestbuilder_new();\n        this.__wbg_ptr = ret >>> 0;\n        TransactionRequestBuilderFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {NoteAndArgsArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withUnauthenticatedInputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, NoteAndArgsArray);\n        const ret = wasm.transactionrequestbuilder_withUnauthenticatedInputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteIdAndArgsArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withAuthenticatedInputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, NoteIdAndArgsArray);\n        const ret = wasm.transactionrequestbuilder_withAuthenticatedInputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {OutputNoteArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withOwnOutputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, OutputNoteArray);\n        const ret = wasm.transactionrequestbuilder_withOwnOutputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {TransactionScript} script\n     * @returns {TransactionRequestBuilder}\n     */\n    withCustomScript(script) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(script, TransactionScript);\n        const ret = wasm.transactionrequestbuilder_withCustomScript(ptr, script.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteRecipientArray} recipients\n     * @returns {TransactionRequestBuilder}\n     */\n    withExpectedOutputRecipients(recipients) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(recipients, NoteRecipientArray);\n        const ret = wasm.transactionrequestbuilder_withExpectedOutputRecipients(ptr, recipients.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteDetailsAndTagArray} note_details_and_tag\n     * @returns {TransactionRequestBuilder}\n     */\n    withExpectedFutureNotes(note_details_and_tag) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(note_details_and_tag, NoteDetailsAndTagArray);\n        const ret = wasm.transactionrequestbuilder_withExpectedFutureNotes(ptr, note_details_and_tag.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AdviceMap} advice_map\n     * @returns {TransactionRequestBuilder}\n     */\n    extendAdviceMap(advice_map) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(advice_map, AdviceMap);\n        const ret = wasm.transactionrequestbuilder_extendAdviceMap(ptr, advice_map.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {ForeignAccountArray} foreign_accounts\n     * @returns {TransactionRequestBuilder}\n     */\n    withForeignAccounts(foreign_accounts) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(foreign_accounts, ForeignAccountArray);\n        const ret = wasm.transactionrequestbuilder_withForeignAccounts(ptr, foreign_accounts.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {Word} script_arg\n     * @returns {TransactionRequestBuilder}\n     */\n    withScriptArg(script_arg) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(script_arg, Word);\n        const ret = wasm.transactionrequestbuilder_withScriptArg(ptr, script_arg.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {Word} auth_arg\n     * @returns {TransactionRequestBuilder}\n     */\n    withAuthArg(auth_arg) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(auth_arg, Word);\n        const ret = wasm.transactionrequestbuilder_withAuthArg(ptr, auth_arg.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionRequest}\n     */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.transactionrequestbuilder_build(ptr);\n        return TransactionRequest.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionRequestBuilder.prototype[Symbol.dispose] = TransactionRequestBuilder.prototype.free;\n\nconst TransactionResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionresult_free(ptr >>> 0, 1));\n/**\n * WASM wrapper around the native [`TransactionResult`].\n */\nclass TransactionResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionResult.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionresult_free(ptr, 0);\n    }\n    /**\n     * Returns the ID of the transaction.\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.executedtransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * Returns the executed transaction.\n     * @returns {ExecutedTransaction}\n     */\n    executedTransaction() {\n        const ret = wasm.transactionresult_executedTransaction(this.__wbg_ptr);\n        return ExecutedTransaction.__wrap(ret);\n    }\n    /**\n     * Returns notes that are expected to be created as a result of follow-up executions.\n     * @returns {NoteDetailsAndTag[]}\n     */\n    futureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionresult_futureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serializes the transaction result into bytes.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionresult_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a transaction result from bytes.\n     * @param {Uint8Array} bytes\n     * @returns {TransactionResult}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionresult_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionResult.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) TransactionResult.prototype[Symbol.dispose] = TransactionResult.prototype.free;\n\nconst TransactionScriptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscript_free(ptr >>> 0, 1));\n\nclass TransactionScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionScript.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionScriptFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscript_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.notescript_root(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionScript.prototype[Symbol.dispose] = TransactionScript.prototype.free;\n\nconst TransactionScriptInputPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscriptinputpair_free(ptr >>> 0, 1));\n\nclass TransactionScriptInputPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionScriptInputPair.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionScriptInputPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof TransactionScriptInputPair)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptInputPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscriptinputpair_free(ptr, 0);\n    }\n    /**\n     * @param {Word} word\n     * @param {FeltArray} felts\n     */\n    constructor(word, felts) {\n        _assertClass(word, Word);\n        var ptr0 = word.__destroy_into_raw();\n        _assertClass(felts, FeltArray);\n        const ret = wasm.transactionscriptinputpair_new(ptr0, felts.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        TransactionScriptInputPairFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Word}\n     */\n    word() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    felts() {\n        const ret = wasm.transactionscriptinputpair_felts(this.__wbg_ptr);\n        return FeltArray.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionScriptInputPair.prototype[Symbol.dispose] = TransactionScriptInputPair.prototype.free;\n\nconst TransactionScriptInputPairArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscriptinputpairarray_free(ptr >>> 0, 1));\n\nclass TransactionScriptInputPairArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptInputPairArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscriptinputpairarray_free(ptr, 0);\n    }\n    /**\n     * @param {TransactionScriptInputPair[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionscriptinputpairarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        TransactionScriptInputPairArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {TransactionScriptInputPair}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionscriptinputpairarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionScriptInputPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {TransactionScriptInputPair} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, TransactionScriptInputPair);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.transactionscriptinputpairarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {TransactionScriptInputPair} element\n     */\n    push(element) {\n        _assertClass(element, TransactionScriptInputPair);\n        wasm.transactionscriptinputpairarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotesarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) TransactionScriptInputPairArray.prototype[Symbol.dispose] = TransactionScriptInputPairArray.prototype.free;\n\nconst TransactionStatusFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionstatus_free(ptr >>> 0, 1));\n\nclass TransactionStatus {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionStatus.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionStatusFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionStatusFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionstatus_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionStatus}\n     */\n    static pending() {\n        const ret = wasm.transactionstatus_pending();\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @param {bigint} commit_timestamp\n     * @returns {TransactionStatus}\n     */\n    static committed(block_num, commit_timestamp) {\n        const ret = wasm.transactionstatus_committed(block_num, commit_timestamp);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @param {string} cause\n     * @returns {TransactionStatus}\n     */\n    static discarded(cause) {\n        const ptr0 = passStringToWasm0(cause, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionstatus_discarded(ptr0, len0);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPending() {\n        const ret = wasm.transactionstatus_isPending(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isCommitted() {\n        const ret = wasm.transactionstatus_isCommitted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isDiscarded() {\n        const ret = wasm.transactionstatus_isDiscarded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    getBlockNum() {\n        const ret = wasm.transactionstatus_getBlockNum(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {bigint | undefined}\n     */\n    getCommitTimestamp() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstatus_getCommitTimestamp(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionStatus.prototype[Symbol.dispose] = TransactionStatus.prototype.free;\n\nconst TransactionStoreUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionstoreupdate_free(ptr >>> 0, 1));\n\nclass TransactionStoreUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionStoreUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionStoreUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionStoreUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionstoreupdate_free(ptr, 0);\n    }\n    /**\n     * @returns {ExecutedTransaction}\n     */\n    executedTransaction() {\n        const ret = wasm.transactionstoreupdate_executedTransaction(this.__wbg_ptr);\n        return ExecutedTransaction.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    submissionHeight() {\n        const ret = wasm.transactionstoreupdate_submissionHeight(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    createdNotes() {\n        const ret = wasm.transactionstoreupdate_createdNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        const ret = wasm.transactionstoreupdate_accountDelta(this.__wbg_ptr);\n        return AccountDelta.__wrap(ret);\n    }\n    /**\n     * @returns {NoteDetailsAndTag[]}\n     */\n    futureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstoreupdate_futureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionstoreupdate_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionStoreUpdate}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstoreupdate_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionStoreUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) TransactionStoreUpdate.prototype[Symbol.dispose] = TransactionStoreUpdate.prototype.free;\n\nconst TransactionSummaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionsummary_free(ptr >>> 0, 1));\n\nclass TransactionSummary {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionSummary.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionSummaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionSummaryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionsummary_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionsummary_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionSummary}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_accountDelta(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {InputNotes}\n     */\n    inputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_inputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return InputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_outputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    salt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_salt(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionSummary.prototype[Symbol.dispose] = TransactionSummary.prototype.free;\n\nconst WebClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_webclient_free(ptr >>> 0, 1));\n\nclass WebClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WebClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_webclient_free(ptr, 0);\n    }\n    /**\n     * @returns {Promise<AccountHeader[]>}\n     */\n    getAccounts() {\n        const ret = wasm.webclient_getAccounts(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<Account | undefined>}\n     */\n    getAccount(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.webclient_getAccount(this.__wbg_ptr, account_id.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Word} pub_key\n     * @returns {Promise<AuthSecretKey>}\n     */\n    getAccountAuthByPubKey(pub_key) {\n        _assertClass(pub_key, Word);\n        const ret = wasm.webclient_getAccountAuthByPubKey(this.__wbg_ptr, pub_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    insertAccountAddress(account_id, address) {\n        _assertClass(account_id, AccountId);\n        _assertClass(address, Address);\n        const ret = wasm.webclient_insertAccountAddress(this.__wbg_ptr, account_id.__wbg_ptr, address.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    removeAccountAddress(account_id, address) {\n        _assertClass(account_id, AccountId);\n        _assertClass(address, Address);\n        const ret = wasm.webclient_removeAccountAddress(this.__wbg_ptr, account_id.__wbg_ptr, address.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @param {string} export_type\n     * @returns {Promise<NoteFile>}\n     */\n    exportNoteFile(note_id, export_type) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(export_type, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_exportNoteFile(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return takeObject(ret);\n    }\n    /**\n     * Retrieves the entire underlying web store and returns it as a `JsValue`\n     *\n     * Meant to be used in conjunction with the `force_import_store` method\n     * @returns {Promise<any>}\n     */\n    exportStore() {\n        const ret = wasm.webclient_exportStore(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<AccountFile>}\n     */\n    exportAccountFile(account_id) {\n        _assertClass(account_id, AccountId);\n        var ptr0 = account_id.__destroy_into_raw();\n        const ret = wasm.webclient_exportAccountFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountFile} account_file\n     * @returns {Promise<any>}\n     */\n    importAccountFile(account_file) {\n        _assertClass(account_file, AccountFile);\n        var ptr0 = account_file.__destroy_into_raw();\n        const ret = wasm.webclient_importAccountFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} init_seed\n     * @param {boolean} mutable\n     * @param {number} auth_scheme_id\n     * @returns {Promise<Account>}\n     */\n    importPublicAccountFromSeed(init_seed, mutable, auth_scheme_id) {\n        const ptr0 = passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_importPublicAccountFromSeed(this.__wbg_ptr, ptr0, len0, mutable, auth_scheme_id);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<any>}\n     */\n    importAccountById(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.webclient_importAccountById(this.__wbg_ptr, account_id.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFile} note_file\n     * @returns {Promise<NoteId>}\n     */\n    importNoteFile(note_file) {\n        _assertClass(note_file, NoteFile);\n        var ptr0 = note_file.__destroy_into_raw();\n        const ret = wasm.webclient_importNoteFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {any} store_dump\n     * @returns {Promise<any>}\n     */\n    forceImportStore(store_dump) {\n        const ret = wasm.webclient_forceImportStore(this.__wbg_ptr, addHeapObject(store_dump));\n        return takeObject(ret);\n    }\n    /**\n     * Creates a new client with a mock RPC API. Useful for testing purposes and proof-of-concept\n     * applications as it uses a mock chain that simulates the behavior of a real node.\n     * @param {Uint8Array | null} [seed]\n     * @param {Uint8Array | null} [serialized_mock_chain]\n     * @param {Uint8Array | null} [serialized_mock_note_transport_node]\n     * @returns {Promise<any>}\n     */\n    createMockClient(seed, serialized_mock_chain, serialized_mock_note_transport_node) {\n        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(serialized_mock_chain) ? 0 : passArray8ToWasm0(serialized_mock_chain, wasm.__wbindgen_export);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(serialized_mock_note_transport_node) ? 0 : passArray8ToWasm0(serialized_mock_note_transport_node, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createMockClient(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return takeObject(ret);\n    }\n    /**\n     * Returns the inner serialized mock chain if it exists.\n     * @returns {Uint8Array}\n     */\n    serializeMockChain() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_serializeMockChain(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the inner serialized mock note transport node if it exists.\n     * @returns {Uint8Array}\n     */\n    serializeMockNoteTransportNode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_serializeMockNoteTransportNode(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    proveBlock() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_proveBlock(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    usesMockChain() {\n        const ret = wasm.webclient_usesMockChain(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @param {boolean} mutable\n     * @param {number} auth_scheme_id\n     * @param {Uint8Array | null} [init_seed]\n     * @returns {Promise<Account>}\n     */\n    newWallet(storage_mode, mutable, auth_scheme_id, init_seed) {\n        _assertClass(storage_mode, AccountStorageMode);\n        var ptr0 = isLikeNone(init_seed) ? 0 : passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_newWallet(this.__wbg_ptr, storage_mode.__wbg_ptr, mutable, auth_scheme_id, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @param {boolean} non_fungible\n     * @param {string} token_symbol\n     * @param {number} decimals\n     * @param {bigint} max_supply\n     * @param {number} auth_scheme_id\n     * @returns {Promise<Account>}\n     */\n    newFaucet(storage_mode, non_fungible, token_symbol, decimals, max_supply, auth_scheme_id) {\n        _assertClass(storage_mode, AccountStorageMode);\n        const ptr0 = passStringToWasm0(token_symbol, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_newFaucet(this.__wbg_ptr, storage_mode.__wbg_ptr, non_fungible, ptr0, len0, decimals, max_supply, auth_scheme_id);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Account} account\n     * @param {boolean} overwrite\n     * @returns {Promise<void>}\n     */\n    newAccount(account, overwrite) {\n        _assertClass(account, Account);\n        const ret = wasm.webclient_newAccount(this.__wbg_ptr, account.__wbg_ptr, overwrite);\n        return takeObject(ret);\n    }\n    /**\n     * @param {SecretKey} secret_key\n     * @returns {Promise<void>}\n     */\n    addAccountSecretKeyToWebStore(secret_key) {\n        _assertClass(secret_key, SecretKey);\n        const ret = wasm.webclient_addAccountSecretKeyToWebStore(this.__wbg_ptr, secret_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Executes a transaction specified by the request against the specified account,\n     * proves it, submits it to the network, and updates the local database.\n     *\n     * If the transaction utilizes foreign account data, there is a chance that the client doesn't\n     * have the required block header in the local database. In these scenarios, a sync to\n     * the chain tip is performed, and the required block header is retrieved.\n     * @param {AccountId} account_id\n     * @param {TransactionRequest} transaction_request\n     * @returns {Promise<TransactionId>}\n     */\n    submitNewTransaction(account_id, transaction_request) {\n        _assertClass(account_id, AccountId);\n        _assertClass(transaction_request, TransactionRequest);\n        const ret = wasm.webclient_submitNewTransaction(this.__wbg_ptr, account_id.__wbg_ptr, transaction_request.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Executes a transaction specified by the request against the specified account but does not\n     * submit it to the network nor update the local database. The returned [`TransactionResult`]\n     * retains the execution artifacts needed to continue with the transaction lifecycle.\n     *\n     * If the transaction utilizes foreign account data, there is a chance that the client doesn't\n     * have the required block header in the local database. In these scenarios, a sync to\n     * the chain tip is performed, and the required block header is retrieved.\n     * @param {AccountId} account_id\n     * @param {TransactionRequest} transaction_request\n     * @returns {Promise<TransactionResult>}\n     */\n    executeTransaction(account_id, transaction_request) {\n        _assertClass(account_id, AccountId);\n        _assertClass(transaction_request, TransactionRequest);\n        const ret = wasm.webclient_executeTransaction(this.__wbg_ptr, account_id.__wbg_ptr, transaction_request.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Generates a transaction proof using either the provided prover or the client's default\n     * prover if none is supplied.\n     * @param {TransactionResult} transaction_result\n     * @param {TransactionProver | null} [prover]\n     * @returns {Promise<ProvenTransaction>}\n     */\n    proveTransaction(transaction_result, prover) {\n        _assertClass(transaction_result, TransactionResult);\n        let ptr0 = 0;\n        if (!isLikeNone(prover)) {\n            _assertClass(prover, TransactionProver);\n            ptr0 = prover.__destroy_into_raw();\n        }\n        const ret = wasm.webclient_proveTransaction(this.__wbg_ptr, transaction_result.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {ProvenTransaction} proven_transaction\n     * @param {TransactionResult} transaction_result\n     * @returns {Promise<number>}\n     */\n    submitProvenTransaction(proven_transaction, transaction_result) {\n        _assertClass(proven_transaction, ProvenTransaction);\n        _assertClass(transaction_result, TransactionResult);\n        const ret = wasm.webclient_submitProvenTransaction(this.__wbg_ptr, proven_transaction.__wbg_ptr, transaction_result.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {TransactionResult} transaction_result\n     * @param {number} submission_height\n     * @returns {Promise<TransactionStoreUpdate>}\n     */\n    applyTransaction(transaction_result, submission_height) {\n        _assertClass(transaction_result, TransactionResult);\n        const ret = wasm.webclient_applyTransaction(this.__wbg_ptr, transaction_result.__wbg_ptr, submission_height);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} target_account_id\n     * @param {AccountId} faucet_id\n     * @param {NoteType} note_type\n     * @param {bigint} amount\n     * @returns {TransactionRequest}\n     */\n    newMintTransactionRequest(target_account_id, faucet_id, note_type, amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(target_account_id, AccountId);\n            _assertClass(faucet_id, AccountId);\n            wasm.webclient_newMintTransactionRequest(retptr, this.__wbg_ptr, target_account_id.__wbg_ptr, faucet_id.__wbg_ptr, note_type, amount);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender_account_id\n     * @param {AccountId} target_account_id\n     * @param {AccountId} faucet_id\n     * @param {NoteType} note_type\n     * @param {bigint} amount\n     * @param {number | null} [recall_height]\n     * @param {number | null} [timelock_height]\n     * @returns {TransactionRequest}\n     */\n    newSendTransactionRequest(sender_account_id, target_account_id, faucet_id, note_type, amount, recall_height, timelock_height) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender_account_id, AccountId);\n            _assertClass(target_account_id, AccountId);\n            _assertClass(faucet_id, AccountId);\n            wasm.webclient_newSendTransactionRequest(retptr, this.__wbg_ptr, sender_account_id.__wbg_ptr, target_account_id.__wbg_ptr, faucet_id.__wbg_ptr, note_type, amount, isLikeNone(recall_height) ? 0x100000001 : (recall_height) >>> 0, isLikeNone(timelock_height) ? 0x100000001 : (timelock_height) >>> 0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string[]} list_of_note_ids\n     * @returns {TransactionRequest}\n     */\n    newConsumeTransactionRequest(list_of_note_ids) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(list_of_note_ids, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.webclient_newConsumeTransactionRequest(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender_account_id\n     * @param {AccountId} offered_asset_faucet_id\n     * @param {bigint} offered_asset_amount\n     * @param {AccountId} requested_asset_faucet_id\n     * @param {bigint} requested_asset_amount\n     * @param {NoteType} note_type\n     * @param {NoteType} payback_note_type\n     * @returns {TransactionRequest}\n     */\n    newSwapTransactionRequest(sender_account_id, offered_asset_faucet_id, offered_asset_amount, requested_asset_faucet_id, requested_asset_amount, note_type, payback_note_type) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender_account_id, AccountId);\n            _assertClass(offered_asset_faucet_id, AccountId);\n            _assertClass(requested_asset_faucet_id, AccountId);\n            wasm.webclient_newSwapTransactionRequest(retptr, this.__wbg_ptr, sender_account_id.__wbg_ptr, offered_asset_faucet_id.__wbg_ptr, offered_asset_amount, requested_asset_faucet_id.__wbg_ptr, requested_asset_amount, note_type, payback_note_type);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Send a private note via the note transport layer\n     * @param {Note} note\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    sendPrivateNote(note, address) {\n        _assertClass(note, Note);\n        var ptr0 = note.__destroy_into_raw();\n        _assertClass(address, Address);\n        var ptr1 = address.__destroy_into_raw();\n        const ret = wasm.webclient_sendPrivateNote(this.__wbg_ptr, ptr0, ptr1);\n        return takeObject(ret);\n    }\n    /**\n     * Fetch private notes from the note transport layer\n     *\n     * Uses an internal pagination mechanism to avoid fetching duplicate notes.\n     * @returns {Promise<void>}\n     */\n    fetchPrivateNotes() {\n        const ret = wasm.webclient_fetchPrivateNotes(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Fetch all private notes from the note transport layer\n     *\n     * Fetches all notes stored in the transport layer, with no pagination.\n     * Prefer using [`WebClient::fetch_private_notes`] for a more efficient, on-going,\n     * fetching mechanism.\n     * @returns {Promise<void>}\n     */\n    fetchAllPrivateNotes() {\n        const ret = wasm.webclient_fetchAllPrivateNotes(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFilter} filter\n     * @returns {Promise<InputNoteRecord[]>}\n     */\n    getInputNotes(filter) {\n        _assertClass(filter, NoteFilter);\n        var ptr0 = filter.__destroy_into_raw();\n        const ret = wasm.webclient_getInputNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @returns {Promise<InputNoteRecord | undefined>}\n     */\n    getInputNote(note_id) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getInputNote(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFilter} filter\n     * @returns {Promise<any>}\n     */\n    getOutputNotes(filter) {\n        _assertClass(filter, NoteFilter);\n        var ptr0 = filter.__destroy_into_raw();\n        const ret = wasm.webclient_getOutputNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @returns {Promise<any>}\n     */\n    getOutputNote(note_id) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getOutputNote(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId | null} [account_id]\n     * @returns {Promise<ConsumableNoteRecord[]>}\n     */\n    getConsumableNotes(account_id) {\n        let ptr0 = 0;\n        if (!isLikeNone(account_id)) {\n            _assertClass(account_id, AccountId);\n            ptr0 = account_id.__destroy_into_raw();\n        }\n        const ret = wasm.webclient_getConsumableNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * Retrieves the setting value for `key`, or `None` if it hasnt been set.\n     * @param {string} key\n     * @returns {Promise<any | undefined>}\n     */\n    getSetting(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getSetting(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Sets a setting key-value in the store. It can then be retrieved using `get_setting`.\n     * @param {string} key\n     * @param {any} value\n     * @returns {Promise<void>}\n     */\n    setSetting(key, value) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_setSetting(this.__wbg_ptr, ptr0, len0, addHeapObject(value));\n        return takeObject(ret);\n    }\n    /**\n     * Deletes a setting key-value from the store.\n     * @param {string} key\n     * @returns {Promise<void>}\n     */\n    removeSetting(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_removeSetting(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Returns all the existing setting keys from the store.\n     * @returns {Promise<string[]>}\n     */\n    listSettingKeys() {\n        const ret = wasm.webclient_listSettingKeys(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<SyncSummary>}\n     */\n    syncState() {\n        const ret = wasm.webclient_syncState(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<number>}\n     */\n    getSyncHeight() {\n        const ret = wasm.webclient_getSyncHeight(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteType} note_type\n     * @param {AccountId} offered_asset_faucet_id\n     * @param {bigint} offered_asset_amount\n     * @param {AccountId} requested_asset_faucet_id\n     * @param {bigint} requested_asset_amount\n     * @returns {NoteTag}\n     */\n    static buildSwapTag(note_type, offered_asset_faucet_id, offered_asset_amount, requested_asset_faucet_id, requested_asset_amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(offered_asset_faucet_id, AccountId);\n            _assertClass(requested_asset_faucet_id, AccountId);\n            wasm.webclient_buildSwapTag(retptr, note_type, offered_asset_faucet_id.__wbg_ptr, offered_asset_amount, requested_asset_faucet_id.__wbg_ptr, requested_asset_amount);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} tag\n     * @returns {Promise<void>}\n     */\n    addTag(tag) {\n        const ptr0 = passStringToWasm0(tag, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_addTag(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} tag\n     * @returns {Promise<void>}\n     */\n    removeTag(tag) {\n        const ptr0 = passStringToWasm0(tag, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_removeTag(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<any>}\n     */\n    listTags() {\n        const ret = wasm.webclient_listTags(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {TransactionFilter} transaction_filter\n     * @returns {Promise<TransactionRecord[]>}\n     */\n    getTransactions(transaction_filter) {\n        _assertClass(transaction_filter, TransactionFilter);\n        var ptr0 = transaction_filter.__destroy_into_raw();\n        const ret = wasm.webclient_getTransactions(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    constructor() {\n        const ret = wasm.webclient_new();\n        this.__wbg_ptr = ret >>> 0;\n        WebClientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Creates a new client with the given node URL and optional seed.\n     * If `node_url` is `None`, it defaults to the testnet endpoint.\n     * @param {string | null} [node_url]\n     * @param {string | null} [node_note_transport_url]\n     * @param {Uint8Array | null} [seed]\n     * @returns {Promise<any>}\n     */\n    createClient(node_url, node_note_transport_url, seed) {\n        var ptr0 = isLikeNone(node_url) ? 0 : passStringToWasm0(node_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(node_note_transport_url) ? 0 : passStringToWasm0(node_note_transport_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createClient(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return takeObject(ret);\n    }\n    /**\n     * Creates a new client with the given node URL, optional seed, and external keystore\n     * callbacks. If `node_url` is `None`, it defaults to the testnet endpoint.\n     * @param {string | null} [node_url]\n     * @param {string | null} [node_note_transport_url]\n     * @param {Uint8Array | null} [seed]\n     * @param {Function | null} [get_key_cb]\n     * @param {Function | null} [insert_key_cb]\n     * @param {Function | null} [sign_cb]\n     * @returns {Promise<any>}\n     */\n    createClientWithExternalKeystore(node_url, node_note_transport_url, seed, get_key_cb, insert_key_cb, sign_cb) {\n        var ptr0 = isLikeNone(node_url) ? 0 : passStringToWasm0(node_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(node_note_transport_url) ? 0 : passStringToWasm0(node_note_transport_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createClientWithExternalKeystore(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, isLikeNone(get_key_cb) ? 0 : addHeapObject(get_key_cb), isLikeNone(insert_key_cb) ? 0 : addHeapObject(insert_key_cb), isLikeNone(sign_cb) ? 0 : addHeapObject(sign_cb));\n        return takeObject(ret);\n    }\n    /**\n     * @returns {ScriptBuilder}\n     */\n    createScriptBuilder() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_createScriptBuilder(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptBuilder.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) WebClient.prototype[Symbol.dispose] = WebClient.prototype.free;\n\nconst WordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_word_free(ptr >>> 0, 1));\n\nclass Word {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Word.prototype);\n        obj.__wbg_ptr = ptr;\n        WordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Word)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_word_free(ptr, 0);\n    }\n    /**\n     * @param {BigUint64Array} u64_vec\n     */\n    constructor(u64_vec) {\n        const ptr0 = passArray64ToWasm0(u64_vec, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.word_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        WordFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Creates a Word from a hex string.\n     * Fails if the provided string is not a valid hex representation of a Word.\n     * @param {string} hex\n     * @returns {Word}\n     */\n    static fromHex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.word_fromHex(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Felt[]} felt_vec\n     * @returns {Word}\n     */\n    static newFromFelts(felt_vec) {\n        const ptr0 = passArrayJsValueToWasm0(felt_vec, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.word_newFromFelts(ptr0, len0);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toHex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_toHex(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.word_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Word}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.word_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {BigUint64Array}\n     */\n    toU64s() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.word_toU64s(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU64FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 8, 8);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    toFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asElements(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Word.prototype[Symbol.dispose] = Word.prototype.free;\n\nconst EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_Error_e83987f665cf5504 = function(arg0, arg1) {\n        const ret = Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_Number_bb48ca12f395cd08 = function(arg0) {\n        const ret = Number(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_bigint_get_as_i64_f3ebc5a755000afd = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbg___wbindgen_boolean_get_6d5a1ee65bab5f68 = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? v : undefined;\n        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n    };\n    imports.wbg.__wbg___wbindgen_debug_string_df47ffb5e35e6763 = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_in_bb933bd9e1b3bc0f = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_bigint_cb320707dcd35f0b = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_function_ee8a6c5833c90377 = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_null_5e69f72e906cc57c = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_object_c818261d21f283a4 = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_undefined_2d472862bd29a478 = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_jsval_eq_6b13ab83478b1c50 = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_jsval_loose_eq_b664b38a2f582147 = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_number_get_a20bf9b85341449d = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbg___wbindgen_string_get_e4f06c90489ad01b = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_throw_b855445ff6a94295 = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg__wbg_cb_unref_2454a539ea5790d9 = function(arg0) {\n        getObject(arg0)._wbg_cb_unref();\n    };\n    imports.wbg.__wbg_abort_28ad55c5825b004d = function(arg0, arg1) {\n        getObject(arg0).abort(getObject(arg1));\n    };\n    imports.wbg.__wbg_abort_e7eb059f72f9ed0c = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_account_new = function(arg0) {\n        const ret = Account.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_account_unwrap = function(arg0) {\n        const ret = Account.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_accountfile_new = function(arg0) {\n        const ret = AccountFile.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountheader_new = function(arg0) {\n        const ret = AccountHeader.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountid_new = function(arg0) {\n        const ret = AccountId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountid_unwrap = function(arg0) {\n        const ret = AccountId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_addNoteTag_948ab4cc7d3d784b = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getStringFromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        let v2;\n        if (arg4 !== 0) {\n            v2 = getStringFromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n        }\n        const ret = addNoteTag(v0, v1, v2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_b577eb3a177bc0fa = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_applyStateSync_687415d1bcf4dd8a = function(arg0) {\n        const ret = applyStateSync(JsStateSyncUpdate.__wrap(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_authsecretkey_new = function(arg0) {\n        const ret = AuthSecretKey.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_body_587542b2fd8e06c0 = function(arg0) {\n        const ret = getObject(arg0).body;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_ccc4520b36d3ccf4 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_byobRequest_2344e6975f27456e = function(arg0) {\n        const ret = getObject(arg0).byobRequest;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_byteLength_bcd42e4025299788 = function(arg0) {\n        const ret = getObject(arg0).byteLength;\n        return ret;\n    };\n    imports.wbg.__wbg_byteOffset_ca3a6cf7944b364b = function(arg0) {\n        const ret = getObject(arg0).byteOffset;\n        return ret;\n    };\n    imports.wbg.__wbg_call_525440f72fbfc0ea = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e45d2cf9fc925fcf = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e762c39fa8ea36bf = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_cancel_48ab6f9dc366e369 = function(arg0) {\n        const ret = getObject(arg0).cancel();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_catch_943836faa5d29bfb = function(arg0, arg1) {\n        const ret = getObject(arg0).catch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_clearTimeout_2e2c4939388cdfbb = function(arg0) {\n        const ret = clearTimeout(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_close_5a6caed3231b68cd = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_close_6956df845478561a = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_consumablenoterecord_new = function(arg0) {\n        const ret = ConsumableNoteRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_done_2042aa2670fb1db1 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_enqueue_7b18a650aec77898 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).enqueue(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_exportStore_13b5274b45367269 = function() {\n        const ret = exportStore();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_felt_new = function(arg0) {\n        const ret = Felt.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_felt_unwrap = function(arg0) {\n        const ret = Felt.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fetch_53eef7df7b439a49 = function(arg0, arg1) {\n        const ret = fetch(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_8725865ff47e7fcc = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).fetch(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetchednote_new = function(arg0) {\n        const ret = FetchedNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_forceImportStore_e4f1437d6b4cff0e = function(arg0) {\n        const ret = forceImportStore(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_foreignaccount_unwrap = function(arg0) {\n        const ret = ForeignAccount.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fungibleasset_new = function(arg0) {\n        const ret = FungibleAsset.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fungibleasset_unwrap = function(arg0) {\n        const ret = FungibleAsset.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fungibleassetdeltaitem_new = function(arg0) {\n        const ret = FungibleAssetDeltaItem.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountAddresses_57dcaf04403ffff6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountAddresses(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountAuthByPubKey_a99268a0c5e781fc = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountAuthByPubKey(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountCode_255c47880027604f = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountCode(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountHeaderByCommitment_2457b381278acd9d = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountHeaderByCommitment(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountHeader_3e3c0fd16ce78046 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountHeader(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountIds_1dc3cc9beb00dac4 = function() {\n        const ret = getAccountIds();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountStorageMaps_52d390f59d39870a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getAccountStorageMaps(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountStorage_e7e314d3a8c68188 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountStorage(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountVaultAssets_058aa7a3e85f9d7e = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountVaultAssets(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAllAccountHeaders_21ae58fbd74bc207 = function() {\n        const ret = getAllAccountHeaders();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getBlockHeaders_ffbe629419e49f24 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getBlockHeaders(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getForeignAccountCode_84f81a9fb264b2a8 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getForeignAccountCode(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotesFromIds_a4814ff3ee6838f4 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getInputNotesFromIds(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotesFromNullifiers_b125192521cb2707 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getInputNotesFromNullifiers(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotes_9e7daab3e11aada9 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = getInputNotes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getNoteScript_8db4a87f1daa5732 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getNoteScript(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getNoteTags_445672fbda7617ca = function() {\n        const ret = getNoteTags();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotesFromIds_a9f95eee5aea111a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getOutputNotesFromIds(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotesFromNullifiers_15708419209f0017 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getOutputNotesFromNullifiers(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotes_7e9034b7845d8547 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = getOutputNotes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainNodesAll_f7b99da4ecc2cf67 = function() {\n        const ret = getPartialBlockchainNodesAll();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainNodes_4b59f3cf3d67885a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getPartialBlockchainNodes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainPeaksByBlockNum_c3683954cf872601 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getPartialBlockchainPeaksByBlockNum(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getRandomValues_1c61fac11405ffdc = function() { return handleError(function (arg0, arg1) {\n        globalThis.crypto.getRandomValues(getArrayU8FromWasm0(arg0, arg1));\n    }, arguments) };\n    imports.wbg.__wbg_getReader_48e00749fe3f6089 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).getReader();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_getSetting_30d487e26ed3ecff = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getSetting(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getSyncHeight_f7c4ff032d6e8719 = function() {\n        const ret = getSyncHeight();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_14776bfb48a1bff9 = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_getTrackedBlockHeaders_0e922af05410981b = function() {\n        const ret = getTrackedBlockHeaders();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTransactions_7511822ed7df4a04 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getTransactions(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getUnspentInputNoteNullifiers_a53ee1887b305122 = function() {\n        const ret = getUnspentInputNoteNullifiers();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_7bed016f185add81 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_done_a0463af43a1fc764 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n    };\n    imports.wbg.__wbg_get_efcb449f58ec27c2 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_value_5ce96c9f81ce7398 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_with_ref_key_1dc361bd10053bfe = function(arg0, arg1) {\n        const ret = getObject(arg0)[getObject(arg1)];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getproceduresresultitem_new = function(arg0) {\n        const ret = GetProceduresResultItem.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_787fafc980c3ccdb = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_headers_b87d7eaba61c3278 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_inputnote_new = function(arg0) {\n        const ret = InputNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_inputnoterecord_new = function(arg0) {\n        const ret = InputNoteRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_insertAccountAddress_819a7abb57d5c50e = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = insertAccountAddress(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertAccountAuth_88fdf1ae9cfe0155 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            deferred1_0 = arg2;\n            deferred1_1 = arg3;\n            const ret = insertAccountAuth(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertBlockHeader_5e4c39a64aba945d = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            var v2 = getArrayU8FromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n            const ret = insertBlockHeader(getStringFromWasm0(arg0, arg1), v1, v2, arg6 !== 0);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertPartialBlockchainNodes_5139cc9702ff0a99 = function(arg0, arg1, arg2, arg3) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        var v1 = getArrayJsValueFromWasm0(arg2, arg3).slice();\n        wasm.__wbindgen_export3(arg2, arg3 * 4, 4);\n        const ret = insertPartialBlockchainNodes(v0, v1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_insertSetting_1e2fa0de524f2782 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = insertSetting(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertTransactionScript_8e5b6d2bcc70c826 = function(arg0, arg1, arg2, arg3) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        const ret = insertTransactionScript(v0, v1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_70beb1189ca63b38 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Promise_001fdd42afa1b7ef = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Promise;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_20c8e73002f7af98 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_isArray_96e0af9891d0945d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_isSafeInteger_d216eda7911dde36 = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_e5822695327a3c39 = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsaccountupdate_new = function(arg0) {\n        const ret = JsAccountUpdate.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsaccountupdate_unwrap = function(arg0) {\n        const ret = JsAccountUpdate.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsstoragemapentry_new = function(arg0) {\n        const ret = JsStorageMapEntry.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsstoragemapentry_unwrap = function(arg0) {\n        const ret = JsStorageMapEntry.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsstorageslot_new = function(arg0) {\n        const ret = JsStorageSlot.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsstorageslot_unwrap = function(arg0) {\n        const ret = JsStorageSlot.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsvaultasset_new = function(arg0) {\n        const ret = JsVaultAsset.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsvaultasset_unwrap = function(arg0) {\n        const ret = JsVaultAsset.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_length_69bca3cb64fc8748 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_cdd215e10d9dd507 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_listSettingKeys_6940be01c27a8e08 = function() {\n        const ret = listSettingKeys();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_lockAccount_17e6307335343eaa = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = lockAccount(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_new_0_f9740686d739025c = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1acc0b6eea89d040 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_2531773dac38ebb3 = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_3c3d849046688a66 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wasm_bindgen_func_elem_3677(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_new_5a79be3ab53b8aa5 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_9edf9838a2def39c = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_a7442b4b19c1a356 = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_e17d9f43105b08be = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_from_slice_92f4d78ca282a2d2 = function(arg0, arg1) {\n        const ret = new Uint8Array(getArrayU8FromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_no_args_ee98eee5275000a4 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_with_byte_offset_and_length_46e3e6a5e9f9e89b = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_with_str_and_init_0ae7728b6ec367b1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_020810e0ae8ebcb0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_2c826fe5dfec6b6a = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_note_new = function(arg0) {\n        const ret = Note.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteandargs_unwrap = function(arg0) {\n        const ret = NoteAndArgs.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noteconsumability_new = function(arg0) {\n        const ret = NoteConsumability.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteconsumability_unwrap = function(arg0) {\n        const ret = NoteConsumability.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notedetailsandtag_new = function(arg0) {\n        const ret = NoteDetailsAndTag.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_notedetailsandtag_unwrap = function(arg0) {\n        const ret = NoteDetailsAndTag.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notefile_new = function(arg0) {\n        const ret = NoteFile.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteid_new = function(arg0) {\n        const ret = NoteId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteid_unwrap = function(arg0) {\n        const ret = NoteId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noteidandargs_unwrap = function(arg0) {\n        const ret = NoteIdAndArgs.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noterecipient_unwrap = function(arg0) {\n        const ret = NoteRecipient.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notescript_new = function(arg0) {\n        const ret = NoteScript.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_openDatabase_f242cd782d300916 = function() {\n        const ret = openDatabase();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_outputnote_new = function(arg0) {\n        const ret = OutputNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_outputnote_unwrap = function(arg0) {\n        const ret = OutputNote.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_outputnotes_unwrap = function(arg0) {\n        const ret = OutputNotes.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_prototypesetcall_2a6620b6922694b2 = function(arg0, arg1, arg2) {\n        Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), getObject(arg2));\n    };\n    imports.wbg.__wbg_proventransaction_new = function(arg0) {\n        const ret = ProvenTransaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_pruneIrrelevantBlocks_ce5174b85cbd83fa = function() {\n        const ret = pruneIrrelevantBlocks();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_34d692c25c47d05b = function(arg0) {\n        const ret = getObject(arg0).queueMicrotask;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_9d76cacb20c84d58 = function(arg0) {\n        queueMicrotask(getObject(arg0));\n    };\n    imports.wbg.__wbg_read_48f1593df542f968 = function(arg0) {\n        const ret = getObject(arg0).read();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_releaseLock_5d0b5a68887b891d = function(arg0) {\n        getObject(arg0).releaseLock();\n    };\n    imports.wbg.__wbg_removeAccountAddress_94b451fd5476b672 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = removeAccountAddress(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_removeNoteTag_550b0385167f2dcf = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getStringFromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        let v2;\n        if (arg4 !== 0) {\n            v2 = getStringFromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n        }\n        const ret = removeNoteTag(v0, v1, v2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_removeSetting_9f59cbfbe95f4843 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = removeSetting(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_resolve_caf97c30b83f7053 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_respond_0f4dbf5386f5c73e = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).respond(arg1 >>> 0);\n    }, arguments) };\n    imports.wbg.__wbg_serializedinputnotedata_new = function(arg0) {\n        const ret = SerializedInputNoteData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedinputnotedata_unwrap = function(arg0) {\n        const ret = SerializedInputNoteData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_serializedoutputnotedata_new = function(arg0) {\n        const ret = SerializedOutputNoteData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedoutputnotedata_unwrap = function(arg0) {\n        const ret = SerializedOutputNoteData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_serializedtransactiondata_new = function(arg0) {\n        const ret = SerializedTransactionData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedtransactiondata_unwrap = function(arg0) {\n        const ret = SerializedTransactionData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_setTimeout_929c97a7c0f23d36 = function(arg0, arg1) {\n        const ret = setTimeout(getObject(arg0), arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_8b342d8cd9d2a02c = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_set_9e6516df7b7d0f19 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_set_body_3c365989753d61f4 = function(arg0, arg1) {\n        getObject(arg0).body = getObject(arg1);\n    };\n    imports.wbg.__wbg_set_c213c871859d6500 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_set_c2abbebe8b9ebee1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_set_cache_2f9deb19b92b81e3 = function(arg0, arg1) {\n        getObject(arg0).cache = __wbindgen_enum_RequestCache[arg1];\n    };\n    imports.wbg.__wbg_set_credentials_f621cd2d85c0c228 = function(arg0, arg1) {\n        getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];\n    };\n    imports.wbg.__wbg_set_headers_6926da238cd32ee4 = function(arg0, arg1) {\n        getObject(arg0).headers = getObject(arg1);\n    };\n    imports.wbg.__wbg_set_integrity_62a46fc792832f41 = function(arg0, arg1, arg2) {\n        getObject(arg0).integrity = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_method_c02d8cbbe204ac2d = function(arg0, arg1, arg2) {\n        getObject(arg0).method = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_mode_52ef73cfa79639cb = function(arg0, arg1) {\n        getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];\n    };\n    imports.wbg.__wbg_set_redirect_df0285496ec45ff8 = function(arg0, arg1) {\n        getObject(arg0).redirect = __wbindgen_enum_RequestRedirect[arg1];\n    };\n    imports.wbg.__wbg_set_referrer_ec9cf8a8a315d50c = function(arg0, arg1, arg2) {\n        getObject(arg0).referrer = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_referrer_policy_99c1f299b4e37446 = function(arg0, arg1) {\n        getObject(arg0).referrerPolicy = __wbindgen_enum_ReferrerPolicy[arg1];\n    };\n    imports.wbg.__wbg_set_signal_dda2cf7ccb6bee0f = function(arg0, arg1) {\n        getObject(arg0).signal = getObject(arg1);\n    };\n    imports.wbg.__wbg_signal_4db5aa055bf9eb9a = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_slotandkeys_unwrap = function(arg0) {\n        const ret = SlotAndKeys.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_89e1d9ac6a1b250e = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_8b530f326a9e48ac = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_6fdf4b64710cc91b = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_b45bfc5a37f6cfa2 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_status_de7eed5a7a5bfd5d = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_storageslot_unwrap = function(arg0) {\n        const ret = StorageSlot.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_syncsummary_new = function(arg0) {\n        const ret = SyncSummary.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_4f46f6544e6b4a28 = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_70d05cf780a18d77 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_toString_7da7c8dbec78fcb8 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionid_new = function(arg0) {\n        const ret = TransactionId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionid_unwrap = function(arg0) {\n        const ret = TransactionId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_transactionrecord_new = function(arg0) {\n        const ret = TransactionRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionresult_new = function(arg0) {\n        const ret = TransactionResult.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionscriptinputpair_unwrap = function(arg0) {\n        const ret = TransactionScriptInputPair.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_transactionstoreupdate_new = function(arg0) {\n        const ret = TransactionStoreUpdate.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_undoAccountStates_fe9da382937036bd = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = undoAccountStates(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertAccountCode_c93e9111b2c73274 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = upsertAccountCode(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertAccountRecord_88843ee6a71cc8b3 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred1_0;\n        let deferred1_1;\n        let deferred2_0;\n        let deferred2_1;\n        let deferred3_0;\n        let deferred3_1;\n        let deferred4_0;\n        let deferred4_1;\n        let deferred5_0;\n        let deferred5_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            deferred1_0 = arg2;\n            deferred1_1 = arg3;\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            deferred3_0 = arg6;\n            deferred3_1 = arg7;\n            deferred4_0 = arg8;\n            deferred4_1 = arg9;\n            deferred5_0 = arg11;\n            deferred5_1 = arg12;\n            let v6;\n            if (arg13 !== 0) {\n                v6 = getArrayU8FromWasm0(arg13, arg14).slice();\n                wasm.__wbindgen_export3(arg13, arg14 * 1, 1);\n            }\n            const ret = upsertAccountRecord(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7), getStringFromWasm0(arg8, arg9), arg10 !== 0, getStringFromWasm0(arg11, arg12), v6);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n            wasm.__wbindgen_export3(deferred4_0, deferred4_1, 1);\n            wasm.__wbindgen_export3(deferred5_0, deferred5_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertAccountStorage_71aea983d8e45253 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertAccountStorage(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertForeignAccountCode_a2ffdd0deb87c063 = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            const ret = upsertForeignAccountCode(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertInputNote_7733702c48e2ae17 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred4_0;\n        let deferred4_1;\n        let deferred6_0;\n        let deferred6_1;\n        let deferred7_0;\n        let deferred7_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            var v2 = getArrayU8FromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n            var v3 = getArrayU8FromWasm0(arg6, arg7).slice();\n            wasm.__wbindgen_export3(arg6, arg7 * 1, 1);\n            deferred4_0 = arg8;\n            deferred4_1 = arg9;\n            var v5 = getArrayU8FromWasm0(arg10, arg11).slice();\n            wasm.__wbindgen_export3(arg10, arg11 * 1, 1);\n            deferred6_0 = arg12;\n            deferred6_1 = arg13;\n            deferred7_0 = arg14;\n            deferred7_1 = arg15;\n            var v8 = getArrayU8FromWasm0(arg17, arg18).slice();\n            wasm.__wbindgen_export3(arg17, arg18 * 1, 1);\n            const ret = upsertInputNote(getStringFromWasm0(arg0, arg1), v1, v2, v3, getStringFromWasm0(arg8, arg9), v5, getStringFromWasm0(arg12, arg13), getStringFromWasm0(arg14, arg15), arg16, v8);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred4_0, deferred4_1, 1);\n            wasm.__wbindgen_export3(deferred6_0, deferred6_1, 1);\n            wasm.__wbindgen_export3(deferred7_0, deferred7_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertNoteScript_3c569a673eff21c9 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = upsertNoteScript(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertOutputNote_1a9c6b80bc3b2979 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            var v3 = getArrayU8FromWasm0(arg6, arg7).slice();\n            wasm.__wbindgen_export3(arg6, arg7 * 1, 1);\n            let v4;\n            if (arg8 !== 0) {\n                v4 = getStringFromWasm0(arg8, arg9).slice();\n                wasm.__wbindgen_export3(arg8, arg9 * 1, 1);\n            }\n            var v5 = getArrayU8FromWasm0(arg12, arg13).slice();\n            wasm.__wbindgen_export3(arg12, arg13 * 1, 1);\n            const ret = upsertOutputNote(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5), v3, v4, arg10 >>> 0, arg11, v5);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertStorageMapEntries_57da734cbee448bf = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertStorageMapEntries(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertTransactionRecord_e4a8b05f1b3714ea = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            var v3 = getArrayU8FromWasm0(arg7, arg8).slice();\n            wasm.__wbindgen_export3(arg7, arg8 * 1, 1);\n            let v4;\n            if (arg9 !== 0) {\n                v4 = getArrayU8FromWasm0(arg9, arg10).slice();\n                wasm.__wbindgen_export3(arg9, arg10 * 1, 1);\n            }\n            const ret = upsertTransactionRecord(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5), arg6, v3, v4);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertVaultAssets_ce549ede4457df6e = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertVaultAssets(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_value_692627309814bb8c = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_view_f6c15ac9fed63bbd = function(arg0) {\n        const ret = getObject(arg0).view;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_word_new = function(arg0) {\n        const ret = Word.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_word_unwrap = function(arg0) {\n        const ret = Word.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_cast_1ff30c89f8c13d4b = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"TransactionRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {\n        // Cast intrinsic for `Ref(String) -> Externref`.\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_25a0a844437d0e92 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"string\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_298dfd99998f1bbf = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"ConsumableNoteRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_3186144f3014a6e9 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"FetchedNote\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_356a649c76ea3d4a = function(arg0, arg1) {\n        // Cast intrinsic for `Closure(Closure { dtor_idx: 516, function: Function { arguments: [], shim_idx: 517, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n        const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_9308, __wasm_bindgen_func_elem_9309);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_4625c577ab2ec9ee = function(arg0) {\n        // Cast intrinsic for `U64 -> Externref`.\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_61180cf2da5580dc = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"AccountHeader\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_77bc3e92745e9a35 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        // Cast intrinsic for `Vector(U8) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_a0c9c97993851672 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"InputNoteRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_c8873871663829dd = function(arg0, arg1) {\n        // Cast intrinsic for `Closure(Closure { dtor_idx: 516, function: Function { arguments: [Externref], shim_idx: 521, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n        const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_9308, __wasm_bindgen_func_elem_9375);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_d6cd19b81560fd6e = function(arg0) {\n        // Cast intrinsic for `F64 -> Externref`.\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n\n    return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedBigUint64ArrayMemory0 = null;\n    cachedDataViewMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module);\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path);\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n        }\n    }\n\n\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nconst module = /* asset import */ new __webpack_require__.U(__webpack_require__(/*! assets/miden_client_web.wasm */ \"(ssr)/./node_modules/@demox-labs/miden-sdk/dist/assets/miden_client_web.wasm\"));\n                \n                    await __wbg_init({ module_or_path: module });\n\n\n//# sourceMappingURL=Cargo-acbd8ac5.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlbW94LWxhYnMvbWlkZW4tc2RrL2Rpc3QvQ2FyZ28tYWNiZDhhYzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDeEYsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsT0FBTztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkVBQTJFO0FBQzFGLGVBQWUsNkRBQTZEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG1EQUFtRCwyQkFBMkIsSUFBSSwwQkFBMEIsb0JBQW9CO0FBQ3pNLHdFQUF3RSxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdCQUFnQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxNQUFNO0FBQ047QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsMENBQTBDLDRCQUE0QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHVCQUF1QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQ0FBMkMsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUYsY0FBYztBQUNkLDZFQUE2RSw0QkFBNEI7QUFDekcsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw2Q0FBNkM7QUFDeEc7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkRBQTJEO0FBQzFHLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QyxxQ0FBcUM7QUFDckMsVUFBVTtBQUNWLHdCQUF3QixtQkFBbUIsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDLHFDQUFxQztBQUNyQyxVQUFVO0FBQ1Y7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pELHFDQUFxQztBQUNyQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsdURBQXVELHNCQUFzQixzQ0FBc0Msc0JBQXNCLHNCQUFzQix1Q0FBdUM7QUFDdFEsNkNBQTZDLHlDQUF5QyxJQUFJO0FBQzFGLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx1REFBdUQsd0JBQXdCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLG1CQUFtQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esa0RBQWtELHFDQUFxQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUF5RDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxtREFBbUQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hELHlEQUF5RCxtREFBbUQ7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZ0JBQWdCO0FBQzVHLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkVBQTJFO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0VBQW9FLElBQUksK0NBQStDO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFLDRDQUE0QyxzQ0FBc0M7QUFDbEYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBDQUEwQztBQUNuRyxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCLDZDQUE2QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx5QkFBeUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsNkJBQTZCO0FBQ2xILCtCQUErQixpQkFBaUIsaURBQWlEO0FBQ2pHO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZEQUE2RDtBQUM3RDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQsaUZBQWlGLHNDQUFzQztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRkFBaUY7QUFDN0gsY0FBYyx3QkFBd0IsaUZBQWlGO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMkJBQTJCLGlGQUFpRixJQUFJO0FBQ2hMLHdDQUF3QyxpRkFBaUY7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMkJBQTJCLDJDQUEyQyxJQUFJO0FBQzFJLHdDQUF3Qyw0RUFBNEU7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQixvREFBb0QsSUFBSTtBQUNuSix3Q0FBd0MsNEVBQTRFO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQixtQ0FBbUMsc0NBQXNDLElBQUk7QUFDMUgsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVGQUF1RjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVGQUF1RjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRixxRUFBcUUsdUJBQXVCO0FBQzVGO0FBQ0E7QUFDQSw0Q0FBNEMsMENBQTBDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxnQkFBZ0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMENBQTBDO0FBQ3RGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxzRkFBc0YsbUJBQW1CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUNBQXFDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNkJBQTZCLG1CQUFtQiwwQkFBMEI7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQ0FBbUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MseUVBQXlFLHNCQUFzQixtQkFBbUIsa0JBQWtCLFVBQVUsaUJBQWlCLGdCQUFnQixVQUFVO0FBQ3pMLCtFQUErRSxzQkFBc0I7QUFDckc7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNDQUFzQztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDhDQUE4QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEIsb0NBQW9DO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTLGVBQWU7QUFDNUUsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdCQUF3Qiw0Q0FBNEMsYUFBYTtBQUN6STtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0NBQWdDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw4Q0FBOEM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QixrREFBa0QsSUFBSSxxQkFBcUI7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QixtREFBbUQsSUFBSTtBQUNqSDtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUIsdUNBQXVDO0FBQ2pILHdEQUF3RCxxREFBcUQ7QUFDN0c7QUFDQSx5REFBeUQsZUFBZSxZQUFZO0FBQ3BGO0FBQ0Esa0lBQWtJLHVCQUF1QjtBQUN6SjtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHdCQUF3QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3RELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3RELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLDZEQUE2RCxrQkFBa0I7QUFDL0UsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSw2RUFBNkU7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3REFBd0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpRUFBaUU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNkNBQTZDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDhDQUE4QztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvREFBb0Q7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsdUNBQXVDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwrQkFBK0I7QUFDbEc7QUFDQTtBQUNBLG1FQUFtRSxvQkFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2QkFBNkI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2QkFBNkIsNEJBQTRCLElBQUk7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0RBQWtEO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCO0FBQ3JFO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDRDQUE0QztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsOENBQThDLDRDQUE0QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQyxnREFBZ0Q7QUFDbEYsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdGQUF3RjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdDQUFnQztBQUM3RjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw4Q0FBOEM7QUFDNUgsdUVBQXVFLDhDQUE4QztBQUNySDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0VBQWdFLG1CQUFtQiwrREFBK0Q7QUFDak07QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDZCQUE2QjtBQUMvRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtDQUFrQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEZBQTRGLGdDQUFnQztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCLHNDQUFzQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrRkFBa0Y7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3REFBd0Q7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLG9CQUFvQjtBQUMvRztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvREFBb0QscUJBQXFCLGVBQWU7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQiw2QkFBNkI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQ0FBbUM7QUFDakc7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsd0NBQXdDO0FBQ3pHO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0NBQWdDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQkFBK0I7QUFDL0U7QUFDQSxtRUFBbUUsb0VBQW9FO0FBQ3ZJO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1EQUFtRCxvQ0FBb0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0VBQXdFO0FBQzNIO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHNDQUFzQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0NBQWdDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixpRUFBaUUsc0NBQXNDO0FBQ3ZHO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esa0dBQWtHLHVCQUF1QjtBQUN6SDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiwwQkFBMEI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQXdEO0FBQ3ZFLGVBQWUsNkJBQTZCO0FBQzVDLDBDQUEwQyw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxvREFBb0QsMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkNBQTJDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRCwrQ0FBK0MsNkJBQTZCO0FBQzVFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QixtQ0FBbUM7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFFQUFxRSxJQUFJLE1BQU07QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwrQ0FBK0MsbUNBQW1DO0FBQ2xGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFLHVEQUF1RDtBQUNwSTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxnQkFBZ0I7QUFDdkY7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUI7QUFDMUU7QUFDQTtBQUNBLG9FQUFvRSx5Q0FBeUM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlDQUFpQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0NBQWtDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw4QkFBOEI7QUFDakc7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLDRDQUE0QywrQkFBK0IsK0JBQStCLCtCQUErQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVELDZEQUE2RCxzRUFBc0U7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLGlJQUFpSTtBQUNqSSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9CQUFvQjtBQUNoRjtBQUNBLGlPQUFpTztBQUNqTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsVUFBVTtBQUM1RTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0RBQWtELFlBQVksNEJBQTRCLGFBQWEsc0ZBQXNGO0FBQzdMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0NBQStDO0FBQ3RHLHdCQUF3QjtBQUN4QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCLGVBQWU7QUFDbEY7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDZCQUE2QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNkJBQTZCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw2QkFBNkI7QUFDakg7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDBCQUEwQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxVQUFVLFlBQVksZUFBZTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGtDQUFrQztBQUNsQyx1RUFBdUUsMkNBQTJDO0FBQ2xIO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNDQUFzQyxpQ0FBaUMsZ0JBQWdCO0FBQzdJO0FBQ0E7QUFDQSx5REFBeUQsNENBQTRDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMkZBQTJGLFlBQVksbURBQW1EO0FBQzFKO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyREFBMkQ7QUFDMUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQTBDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxzRUFBc0U7QUFDcEwsMERBQTBELFlBQVk7QUFDdEU7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsWUFBWTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsK0NBQStDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RiwyQkFBMkI7QUFDcEgsaUdBQWlHLHFDQUFxQztBQUN0SSxpRkFBaUYsNkJBQTZCO0FBQzlHO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkM7QUFDNUYsbURBQW1ELHdEQUF3RDtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFVBQVUsZUFBZTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwwREFBMEQ7QUFDMUQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsZ0RBQWdELDhCQUE4QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLDhEQUE4RCw4QkFBOEI7QUFDNUY7QUFDQTtBQUNBLGtFQUFrRSw4QkFBOEI7QUFDaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNDQUFzQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBLHdGQUF3RiwyQkFBMkI7QUFDbkg7QUFDQTtBQUNBLHVDQUF1QyxvRUFBb0U7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMEVBQTBFO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx1REFBdUQ7QUFDNUg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxzQkFBc0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsK0JBQStCO0FBQ2hJO0FBQ0EsMEdBQTBHLGdCQUFnQjtBQUMxSDtBQUNBLHdGQUF3RixnQkFBZ0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLDRDQUE0QztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILCtCQUErQjtBQUNuSiwwR0FBMEcsZ0JBQWdCO0FBQzFIO0FBQ0Esd0ZBQXdGLGdCQUFnQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsNENBQTRDO0FBQzVKO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxnQkFBZ0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLDRDQUE0QztBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixtQkFBbUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdLQUFnSyxxQkFBcUI7QUFDckw7QUFDQSxtRkFBbUYsVUFBVTtBQUM3RjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLDBDQUEwQyxHQUFHO0FBQzdDO0FBQ0E7QUFDQSxrRUFBa0UsdUVBQXVFO0FBQ3pJLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsdUZBQXVGLCtCQUErQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1FQUFtRTtBQUMvRyx5Q0FBeUMsd0NBQXdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMEJBQTBCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMENBQTBDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQSxnQ0FBZ0MsNkVBQTZFO0FBQzdHLGdEQUFnRCwyQkFBMkI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRyxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNENBQTRDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw0Q0FBNEM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyREFBMkQ7QUFDbEgsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLFVBQVU7QUFDVjtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQSxjQUFjLDZDQUE2QyxlQUFlO0FBQzFFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGdDQUFnQztBQUNoQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3RELDBDQUEwQyx1Q0FBdUMsR0FBRztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7O0FBRUE7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDs7QUFFQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLHVDQUF1QyxrQkFBa0I7O0FBRXpEOztBQUVBLEVBQUU7QUFDRjtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZSxNQUFNLGFBQWE7QUFDakg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhLG1CQUFtQixXQUFXLEtBQUssY0FBYztBQUMzRjtBQUNBO0FBQ0EsNkNBQTZDLFdBQVcsS0FBSyxjQUFjO0FBQzNFO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEVBQThFLHNCQUFzQixpQkFBaUIsZUFBZTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsVUFBVTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixrQkFBa0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxTQUFTO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGtCQUFrQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFVBQVU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxPQUFPO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlCQUFpQixxQkFBcUIsVUFBVTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsVUFBVTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDZCQUE2QjtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsaUNBQWlDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFDQUFxQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGtDQUFrQztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxLQUFLLHFCQUFxQiwwQkFBMEI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsOEJBQThCOztBQUVqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDhCQUE4QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLElBQUksWUFBWSxJQUFJLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSw0QkFBNEI7QUFDM0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLGNBQWM7QUFDN0IsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLDBCQUEwQjtBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxLQUFLO0FBQ0wsNERBQTREO0FBQzVEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQ0FBb0MsZ0VBQWdFLGlCQUFpQjtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0NBQW9DLHlFQUF5RSxpQkFBaUI7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsVUFBVTtBQUNWLHdFQUF3RTtBQUN4RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QixVQUFVO0FBQ1YsdUZBQXVGO0FBQ3ZGO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTs7QUFFQSxlQUFlLHFMQUF3RDtBQUN2RTtBQUNBLHVDQUF1Qyx3QkFBd0I7O0FBRSsxRDtBQUM5NUQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcY3JhYmRhby1hZ2VudFxcbWlkZW4td2ViLXR1dG9yaWFsc1xcbm9kZV9tb2R1bGVzXFxAZGVtb3gtbGFic1xcbWlkZW4tc2RrXFxkaXN0XFxDYXJnby1hY2JkOGFjNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGRleGllID0ge2V4cG9ydHM6IHt9fTtcblxuLypcbiAqIERleGllLmpzIC0gYSBtaW5pbWFsaXN0aWMgd3JhcHBlciBmb3IgSW5kZXhlZERCXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEJ5IERhdmlkIEZhaGxhbmRlciwgZGF2aWQuZmFobGFuZGVyQGdtYWlsLmNvbVxuICpcbiAqIFZlcnNpb24gNC4wLjgsIFdlZCBKdWwgMTAgMjAyNFxuICpcbiAqIGh0dHBzOi8vZGV4aWUub3JnXG4gKlxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuICovXG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA7XG5cdH0pKGNvbW1vbmpzR2xvYmFsLCAoZnVuY3Rpb24gKCkge1xuXHQgICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblx0ICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuXHQgICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXHQgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuXHQgICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5cdCAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5cdCAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cblx0ICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5cdCAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5cdCAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXHQgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfVxuXHQgICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblx0ICAgIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcblx0ICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuXHQgICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOlxuXHQgICAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuXHQgICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6XG5cdCAgICAgICAgICAgICAgICBjb21tb25qc0dsb2JhbDtcblxuXHQgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cztcblx0ICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblx0ICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIV9nbG9iYWwuUHJvbWlzZSkge1xuXHQgICAgICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBleHRlbmQob2JqLCBleHRlbnNpb24pIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpXG5cdCAgICAgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICAgICAga2V5cyhleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9XG5cdCAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cdCAgICB2YXIgX2hhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXHQgICAgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuXHQgICAgICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHByb3BzKHByb3RvLCBleHRlbnNpb24pIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJylcblx0ICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGdldFByb3RvKHByb3RvKSk7XG5cdCAgICAgICAgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8ga2V5cyA6IFJlZmxlY3Qub3duS2V5cykoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdCAgICBmdW5jdGlvbiBzZXRQcm9wKG9iaiwgcHJvcCwgZnVuY3Rpb25PckdldFNldCwgb3B0aW9ucykge1xuXHQgICAgICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdCAgICAgICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuXHQgICAgICAgICAgICB7IHZhbHVlOiBmdW5jdGlvbk9yR2V0U2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sIG9wdGlvbnMpKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcblx0ICAgICAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cdCAgICAgICAgICAgICAgICBzZXRQcm9wKENoaWxkLnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBDaGlsZCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXHQgICAgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuXHQgICAgICAgIHZhciBwZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuXHQgICAgICAgIHZhciBwcm90bztcblx0ICAgICAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcblx0ICAgIH1cblx0ICAgIHZhciBfc2xpY2UgPSBbXS5zbGljZTtcblx0ICAgIGZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcblx0ICAgICAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJncywgc3RhcnQsIGVuZCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuXHQgICAgICAgIHJldHVybiBvdmVycmlkZWRGYWN0b3J5KG9yaWdGdW5jKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFzc2VydChiKSB7XG5cdCAgICAgICAgaWYgKCFiKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYXNhcCQxKGZuKSB7XG5cdCAgICAgICAgaWYgKF9nbG9iYWwuc2V0SW1tZWRpYXRlKVxuXHQgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuXHQgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycmF5LCBleHRyYWN0b3IpIHtcblx0ICAgICAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGl0ZW0sIGkpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVBbmRWYWx1ZSA9IGV4dHJhY3RvcihpdGVtLCBpKTtcblx0ICAgICAgICAgICAgaWYgKG5hbWVBbmRWYWx1ZSlcblx0ICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sIHt9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnICYmIGhhc093bihvYmosIGtleVBhdGgpKVxuXHQgICAgICAgICAgICByZXR1cm4gb2JqW2tleVBhdGhdO1xuXHQgICAgICAgIGlmICgha2V5UGF0aClcblx0ICAgICAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgICAgICBpZiAodHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgIHZhciBydiA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleVBhdGgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsID0gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSk7XG5cdCAgICAgICAgICAgICAgICBydi5wdXNoKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG5cdCAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2tleVBhdGguc3Vic3RyKDAsIHBlcmlvZCldO1xuXHQgICAgICAgICAgICByZXR1cm4gaW5uZXJPYmogPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGdldEJ5S2V5UGF0aChpbm5lck9iaiwga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpIHtcblx0ICAgICAgICBpZiAoIW9iaiB8fCBrZXlQYXRoID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICBpZiAoJ2lzRnJvemVuJyBpbiBPYmplY3QgJiYgT2JqZWN0LmlzRnJvemVuKG9iaikpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICBpZiAodHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIGtleVBhdGgpIHtcblx0ICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4gdmFsdWUpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleVBhdGgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldLCB2YWx1ZVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcblx0ICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJyZW50S2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKDAsIHBlcmlvZCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nS2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0tleVBhdGggPT09IFwiXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoY3VycmVudEtleVBhdGgpKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2UoY3VycmVudEtleVBhdGgsIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmpbY3VycmVudEtleVBhdGhdID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpbY3VycmVudEtleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaW5uZXJPYmogfHwgIWhhc093bihvYmosIGN1cnJlbnRLZXlQYXRoKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSAob2JqW2N1cnJlbnRLZXlQYXRoXSA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaW5uZXJPYmosIHJlbWFpbmluZ0tleVBhdGgsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoa2V5UGF0aCkpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmouc3BsaWNlKGtleVBhdGgsIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBvYmpba2V5UGF0aF0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRlbEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB1bmRlZmluZWQpO1xuXHQgICAgICAgIGVsc2UgaWYgKCdsZW5ndGgnIGluIGtleVBhdGgpXG5cdCAgICAgICAgICAgIFtdLm1hcC5jYWxsKGtleVBhdGgsIGZ1bmN0aW9uIChrcCkge1xuXHQgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuXHQgICAgICAgIHZhciBydiA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG5cdCAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcblx0ICAgICAgICAgICAgICAgIHJ2W21dID0gb2JqW21dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cdCAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0O1xuXHQgICAgZnVuY3Rpb24gZmxhdHRlbihhKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYSk7XG5cdCAgICB9XG5cdCAgICB2YXIgaW50cmluc2ljVHlwZU5hbWVzID0gXCJCaWdVaW50NjRBcnJheSxCaWdJbnQ2NEFycmF5LEFycmF5LEJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxGaWxlU3lzdGVtRmlsZUhhbmRsZSxGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLEFycmF5QnVmZmVyLERhdGFWaWV3LFVpbnQ4Q2xhbXBlZEFycmF5LEltYWdlQml0bWFwLEltYWdlRGF0YSxNYXAsU2V0LENyeXB0b0tleVwiXG5cdCAgICAgICAgLnNwbGl0KCcsJykuY29uY2F0KGZsYXR0ZW4oWzgsIDE2LCAzMiwgNjRdLm1hcChmdW5jdGlvbiAobnVtKSB7IHJldHVybiBbXCJJbnRcIiwgXCJVaW50XCIsIFwiRmxvYXRcIl0ubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICsgbnVtICsgXCJBcnJheVwiOyB9KTsgfSkpKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIF9nbG9iYWxbdF07IH0pO1xuXHQgICAgdmFyIGludHJpbnNpY1R5cGVzID0gbmV3IFNldChpbnRyaW5zaWNUeXBlTmFtZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZ2xvYmFsW3RdOyB9KSk7XG5cdCAgICBmdW5jdGlvbiBjbG9uZVNpbXBsZU9iamVjdFRyZWUobykge1xuXHQgICAgICAgIHZhciBydiA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGsgaW4gbylcblx0ICAgICAgICAgICAgaWYgKGhhc093bihvLCBrKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHYgPSBvW2tdO1xuXHQgICAgICAgICAgICAgICAgcnZba10gPSAhdiB8fCB0eXBlb2YgdiAhPT0gJ29iamVjdCcgfHwgaW50cmluc2ljVHlwZXMuaGFzKHYuY29uc3RydWN0b3IpID8gdiA6IGNsb25lU2ltcGxlT2JqZWN0VHJlZSh2KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG9iamVjdElzRW1wdHkobykge1xuXHQgICAgICAgIGZvciAodmFyIGsgaW4gbylcblx0ICAgICAgICAgICAgaWYgKGhhc093bihvLCBrKSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHZhciBjaXJjdWxhclJlZnMgPSBudWxsO1xuXHQgICAgZnVuY3Rpb24gZGVlcENsb25lKGFueSkge1xuXHQgICAgICAgIGNpcmN1bGFyUmVmcyA9IG5ldyBXZWFrTWFwKCk7XG5cdCAgICAgICAgdmFyIHJ2ID0gaW5uZXJEZWVwQ2xvbmUoYW55KTtcblx0ICAgICAgICBjaXJjdWxhclJlZnMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGlubmVyRGVlcENsb25lKHgpIHtcblx0ICAgICAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKVxuXHQgICAgICAgICAgICByZXR1cm4geDtcblx0ICAgICAgICB2YXIgcnYgPSBjaXJjdWxhclJlZnMuZ2V0KHgpO1xuXHQgICAgICAgIGlmIChydilcblx0ICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgIGlmIChpc0FycmF5KHgpKSB7XG5cdCAgICAgICAgICAgIHJ2ID0gW107XG5cdCAgICAgICAgICAgIGNpcmN1bGFyUmVmcy5zZXQoeCwgcnYpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBydi5wdXNoKGlubmVyRGVlcENsb25lKHhbaV0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5oYXMoeC5jb25zdHJ1Y3RvcikpIHtcblx0ICAgICAgICAgICAgcnYgPSB4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG8oeCk7XG5cdCAgICAgICAgICAgIHJ2ID0gcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgPyB7fSA6IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuXHQgICAgICAgICAgICBjaXJjdWxhclJlZnMuc2V0KHgsIHJ2KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHgsIHByb3ApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZSh4W3Byb3BdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cdCAgICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblx0ICAgIGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG8pIHtcblx0ICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG5cdCAgICB9XG5cdCAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/XG5cdCAgICAgICAgU3ltYm9sLml0ZXJhdG9yIDpcblx0ICAgICAgICAnQEBpdGVyYXRvcic7XG5cdCAgICB2YXIgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgdmFyIGk7XG5cdCAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xuXHQgICAgfSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG5cdCAgICBmdW5jdGlvbiBkZWxBcnJheUl0ZW0oYSwgeCkge1xuXHQgICAgICAgIHZhciBpID0gYS5pbmRleE9mKHgpO1xuXHQgICAgICAgIGlmIChpID49IDApXG5cdCAgICAgICAgICAgIGEuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgIHJldHVybiBpID49IDA7XG5cdCAgICB9XG5cdCAgICB2YXIgTk9fQ0hBUl9BUlJBWSA9IHt9O1xuXHQgICAgZnVuY3Rpb24gZ2V0QXJyYXlPZihhcnJheUxpa2UpIHtcblx0ICAgICAgICB2YXIgaSwgYSwgeCwgaXQ7XG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXlMaWtlKSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMgPT09IE5PX0NIQVJfQVJSQVkgJiYgdHlwZW9mIGFycmF5TGlrZSA9PT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG5cdCAgICAgICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG5cdCAgICAgICAgICAgICAgICBhID0gW107XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKVxuXHQgICAgICAgICAgICAgICAgICAgIGEucHVzaCh4LnZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcblx0ICAgICAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuXHQgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhcnJheUxpa2VbaV07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSlcblx0ICAgICAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICByZXR1cm4gYTtcblx0ICAgIH1cblx0ICAgIHZhciBpc0FzeW5jRnVuY3Rpb24gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuXHQgICAgICAgID8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbic7IH1cblx0ICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG5cdCAgICB2YXIgZGV4aWVFcnJvck5hbWVzID0gW1xuXHQgICAgICAgICdNb2RpZnknLFxuXHQgICAgICAgICdCdWxrJyxcblx0ICAgICAgICAnT3BlbkZhaWxlZCcsXG5cdCAgICAgICAgJ1ZlcnNpb25DaGFuZ2UnLFxuXHQgICAgICAgICdTY2hlbWEnLFxuXHQgICAgICAgICdVcGdyYWRlJyxcblx0ICAgICAgICAnSW52YWxpZFRhYmxlJyxcblx0ICAgICAgICAnTWlzc2luZ0FQSScsXG5cdCAgICAgICAgJ05vU3VjaERhdGFiYXNlJyxcblx0ICAgICAgICAnSW52YWxpZEFyZ3VtZW50Jyxcblx0ICAgICAgICAnU3ViVHJhbnNhY3Rpb24nLFxuXHQgICAgICAgICdVbnN1cHBvcnRlZCcsXG5cdCAgICAgICAgJ0ludGVybmFsJyxcblx0ICAgICAgICAnRGF0YWJhc2VDbG9zZWQnLFxuXHQgICAgICAgICdQcmVtYXR1cmVDb21taXQnLFxuXHQgICAgICAgICdGb3JlaWduQXdhaXQnXG5cdCAgICBdO1xuXHQgICAgdmFyIGlkYkRvbUVycm9yTmFtZXMgPSBbXG5cdCAgICAgICAgJ1Vua25vd24nLFxuXHQgICAgICAgICdDb25zdHJhaW50Jyxcblx0ICAgICAgICAnRGF0YScsXG5cdCAgICAgICAgJ1RyYW5zYWN0aW9uSW5hY3RpdmUnLFxuXHQgICAgICAgICdSZWFkT25seScsXG5cdCAgICAgICAgJ1ZlcnNpb24nLFxuXHQgICAgICAgICdOb3RGb3VuZCcsXG5cdCAgICAgICAgJ0ludmFsaWRTdGF0ZScsXG5cdCAgICAgICAgJ0ludmFsaWRBY2Nlc3MnLFxuXHQgICAgICAgICdBYm9ydCcsXG5cdCAgICAgICAgJ1RpbWVvdXQnLFxuXHQgICAgICAgICdRdW90YUV4Y2VlZGVkJyxcblx0ICAgICAgICAnU3ludGF4Jyxcblx0ICAgICAgICAnRGF0YUNsb25lJ1xuXHQgICAgXTtcblx0ICAgIHZhciBlcnJvckxpc3QgPSBkZXhpZUVycm9yTmFtZXMuY29uY2F0KGlkYkRvbUVycm9yTmFtZXMpO1xuXHQgICAgdmFyIGRlZmF1bHRUZXh0cyA9IHtcblx0ICAgICAgICBWZXJzaW9uQ2hhbmdlZDogXCJEYXRhYmFzZSB2ZXJzaW9uIGNoYW5nZWQgYnkgb3RoZXIgZGF0YWJhc2UgY29ubmVjdGlvblwiLFxuXHQgICAgICAgIERhdGFiYXNlQ2xvc2VkOiBcIkRhdGFiYXNlIGhhcyBiZWVuIGNsb3NlZFwiLFxuXHQgICAgICAgIEFib3J0OiBcIlRyYW5zYWN0aW9uIGFib3J0ZWRcIixcblx0ICAgICAgICBUcmFuc2FjdGlvbkluYWN0aXZlOiBcIlRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBmYWlsZWRcIixcblx0ICAgICAgICBNaXNzaW5nQVBJOiBcIkluZGV4ZWREQiBBUEkgbWlzc2luZy4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vdGlueXVybC5jb20veTJ1dXZza2JcIlxuXHQgICAgfTtcblx0ICAgIGZ1bmN0aW9uIERleGllRXJyb3IobmFtZSwgbXNnKSB7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG5cdCAgICB9XG5cdCAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShFcnJvcikuZXh0ZW5kKHtcblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9XG5cdCAgICB9KTtcblx0ICAgIGZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpIHtcblx0ICAgICAgICByZXR1cm4gbXNnICsgXCIuIEVycm9yczogXCIgKyBPYmplY3Qua2V5cyhmYWlsdXJlcylcblx0ICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmYWlsdXJlc1trZXldLnRvU3RyaW5nKCk7IH0pXG5cdCAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIHMpIHsgcmV0dXJuIHMuaW5kZXhPZih2KSA9PT0gaTsgfSlcblx0ICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gTW9kaWZ5RXJyb3IobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG5cdCAgICAgICAgdGhpcy5mYWlsdXJlcyA9IGZhaWx1cmVzO1xuXHQgICAgICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG5cdCAgICAgICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG5cdCAgICAgICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG5cdCAgICB9XG5cdCAgICBkZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG5cdCAgICBmdW5jdGlvbiBCdWxrRXJyb3IobXNnLCBmYWlsdXJlcykge1xuXHQgICAgICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG5cdCAgICAgICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gZmFpbHVyZXNbcG9zXTsgfSk7XG5cdCAgICAgICAgdGhpcy5mYWlsdXJlc0J5UG9zID0gZmFpbHVyZXM7XG5cdCAgICAgICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCB0aGlzLmZhaWx1cmVzKTtcblx0ICAgIH1cblx0ICAgIGRlcml2ZShCdWxrRXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG5cdCAgICB2YXIgZXJybmFtZXMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHsgcmV0dXJuIChvYmpbbmFtZV0gPSBuYW1lICsgXCJFcnJvclwiLCBvYmopOyB9LCB7fSk7XG5cdCAgICB2YXIgQmFzZUV4Y2VwdGlvbiA9IERleGllRXJyb3I7XG5cdCAgICB2YXIgZXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuXHQgICAgICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG5cdCAgICAgICAgZnVuY3Rpb24gRGV4aWVFcnJvcihtc2dPcklubmVyLCBpbm5lcikge1xuXHQgICAgICAgICAgICB0aGlzLm5hbWUgPSBmdWxsTmFtZTtcblx0ICAgICAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiXCIuY29uY2F0KG1zZ09ySW5uZXIpLmNvbmNhdCghaW5uZXIgPyAnJyA6ICdcXG4gJyArIGlubmVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lciB8fCBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIi5jb25jYXQobXNnT3JJbm5lci5uYW1lLCBcIiBcIikuY29uY2F0KG1zZ09ySW5uZXIubWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gbXNnT3JJbm5lcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShCYXNlRXhjZXB0aW9uKTtcblx0ICAgICAgICBvYmpbbmFtZV0gPSBEZXhpZUVycm9yO1xuXHQgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9LCB7fSk7XG5cdCAgICBleGNlcHRpb25zLlN5bnRheCA9IFN5bnRheEVycm9yO1xuXHQgICAgZXhjZXB0aW9ucy5UeXBlID0gVHlwZUVycm9yO1xuXHQgICAgZXhjZXB0aW9ucy5SYW5nZSA9IFJhbmdlRXJyb3I7XG5cdCAgICB2YXIgZXhjZXB0aW9uTWFwID0gaWRiRG9tRXJyb3JOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuXHQgICAgICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG5cdCAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgIH0sIHt9KTtcblx0ICAgIGZ1bmN0aW9uIG1hcEVycm9yKGRvbUVycm9yLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuXHQgICAgICAgICAgICByZXR1cm4gZG9tRXJyb3I7XG5cdCAgICAgICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcblx0ICAgICAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG5cdCAgICAgICAgICAgIHNldFByb3AocnYsIFwic3RhY2tcIiwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcblx0ICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblx0ICAgIHZhciBmdWxsTmFtZUV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcblx0ICAgICAgICBpZiAoW1wiU3ludGF4XCIsIFwiVHlwZVwiLCBcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuXHQgICAgICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuXHQgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9LCB7fSk7XG5cdCAgICBmdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcblx0ICAgIGZ1bGxOYW1lRXhjZXB0aW9ucy5EZXhpZUVycm9yID0gRGV4aWVFcnJvcjtcblx0ICAgIGZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG5cblx0ICAgIGZ1bmN0aW9uIG5vcCgpIHsgfVxuXHQgICAgZnVuY3Rpb24gbWlycm9yKHZhbCkgeyByZXR1cm4gdmFsOyB9XG5cdCAgICBmdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcblx0ICAgICAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKVxuXHQgICAgICAgICAgICByZXR1cm4gZjI7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG5cdCAgICAgICAgaWYgKGYxID09PSBub3ApXG5cdCAgICAgICAgICAgIHJldHVybiBmMjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gcmVzO1xuXHQgICAgICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG5cdCAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG5cdCAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAob25zdWNjZXNzKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuXHQgICAgICAgICAgICBpZiAob25lcnJvcilcblx0ICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzMiAhPT0gdW5kZWZpbmVkID8gcmVzMiA6IHJlcztcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaG9va0RlbGV0aW5nQ2hhaW4oZjEsIGYyKSB7XG5cdCAgICAgICAgaWYgKGYxID09PSBub3ApXG5cdCAgICAgICAgICAgIHJldHVybiBmMjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG5cdCAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG5cdCAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKG9uc3VjY2Vzcylcblx0ICAgICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2Vzcztcblx0ICAgICAgICAgICAgaWYgKG9uZXJyb3IpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaG9va1VwZGF0aW5nQ2hhaW4oZjEsIGYyKSB7XG5cdCAgICAgICAgaWYgKGYxID09PSBub3ApXG5cdCAgICAgICAgICAgIHJldHVybiBmMjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmaWNhdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGV4dGVuZChtb2RpZmljYXRpb25zLCByZXMpO1xuXHQgICAgICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG5cdCAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG5cdCAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAob25zdWNjZXNzKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuXHQgICAgICAgICAgICBpZiAob25lcnJvcilcblx0ICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgP1xuXHQgICAgICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcblx0ICAgICAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMSA9PT0gbm9wKVxuXHQgICAgICAgICAgICByZXR1cm4gZjI7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICByZXR1cm4gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcHJvbWlzYWJsZUNoYWluKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMSA9PT0gbm9wKVxuXHQgICAgICAgICAgICByZXR1cm4gZjI7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpeiA9IHRoaXMsIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZjIuYXBwbHkodGhpeiwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZGVidWcgPSB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuXHQgICAgZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuXHQgICAgICAgIGRlYnVnID0gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBJTlRFUk5BTCA9IHt9O1xuXHQgICAgdmFyIFpPTkVfRUNIT19MSU1JVCA9IDEwMCwgX2EkMSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/XG5cdCAgICAgICAgW10gOlxuXHQgICAgICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBnbG9iYWxQID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLnN1YnRsZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbZ2xvYmFsUCwgZ2V0UHJvdG8oZ2xvYmFsUCksIGdsb2JhbFBdO1xuXHQgICAgICAgICAgICB2YXIgbmF0aXZlUCA9IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBuZXcgVWludDhBcnJheShbMF0pKTtcblx0ICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgIG5hdGl2ZVAsXG5cdCAgICAgICAgICAgICAgICBnZXRQcm90byhuYXRpdmVQKSxcblx0ICAgICAgICAgICAgICAgIGdsb2JhbFBcblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICB9KSgpLCByZXNvbHZlZE5hdGl2ZVByb21pc2UgPSBfYSQxWzBdLCBuYXRpdmVQcm9taXNlUHJvdG8gPSBfYSQxWzFdLCByZXNvbHZlZEdsb2JhbFByb21pc2UgPSBfYSQxWzJdLCBuYXRpdmVQcm9taXNlVGhlbiA9IG5hdGl2ZVByb21pc2VQcm90byAmJiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbjtcblx0ICAgIHZhciBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3Rvcjtcblx0ICAgIHZhciBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcblx0ICAgIGZ1bmN0aW9uIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCkge1xuXHQgICAgICAgIHF1ZXVlTWljcm90YXNrKHBoeXNpY2FsVGljayk7XG5cdCAgICB9XG5cdCAgICB2YXIgYXNhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuXHQgICAgICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG5cdCAgICAgICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG5cdCAgICAgICAgICAgIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCk7XG5cdCAgICAgICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHZhciBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlLFxuXHQgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlLFxuXHQgICAgdW5oYW5kbGVkRXJyb3JzID0gW10sXG5cdCAgICByZWplY3RpbmdFcnJvcnMgPSBbXSxcblx0ICAgIHJlamVjdGlvbk1hcHBlciA9IG1pcnJvcjtcblx0ICAgIHZhciBnbG9iYWxQU0QgPSB7XG5cdCAgICAgICAgaWQ6ICdnbG9iYWwnLFxuXHQgICAgICAgIGdsb2JhbDogdHJ1ZSxcblx0ICAgICAgICByZWY6IDAsXG5cdCAgICAgICAgdW5oYW5kbGVkczogW10sXG5cdCAgICAgICAgb251bmhhbmRsZWQ6IG5vcCxcblx0ICAgICAgICBwZ3A6IGZhbHNlLFxuXHQgICAgICAgIGVudjoge30sXG5cdCAgICAgICAgZmluYWxpemU6IG5vcFxuXHQgICAgfTtcblx0ICAgIHZhciBQU0QgPSBnbG9iYWxQU0Q7XG5cdCAgICB2YXIgbWljcm90aWNrUXVldWUgPSBbXTtcblx0ICAgIHZhciBudW1TY2hlZHVsZWRDYWxscyA9IDA7XG5cdCAgICB2YXIgdGlja0ZpbmFsaXplcnMgPSBbXTtcblx0ICAgIGZ1bmN0aW9uIERleGllUHJvbWlzZShmbikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuXHQgICAgICAgIHRoaXMuX2xpYiA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcblx0ICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcblx0ICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBhcmd1bWVudHNbMl07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgKytwc2QucmVmO1xuXHQgICAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG5cdCAgICB9XG5cdCAgICB2YXIgdGhlblByb3AgPSB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwc2QgPSBQU0QsIG1pY3JvVGFza0lkID0gdG90YWxFY2hvZXM7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVBd2FpdCA9ICFwc2QuZ2xvYmFsICYmIChwc2QgIT09IFBTRCB8fCBtaWNyb1Rhc2tJZCAhPT0gdG90YWxFY2hvZXMpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihfdGhpcywgbmV3IExpc3RlbmVyKG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgcmVzb2x2ZSwgcmVqZWN0LCBwc2QpKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnNvbGVUYXNrKVxuXHQgICAgICAgICAgICAgICAgICAgIHJ2Ll9jb25zb2xlVGFzayA9IHRoaXMuX2NvbnNvbGVUYXNrO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGVuO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuXHQgICAgICAgICAgICAgICAgdGhlblByb3AgOlxuXHQgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcblx0ICAgICAgICB0aGVuOiB0aGVuUHJvcCxcblx0ICAgICAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdCAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuXHQgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG5cdCAgICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBoYW5kbGVyID0gYXJndW1lbnRzWzFdO1xuXHQgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICA6IHRoaXMudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyciAmJiBlcnIubmFtZSA9PT0gdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmluYWxseTogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2VSZWplY3QoZXJyKTsgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdGltZW91dDogZnVuY3Rpb24gKG1zLCBtc2cpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIG1zIDwgSW5maW5pdHkgP1xuXHQgICAgICAgICAgICAgICAgbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KG5ldyBleGNlcHRpb25zLlRpbWVvdXQobXNnKSk7IH0sIG1zKTtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCkuZmluYWxseShjbGVhclRpbWVvdXQuYmluZChudWxsLCBoYW5kbGUpKTtcblx0ICAgICAgICAgICAgICAgIH0pIDogdGhpcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpXG5cdCAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdEZXhpZS5Qcm9taXNlJyk7XG5cdCAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcblx0ICAgIGZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcblx0ICAgICAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuXHQgICAgICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG5cdCAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcblx0ICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcblx0ICAgICAgICB0aGlzLnBzZCA9IHpvbmU7XG5cdCAgICB9XG5cdCAgICBwcm9wcyhEZXhpZVByb21pc2UsIHtcblx0ICAgICAgICBhbGw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuXHQgICAgICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcblx0ICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7IH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZXhpZVByb21pc2UpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgdHJ1ZSwgdmFsdWUpO1xuXHQgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByZWplY3Q6IFByb21pc2VSZWplY3QsXG5cdCAgICAgICAgcmFjZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTsgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgUFNEOiB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUFNEOyB9LFxuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gUFNEID0gdmFsdWU7IH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHRvdGFsRWNob2VzOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG90YWxFY2hvZXM7IH0gfSxcblx0ICAgICAgICBuZXdQU0Q6IG5ld1Njb3BlLFxuXHQgICAgICAgIHVzZVBTRDogdXNlUFNELFxuXHQgICAgICAgIHNjaGVkdWxlcjoge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzYXA7IH0sXG5cdCAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IGFzYXAgPSB2YWx1ZTsgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmVqZWN0aW9uTWFwcGVyOiB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0aW9uTWFwcGVyOyB9LFxuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZWplY3Rpb25NYXBwZXIgPSB2YWx1ZTsgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZm9sbG93OiBmdW5jdGlvbiAoZm4sIHpvbmVQcm9wcykge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwc2QgPSBQU0Q7XG5cdCAgICAgICAgICAgICAgICAgICAgcHNkLnVuaGFuZGxlZHMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBwc2Qub251bmhhbmRsZWQgPSByZWplY3Q7XG5cdCAgICAgICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuaGFuZGxlZHMubGVuZ3RoID09PSAwID8gcmVzb2x2ZSgpIDogcmVqZWN0KF90aGlzLnVuaGFuZGxlZHNbMF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCBwc2QuZmluYWxpemUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZuKCk7XG5cdCAgICAgICAgICAgICAgICB9LCB6b25lUHJvcHMsIHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgaWYgKE5hdGl2ZVByb21pc2UpIHtcblx0ICAgICAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbGxTZXR0bGVkKVxuXHQgICAgICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbGxTZXR0bGVkXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHJlc3VsdHNbaV0gPSB7IHN0YXR1czogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07IH0sIGZ1bmN0aW9uIChyZWFzb24pIHsgcmV0dXJuIHJlc3VsdHNbaV0gPSB7IHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9OyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpOyB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKE5hdGl2ZVByb21pc2UuYW55ICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gJ3VuZGVmaW5lZCcpXG5cdCAgICAgICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFueVwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10pKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7IH0sIGZ1bmN0aW9uIChmYWlsdXJlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW2ldID0gZmFpbHVyZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoZmFpbHVyZXMpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZm4pIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHByb21pc2UpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihyZXNvbHZlLCByZWplY3QpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcblx0ICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcblx0ICAgICAgICByZWplY3RpbmdFcnJvcnMucHVzaChyZWFzb24pO1xuXHQgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG5cdCAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcblx0ICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcblx0ICAgICAgICBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpO1xuXHQgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcblx0ICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spXG5cdCAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSkge1xuXHQgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9taXNlLl9saXN0ZW5lcnM7XG5cdCAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwc2QgPSBwcm9taXNlLl9QU0Q7XG5cdCAgICAgICAgLS1wc2QucmVmIHx8IHBzZC5maW5hbGl6ZSgpO1xuXHQgICAgICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuXHQgICAgICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuXHQgICAgICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG5cdCAgICAgICAgICAgIH0sIFtdKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHByb21pc2UuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY2IgPSBwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLm9uRnVsZmlsbGVkIDogbGlzdGVuZXIub25SZWplY3RlZDtcblx0ICAgICAgICBpZiAoY2IgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpKHByb21pc2UuX3ZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgKytsaXN0ZW5lci5wc2QucmVmO1xuXHQgICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG5cdCAgICAgICAgYXNhcChjYWxsTGlzdGVuZXIsIFtjYiwgcHJvbWlzZSwgbGlzdGVuZXJdKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihjYiwgcHJvbWlzZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuXHQgICAgICAgICAgICBpZiAoIXByb21pc2UuX3N0YXRlICYmIHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpXG5cdCAgICAgICAgICAgICAgICByZWplY3RpbmdFcnJvcnMgPSBbXTtcblx0ICAgICAgICAgICAgcmV0ID0gZGVidWcgJiYgcHJvbWlzZS5fY29uc29sZVRhc2sgPyBwcm9taXNlLl9jb25zb2xlVGFzay5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IodmFsdWUpOyB9KSA6IGNiKHZhbHVlKTtcblx0ICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9zdGF0ZSAmJiByZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcblx0ICAgICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG5cdCAgICAgICAgICAgIC0tbGlzdGVuZXIucHNkLnJlZiB8fCBsaXN0ZW5lci5wc2QuZmluYWxpemUoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG5cdCAgICAgICAgdXNlUFNEKGdsb2JhbFBTRCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBiZWdpbk1pY3JvVGlja1Njb3BlKCkgJiYgZW5kTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGJlZ2luTWljcm9UaWNrU2NvcGUoKSB7XG5cdCAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gaXNPdXRzaWRlTWljcm9UaWNrO1xuXHQgICAgICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IGZhbHNlO1xuXHQgICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG5cdCAgICAgICAgcmV0dXJuIHdhc1Jvb3RFeGVjO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZW5kTWljcm9UaWNrU2NvcGUoKSB7XG5cdCAgICAgICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcblx0ICAgICAgICBkbyB7XG5cdCAgICAgICAgICAgIHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcblx0ICAgICAgICAgICAgICAgIG1pY3JvdGlja1F1ZXVlID0gW107XG5cdCAgICAgICAgICAgICAgICBsID0gY2FsbGJhY2tzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNhbGxiYWNrc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtWzBdLmFwcGx5KG51bGwsIGl0ZW1bMV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCk7XG5cdCAgICAgICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcblx0ICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcblx0ICAgICAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcblx0ICAgICAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcblx0ICAgICAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcblx0ICAgICAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG5cdCAgICAgICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcblx0ICAgICAgICB3aGlsZSAoaSlcblx0ICAgICAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKGZuKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuXHQgICAgICAgICAgICBmbigpO1xuXHQgICAgICAgICAgICB0aWNrRmluYWxpemVycy5zcGxpY2UodGlja0ZpbmFsaXplcnMuaW5kZXhPZihmaW5hbGl6ZXIpLCAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGlja0ZpbmFsaXplcnMucHVzaChmaW5hbGl6ZXIpO1xuXHQgICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG5cdCAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcblx0ICAgICAgICB9LCBbXSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcblx0ICAgICAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWU7IH0pKVxuXHQgICAgICAgICAgICB1bmhhbmRsZWRFcnJvcnMucHVzaChwcm9taXNlKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG5cdCAgICAgICAgdmFyIGkgPSB1bmhhbmRsZWRFcnJvcnMubGVuZ3RoO1xuXHQgICAgICAgIHdoaWxlIChpKVxuXHQgICAgICAgICAgICBpZiAodW5oYW5kbGVkRXJyb3JzWy0taV0uX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gUHJvbWlzZVJlamVjdChyZWFzb24pIHtcblx0ICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgZmFsc2UsIHJlYXNvbik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB3cmFwKGZuLCBlcnJvckNhdGNoZXIpIHtcblx0ICAgICAgICB2YXIgcHNkID0gUFNEO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKSwgb3V0ZXJTY29wZSA9IFBTRDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIGVycm9yQ2F0Y2hlciAmJiBlcnJvckNhdGNoZXIoZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuXHQgICAgICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgdmFyIHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMCB9O1xuXHQgICAgdmFyIHRhc2tDb3VudGVyID0gMDtcblx0ICAgIHZhciB6b25lU3RhY2sgPSBbXTtcblx0ICAgIHZhciB6b25lRWNob2VzID0gMDtcblx0ICAgIHZhciB0b3RhbEVjaG9lcyA9IDA7XG5cdCAgICB2YXIgem9uZV9pZF9jb3VudGVyID0gMDtcblx0ICAgIGZ1bmN0aW9uIG5ld1Njb3BlKGZuLCBwcm9wcywgYTEsIGEyKSB7XG5cdCAgICAgICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuXHQgICAgICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG5cdCAgICAgICAgcHNkLnJlZiA9IDA7XG5cdCAgICAgICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuXHQgICAgICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuXHQgICAgICAgIGdsb2JhbFBTRC5lbnY7XG5cdCAgICAgICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcblx0ICAgICAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuXHQgICAgICAgICAgICBQcm9taXNlUHJvcDogeyB2YWx1ZTogRGV4aWVQcm9taXNlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG5cdCAgICAgICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcblx0ICAgICAgICAgICAgcmFjZTogRGV4aWVQcm9taXNlLnJhY2UsXG5cdCAgICAgICAgICAgIGFsbFNldHRsZWQ6IERleGllUHJvbWlzZS5hbGxTZXR0bGVkLFxuXHQgICAgICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG5cdCAgICAgICAgICAgIHJlc29sdmU6IERleGllUHJvbWlzZS5yZXNvbHZlLFxuXHQgICAgICAgICAgICByZWplY3Q6IERleGllUHJvbWlzZS5yZWplY3QsXG5cdCAgICAgICAgfSA6IHt9O1xuXHQgICAgICAgIGlmIChwcm9wcylcblx0ICAgICAgICAgICAgZXh0ZW5kKHBzZCwgcHJvcHMpO1xuXHQgICAgICAgICsrcGFyZW50LnJlZjtcblx0ICAgICAgICBwc2QuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC0tdGhpcy5wYXJlbnQucmVmIHx8IHRoaXMucGFyZW50LmZpbmFsaXplKCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgcnYgPSB1c2VQU0QocHNkLCBmbiwgYTEsIGEyKTtcblx0ICAgICAgICBpZiAocHNkLnJlZiA9PT0gMClcblx0ICAgICAgICAgICAgcHNkLmZpbmFsaXplKCk7XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG5cdCAgICAgICAgaWYgKCF0YXNrLmlkKVxuXHQgICAgICAgICAgICB0YXNrLmlkID0gKyt0YXNrQ291bnRlcjtcblx0ICAgICAgICArK3Rhc2suYXdhaXRzO1xuXHQgICAgICAgIHRhc2suZWNob2VzICs9IFpPTkVfRUNIT19MSU1JVDtcblx0ICAgICAgICByZXR1cm4gdGFzay5pZDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuXHQgICAgICAgIGlmICghdGFzay5hd2FpdHMpXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICBpZiAoLS10YXNrLmF3YWl0cyA9PT0gMClcblx0ICAgICAgICAgICAgdGFzay5pZCA9IDA7XG5cdCAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyAqIFpPTkVfRUNIT19MSU1JVDtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICgoJycgKyBuYXRpdmVQcm9taXNlVGhlbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpID09PSAtMSkge1xuXHQgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBub3A7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMocG9zc2libGVQcm9taXNlKSB7XG5cdCAgICAgICAgaWYgKHRhc2suZWNob2VzICYmIHBvc3NpYmxlUHJvbWlzZSAmJiBwb3NzaWJsZVByb21pc2UuY29uc3RydWN0b3IgPT09IE5hdGl2ZVByb21pc2UpIHtcblx0ICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG5cdCAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwb3NzaWJsZVByb21pc2U7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB6b25lRW50ZXJFY2hvKHRhcmdldFpvbmUpIHtcblx0ICAgICAgICArK3RvdGFsRWNob2VzO1xuXHQgICAgICAgIGlmICghdGFzay5lY2hvZXMgfHwgLS10YXNrLmVjaG9lcyA9PT0gMCkge1xuXHQgICAgICAgICAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzID0gdGFzay5pZCA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG5cdCAgICAgICAgc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcblx0ICAgICAgICB2YXIgem9uZSA9IHpvbmVTdGFja1t6b25lU3RhY2subGVuZ3RoIC0gMV07XG5cdCAgICAgICAgem9uZVN0YWNrLnBvcCgpO1xuXHQgICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgYkVudGVyaW5nWm9uZSkge1xuXHQgICAgICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcblx0ICAgICAgICBpZiAoYkVudGVyaW5nWm9uZSA/IHRhc2suZWNob2VzICYmICghem9uZUVjaG9lcysrIHx8IHRhcmdldFpvbmUgIT09IFBTRCkgOiB6b25lRWNob2VzICYmICghLS16b25lRWNob2VzIHx8IHRhcmdldFpvbmUgIT09IFBTRCkpIHtcblx0ICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soYkVudGVyaW5nWm9uZSA/IHpvbmVFbnRlckVjaG8uYmluZChudWxsLCB0YXJnZXRab25lKSA6IHpvbmVMZWF2ZUVjaG8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGFyZ2V0Wm9uZSA9PT0gUFNEKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgUFNEID0gdGFyZ2V0Wm9uZTtcblx0ICAgICAgICBpZiAoY3VycmVudFpvbmUgPT09IGdsb2JhbFBTRClcblx0ICAgICAgICAgICAgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5cdCAgICAgICAgaWYgKHBhdGNoR2xvYmFsUHJvbWlzZSkge1xuXHQgICAgICAgICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IGdsb2JhbFBTRC5lbnYuUHJvbWlzZTtcblx0ICAgICAgICAgICAgdmFyIHRhcmdldEVudiA9IHRhcmdldFpvbmUuZW52O1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFpvbmUuZ2xvYmFsIHx8IHRhcmdldFpvbmUuZ2xvYmFsKSB7XG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2dsb2JhbCwgJ1Byb21pc2UnLCB0YXJnZXRFbnYuUHJvbWlzZVByb3ApO1xuXHQgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGwgPSB0YXJnZXRFbnYuYWxsO1xuXHQgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG5cdCAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlc29sdmUgPSB0YXJnZXRFbnYucmVzb2x2ZTtcblx0ICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVqZWN0ID0gdGFyZ2V0RW52LnJlamVjdDtcblx0ICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYWxsU2V0dGxlZClcblx0ICAgICAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQgPSB0YXJnZXRFbnYuYWxsU2V0dGxlZDtcblx0ICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYW55KVxuXHQgICAgICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHNuYXBTaG90KCkge1xuXHQgICAgICAgIHZhciBHbG9iYWxQcm9taXNlID0gX2dsb2JhbC5Qcm9taXNlO1xuXHQgICAgICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG5cdCAgICAgICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG5cdCAgICAgICAgICAgIFByb21pc2VQcm9wOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9nbG9iYWwsIFwiUHJvbWlzZVwiKSxcblx0ICAgICAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcblx0ICAgICAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuXHQgICAgICAgICAgICBhbGxTZXR0bGVkOiBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQsXG5cdCAgICAgICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG5cdCAgICAgICAgICAgIHJlc29sdmU6IEdsb2JhbFByb21pc2UucmVzb2x2ZSxcblx0ICAgICAgICAgICAgcmVqZWN0OiBHbG9iYWxQcm9taXNlLnJlamVjdCxcblx0ICAgICAgICB9IDoge307XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB1c2VQU0QocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuXHQgICAgICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuXHQgICAgICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBvdXRlclpvbmUgPSBQU0Q7XG5cdCAgICAgICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuXHQgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgc3dpdGNoVG9ab25lKHpvbmUsIHRydWUpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJab25lLCBmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2xlYW51cClcblx0ICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZXhlY0luR2xvYmFsQ29udGV4dChjYikge1xuXHQgICAgICAgIGlmIChQcm9taXNlID09PSBOYXRpdmVQcm9taXNlICYmIHRhc2suZWNob2VzID09PSAwKSB7XG5cdCAgICAgICAgICAgIGlmICh6b25lRWNob2VzID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBjYigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayhjYik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciByZWplY3Rpb24gPSBEZXhpZVByb21pc2UucmVqZWN0O1xuXG5cdCAgICBmdW5jdGlvbiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG5cdCAgICAgICAgaWYgKCFkYi5pZGJkYiB8fCAoIWRiLl9zdGF0ZS5vcGVuQ29tcGxldGUgJiYgKCFQU0QubGV0VGhyb3VnaCAmJiAhZGIuX3ZpcCkpKSB7XG5cdCAgICAgICAgICAgIGlmIChkYi5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghZGIuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghZGIuX3N0YXRlLmF1dG9PcGVuKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG5cdCAgICAgICAgICAgICAgICBkYi5vcGVuKCkuY2F0Y2gobm9wKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbik7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJhbnMuX3Byb21pc2UobW9kZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0cmFucyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpXG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMuY29tbWl0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kZSA9PT0gJ3JlYWRvbmx5JyA/IHJlc3VsdCA6IHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzdWx0OyB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgREVYSUVfVkVSU0lPTiA9ICc0LjAuOCc7XG5cdCAgICB2YXIgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG5cdCAgICB2YXIgbWluS2V5ID0gLUluZmluaXR5O1xuXHQgICAgdmFyIElOVkFMSURfS0VZX0FSR1VNRU5UID0gXCJJbnZhbGlkIGtleSBwcm92aWRlZC4gS2V5cyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLCBudW1iZXIsIERhdGUgb3IgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgRGF0ZT4uXCI7XG5cdCAgICB2YXIgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG5cdCAgICB2YXIgY29ubmVjdGlvbnMgPSBbXTtcblx0ICAgIHZhciBEQk5BTUVTX0RCID0gJ19fZGJuYW1lcyc7XG5cdCAgICB2YXIgUkVBRE9OTFkgPSAncmVhZG9ubHknO1xuXHQgICAgdmFyIFJFQURXUklURSA9ICdyZWFkd3JpdGUnO1xuXG5cdCAgICBmdW5jdGlvbiBjb21iaW5lKGZpbHRlcjEsIGZpbHRlcjIpIHtcblx0ICAgICAgICByZXR1cm4gZmlsdGVyMSA/XG5cdCAgICAgICAgICAgIGZpbHRlcjIgP1xuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGZpbHRlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSA6XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIxIDpcblx0ICAgICAgICAgICAgZmlsdGVyMjtcblx0ICAgIH1cblxuXHQgICAgdmFyIEFueVJhbmdlID0ge1xuXHQgICAgICAgIHR5cGU6IDMgLFxuXHQgICAgICAgIGxvd2VyOiAtSW5maW5pdHksXG5cdCAgICAgICAgbG93ZXJPcGVuOiBmYWxzZSxcblx0ICAgICAgICB1cHBlcjogW1tdXSxcblx0ICAgICAgICB1cHBlck9wZW46IGZhbHNlXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSBcInN0cmluZ1wiICYmICEvXFwuLy50ZXN0KGtleVBhdGgpXG5cdCAgICAgICAgICAgID8gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9ialtrZXlQYXRoXSA9PT0gdW5kZWZpbmVkICYmIChrZXlQYXRoIGluIG9iaikpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvYmogPSBkZWVwQ2xvbmUob2JqKTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gRW50aXR5KCkge1xuXHQgICAgICAgIHRocm93IGV4Y2VwdGlvbnMuVHlwZSgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjbXAoYSwgYikge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHZhciB0YSA9IHR5cGUoYSk7XG5cdCAgICAgICAgICAgIHZhciB0YiA9IHR5cGUoYik7XG5cdCAgICAgICAgICAgIGlmICh0YSAhPT0gdGIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0YSA9PT0gJ0FycmF5Jylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YiA9PT0gJ0FycmF5Jylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdiaW5hcnknKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRiID09PSAnYmluYXJ5Jylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRiID09PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdEYXRlJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YiAhPT0gJ0RhdGUnKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc3dpdGNoICh0YSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuXHQgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVVaW50OEFycmF5cyhnZXRVaW50OEFycmF5KGEpLCBnZXRVaW50OEFycmF5KGIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhc2UgJ0FycmF5Jzpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhhLCBiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoX2EpIHsgfVxuXHQgICAgICAgIHJldHVybiBOYU47XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGEsIGIpIHtcblx0ICAgICAgICB2YXIgYWwgPSBhLmxlbmd0aDtcblx0ICAgICAgICB2YXIgYmwgPSBiLmxlbmd0aDtcblx0ICAgICAgICB2YXIgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciByZXMgPSBjbXAoYVtpXSwgYltpXSk7XG5cdCAgICAgICAgICAgIGlmIChyZXMgIT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoYSwgYikge1xuXHQgICAgICAgIHZhciBhbCA9IGEubGVuZ3RoO1xuXHQgICAgICAgIHZhciBibCA9IGIubGVuZ3RoO1xuXHQgICAgICAgIHZhciBsID0gYWwgPCBibCA/IGFsIDogYmw7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHR5cGUoeCkge1xuXHQgICAgICAgIHZhciB0ID0gdHlwZW9mIHg7XG5cdCAgICAgICAgaWYgKHQgIT09ICdvYmplY3QnKVxuXHQgICAgICAgICAgICByZXR1cm4gdDtcblx0ICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKVxuXHQgICAgICAgICAgICByZXR1cm4gJ2JpbmFyeSc7XG5cdCAgICAgICAgdmFyIHRzVGFnID0gdG9TdHJpbmdUYWcoeCk7XG5cdCAgICAgICAgcmV0dXJuIHRzVGFnID09PSAnQXJyYXlCdWZmZXInID8gJ2JpbmFyeScgOiB0c1RhZztcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldFVpbnQ4QXJyYXkoYSkge1xuXHQgICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSlcblx0ICAgICAgICAgICAgcmV0dXJuIGE7XG5cdCAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhKSlcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgVGFibGUgPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBUYWJsZSgpIHtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLl90cmFucyA9IGZ1bmN0aW9uIChtb2RlLCBmbiwgd3JpdGVMb2NrZWQpIHtcblx0ICAgICAgICAgICAgdmFyIHRyYW5zID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuXHQgICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuXHQgICAgICAgICAgICB2YXIgdGFzayA9IGRlYnVnICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmNyZWF0ZVRhc2sgJiYgY29uc29sZS5jcmVhdGVUYXNrKFwiRGV4aWU6IFwiLmNvbmNhdChtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWQnIDogJ3dyaXRlJywgXCIgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCB0cmFucykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0cmFucy5zY2hlbWFbdGFibGVOYW1lXSlcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm4odHJhbnMuaWRidHJhbnMsIHRyYW5zKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcCA9IHRyYW5zICYmIHRyYW5zLmRiLl9ub3ZpcCA9PT0gdGhpcy5kYi5fbm92aXAgP1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zID09PSBQU0QudHJhbnMgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKTsgfSwgeyB0cmFuczogdHJhbnMsIHRyYW5zbGVzczogUFNELnRyYW5zbGVzcyB8fCBQU0QgfSkgOlxuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBUcmFuc2FjdGlvbih0aGlzLmRiLCBtb2RlLCBbdGhpcy5uYW1lXSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhc2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBwLl9jb25zb2xlVGFzayA9IHRhc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgcCA9IHAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuXHQgICAgICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5T3JDcml0LCBjYikge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoa2V5T3JDcml0KS5maXJzdChjYik7XG5cdCAgICAgICAgICAgIGlmIChrZXlPckNyaXQgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHlwZShcIkludmFsaWQgYXJndW1lbnQgdG8gVGFibGUuZ2V0KClcIikpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5nZXQoeyB0cmFuczogdHJhbnMsIGtleToga2V5T3JDcml0IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKTsgfSk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGluZGV4T3JDcml0KSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGluZGV4T3JDcml0KTtcblx0ICAgICAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIFwiW1wiLmNvbmNhdChpbmRleE9yQ3JpdC5qb2luKCcrJyksIFwiXVwiKSk7XG5cdCAgICAgICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoaW5kZXhPckNyaXQpO1xuXHQgICAgICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG5cdCAgICAgICAgICAgICAgICAgICAgLmVxdWFscyhpbmRleE9yQ3JpdFtrZXlQYXRoc1swXV0pO1xuXHQgICAgICAgICAgICB2YXIgY29tcG91bmRJbmRleCA9IHRoaXMuc2NoZW1hLmluZGV4ZXMuY29uY2F0KHRoaXMuc2NoZW1hLnByaW1LZXkpLmZpbHRlcihmdW5jdGlvbiAoaXgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpeC5jb21wb3VuZCAmJlxuXHQgICAgICAgICAgICAgICAgICAgIGtleVBhdGhzLmV2ZXJ5KGZ1bmN0aW9uIChrZXlQYXRoKSB7IHJldHVybiBpeC5rZXlQYXRoLmluZGV4T2Yoa2V5UGF0aCkgPj0gMDsgfSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVBhdGhzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRocy5pbmRleE9mKGl4LmtleVBhdGhbaV0pID09PSAtMSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEua2V5UGF0aC5sZW5ndGggLSBiLmtleVBhdGgubGVuZ3RoOyB9KVswXTtcblx0ICAgICAgICAgICAgaWYgKGNvbXBvdW5kSW5kZXggJiYgdGhpcy5kYi5fbWF4S2V5ICE9PSBtYXhTdHJpbmcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoc0luVmFsaWRPcmRlciA9IGNvbXBvdW5kSW5kZXgua2V5UGF0aC5zbGljZSgwLCBrZXlQYXRocy5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNJblZhbGlkT3JkZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgLmVxdWFscyhrZXlQYXRoc0luVmFsaWRPcmRlci5tYXAoZnVuY3Rpb24gKGtwKSB7IHJldHVybiBpbmRleE9yQ3JpdFtrcF07IH0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIWNvbXBvdW5kSW5kZXggJiYgZGVidWcpXG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgcXVlcnkgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGluZGV4T3JDcml0KSwgXCIgb24gXCIpLmNvbmNhdCh0aGlzLm5hbWUsIFwiIHdvdWxkIGJlbmVmaXQgZnJvbSBhIFwiKSArXG5cdCAgICAgICAgICAgICAgICAgICAgXCJjb21wb3VuZCBpbmRleCBbXCIuY29uY2F0KGtleVBhdGhzLmpvaW4oJysnKSwgXCJdXCIpKTtcblx0ICAgICAgICAgICAgdmFyIGlkeEJ5TmFtZSA9IHRoaXMuc2NoZW1hLmlkeEJ5TmFtZTtcblx0ICAgICAgICAgICAgdmFyIGlkYiA9IHRoaXMuZGIuX2RlcHMuaW5kZXhlZERCO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGlkYi5jbXAoYSwgYikgPT09IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9hID0ga2V5UGF0aHMucmVkdWNlKGZ1bmN0aW9uIChfYSwga2V5UGF0aCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IF9hWzBdLCBwcmV2RmlsdGVyRm4gPSBfYVsxXTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4T3JDcml0W2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4IHx8ICFpbmRleCA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmUocHJldkZpbHRlckZuLCBpbmRleCAmJiBpbmRleC5tdWx0aSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHByb3ApICYmIHByb3Auc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gZXF1YWxzKHZhbHVlLCBpdGVtKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGVxdWFscyh2YWx1ZSwgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpKTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmV2RmlsdGVyRm5cblx0ICAgICAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgIH0sIFtudWxsLCBudWxsXSksIGlkeCA9IF9hWzBdLCBmaWx0ZXJGdW5jdGlvbiA9IF9hWzFdO1xuXHQgICAgICAgICAgICByZXR1cm4gaWR4ID9cblx0ICAgICAgICAgICAgICAgIHRoaXMud2hlcmUoaWR4Lm5hbWUpLmVxdWFscyhpbmRleE9yQ3JpdFtpZHgua2V5UGF0aF0pXG5cdCAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuXHQgICAgICAgICAgICAgICAgY29tcG91bmRJbmRleCA/XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGtleVBhdGhzKS5lcXVhbHMoJycpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKHRoZW5TaG9ydGN1dCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkub2Zmc2V0KG9mZnNldCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobnVtUm93cykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5saW1pdChudW1Sb3dzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goY2FsbGJhY2spO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAodGhlblNob3J0Y3V0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkodGhlblNob3J0Y3V0KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS50b0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMpKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5vcmRlckJ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGlzQXJyYXkoaW5kZXgpID9cblx0ICAgICAgICAgICAgICAgIFwiW1wiLmNvbmNhdChpbmRleC5qb2luKCcrJyksIFwiXVwiKSA6XG5cdCAgICAgICAgICAgICAgICBpbmRleCkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnJldmVyc2UoKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5tYXBUb0NsYXNzID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGRiID0gX2EuZGIsIHRhYmxlTmFtZSA9IF9hLm5hbWU7XG5cdCAgICAgICAgICAgIHRoaXMuc2NoZW1hLm1hcHBlZENsYXNzID0gY29uc3RydWN0b3I7XG5cdCAgICAgICAgICAgIGlmIChjb25zdHJ1Y3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBFbnRpdHkpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwiZGJcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiOyB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWJsZU5hbWU7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG5cdCAgICAgICAgICAgICAgICB9KGNvbnN0cnVjdG9yKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGluaGVyaXRlZFByb3BzID0gbmV3IFNldCgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTsgcHJvdG87IHByb3RvID0gZ2V0UHJvdG8ocHJvdG8pKSB7XG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIGluaGVyaXRlZFByb3BzLmFkZChwcm9wTmFtZSk7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZWFkSG9vayA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgICAgIGlmICghb2JqKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmhlcml0ZWRQcm9wcy5oYXMobSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNbbV0gPSBvYmpbbV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhvb2sucmVhZGluZy51bnN1YnNjcmliZSh0aGlzLnNjaGVtYS5yZWFkSG9vayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcblx0ICAgICAgICAgICAgdGhpcy5ob29rKFwicmVhZGluZ1wiLCByZWFkSG9vayk7XG5cdCAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5kZWZpbmVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcFRvQ2xhc3MoQ2xhc3MpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG5cdCAgICAgICAgICAgIHZhciBvYmpUb0FkZCA9IG9iajtcblx0ICAgICAgICAgICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuXHQgICAgICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCwgdmFsdWVzOiBbb2JqVG9BZGRdIH0pO1xuXHQgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0OyB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxhc3RSZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoa2V5T3JPYmplY3QsIG1vZGlmaWNhdGlvbnMpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlPck9iamVjdCA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoa2V5T3JPYmplY3QpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXkpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXlPck9iamVjdCkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcblx0ICAgICAgICAgICAgdmFyIG9ialRvQWRkID0gb2JqO1xuXHQgICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG5cdCAgICAgICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAncHV0JywgdmFsdWVzOiBbb2JqVG9BZGRdLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCB9KTsgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0OyB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxhc3RSZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldIH0pOyB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlUmFuZ2UnLCByYW5nZTogQW55UmFuZ2UgfSk7IH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQ7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtHZXQgPSBmdW5jdGlvbiAoa2V5cykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5nZXRNYW55KHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLFxuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFuc1xuXHQgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcyk7IH0pOyB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0FkZCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG5cdCAgICAgICAgICAgIHZhciB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleVBhdGggJiYga2V5cylcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3RzLm1hcCh3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSkgOlxuXHQgICAgICAgICAgICAgICAgICAgIG9iamVjdHM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb0FkZCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIHJlc3VsdHMgPSBfYS5yZXN1bHRzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdCwgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrQWRkKCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrUHV0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcblx0ICAgICAgICAgICAgdmFyIHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciBvYmplY3RzVG9QdXQgPSBrZXlQYXRoICYmIGF1dG8gP1xuXHQgICAgICAgICAgICAgICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0cztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvUHV0LCB3YW50UmVzdWx0czogd2FudFJlc3VsdHMgfSlcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtQdXQoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1PYmplY3RzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtVcGRhdGUgPSBmdW5jdGlvbiAoa2V5c0FuZENoYW5nZXMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGNvcmVUYWJsZSA9IHRoaXMuY29yZTtcblx0ICAgICAgICAgICAgdmFyIGtleXMgPSBrZXlzQW5kQ2hhbmdlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5rZXk7IH0pO1xuXHQgICAgICAgICAgICB2YXIgY2hhbmdlU3BlY3MgPSBrZXlzQW5kQ2hhbmdlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5jaGFuZ2VzOyB9KTtcblx0ICAgICAgICAgICAgdmFyIG9mZnNldE1hcCA9IFtdO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHsgdHJhbnM6IHRyYW5zLCBrZXlzOiBrZXlzLCBjYWNoZTogJ2Nsb25lJyB9KS50aGVuKGZ1bmN0aW9uIChvYmpzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdEtleXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0T2JqcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXNBbmRDaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBpZHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hLmtleSwgY2hhbmdlcyA9IF9hLmNoYW5nZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBvYmpzW2lkeF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKTsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IF9iW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VzW2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoID09PSBfdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbXAodmFsdWUsIGtleSkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkNvbnN0cmFpbnQoXCJDYW5ub3QgdXBkYXRlIHByaW1hcnkga2V5IGluIGJ1bGtVcGRhdGUoKVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldE1hcC5wdXNoKGlkeCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRLZXlzLnB1c2goa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE9ianMucHVzaChvYmopO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG51bUVudHJpZXMgPSByZXN1bHRLZXlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5tdXRhdGUoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiByZXN1bHRLZXlzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlc3VsdE9ianMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXM6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTcGVjczogY2hhbmdlU3BlY3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bUVudHJpZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBPYmplY3Qua2V5cyhmYWlsdXJlcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX2JbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBlZE9mZnNldCA9IG9mZnNldE1hcFtOdW1iZXIob2Zmc2V0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkT2Zmc2V0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZSA9IGZhaWx1cmVzW29mZnNldF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZhaWx1cmVzW29mZnNldF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbbWFwcGVkT2Zmc2V0XSA9IGZhaWx1cmU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrVXBkYXRlKCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtRW50cmllcywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrRGVsZXRlID0gZnVuY3Rpb24gKGtleXMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IGtleXMgfSk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtEZWxldGUoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1LZXlzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBUYWJsZTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIGZ1bmN0aW9uIEV2ZW50cyhjdHgpIHtcblx0ICAgICAgICB2YXIgZXZzID0ge307XG5cdCAgICAgICAgdmFyIHJ2ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3Vic2NyaWJlcikge1xuXHQgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgtLWkpXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBldnNbZXZlbnROYW1lXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcnYuYWRkRXZlbnRUeXBlID0gYWRkO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbikge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ29iamVjdCcpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWRkQ29uZmlndXJlZEV2ZW50cyhldmVudE5hbWUpO1xuXHQgICAgICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pXG5cdCAgICAgICAgICAgICAgICBjaGFpbkZ1bmN0aW9uID0gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW47XG5cdCAgICAgICAgICAgIGlmICghZGVmYXVsdEZ1bmN0aW9uKVxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdEZ1bmN0aW9uID0gbm9wO1xuXHQgICAgICAgICAgICB2YXIgY29udGV4dCA9IHtcblx0ICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcblx0ICAgICAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcblx0ICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3Vic2NyaWJlcnMuaW5kZXhPZihjYikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNoYWluRnVuY3Rpb24oY29udGV4dC5maXJlLCBjYik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzID0gY29udGV4dC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAhPT0gY2I7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuXHQgICAgICAgICAgICBrZXlzKGNmZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGNmZ1tldmVudE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZGQoZXZlbnROYW1lLCBjZmdbZXZlbnROYW1lXVswXSwgY2ZnW2V2ZW50TmFtZV1bMV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhZGQoZXZlbnROYW1lLCBtaXJyb3IsIGZ1bmN0aW9uIGZpcmUoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAkMShmdW5jdGlvbiBmaXJlRXZlbnQoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCBldmVudCBjb25maWdcIik7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gbWFrZUNsYXNzQ29uc3RydWN0b3IocHJvdG90eXBlLCBjb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7IHByb3RvdHlwZTogcHJvdG90eXBlIH0pO1xuXHQgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvcjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvcihkYikge1xuXHQgICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihUYWJsZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFRhYmxlKG5hbWUsIHRhYmxlU2NoZW1hLCB0cmFucykge1xuXHQgICAgICAgICAgICB0aGlzLmRiID0gZGI7XG5cdCAgICAgICAgICAgIHRoaXMuX3R4ID0gdHJhbnM7XG5cdCAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gdGFibGVTY2hlbWE7XG5cdCAgICAgICAgICAgIHRoaXMuaG9vayA9IGRiLl9hbGxUYWJsZXNbbmFtZV0gPyBkYi5fYWxsVGFibGVzW25hbWVdLmhvb2sgOiBFdmVudHMobnVsbCwge1xuXHQgICAgICAgICAgICAgICAgXCJjcmVhdGluZ1wiOiBbaG9va0NyZWF0aW5nQ2hhaW4sIG5vcF0sXG5cdCAgICAgICAgICAgICAgICBcInJlYWRpbmdcIjogW3B1cmVGdW5jdGlvbkNoYWluLCBtaXJyb3JdLFxuXHQgICAgICAgICAgICAgICAgXCJ1cGRhdGluZ1wiOiBbaG9va1VwZGF0aW5nQ2hhaW4sIG5vcF0sXG5cdCAgICAgICAgICAgICAgICBcImRlbGV0aW5nXCI6IFtob29rRGVsZXRpbmdDaGFpbiwgbm9wXVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaXNQbGFpbktleVJhbmdlKGN0eCwgaWdub3JlTGltaXRGaWx0ZXIpIHtcblx0ICAgICAgICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuXHQgICAgICAgICAgICAoaWdub3JlTGltaXRGaWx0ZXIgPyBjdHguanVzdExpbWl0IDogIWN0eC5yZXBsYXlGaWx0ZXIpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRkRmlsdGVyKGN0eCwgZm4pIHtcblx0ICAgICAgICBjdHguZmlsdGVyID0gY29tYmluZShjdHguZmlsdGVyLCBmbik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyKSB7XG5cdCAgICAgICAgdmFyIGN1cnIgPSBjdHgucmVwbGF5RmlsdGVyO1xuXHQgICAgICAgIGN0eC5yZXBsYXlGaWx0ZXIgPSBjdXJyID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tYmluZShjdXJyKCksIGZhY3RvcnkoKSk7IH0gOiBmYWN0b3J5O1xuXHQgICAgICAgIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRkTWF0Y2hGaWx0ZXIoY3R4LCBmbikge1xuXHQgICAgICAgIGN0eC5pc01hdGNoID0gY29tYmluZShjdHguaXNNYXRjaCwgZm4pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVNjaGVtYSkge1xuXHQgICAgICAgIGlmIChjdHguaXNQcmltS2V5KVxuXHQgICAgICAgICAgICByZXR1cm4gY29yZVNjaGVtYS5wcmltYXJ5S2V5O1xuXHQgICAgICAgIHZhciBpbmRleCA9IGNvcmVTY2hlbWEuZ2V0SW5kZXhCeUtleVBhdGgoY3R4LmluZGV4KTtcblx0ICAgICAgICBpZiAoIWluZGV4KVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJLZXlQYXRoIFwiICsgY3R4LmluZGV4ICsgXCIgb24gb2JqZWN0IHN0b3JlIFwiICsgY29yZVNjaGVtYS5uYW1lICsgXCIgaXMgbm90IGluZGV4ZWRcIik7XG5cdCAgICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gb3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgdHJhbnMpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKTtcblx0ICAgICAgICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuXHQgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgIHZhbHVlczogIWN0eC5rZXlzT25seSxcblx0ICAgICAgICAgICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuXHQgICAgICAgICAgICB1bmlxdWU6ICEhY3R4LnVuaXF1ZSxcblx0ICAgICAgICAgICAgcXVlcnk6IHtcblx0ICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2Vcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaXRlcihjdHgsIGZuLCBjb3JlVHJhbnMsIGNvcmVUYWJsZSkge1xuXHQgICAgICAgIHZhciBmaWx0ZXIgPSBjdHgucmVwbGF5RmlsdGVyID8gY29tYmluZShjdHguZmlsdGVyLCBjdHgucmVwbGF5RmlsdGVyKCkpIDogY3R4LmZpbHRlcjtcblx0ICAgICAgICBpZiAoIWN0eC5vcikge1xuXHQgICAgICAgICAgICByZXR1cm4gaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZpbHRlciksIGZuLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgc2V0XzEgPSB7fTtcblx0ICAgICAgICAgICAgdmFyIHVuaW9uID0gZnVuY3Rpb24gKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZSwgZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gY3Vyc29yLnN0b3AocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY3Vyc29yLmZhaWwoZXJyKTsgfSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJyArIHByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gJycgKyBuZXcgVWludDhBcnJheShwcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXRfMSwga2V5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXRfMVtrZXldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm4oaXRlbSwgY3Vyc29yLCBhZHZhbmNlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG5cdCAgICAgICAgICAgICAgICBjdHgub3IuX2l0ZXJhdGUodW5pb24sIGNvcmVUcmFucyksXG5cdCAgICAgICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGN0eC5hbGdvcml0aG0sIHVuaW9uLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcilcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlLCBmaWx0ZXIsIGZuLCB2YWx1ZU1hcHBlcikge1xuXHQgICAgICAgIHZhciBtYXBwZWRGbiA9IHZhbHVlTWFwcGVyID8gZnVuY3Rpb24gKHgsIGMsIGEpIHsgcmV0dXJuIGZuKHZhbHVlTWFwcGVyKHgpLCBjLCBhKTsgfSA6IGZuO1xuXHQgICAgICAgIHZhciB3cmFwcGVkRm4gPSB3cmFwKG1hcHBlZEZuKTtcblx0ICAgICAgICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5zdGFydChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJzb3IuY29udGludWUoKTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgcmV0dXJuIGMgPSBhZHZhbmNlcjsgfSwgZnVuY3Rpb24gKHZhbCkgeyBjdXJzb3Iuc3RvcCh2YWwpOyBjID0gbm9wOyB9LCBmdW5jdGlvbiAoZSkgeyBjdXJzb3IuZmFpbChlKTsgYyA9IG5vcDsgfSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbihjdXJzb3IudmFsdWUsIGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IHJldHVybiBjID0gYWR2YW5jZXI7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGMoKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBQcm9wTW9kU3ltYm9sID0gU3ltYm9sKCk7XG5cdCAgICB2YXIgUHJvcE1vZGlmaWNhdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFByb3BNb2RpZmljYXRpb24oc3BlYykge1xuXHQgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHNwZWMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBQcm9wTW9kaWZpY2F0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBfYTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWRkICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gdGhpcy5hZGQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSh0ZXJtKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pLCB0cnVlKSwgdGVybSwgdHJ1ZSkuc29ydCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXJtID09PSAnbnVtYmVyJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE51bWJlcih2YWx1ZSkgfHwgMCkgKyB0ZXJtO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXJtID09PSAnYmlnaW50Jykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpICsgdGVybTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9iKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCkgKyB0ZXJtO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRlcm0gXCIuY29uY2F0KHRlcm0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5yZW1vdmUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnRyYWhlbmRfMSA9IHRoaXMucmVtb3ZlO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3VidHJhaGVuZF8xKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIXN1YnRyYWhlbmRfMS5pbmNsdWRlcyhpdGVtKTsgfSkuc29ydCgpIDogW107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmRfMSA9PT0gJ251bWJlcicpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgLSBzdWJ0cmFoZW5kXzE7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnRyYWhlbmRfMSA9PT0gJ2JpZ2ludCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKSAtIHN1YnRyYWhlbmRfMTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9jKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCkgLSBzdWJ0cmFoZW5kXzE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3VidHJhaGVuZCBcIi5jb25jYXQoc3VidHJhaGVuZF8xKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHByZWZpeFRvUmVwbGFjZSA9IChfYSA9IHRoaXMucmVwbGFjZVByZWZpeCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuXHQgICAgICAgICAgICBpZiAocHJlZml4VG9SZXBsYWNlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuc3RhcnRzV2l0aChwcmVmaXhUb1JlcGxhY2UpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUHJlZml4WzFdICsgdmFsdWUuc3Vic3RyaW5nKHByZWZpeFRvUmVwbGFjZS5sZW5ndGgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBQcm9wTW9kaWZpY2F0aW9uO1xuXHQgICAgfSgpKTtcblxuXHQgICAgdmFyIENvbGxlY3Rpb24gPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuXHQgICAgICAgIH1cblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChmbiwgY2IpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG5cdCAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcblx0ICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGZuKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuXHQgICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG5cdCAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkd3JpdGUnLCBmbiwgXCJsb2NrZWRcIik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fYWRkQWxnb3JpdGhtID0gZnVuY3Rpb24gKGZuKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCBjb3JlVHJhbnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGl0ZXIodGhpcy5fY3R4LCBmbiwgY29yZVRyYW5zLCB0aGlzLl9jdHgudGFibGUuY29yZSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHQgICAgICAgICAgICB2YXIgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSwgY3R4ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdHgpO1xuXHQgICAgICAgICAgICBpZiAocHJvcHMpXG5cdCAgICAgICAgICAgICAgICBleHRlbmQoY3R4LCBwcm9wcyk7XG5cdCAgICAgICAgICAgIHJ2Ll9jdHggPSBjdHg7XG5cdCAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4LnZhbHVlTWFwcGVyID0gbnVsbDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGZuKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN0eCA9IF90aGlzLl9jdHg7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIE1hdGgubWluKGNvdW50LCBjdHgubGltaXQpOyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7ICsrY291bnQ7IHJldHVybiBmYWxzZTsgfSwgdHJhbnMsIGNvcmVUYWJsZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnQ7IH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uIChrZXlQYXRoLCBjYikge1xuXHQgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXlQYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpLCBsYXN0UGFydCA9IHBhcnRzWzBdLCBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBnZXR2YWwob2JqLCBpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSlcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBvcmRlciA9IHRoaXMuX2N0eC5kaXIgPT09IFwibmV4dFwiID8gMSA6IC0xO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFWYWwgPSBnZXR2YWwoYSwgbGFzdEluZGV4KSwgYlZhbCA9IGdldHZhbChiLCBsYXN0SW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFWYWwgPCBiVmFsID8gLW9yZGVyIDogYVZhbCA+IGJWYWwgPyBvcmRlciA6IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheShmdW5jdGlvbiAoYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuXHQgICAgICAgICAgICB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3RoaXMuX2N0eDtcblx0ICAgICAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hcHBlcl8xID0gY3R4LnZhbHVlTWFwcGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVNYXBwZXJfMSA/IHJlc3VsdC5tYXAodmFsdWVNYXBwZXJfMSkgOiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYV8xID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYV8xLnB1c2goaXRlbSk7IH0sIHRyYW5zLCBjdHgudGFibGUuY29yZSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBhXzE7IH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LCBjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICBjdHgub2Zmc2V0ICs9IG9mZnNldDtcblx0ICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG5cdCAgICAgICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tb2Zmc2V0TGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9mZnNldExlZnQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoLS1vZmZzZXRMZWZ0IDwgMCk7IH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24gKG51bVJvd3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTtcblx0ICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJvd3NMZWZ0ID0gbnVtUm93cztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKC0tcm93c0xlZnQgPD0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0sIHRydWUpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnVudGlsID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uLCBiSW5jbHVkZVN0b3BFbnRyeSkge1xuXHQgICAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJJbmNsdWRlU3RvcEVudHJ5O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3QoY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZmlsdGVyKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4LmRpciA9ICh0aGlzLl9jdHguZGlyID09PSBcInByZXZcIiA/IFwibmV4dFwiIDogXCJwcmV2XCIpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UpXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZXNjID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoS2V5ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoVW5pcXVlS2V5ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoS2V5KGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hQcmltYXJ5S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvcik7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG5cdCAgICAgICAgICAgIHZhciBhID0gW107XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5rZXkpO1xuXHQgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhO1xuXHQgICAgICAgICAgICB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnByaW1hcnlLZXlzID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkudGhlbihjYik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuXHQgICAgICAgICAgICB2YXIgYSA9IFtdO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgIGEucHVzaChjdXJzb3IucHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW5pcXVlS2V5cyA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maXJzdEtleSA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS5rZXlzKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmxhc3RLZXkgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0S2V5KGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCBpZHggPSBjdHguaW5kZXggJiYgY3R4LnRhYmxlLnNjaGVtYS5pZHhCeU5hbWVbY3R4LmluZGV4XTtcblx0ICAgICAgICAgICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgc2V0ID0ge307XG5cdCAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdHJLZXkgPSBjdXJzb3IucHJpbWFyeUtleS50b1N0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gaGFzT3duKHNldCwgc3RyS2V5KTtcblx0ICAgICAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1vZGlmeSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RpZnllcjtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gY2hhbmdlcztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoY2hhbmdlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW55dGhpbmdNb2RpZmllZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjaGFuZ2VzW2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdWYWwgPSBnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUHJvcE1vZGlmaWNhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwuZXhlY3V0ZShvcmlnVmFsKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcmlnVmFsICE9PSB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuXHQgICAgICAgICAgICAgICAgdmFyIF9hID0gY29yZVRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5LCBvdXRib3VuZCA9IF9hLm91dGJvdW5kLCBleHRyYWN0S2V5ID0gX2EuZXh0cmFjdEtleTtcblx0ICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IF90aGlzLmRiLl9vcHRpb25zLm1vZGlmeUNodW5rU2l6ZSB8fCAyMDA7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG90YWxGYWlsdXJlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDb3VudCA9IDA7XG5cdCAgICAgICAgICAgICAgICB2YXIgZmFpbGVkS2V5cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFwcGx5TXV0YXRlUmVzdWx0ID0gZnVuY3Rpb24gKGV4cGVjdGVkQ291bnQsIHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IHJlcy5mYWlsdXJlcywgbnVtRmFpbHVyZXMgPSByZXMubnVtRmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGV4cGVjdGVkQ291bnQgLSBudW1GYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0ga2V5cyhmYWlsdXJlcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfYVtfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRmFpbHVyZXMucHVzaChmYWlsdXJlc1twb3NdKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGZ1bmN0aW9uIChrZXlzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNyaXRlcmlhID0gaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbWl0ID09PSBJbmZpbml0eSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbicgfHwgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spICYmIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGN0eC5pbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaHVuayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4obGltaXQsIGtleXMubGVuZ3RoIC0gb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogXCJpbW11dGFibGVcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRWYWx1ZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRWYWx1ZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRLZXlzID0gb3V0Ym91bmQgPyBbXSA6IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlS2V5cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdWYWx1ZSA9IHZhbHVlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4XzEgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleToga2V5c1tvZmZzZXQgKyBpXVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeWVyLmNhbGwoY3R4XzEsIGN0eF8xLnZhbHVlLCBjdHhfMSkgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHhfMS52YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW91dGJvdW5kICYmIGNtcChleHRyYWN0S2V5KG9yaWdWYWx1ZSksIGV4dHJhY3RLZXkoY3R4XzEudmFsdWUpKSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFsdWVzLnB1c2goY3R4XzEudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dEtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnYWRkJywgdmFsdWVzOiBhZGRWYWx1ZXMgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnNwbGljZShwYXJzZUludChwb3MpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChwdXRWYWx1ZXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgdHlwZW9mIGNoYW5nZXMgPT09ICdvYmplY3QnKSkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0Jyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcHV0S2V5cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBwdXRWYWx1ZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBjcml0ZXJpYSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlYzogdHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbidcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWRkaXRpb25hbENodW5rOiBvZmZzZXQgPiAwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBhcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpOyB9KTsgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAoZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBjcml0ZXJpYSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBZGRpdGlvbmFsQ2h1bms6IG9mZnNldCA+IDBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGFwcGx5TXV0YXRlUmVzdWx0KGRlbGV0ZUtleXMubGVuZ3RoLCByZXMpOyB9KTsgfSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gb2Zmc2V0ICsgY291bnQgJiYgbmV4dENodW5rKG9mZnNldCArIGxpbWl0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2h1bmsoMCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbEZhaWx1cmVzLmxlbmd0aCA+IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCB0b3RhbEZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIHJhbmdlID0gY3R4LnJhbmdlO1xuXHQgICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkgJiZcblx0ICAgICAgICAgICAgICAgIChjdHguaXNQcmltS2V5IHx8IHJhbmdlLnR5cGUgPT09IDMgKSlcblx0ICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN0eC50YWJsZS5jb3JlLnNjaGVtYS5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb3JlUmFuZ2UgPSByYW5nZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUuY291bnQoeyB0cmFuczogdHJhbnMsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogY29yZVJhbmdlIH0gfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZSB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBfYS5mYWlsdXJlczsgX2EubGFzdFJlc3VsdDsgX2EucmVzdWx0czsgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiQ291bGQgbm90IGRlbGV0ZSBzb21lIHZhbHVlc1wiLCBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGZhaWx1cmVzW3Bvc107IH0pLCBjb3VudCAtIG51bUZhaWx1cmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCAtIG51bUZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGlmeShkZWxldGVDYWxsYmFjayk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gQ29sbGVjdGlvbjtcblx0ICAgIH0oKSk7XG5cdCAgICB2YXIgZGVsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGN0eCkgeyByZXR1cm4gY3R4LnZhbHVlID0gbnVsbDsgfTtcblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKENvbGxlY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBrZXlSYW5nZUdlbmVyYXRvcikge1xuXHQgICAgICAgICAgICB0aGlzLmRiID0gZGI7XG5cdCAgICAgICAgICAgIHZhciBrZXlSYW5nZSA9IEFueVJhbmdlLCBlcnJvciA9IG51bGw7XG5cdCAgICAgICAgICAgIGlmIChrZXlSYW5nZUdlbmVyYXRvcilcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5UmFuZ2UgPSBrZXlSYW5nZUdlbmVyYXRvcigpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcblx0ICAgICAgICAgICAgdmFyIHRhYmxlID0gd2hlcmVDdHgudGFibGU7XG5cdCAgICAgICAgICAgIHZhciByZWFkaW5nSG9vayA9IHRhYmxlLmhvb2sucmVhZGluZy5maXJlO1xuXHQgICAgICAgICAgICB0aGlzLl9jdHggPSB7XG5cdCAgICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG5cdCAgICAgICAgICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG5cdCAgICAgICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcblx0ICAgICAgICAgICAgICAgIGtleXNPbmx5OiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG5cdCAgICAgICAgICAgICAgICB1bmlxdWU6IFwiXCIsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IG51bGwsXG5cdCAgICAgICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG5cdCAgICAgICAgICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBqdXN0TGltaXQ6IHRydWUsXG5cdCAgICAgICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuXHQgICAgICAgICAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuXHQgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuXHQgICAgICAgICAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuXHQgICAgICAgICAgICAgICAgdmFsdWVNYXBwZXI6IHJlYWRpbmdIb29rICE9PSBtaXJyb3IgPyByZWFkaW5nSG9vayA6IG51bGxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZShhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBzaW1wbGVDb21wYXJlUmV2ZXJzZShhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UsIGVyciwgVCkge1xuXHQgICAgICAgIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG5cdCAgICAgICAgICAgIG5ldyBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZS5Db2xsZWN0aW9uKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlKSA6XG5cdCAgICAgICAgICAgIGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlO1xuXHQgICAgICAgIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuXHQgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5nZUVxdWFsKFwiXCIpOyB9KS5saW1pdCgwKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXIpIHtcblx0ICAgICAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH0gOlxuXHQgICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuXHQgICAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cblx0ICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTsgfSA6XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvVXBwZXJDYXNlKCk7IH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oa2V5Lmxlbmd0aCwgbG93ZXJOZWVkbGUubGVuZ3RoKTtcblx0ICAgICAgICB2YXIgbGxwID0gLTE7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICB2YXIgbHdyS2V5Q2hhciA9IGxvd2VyS2V5W2ldO1xuXHQgICAgICAgICAgICBpZiAobHdyS2V5Q2hhciAhPT0gbG93ZXJOZWVkbGVbaV0pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgdXBwZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGxvd2VyTmVlZGxlW2ldKSA8IDApXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG5cdCAgICAgICAgICAgICAgICBpZiAobGxwID49IDApXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyS2V5W2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbHdyS2V5Q2hhcikgPCAwKVxuXHQgICAgICAgICAgICAgICAgbGxwID0gaTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxlbmd0aCA8IGxvd2VyTmVlZGxlLmxlbmd0aCAmJiBkaXIgPT09IFwibmV4dFwiKVxuXHQgICAgICAgICAgICByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuXHQgICAgICAgIGlmIChsZW5ndGggPCBrZXkubGVuZ3RoICYmIGRpciA9PT0gXCJwcmV2XCIpXG5cdCAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIHVwcGVyTmVlZGxlLmxlbmd0aCk7XG5cdCAgICAgICAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh3aGVyZUNsYXVzZSwgbWF0Y2gsIG5lZWRsZXMsIHN1ZmZpeCkge1xuXHQgICAgICAgIHZhciB1cHBlciwgbG93ZXIsIGNvbXBhcmUsIHVwcGVyTmVlZGxlcywgbG93ZXJOZWVkbGVzLCBkaXJlY3Rpb24sIG5leHRLZXlTdWZmaXgsIG5lZWRsZXNMZW4gPSBuZWVkbGVzLmxlbmd0aDtcblx0ICAgICAgICBpZiAoIW5lZWRsZXMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhaWwod2hlcmVDbGF1c2UsIFNUUklOR19FWFBFQ1RFRCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG5cdCAgICAgICAgICAgIHVwcGVyID0gdXBwZXJGYWN0b3J5KGRpcik7XG5cdCAgICAgICAgICAgIGxvd2VyID0gbG93ZXJGYWN0b3J5KGRpcik7XG5cdCAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG5cdCAgICAgICAgICAgIHZhciBuZWVkbGVCb3VuZHMgPSBuZWVkbGVzLm1hcChmdW5jdGlvbiAobmVlZGxlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyBsb3dlcjogbG93ZXIobmVlZGxlKSwgdXBwZXI6IHVwcGVyKG5lZWRsZSkgfTtcblx0ICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYS5sb3dlciwgYi5sb3dlcik7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuXHQgICAgICAgICAgICBsb3dlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIubG93ZXI7IH0pO1xuXHQgICAgICAgICAgICBkaXJlY3Rpb24gPSBkaXI7XG5cdCAgICAgICAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpbml0RGlyZWN0aW9uKFwibmV4dFwiKTtcblx0ICAgICAgICB2YXIgYyA9IG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1cHBlck5lZWRsZXNbMF0sIGxvd2VyTmVlZGxlc1tuZWVkbGVzTGVuIC0gMV0gKyBzdWZmaXgpOyB9KTtcblx0ICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgaW5pdERpcmVjdGlvbihkaXJlY3Rpb24pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIGZpcnN0UG9zc2libGVOZWVkbGUgPSAwO1xuXHQgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBsb3dlcktleSA9IGxvd2VyKGtleSk7XG5cdCAgICAgICAgICAgIGlmIChtYXRjaChsb3dlcktleSwgbG93ZXJOZWVkbGVzLCBmaXJzdFBvc3NpYmxlTmVlZGxlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UG9zc2libGVOZWVkbGU7IGkgPCBuZWVkbGVzTGVuOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2FzaW5nID0gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZXNbaV0sIGxvd2VyTmVlZGxlc1tpXSwgY29tcGFyZSwgZGlyZWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FzaW5nID09PSBudWxsICYmIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFBvc3NpYmxlTmVlZGxlID0gaSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwgfHwgY29tcGFyZShsb3dlc3RQb3NzaWJsZUNhc2luZywgY2FzaW5nKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBjYXNpbmc7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShsb3dlc3RQb3NzaWJsZUNhc2luZyArIG5leHRLZXlTdWZmaXgpOyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gYztcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0eXBlOiAyICxcblx0ICAgICAgICAgICAgbG93ZXI6IGxvd2VyLFxuXHQgICAgICAgICAgICB1cHBlcjogdXBwZXIsXG5cdCAgICAgICAgICAgIGxvd2VyT3BlbjogbG93ZXJPcGVuLFxuXHQgICAgICAgICAgICB1cHBlck9wZW46IHVwcGVyT3BlblxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByYW5nZUVxdWFsKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogMSAsXG5cdCAgICAgICAgICAgIGxvd2VyOiB2YWx1ZSxcblx0ICAgICAgICAgICAgdXBwZXI6IHZhbHVlXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIFdoZXJlQ2xhdXNlID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UoKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaGVyZUNsYXVzZS5wcm90b3R5cGUsIFwiQ29sbGVjdGlvblwiLCB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC50YWJsZS5kYi5Db2xsZWN0aW9uO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJldHdlZW4gPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyLCBpbmNsdWRlTG93ZXIsIGluY2x1ZGVVcHBlcikge1xuXHQgICAgICAgICAgICBpbmNsdWRlTG93ZXIgPSBpbmNsdWRlTG93ZXIgIT09IGZhbHNlO1xuXHQgICAgICAgICAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID4gMCkgfHxcblx0ICAgICAgICAgICAgICAgICAgICAodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPT09IDAgJiYgKGluY2x1ZGVMb3dlciB8fCBpbmNsdWRlVXBwZXIpICYmICEoaW5jbHVkZUxvd2VyICYmIGluY2x1ZGVVcHBlcikpKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsICFpbmNsdWRlTG93ZXIsICFpbmNsdWRlVXBwZXIpOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5nZUVxdWFsKHZhbHVlKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYWJvdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIHRydWUpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hYm92ZU9yRXF1YWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIGZhbHNlKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYmVsb3cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUsIGZhbHNlLCB0cnVlKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYmVsb3dPckVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgU1RSSU5HX0VYUEVDVEVEKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aElnbm9yZUNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICAgICAgICAgIGlmIChzdHIgPT09IFwiXCIpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG5cdCAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiB4LmluZGV4T2YoYVswXSkgPT09IDA7IH0sIFtzdHJdLCBtYXhTdHJpbmcpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmVxdWFsc0lnbm9yZUNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiB4ID09PSBhWzBdOyB9LCBbc3RyXSwgXCJcIik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYW55T2ZJZ25vcmVDYXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiBhLmluZGV4T2YoeCkgIT09IC0xOyB9LCBzZXQsIFwiXCIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIGEuc29tZShmdW5jdGlvbiAobikgeyByZXR1cm4geC5pbmRleE9mKG4pID09PSAwOyB9KTsgfSwgc2V0LCBtYXhTdHJpbmcpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFueU9mID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NtcDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICB2YXIgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2Uoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKTsgfSk7XG5cdCAgICAgICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgY29tcGFyZSA9IChkaXJlY3Rpb24gPT09IFwibmV4dFwiID9cblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXNjZW5kaW5nIDpcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGVzY2VuZGluZyk7XG5cdCAgICAgICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdmFyIGkgPSAwO1xuXHQgICAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShrZXksIHNldFtpXSkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKytpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIHNldFtpXSkgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIHRoaXMuZGIuX21heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5ub25lT2YgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzZXQuc29ydCh0aGlzLl9hc2NlbmRpbmcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHNldC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgdmFsKSB7IHJldHVybiByZXMgP1xuXHQgICAgICAgICAgICAgICAgcmVzLmNvbmNhdChbW3Jlc1tyZXMubGVuZ3RoIC0gMV1bMV0sIHZhbF1dKSA6XG5cdCAgICAgICAgICAgICAgICBbW21pbktleSwgdmFsXV07IH0sIG51bGwpO1xuXHQgICAgICAgICAgICByYW5nZXMucHVzaChbc2V0W3NldC5sZW5ndGggLSAxXSwgdGhpcy5kYi5fbWF4S2V5XSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UocmFuZ2VzLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5pbkFueVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlcywgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgY21wID0gdGhpcy5fY21wLCBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nLCBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heDtcblx0ICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShmdW5jdGlvbiAocmFuZ2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXSAhPT0gdW5kZWZpbmVkICYmXG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJlxuXHQgICAgICAgICAgICAgICAgICAgIGFzY2VuZGluZyhyYW5nZVswXSwgcmFuZ2VbMV0pIDw9IDA7XG5cdCAgICAgICAgICAgIH0pKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcIkZpcnN0IGFyZ3VtZW50IHRvIGluQW55UmFuZ2UoKSBtdXN0IGJlIGFuIEFycmF5IG9mIHR3by12YWx1ZSBBcnJheXMgW2xvd2VyLHVwcGVyXSB3aGVyZSB1cHBlciBtdXN0IG5vdCBiZSBsb3dlciB0aGFuIGxvd2VyXCIsIGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaW5jbHVkZUxvd2VycyA9ICFvcHRpb25zIHx8IG9wdGlvbnMuaW5jbHVkZUxvd2VycyAhPT0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBpbmNsdWRlVXBwZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVVcHBlcnMgPT09IHRydWU7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY21wKG5ld1JhbmdlWzBdLCByYW5nZVsxXSkgPCAwICYmIGNtcChuZXdSYW5nZVsxXSwgcmFuZ2VbMF0pID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVswXSA9IG1pbihyYW5nZVswXSwgbmV3UmFuZ2VbMF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbClcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChuZXdSYW5nZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG5cdCAgICAgICAgICAgIHZhciBzZXQ7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzZXQgPSByYW5nZXMucmVkdWNlKGFkZFJhbmdlLCBbXSk7XG5cdCAgICAgICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHJhbmdlUG9zID0gMDtcblx0ICAgICAgICAgICAgdmFyIGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+IDA7IH0gOlxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDsgfTtcblx0ICAgICAgICAgICAgdmFyIGtleUlzQmVmb3JlQ3VycmVudEVudHJ5ID0gaW5jbHVkZUxvd2VycyA/XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPiAwOyB9IDpcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+PSAwOyB9O1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWtleUlzQmV5b25kQ3VycmVudEVudHJ5KGtleSkgJiYgIWtleUlzQmVmb3JlQ3VycmVudEVudHJ5KGtleSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG5cdCAgICAgICAgICAgIHZhciBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZShzZXRbMF1bMF0sIHNldFtzZXQubGVuZ3RoIC0gMV1bMV0sICFpbmNsdWRlTG93ZXJzLCAhaW5jbHVkZVVwcGVycyk7IH0pO1xuXHQgICAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwibmV4dFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcblx0ICAgICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcblx0ICAgICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gZGVzY2VuZGluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGNoZWNrS2V5KGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3JhbmdlUG9zO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVBvcyA9PT0gc2V0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPT09IDAgfHwgX3RoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMF0pID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSBhc2NlbmRpbmcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVswXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzFdKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gYztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoQW55T2YgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmICghc2V0LmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcInN0YXJ0c1dpdGhBbnlPZigpIG9ubHkgd29ya3Mgd2l0aCBzdHJpbmdzXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFtzdHIsIHN0ciArIG1heFN0cmluZ107IH0pKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBXaGVyZUNsYXVzZTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IoZGIpIHtcblx0ICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBmdW5jdGlvbiBXaGVyZUNsYXVzZSh0YWJsZSwgaW5kZXgsIG9yQ29sbGVjdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLmRiID0gZGI7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eCA9IHtcblx0ICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcblx0ICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcblx0ICAgICAgICAgICAgICAgIG9yOiBvckNvbGxlY3Rpb25cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gY21wO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXNjZW5kaW5nID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChiLCBhKTsgfTtcblx0ICAgICAgICAgICAgdGhpcy5fbWF4ID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA+IDAgPyBhIDogYjsgfTtcblx0ICAgICAgICAgICAgdGhpcy5fbWluID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYjsgfTtcblx0ICAgICAgICAgICAgdGhpcy5fSURCS2V5UmFuZ2UgPSBkYi5fZGVwcy5JREJLZXlSYW5nZTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9JREJLZXlSYW5nZSlcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuXHQgICAgICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG5cdCAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdCAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcblx0ICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FID0gJ3N0b3JhZ2VtdXRhdGVkJztcblx0ICAgIHZhciBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgPSAneC1zdG9yYWdlbXV0YXRlZC0xJztcblx0ICAgIHZhciBnbG9iYWxFdmVudHMgPSBFdmVudHMobnVsbCwgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpO1xuXG5cdCAgICB2YXIgVHJhbnNhY3Rpb24gPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbigpIHtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9sb2NrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuXHQgICAgICAgICAgICArK3RoaXMuX3JlY3Vsb2NrO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fcmVjdWxvY2sgPT09IDEgJiYgIVBTRC5nbG9iYWwpXG5cdCAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX3VubG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcblx0ICAgICAgICAgICAgaWYgKC0tdGhpcy5fcmVjdWxvY2sgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGlmICghUFNELmdsb2JhbClcblx0ICAgICAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9ibG9ja2VkRnVuY3MubGVuZ3RoID4gMCAmJiAhdGhpcy5fbG9ja2VkKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZm5BbmRQU0QgPSB0aGlzLl9ibG9ja2VkRnVuY3Muc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1c2VQU0QoZm5BbmRQU0RbMV0sIGZuQW5kUFNEWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9sb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpZGJ0cmFucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMubW9kZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuXHQgICAgICAgICAgICB2YXIgZGJPcGVuRXJyb3IgPSB0aGlzLmRiLl9zdGF0ZS5kYk9wZW5FcnJvcjtcblx0ICAgICAgICAgICAgYXNzZXJ0KCF0aGlzLmlkYnRyYW5zKTtcblx0ICAgICAgICAgICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoZGJPcGVuRXJyb3IgJiYgZGJPcGVuRXJyb3IubmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEYXRhYmFzZUNsb3NlZEVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiT3BlbkVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoZGJPcGVuRXJyb3IubWVzc2FnZSwgZGJPcGVuRXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk9wZW5GYWlsZWQoZGJPcGVuRXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCk7XG5cdCAgICAgICAgICAgIGFzc2VydCh0aGlzLl9jb21wbGV0aW9uLl9zdGF0ZSA9PT0gbnVsbCk7XG5cdCAgICAgICAgICAgIGlkYnRyYW5zID0gdGhpcy5pZGJ0cmFucyA9IGlkYnRyYW5zIHx8XG5cdCAgICAgICAgICAgICAgICAodGhpcy5kYi5jb3JlXG5cdCAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmRiLmNvcmUudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSlcblx0ICAgICAgICAgICAgICAgICAgICA6IGlkYmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pKTtcblx0ICAgICAgICAgICAgaWRidHJhbnMub25lcnJvciA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0KGlkYnRyYW5zLmVycm9yKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlICYmIF90aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoaWRidHJhbnMuZXJyb3IpKTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMub24oXCJhYm9ydFwiKS5maXJlKGV2KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlkYnRyYW5zLm9uY29tcGxldGUgPSB3cmFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgIGlmICgnbXV0YXRlZFBhcnRzJyBpbiBpZGJ0cmFucykge1xuXHQgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9wcm9taXNlID0gZnVuY3Rpb24gKG1vZGUsIGZuLCBiV3JpdGVMb2NrKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFtmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBQU0RdKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGJXcml0ZUxvY2spIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvY2soKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCBfdGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHAuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdW5sb2NrKCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCBfdGhpcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX3Jvb3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Ll9yb290KCkgOiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiAocHJvbWlzZUxpa2UpIHtcblx0ICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290KCk7XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuXHQgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuXHQgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHJvb3QuX3dhaXRpbmdGb3IudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9taXNlOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSByb290LmlkYnRyYW5zLm9iamVjdFN0b3JlKHJvb3Quc3RvcmVOYW1lc1swXSk7XG5cdCAgICAgICAgICAgICAgICAoZnVuY3Rpb24gc3BpbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDtcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAocm9vdC5fd2FpdGluZ1F1ZXVlLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuXHQgICAgICAgICAgICAgICAgfSgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY3VycmVudFdhaXRQcm9taXNlID0gcm9vdC5fd2FpdGluZ0Zvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVzb2x2ZS5iaW5kKG51bGwsIHJlcykpKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSk7IH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pZGJ0cmFucylcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgdmFyIG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG5cdCAgICAgICAgICAgIGlmIChoYXNPd24obWVtb2l6ZWRUYWJsZXMsIHRhYmxlTmFtZSkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXTtcblx0ICAgICAgICAgICAgdmFyIHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcblx0ICAgICAgICAgICAgaWYgKCF0YWJsZVNjaGVtYSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbkJvdW5kVGFibGUgPSBuZXcgdGhpcy5kYi5UYWJsZSh0YWJsZU5hbWUsIHRhYmxlU2NoZW1hLCB0aGlzKTtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlLmNvcmUgPSB0aGlzLmRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXSA9IHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbjtcblx0ICAgIH0oKSk7XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcblx0ICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnQpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuXHQgICAgICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuXHQgICAgICAgICAgICB0aGlzLnN0b3JlTmFtZXMgPSBzdG9yZU5hbWVzO1xuXHQgICAgICAgICAgICB0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1xuXHQgICAgICAgICAgICB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSA9IGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTtcblx0ICAgICAgICAgICAgdGhpcy5pZGJ0cmFucyA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG5cdCAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuXHQgICAgICAgICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl93YWl0aW5nUXVldWUgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9zcGluQ291bnQgPSAwO1xuXHQgICAgICAgICAgICB0aGlzLl9jb21wbGV0aW9uID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMub24uY29tcGxldGUuZmlyZSgpO1xuXHQgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdhc0FjdGl2ZSA9IF90aGlzLmFjdGl2ZTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMub24uZXJyb3IuZmlyZShlKTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudCA/XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Ll9yZWplY3QoZSkgOlxuXHQgICAgICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiBfdGhpcy5pZGJ0cmFucyAmJiBfdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoLCB1bmlxdWUsIG11bHRpLCBhdXRvLCBjb21wb3VuZCwgaXNQcmltS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcblx0ICAgICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG5cdCAgICAgICAgICAgIG11bHRpOiBtdWx0aSxcblx0ICAgICAgICAgICAgYXV0bzogYXV0byxcblx0ICAgICAgICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuXHQgICAgICAgICAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aClcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbmFtZUZyb21LZXlQYXRoKGtleVBhdGgpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cblx0ICAgICAgICAgICAga2V5UGF0aCA6XG5cdCAgICAgICAgICAgIGtleVBhdGggPyAoJ1snICsgW10uam9pbi5jYWxsKGtleVBhdGgsICcrJykgKyAnXScpIDogXCJcIjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgIHByaW1LZXk6IHByaW1LZXksXG5cdCAgICAgICAgICAgIGluZGV4ZXM6IGluZGV4ZXMsXG5cdCAgICAgICAgICAgIG1hcHBlZENsYXNzOiBudWxsLFxuXHQgICAgICAgICAgICBpZHhCeU5hbWU6IGFycmF5VG9PYmplY3QoaW5kZXhlcywgZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBbaW5kZXgubmFtZSwgaW5kZXhdOyB9KVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNhZmFyaU11bHRpU3RvcmVGaXgoc3RvcmVOYW1lcykge1xuXHQgICAgICAgIHJldHVybiBzdG9yZU5hbWVzLmxlbmd0aCA9PT0gMSA/IHN0b3JlTmFtZXNbMF0gOiBzdG9yZU5hbWVzO1xuXHQgICAgfVxuXHQgICAgdmFyIGdldE1heEtleSA9IGZ1bmN0aW9uIChJZGJLZXlSYW5nZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIElkYktleVJhbmdlLm9ubHkoW1tdXSk7XG5cdCAgICAgICAgICAgIGdldE1heEtleSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtbXV07IH07XG5cdCAgICAgICAgICAgIHJldHVybiBbW11dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTdHJpbmc7IH07XG5cdCAgICAgICAgICAgIHJldHVybiBtYXhTdHJpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcblx0ICAgICAgICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTsgfTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcblx0ICAgICAgICB2YXIgc3BsaXQgPSBrZXlQYXRoLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqW2tleVBhdGhdOyB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpOyB9O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXJyYXlpZnkoYXJyYXlMaWtlKSB7XG5cdCAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcblx0ICAgIH1cblx0ICAgIHZhciBfaWRfY291bnRlciA9IDA7XG5cdCAgICBmdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCkge1xuXHQgICAgICAgIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuXHQgICAgICAgICAgICBcIjppZFwiIDpcblx0ICAgICAgICAgICAgdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cblx0ICAgICAgICAgICAgICAgIGtleVBhdGggOlxuXHQgICAgICAgICAgICAgICAgXCJbXCIuY29uY2F0KGtleVBhdGguam9pbignKycpLCBcIl1cIik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjcmVhdGVEQkNvcmUoZGIsIElkYktleVJhbmdlLCB0bXBUcmFucykge1xuXHQgICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RTY2hlbWEoZGIsIHRyYW5zKSB7XG5cdCAgICAgICAgICAgIHZhciB0YWJsZXMgPSBhcnJheWlmeShkYi5vYmplY3RTdG9yZU5hbWVzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHNjaGVtYToge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRiLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgdGFibGVzOiB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkgeyByZXR1cm4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpOyB9KS5tYXAoZnVuY3Rpb24gKHN0b3JlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUua2V5UGF0aCwgYXV0b0luY3JlbWVudCA9IHN0b3JlLmF1dG9JbmNyZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4QnlLZXlQYXRoID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdG9yZS5uYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmltYXJ5S2V5OiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kOiBvdXRib3VuZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50OiBhdXRvSW5jcmVtZW50LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBhcnJheWlmeShzdG9yZS5pbmRleE5hbWVzKS5tYXAoZnVuY3Rpb24gKGluZGV4TmFtZSkgeyByZXR1cm4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaW5kZXgubmFtZSwgdW5pcXVlID0gaW5kZXgudW5pcXVlLCBtdWx0aUVudHJ5ID0gaW5kZXgubXVsdGlFbnRyeSwga2V5UGF0aCA9IGluZGV4LmtleVBhdGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdW5pcXVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5OiBtdWx0aUVudHJ5LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IGZ1bmN0aW9uIChrZXlQYXRoKSB7IHJldHVybiBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgaGFzR2V0QWxsOiB0YWJsZXMubGVuZ3RoID4gMCAmJiAoJ2dldEFsbCcgaW4gdHJhbnMub2JqZWN0U3RvcmUodGFibGVzWzBdKSkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAhKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZShyYW5nZSkge1xuXHQgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbmV2ZXIgdHlwZSB0byBJREJLZXlSYW5nZVwiKTtcblx0ICAgICAgICAgICAgdmFyIGxvd2VyID0gcmFuZ2UubG93ZXIsIHVwcGVyID0gcmFuZ2UudXBwZXIsIGxvd2VyT3BlbiA9IHJhbmdlLmxvd2VyT3BlbiwgdXBwZXJPcGVuID0gcmFuZ2UudXBwZXJPcGVuO1xuXHQgICAgICAgICAgICB2YXIgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgICAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuXHQgICAgICAgICAgICAgICAgICAgIG51bGwgOlxuXHQgICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6XG5cdCAgICAgICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5sb3dlckJvdW5kKGxvd2VyLCAhIWxvd2VyT3BlbikgOlxuXHQgICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgISFsb3dlck9wZW4sICEhdXBwZXJPcGVuKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGlkYlJhbmdlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSkge1xuXHQgICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGFibGVTY2hlbWEubmFtZTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gbXV0YXRlKF9hKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywgdHlwZSA9IF9hLnR5cGUsIGtleXMgPSBfYS5rZXlzLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHJhbmdlID0gX2EucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG91dGJvdW5kID0gc3RvcmUua2V5UGF0aCA9PSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpc0FkZE9yUHV0ID0gdHlwZSA9PT0gXCJwdXRcIiB8fCB0eXBlID09PSBcImFkZFwiO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaXNBZGRPclB1dCAmJiB0eXBlICE9PSAnZGVsZXRlJyAmJiB0eXBlICE9PSAnZGVsZXRlUmFuZ2UnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSAoa2V5cyB8fCB2YWx1ZXMgfHwgeyBsZW5ndGg6IDEgfSkubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBrZXlzIGFycmF5IG11c3QgaGF2ZSBzYW1lIGxlbmd0aCBhcyBnaXZlbiB2YWx1ZXMgYXJyYXkuXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlcTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICArK251bUZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RlbGV0ZVJhbmdlJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gNCApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcywgZmFpbHVyZXM6IGZhaWx1cmVzLCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuY2xlYXIoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5kZWxldGUobWFrZUlEQktleVJhbmdlKHJhbmdlKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gaXNBZGRPclB1dCA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywga2V5c10gOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIG51bGxdIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtrZXlzLCBudWxsXSwgYXJnczEgPSBfYVswXSwgYXJnczIgPSBfYVsxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gKGFyZ3MyICYmIGFyZ3MyW2ldICE9PSB1bmRlZmluZWQgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSwgYXJnczJbaV0pIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0pKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RSZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXFzLmZvckVhY2goZnVuY3Rpb24gKHJlcSwgaSkgeyByZXR1cm4gcmVxLmVycm9yICE9IG51bGwgJiYgKGZhaWx1cmVzW2ldID0gcmVxLmVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXM6IGZhaWx1cmVzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdHlwZSA9PT0gXCJkZWxldGVcIiA/IGtleXMgOiByZXFzLm1hcChmdW5jdGlvbiAocmVxKSB7IHJldHVybiByZXEucmVzdWx0OyB9KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQ6IGxhc3RSZXN1bHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBkb25lO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZnVuY3Rpb24gb3BlbkN1cnNvcihfYSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIHZhbHVlcyA9IF9hLnZhbHVlcywgcXVlcnkgPSBfYS5xdWVyeSwgcmV2ZXJzZSA9IF9hLnJldmVyc2UsIHVuaXF1ZSA9IF9hLnVuaXF1ZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZ1bmlxdWVcIiA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZcIiA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5leHR1bmlxdWVcIiA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRcIjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLl9fX2lkID0gKytfaWRfY291bnRlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRvbmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJzb3JDb250aW51ZSA9IGN1cnNvci5jb250aW51ZS5iaW5kKGN1cnNvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleS5iaW5kKGN1cnNvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RhcnRlZFwiKTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnRyYW5zID0gdHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSB3cmFwKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnb3RPbmUgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ290T25lLS0gPyBfdGhpcy5jb250aW51ZSgpIDogX3RoaXMuc3RvcCgpOyB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3RJdGVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gcmVqZWN0SXRlcmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbih2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIGJlaGluZCBsYXN0IGVudHJ5XCIpOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUgPSBfY3Vyc29yQ29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlID0gX2N1cnNvckFkdmFuY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRpb25Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGN1cnNvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHF1ZXJ5KGhhc0dldEFsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IHJlcXVlc3QudHJhbnMsIHZhbHVlcyA9IHJlcXVlc3QudmFsdWVzLCBsaW1pdCA9IHJlcXVlc3QubGltaXQsIHF1ZXJ5ID0gcmVxdWVzdC5xdWVyeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbkluZmluaXRMaW1pdCA9IGxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IGxpbWl0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5pbmRleCwgcmFuZ2UgPSBxdWVyeS5yYW5nZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiBbXSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHZhbHVlcyA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbChpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0IH0pOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudF8xID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFfMSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKGlkYktleVJhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxXzEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcV8xLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdF8xIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xLnB1c2godmFsdWVzID8gY3Vyc29yLnZhbHVlIDogY3Vyc29yLnByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50XzEgPT09IGxpbWl0KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogcmVzdWx0XzEgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxXzEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZU5hbWUsXG5cdCAgICAgICAgICAgICAgICBzY2hlbWE6IHRhYmxlU2NoZW1hLFxuXHQgICAgICAgICAgICAgICAgbXV0YXRlOiBtdXRhdGUsXG5cdCAgICAgICAgICAgICAgICBnZXRNYW55OiBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywga2V5cyA9IF9hLmtleXM7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5Q291bnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDb3VudCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGV2ZW50LnRhcmdldDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0W3JlcS5fcG9zXSA9IHJlcS5yZXN1bHQpICE9IG51bGwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gc3RvcmUuZ2V0KGtleXNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gc3VjY2Vzc0hhbmRsZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytrZXlDb3VudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywga2V5ID0gX2Eua2V5O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5KGhhc0dldEFsbCksXG5cdCAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yOiBvcGVuQ3Vyc29yLFxuXHQgICAgICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCB0cmFucyA9IF9hLnRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmluZGV4LCByYW5nZSA9IHF1ZXJ5LnJhbmdlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiS2V5UmFuZ2UgPyBzb3VyY2UuY291bnQoaWRiS2V5UmFuZ2UpIDogc291cmNlLmNvdW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uIChldikgeyByZXR1cm4gcmVzb2x2ZShldi50YXJnZXQucmVzdWx0KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBfYSA9IGV4dHJhY3RTY2hlbWEoZGIsIHRtcFRyYW5zKSwgc2NoZW1hID0gX2Euc2NoZW1hLCBoYXNHZXRBbGwgPSBfYS5oYXNHZXRBbGw7XG5cdCAgICAgICAgdmFyIHRhYmxlcyA9IHNjaGVtYS50YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZVNjaGVtYSkgeyByZXR1cm4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpOyB9KTtcblx0ICAgICAgICB2YXIgdGFibGVNYXAgPSB7fTtcblx0ICAgICAgICB0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHsgcmV0dXJuIHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGU7IH0pO1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbjogZGIudHJhbnNhY3Rpb24uYmluZChkYiksXG5cdCAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhYmxlTWFwW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFibGUgJ1wiLmNvbmNhdChuYW1lLCBcIicgbm90IGZvdW5kXCIpKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZU1hcFtuYW1lXTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgTUlOX0tFWTogLUluZmluaXR5LFxuXHQgICAgICAgICAgICBNQVhfS0VZOiBnZXRNYXhLZXkoSWRiS2V5UmFuZ2UpLFxuXHQgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhzdGFja0ltcGwsIG1pZGRsZXdhcmVzKSB7XG5cdCAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZShmdW5jdGlvbiAoZG93biwgX2EpIHtcblx0ICAgICAgICAgICAgdmFyIGNyZWF0ZSA9IF9hLmNyZWF0ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93biksIGNyZWF0ZShkb3duKSkpO1xuXHQgICAgICAgIH0sIHN0YWNrSW1wbCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKG1pZGRsZXdhcmVzLCBpZGJkYiwgX2EsIHRtcFRyYW5zKSB7XG5cdCAgICAgICAgdmFyIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7IF9hLmluZGV4ZWREQjtcblx0ICAgICAgICB2YXIgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrKGNyZWF0ZURCQ29yZShpZGJkYiwgSURCS2V5UmFuZ2UsIHRtcFRyYW5zKSwgbWlkZGxld2FyZXMuZGJjb3JlKTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBkYmNvcmU6IGRiY29yZVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKSB7XG5cdCAgICAgICAgdmFyIGlkYmRiID0gdG1wVHJhbnMuZGI7XG5cdCAgICAgICAgdmFyIHN0YWNrcyA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MoZGIuX21pZGRsZXdhcmVzLCBpZGJkYiwgZGIuX2RlcHMsIHRtcFRyYW5zKTtcblx0ICAgICAgICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZTtcblx0ICAgICAgICBkYi50YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcblx0ICAgICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRhYmxlLm5hbWU7XG5cdCAgICAgICAgICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZShmdW5jdGlvbiAodGJsKSB7IHJldHVybiB0YmwubmFtZSA9PT0gdGFibGVOYW1lOyB9KSkge1xuXHQgICAgICAgICAgICAgICAgdGFibGUuY29yZSA9IGRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmIChkYlt0YWJsZU5hbWVdIGluc3RhbmNlb2YgZGIuVGFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYlt0YWJsZU5hbWVdLmNvcmUgPSB0YWJsZS5jb3JlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNldEFwaU9uUGxhY2UoZGIsIG9ianMsIHRhYmxlTmFtZXMsIGRic2NoZW1hKSB7XG5cdCAgICAgICAgdGFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgdmFyIHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG5cdCAgICAgICAgICAgIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcERlc2MgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCB0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFwcm9wRGVzYyB8fCAoXCJ2YWx1ZVwiIGluIHByb3BEZXNjICYmIHByb3BEZXNjLnZhbHVlID09PSB1bmRlZmluZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlIHx8IG9iaiBpbnN0YW5jZW9mIGRiLlRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3Aob2JqLCB0YWJsZU5hbWUsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50YWJsZSh0YWJsZU5hbWUpOyB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCB0YWJsZU5hbWUsIHsgdmFsdWU6IHZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9ialt0YWJsZU5hbWVdID0gbmV3IGRiLlRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcmVtb3ZlVGFibGVzQXBpKGRiLCBvYmpzKSB7XG5cdCAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9ialtrZXldIGluc3RhbmNlb2YgZGIuVGFibGUpXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBsb3dlclZlcnNpb25GaXJzdChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBydW5VcGdyYWRlcnMoZGIsIG9sZFZlcnNpb24sIGlkYlVwZ3JhZGVUcmFucywgcmVqZWN0KSB7XG5cdCAgICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYTtcblx0ICAgICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykgJiYgIWdsb2JhbFNjaGVtYS4kbWV0YSkge1xuXHQgICAgICAgICAgICBnbG9iYWxTY2hlbWEuJG1ldGEgPSBjcmVhdGVUYWJsZVNjaGVtYShcIiRtZXRhXCIsIHBhcnNlSW5kZXhTeW50YXgoXCJcIilbMF0sIFtdKTtcblx0ICAgICAgICAgICAgZGIuX3N0b3JlTmFtZXMucHVzaCgnJG1ldGEnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBkYi5fc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcblx0ICAgICAgICB0cmFucy5jcmVhdGUoaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuXHQgICAgICAgIHZhciByZWplY3RUcmFuc2FjdGlvbiA9IHRyYW5zLl9yZWplY3QuYmluZCh0cmFucyk7XG5cdCAgICAgICAgdmFyIHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuXHQgICAgICAgIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG5cdCAgICAgICAgICAgIFBTRC50cmFuc2xlc3MgPSB0cmFuc2xlc3M7XG5cdCAgICAgICAgICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBrZXlzKGdsb2JhbFNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0YWJsZU5hbWUsIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLm9uLnBvcHVsYXRlLmZpcmUodHJhbnMpOyB9KS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhpc3RpbmdWZXJzaW9uKGRiLCB0cmFucywgb2xkVmVyc2lvbilcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2xkVmVyc2lvbikgeyByZXR1cm4gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucyk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcGF0Y2hDdXJyZW50VmVyc2lvbihkYiwgaWRiVXBncmFkZVRyYW5zKSB7XG5cdCAgICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhkYi5fZGJTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgaWYgKGlkYlVwZ3JhZGVUcmFucy5kYi52ZXJzaW9uICUgMTAgPT09IDAgJiYgIWlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCckbWV0YScpKSB7XG5cdCAgICAgICAgICAgIGlkYlVwZ3JhZGVUcmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSgnJG1ldGEnKS5hZGQoTWF0aC5jZWlsKChpZGJVcGdyYWRlVHJhbnMuZGIudmVyc2lvbiAvIDEwKSAtIDEpLCAndmVyc2lvbicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKGdsb2JhbFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcblx0ICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh0YWJsZUNoYW5nZSkge1xuXHQgICAgICAgICAgICBpZiAodGFibGVDaGFuZ2UuY2hhbmdlLmxlbmd0aCB8fCB0YWJsZUNoYW5nZS5yZWNyZWF0ZSkge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIHBhdGNoIGluZGV4ZXMgb2YgdGFibGUgXCIuY29uY2F0KHRhYmxlQ2hhbmdlLm5hbWUsIFwiIGJlY2F1c2UgaXQgaGFzIGNoYW5nZXMgb24gdGhlIHR5cGUgb2YgaW5kZXggb3IgcHJpbWFyeSBrZXkuXCIpKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUodGFibGVDaGFuZ2UubmFtZSk7XG5cdCAgICAgICAgICAgIHRhYmxlQ2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkZWJ1Zylcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiRGV4aWUgdXBncmFkZSBwYXRjaDogQ3JlYXRpbmcgbWlzc2luZyBpbmRleCBcIi5jb25jYXQodGFibGVDaGFuZ2UubmFtZSwgXCIuXCIpLmNvbmNhdChpZHguc3JjKSk7XG5cdCAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGlmZi5jaGFuZ2U7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB0YWJsZUNoYW5nZSA9IF9hW19pXTtcblx0ICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKHRhYmxlQ2hhbmdlKTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0RXhpc3RpbmdWZXJzaW9uKGRiLCB0cmFucywgb2xkVmVyc2lvbikge1xuXHQgICAgICAgIGlmICh0cmFucy5zdG9yZU5hbWVzLmluY2x1ZGVzKCckbWV0YScpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0cmFucy50YWJsZSgnJG1ldGEnKS5nZXQoJ3ZlcnNpb24nKS50aGVuKGZ1bmN0aW9uIChtZXRhVmVyc2lvbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFWZXJzaW9uICE9IG51bGwgPyBtZXRhVmVyc2lvbiA6IG9sZFZlcnNpb247XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKG9sZFZlcnNpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpIHtcblx0ICAgICAgICB2YXIgcXVldWUgPSBbXTtcblx0ICAgICAgICB2YXIgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG5cdCAgICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICB2YXIgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA+PSBvbGRWZXJzaW9uOyB9KTtcblx0ICAgICAgICBpZiAodmVyc1RvUnVuLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKHZlcnNpb24pIHtcblx0ICAgICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb2xkU2NoZW1hID0gZ2xvYmFsU2NoZW1hO1xuXHQgICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcblx0ICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBvbGRTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgbmV3U2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKTtcblx0ICAgICAgICAgICAgICAgIGRpZmYuYWRkLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVjcmVhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVfMSA9IGlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZShjaGFuZ2UubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhZGRJbmRleChzdG9yZV8xLCBpZHgpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlXzEuZGVsZXRlSW5kZXgoaWR4Lm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5kZXgoc3RvcmVfMSwgaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwuZm9yRWFjaChmdW5jdGlvbiAoaWR4TmFtZSkgeyByZXR1cm4gc3RvcmVfMS5kZWxldGVJbmRleChpZHhOYW1lKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGVudFVwZ3JhZGUgPSB2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGU7XG5cdCAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGUgJiYgdmVyc2lvbi5fY2ZnLnZlcnNpb24gPiBvbGRWZXJzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zLl9tZW1vaXplZFRhYmxlcyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB1cGdyYWRlU2NoZW1hXzEgPSBzaGFsbG93Q2xvbmUobmV3U2NoZW1hKTtcblx0ICAgICAgICAgICAgICAgICAgICBkaWZmLmRlbC5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cGdyYWRlU2NoZW1hXzFbdGFibGVdID0gb2xkU2NoZW1hW3RhYmxlXTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcblx0ICAgICAgICAgICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwga2V5cyh1cGdyYWRlU2NoZW1hXzEpLCB1cGdyYWRlU2NoZW1hXzEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IHVwZ3JhZGVTY2hlbWFfMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFVwZ3JhZGVJc0FzeW5jXzEgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmNfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWVfMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUZvbGxvd2VkID0gRGV4aWVQcm9taXNlLmZvbGxvdyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlXzEgPSBjb250ZW50VXBncmFkZSh0cmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZV8xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlXzEudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZV8xICYmIHR5cGVvZiByZXR1cm5WYWx1ZV8xLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZV8xKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlXzE7IH0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuXHQgICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGRiLl9zdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuXHQgICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoaWRidHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkYi5pZGJkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCckbWV0YScpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguY2VpbChkYi5pZGJkYi52ZXJzaW9uIC8gMTApID09PSB2ZXJzaW9uLl9jZmcudmVyc2lvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYi5pZGJkYi5kZWxldGVPYmplY3RTdG9yZSgnJG1ldGEnKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRiLl9kYlNjaGVtYS4kbWV0YTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBkYi5fc3RvcmVOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgIT09ICckbWV0YSc7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMub2JqZWN0U3RvcmUoJyRtZXRhJykucHV0KHZlcnNpb24uX2NmZy52ZXJzaW9uLCAndmVyc2lvbicpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgZnVuY3Rpb24gcnVuUXVldWUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBxdWV1ZS5sZW5ndGggPyBEZXhpZVByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuXHQgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ1blF1ZXVlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZ2xvYmFsU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuXHQgICAgICAgIHZhciBkaWZmID0ge1xuXHQgICAgICAgICAgICBkZWw6IFtdLFxuXHQgICAgICAgICAgICBhZGQ6IFtdLFxuXHQgICAgICAgICAgICBjaGFuZ2U6IFtdXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgdGFibGU7XG5cdCAgICAgICAgZm9yICh0YWJsZSBpbiBvbGRTY2hlbWEpIHtcblx0ICAgICAgICAgICAgaWYgKCFuZXdTY2hlbWFbdGFibGVdKVxuXHQgICAgICAgICAgICAgICAgZGlmZi5kZWwucHVzaCh0YWJsZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodGFibGUgaW4gbmV3U2NoZW1hKSB7XG5cdCAgICAgICAgICAgIHZhciBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLCBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuXHQgICAgICAgICAgICBpZiAoIW9sZERlZikge1xuXHQgICAgICAgICAgICAgICAgZGlmZi5hZGQucHVzaChbdGFibGUsIG5ld0RlZl0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZSxcblx0ICAgICAgICAgICAgICAgICAgICBkZWY6IG5ld0RlZixcblx0ICAgICAgICAgICAgICAgICAgICByZWNyZWF0ZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsOiBbXSxcblx0ICAgICAgICAgICAgICAgICAgICBhZGQ6IFtdLFxuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogW11cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBpZiAoKFxuXHQgICAgICAgICAgICAgICAgJycgKyAob2xkRGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpICE9PSAoJycgKyAobmV3RGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgKG9sZERlZi5wcmltS2V5LmF1dG8gIT09IG5ld0RlZi5wcmltS2V5LmF1dG8pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSW5kZXhlcyA9IG9sZERlZi5pZHhCeU5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZHhOYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBvbGRJbmRleGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwucHVzaChpZHhOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZElkeCA9IG9sZEluZGV4ZXNbaWR4TmFtZV0sIG5ld0lkeCA9IG5ld0luZGV4ZXNbaWR4TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkSWR4KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5wdXNoKG5ld0lkeCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZElkeC5zcmMgIT09IG5ld0lkeC5zcmMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLnB1c2gobmV3SWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5kZWwubGVuZ3RoID4gMCB8fCBjaGFuZ2UuYWRkLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmNoYW5nZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRpZmY7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG5cdCAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCBwcmltS2V5LmtleVBhdGggP1xuXHQgICAgICAgICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuXHQgICAgICAgICAgICB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9KTtcblx0ICAgICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gYWRkSW5kZXgoc3RvcmUsIGlkeCk7IH0pO1xuXHQgICAgICAgIHJldHVybiBzdG9yZTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuXHQgICAgICAgIGtleXMobmV3U2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgaWYgKCFpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRhYmxlTmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkZWJ1Zylcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXhpZTogQ3JlYXRpbmcgbWlzc2luZyB0YWJsZScsIHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBuZXdTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBuZXdTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG5cdCAgICAgICAgW10uc2xpY2UuY2FsbChpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1NjaGVtYVtzdG9yZU5hbWVdID09IG51bGwgJiYgaWRidHJhbnMuZGIuZGVsZXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkZEluZGV4KHN0b3JlLCBpZHgpIHtcblx0ICAgICAgICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG5cdCAgICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IHt9O1xuXHQgICAgICAgIHZhciBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcblx0ICAgICAgICBkYlN0b3JlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciBzdG9yZSA9IHRtcFRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG5cdCAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUua2V5UGF0aDtcblx0ICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBjcmVhdGVJbmRleFNwZWMobmFtZUZyb21LZXlQYXRoKGtleVBhdGgpLCBrZXlQYXRoIHx8IFwiXCIsIHRydWUsIGZhbHNlLCAhIXN0b3JlLmF1dG9JbmNyZW1lbnQsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIHRydWUpO1xuXHQgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZGJpbmRleCA9IHN0b3JlLmluZGV4KHN0b3JlLmluZGV4TmFtZXNbal0pO1xuXHQgICAgICAgICAgICAgICAga2V5UGF0aCA9IGlkYmluZGV4LmtleVBhdGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVJbmRleFNwZWMoaWRiaW5kZXgubmFtZSwga2V5UGF0aCwgISFpZGJpbmRleC51bmlxdWUsICEhaWRiaW5kZXgubXVsdGlFbnRyeSwgZmFsc2UsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBnbG9iYWxTY2hlbWE7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpIHtcblx0ICAgICAgICBkYi52ZXJubyA9IGlkYmRiLnZlcnNpb24gLyAxMDtcblx0ICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG5cdCAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcblx0ICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlc10sIGtleXMoZ2xvYmFsU2NoZW1hKSwgZ2xvYmFsU2NoZW1hKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpIHtcblx0ICAgICAgICB2YXIgaW5zdGFsbGVkU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCB0bXBUcmFucyk7XG5cdCAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKGluc3RhbGxlZFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcblx0ICAgICAgICByZXR1cm4gIShkaWZmLmFkZC5sZW5ndGggfHwgZGlmZi5jaGFuZ2Uuc29tZShmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGNoLmFkZC5sZW5ndGggfHwgY2guY2hhbmdlLmxlbmd0aDsgfSkpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIHNjaGVtYSwgaWRidHJhbnMpIHtcblx0ICAgICAgICB2YXIgc3RvcmVOYW1lcyA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZU5hbWVzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuXHQgICAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuXHQgICAgICAgICAgICBkYi5faGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHN0b3JlLmluZGV4KGluZGV4TmFtZSkua2V5UGF0aDtcblx0ICAgICAgICAgICAgICAgIHZhciBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcblx0ICAgICAgICAgICAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhTcGVjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtpbmRleE5hbWVdID0gaW5kZXhTcGVjO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuXHQgICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcblx0ICAgICAgICAgICAgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJiBfZ2xvYmFsIGluc3RhbmNlb2YgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJlxuXHQgICAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KSB7XG5cdCAgICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwYXJzZUluZGV4U3ludGF4KHByaW1LZXlBbmRJbmRleGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHByaW1LZXlBbmRJbmRleGVzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChpbmRleCwgaW5kZXhOdW0pIHtcblx0ICAgICAgICAgICAgaW5kZXggPSBpbmRleC50cmltKCk7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgdmFyIGtleVBhdGggPSAvXlxcWy8udGVzdChuYW1lKSA/IG5hbWUubWF0Y2goL15cXFsoLiopXFxdJC8pWzFdLnNwbGl0KCcrJykgOiBuYW1lO1xuXHQgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5kZXhTcGVjKG5hbWUsIGtleVBhdGggfHwgbnVsbCwgL1xcJi8udGVzdChpbmRleCksIC9cXCovLnRlc3QoaW5kZXgpLCAvXFwrXFwrLy50ZXN0KGluZGV4KSwgaXNBcnJheShrZXlQYXRoKSwgaW5kZXhOdW0gPT09IDApO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgVmVyc2lvbiA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFZlcnNpb24oKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFZlcnNpb24ucHJvdG90eXBlLl9wYXJzZVN0b3Jlc1NwZWMgPSBmdW5jdGlvbiAoc3RvcmVzLCBvdXRTY2hlbWEpIHtcblx0ICAgICAgICAgICAga2V5cyhzdG9yZXMpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHN0b3Jlc1t0YWJsZU5hbWVdICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBwYXJzZUluZGV4U3ludGF4KHN0b3Jlc1t0YWJsZU5hbWVdKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGluZGV4ZXMuc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBwcmltS2V5LnVuaXF1ZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkubXVsdGkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIlByaW1hcnkga2V5IGNhbm5vdCBiZSBtdWx0aS12YWx1ZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiT25seSBwcmltYXJ5IGtleSBjYW4gYmUgbWFya2VkIGFzIGF1dG9JbmNyZW1lbnQgKCsrKVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHgua2V5UGF0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkluZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYSh0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFZlcnNpb24ucHJvdG90eXBlLnN0b3JlcyA9IGZ1bmN0aW9uIChzdG9yZXMpIHtcblx0ICAgICAgICAgICAgdmFyIGRiID0gdGhpcy5kYjtcblx0ICAgICAgICAgICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgP1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UsIHN0b3JlcykgOlxuXHQgICAgICAgICAgICAgICAgc3RvcmVzO1xuXHQgICAgICAgICAgICB2YXIgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG5cdCAgICAgICAgICAgIHZhciBzdG9yZXNTcGVjID0ge307XG5cdCAgICAgICAgICAgIHZhciBkYnNjaGVtYSA9IHt9O1xuXHQgICAgICAgICAgICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICBleHRlbmQoc3RvcmVzU3BlYywgdmVyc2lvbi5fY2ZnLnN0b3Jlc1NvdXJjZSk7XG5cdCAgICAgICAgICAgICAgICBkYnNjaGVtYSA9ICh2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fSk7XG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uLl9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzU3BlYywgZGJzY2hlbWEpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgZGIuX2RiU2NoZW1hID0gZGJzY2hlbWE7XG5cdCAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcblx0ICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUsIHRoaXMuX2NmZy50YWJsZXNdLCBrZXlzKGRic2NoZW1hKSwgZGJzY2hlbWEpO1xuXHQgICAgICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFZlcnNpb24ucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbiAodXBncmFkZUZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHByb21pc2FibGVDaGFpbih0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgfHwgbm9wLCB1cGdyYWRlRnVuY3Rpb24pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBWZXJzaW9uO1xuXHQgICAgfSgpKTtcblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKGRiKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFZlcnNpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuXHQgICAgICAgICAgICB0aGlzLl9jZmcgPSB7XG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uTnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgc3RvcmVzU291cmNlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgZGJzY2hlbWE6IHt9LFxuXHQgICAgICAgICAgICAgICAgdGFibGVzOiB7fSxcblx0ICAgICAgICAgICAgICAgIGNvbnRlbnRVcGdyYWRlOiBudWxsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKSB7XG5cdCAgICAgICAgdmFyIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl07XG5cdCAgICAgICAgaWYgKCFkYk5hbWVzREIpIHtcblx0ICAgICAgICAgICAgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXSA9IG5ldyBEZXhpZSQxKERCTkFNRVNfREIsIHtcblx0ICAgICAgICAgICAgICAgIGFkZG9uczogW10sXG5cdCAgICAgICAgICAgICAgICBpbmRleGVkREI6IGluZGV4ZWREQixcblx0ICAgICAgICAgICAgICAgIElEQktleVJhbmdlOiBJREJLZXlSYW5nZSxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6IFwibmFtZVwiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGJOYW1lc0RCLnRhYmxlKFwiZGJuYW1lc1wiKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpIHtcblx0ICAgICAgICByZXR1cm4gaW5kZXhlZERCICYmIHR5cGVvZiBpbmRleGVkREIuZGF0YWJhc2VzID09PSBcImZ1bmN0aW9uXCI7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXREYXRhYmFzZU5hbWVzKF9hKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcblx0ICAgICAgICByZXR1cm4gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQilcblx0ICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoaW5kZXhlZERCLmRhdGFiYXNlcygpKS50aGVuKGZ1bmN0aW9uIChpbmZvcykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluZm9zXG5cdCAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5uYW1lOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgIT09IERCTkFNRVNfREI7IH0pO1xuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICA6IGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cygpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gX29uRGF0YWJhc2VDcmVhdGVkKF9hLCBuYW1lKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcblx0ICAgICAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcblx0ICAgICAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuXHQgICAgICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHsgbmFtZTogbmFtZSB9KS5jYXRjaChub3ApO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gX29uRGF0YWJhc2VEZWxldGVkKF9hLCBuYW1lKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ZWREQiA9IF9hLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTtcblx0ICAgICAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcblx0ICAgICAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuXHQgICAgICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkuZGVsZXRlKG5hbWUpLmNhdGNoKG5vcCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHZpcChmbikge1xuXHQgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIFBTRC5sZXRUaHJvdWdoID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGlkYlJlYWR5KCkge1xuXHQgICAgICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuXHQgICAgICAgICAgICAvU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG5cdCAgICAgICAgICAgICEvQ2hyb20oZXxpdW0pXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHQgICAgICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG5cdCAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgICB2YXIgaW50ZXJ2YWxJZDtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgdmFyIHRyeUlkYiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4ZWREQi5kYXRhYmFzZXMoKS5maW5hbGx5KHJlc29sdmUpOyB9O1xuXHQgICAgICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodHJ5SWRiLCAxMDApO1xuXHQgICAgICAgICAgICB0cnlJZGIoKTtcblx0ICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7IH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgX2E7XG5cdCAgICBmdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZSkge1xuXHQgICAgICAgIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xuXHQgICAgfVxuXHQgICAgdmFyIFJhbmdlU2V0ID0gZnVuY3Rpb24gKGZyb21PclRyZWUsIHRvKSB7XG5cdCAgICAgICAgaWYgKHRoaXMpIHtcblx0ICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyB7IGQ6IDEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZSB9IDogeyBkOiAwIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IFJhbmdlU2V0KCk7XG5cdCAgICAgICAgICAgIGlmIChmcm9tT3JUcmVlICYmIChcImRcIiBpbiBmcm9tT3JUcmVlKSkge1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKHJ2LCBmcm9tT3JUcmVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHByb3BzKFJhbmdlU2V0LnByb3RvdHlwZSwgKF9hID0ge1xuXHQgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChyYW5nZVNldCkge1xuXHQgICAgICAgICAgICAgICAgbWVyZ2VSYW5nZXModGhpcywgcmFuZ2VTZXQpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGFkZEtleTogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGFkZEtleXM6IGZ1bmN0aW9uIChrZXlzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFkZFJhbmdlKF90aGlzLCBrZXksIGtleSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGhhc0tleTogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpLm5leHQoa2V5KS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBub2RlICYmIGNtcChub2RlLmZyb20sIGtleSkgPD0gMCAmJiBjbXAobm9kZS50bywga2V5KSA+PSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBfYVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgX2EpKTtcblx0ICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pIHtcblx0ICAgICAgICB2YXIgZGlmZiA9IGNtcChmcm9tLCB0byk7XG5cdCAgICAgICAgaWYgKGlzTmFOKGRpZmYpKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgaWYgKGRpZmYgPiAwKVxuXHQgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCk7XG5cdCAgICAgICAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKVxuXHQgICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHRhcmdldCwgeyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEgfSk7XG5cdCAgICAgICAgdmFyIGxlZnQgPSB0YXJnZXQubDtcblx0ICAgICAgICB2YXIgcmlnaHQgPSB0YXJnZXQucjtcblx0ICAgICAgICBpZiAoY21wKHRvLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG5cdCAgICAgICAgICAgIGxlZnRcblx0ICAgICAgICAgICAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG5cdCAgICAgICAgICAgICAgICA6ICh0YXJnZXQubCA9IHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LnRvKSA+IDApIHtcblx0ICAgICAgICAgICAgcmlnaHRcblx0ICAgICAgICAgICAgICAgID8gYWRkUmFuZ2UocmlnaHQsIGZyb20sIHRvKVxuXHQgICAgICAgICAgICAgICAgOiAodGFyZ2V0LnIgPSB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY21wKGZyb20sIHRhcmdldC5mcm9tKSA8IDApIHtcblx0ICAgICAgICAgICAgdGFyZ2V0LmZyb20gPSBmcm9tO1xuXHQgICAgICAgICAgICB0YXJnZXQubCA9IG51bGw7XG5cdCAgICAgICAgICAgIHRhcmdldC5kID0gcmlnaHQgPyByaWdodC5kICsgMSA6IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjbXAodG8sIHRhcmdldC50bykgPiAwKSB7XG5cdCAgICAgICAgICAgIHRhcmdldC50byA9IHRvO1xuXHQgICAgICAgICAgICB0YXJnZXQuciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByaWdodFdhc0N1dE9mZiA9ICF0YXJnZXQucjtcblx0ICAgICAgICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcblx0ICAgICAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0LCBsZWZ0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJpZ2h0ICYmIHJpZ2h0V2FzQ3V0T2ZmKSB7XG5cdCAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgcmlnaHQpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHRhcmdldCwgbmV3U2V0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KHRhcmdldCwgX2EpIHtcblx0ICAgICAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBsID0gX2EubCwgciA9IF9hLnI7XG5cdCAgICAgICAgICAgIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pO1xuXHQgICAgICAgICAgICBpZiAobClcblx0ICAgICAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuXHQgICAgICAgICAgICBpZiAocilcblx0ICAgICAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWlzRW1wdHlSYW5nZShuZXdTZXQpKVxuXHQgICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBuZXdTZXQpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcmFuZ2VzT3ZlcmxhcChyYW5nZVNldDEsIHJhbmdlU2V0Mikge1xuXHQgICAgICAgIHZhciBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcblx0ICAgICAgICB2YXIgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG5cdCAgICAgICAgaWYgKG5leHRSZXN1bHQxLmRvbmUpXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB2YXIgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuXHQgICAgICAgIHZhciBpMiA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQxKTtcblx0ICAgICAgICB2YXIgbmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSk7XG5cdCAgICAgICAgdmFyIGIgPSBuZXh0UmVzdWx0Mi52YWx1ZTtcblx0ICAgICAgICB3aGlsZSAoIW5leHRSZXN1bHQxLmRvbmUgJiYgIW5leHRSZXN1bHQyLmRvbmUpIHtcblx0ICAgICAgICAgICAgaWYgKGNtcChiLmZyb20sIGEudG8pIDw9IDAgJiYgY21wKGIudG8sIGEuZnJvbSkgPj0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICBjbXAoYS5mcm9tLCBiLmZyb20pIDwgMFxuXHQgICAgICAgICAgICAgICAgPyAoYSA9IChuZXh0UmVzdWx0MSA9IGkxLm5leHQoYi5mcm9tKSkudmFsdWUpXG5cdCAgICAgICAgICAgICAgICA6IChiID0gKG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pKS52YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldFJhbmdlU2V0SXRlcmF0b3Iobm9kZSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGlzRW1wdHlSYW5nZShub2RlKSA/IG51bGwgOiB7IHM6IDAsIG46IG5vZGUgfTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5UHJvdmlkZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQcm92aWRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwgJiYgY21wKGtleSwgc3RhdGUubi5mcm9tKSA8IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlQcm92aWRlZCB8fCBjbXAoa2V5LCBzdGF0ZS5uLnRvKSA8PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzdGF0ZS5uLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubi5yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5yLCBzOiAwIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGUudXA7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByZWJhbGFuY2UodGFyZ2V0KSB7XG5cdCAgICAgICAgdmFyIF9hLCBfYjtcblx0ICAgICAgICB2YXIgZGlmZiA9ICgoKF9hID0gdGFyZ2V0LnIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kKSB8fCAwKSAtICgoKF9iID0gdGFyZ2V0LmwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kKSB8fCAwKTtcblx0ICAgICAgICB2YXIgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG5cdCAgICAgICAgaWYgKHIpIHtcblx0ICAgICAgICAgICAgdmFyIGwgPSByID09PSBcInJcIiA/IFwibFwiIDogXCJyXCI7XG5cdCAgICAgICAgICAgIHZhciByb290Q2xvbmUgPSBfX2Fzc2lnbih7fSwgdGFyZ2V0KTtcblx0ICAgICAgICAgICAgdmFyIG9sZFJvb3RSaWdodCA9IHRhcmdldFtyXTtcblx0ICAgICAgICAgICAgdGFyZ2V0LmZyb20gPSBvbGRSb290UmlnaHQuZnJvbTtcblx0ICAgICAgICAgICAgdGFyZ2V0LnRvID0gb2xkUm9vdFJpZ2h0LnRvO1xuXHQgICAgICAgICAgICB0YXJnZXRbcl0gPSBvbGRSb290UmlnaHRbcl07XG5cdCAgICAgICAgICAgIHJvb3RDbG9uZVtyXSA9IG9sZFJvb3RSaWdodFtsXTtcblx0ICAgICAgICAgICAgdGFyZ2V0W2xdID0gcm9vdENsb25lO1xuXHQgICAgICAgICAgICByb290Q2xvbmUuZCA9IGNvbXB1dGVEZXB0aChyb290Q2xvbmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0YXJnZXQuZCA9IGNvbXB1dGVEZXB0aCh0YXJnZXQpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY29tcHV0ZURlcHRoKF9hKSB7XG5cdCAgICAgICAgdmFyIHIgPSBfYS5yLCBsID0gX2EubDtcblx0ICAgICAgICByZXR1cm4gKHIgPyAobCA/IE1hdGgubWF4KHIuZCwgbC5kKSA6IHIuZCkgOiBsID8gbC5kIDogMCkgKyAxO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRhcmdldCwgbmV3U2V0KSB7XG5cdCAgICAgICAga2V5cyhuZXdTZXQpLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcblx0ICAgICAgICAgICAgaWYgKHRhcmdldFtwYXJ0XSlcblx0ICAgICAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldFtwYXJ0XSwgbmV3U2V0W3BhcnRdKTtcblx0ICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0W3BhcnRdID0gY2xvbmVTaW1wbGVPYmplY3RUcmVlKG5ld1NldFtwYXJ0XSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRhcmdldDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gb2JzU2V0c092ZXJsYXAob3MxLCBvczIpIHtcblx0ICAgICAgICByZXR1cm4gb3MxLmFsbCB8fCBvczIuYWxsIHx8IE9iamVjdC5rZXlzKG9zMSkuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvczJba2V5XSAmJiByYW5nZXNPdmVybGFwKG9zMltrZXldLCBvczFba2V5XSk7IH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FjaGUgPSB7fTtcblxuXHQgICAgdmFyIHVuc2lnbmFsZWRQYXJ0cyA9IHt9O1xuXHQgICAgdmFyIGlzVGFza0VucXVldWVkID0gZmFsc2U7XG5cdCAgICBmdW5jdGlvbiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShwYXJ0LCBvcHRpbWlzdGljKSB7XG5cdCAgICAgICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCh1bnNpZ25hbGVkUGFydHMsIHBhcnQpO1xuXHQgICAgICAgIGlmICghaXNUYXNrRW5xdWV1ZWQpIHtcblx0ICAgICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGlzVGFza0VucXVldWVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSB1bnNpZ25hbGVkUGFydHM7XG5cdCAgICAgICAgICAgICAgICB1bnNpZ25hbGVkUGFydHMgPSB7fTtcblx0ICAgICAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KHBhcnRzLCBmYWxzZSk7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZWRQYXJ0cywgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcblx0ICAgICAgICBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMgPT09IHZvaWQgMCkgeyBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyA9IGZhbHNlOyB9XG5cdCAgICAgICAgdmFyIHF1ZXJpZXNUb1NpZ25hbCA9IG5ldyBTZXQoKTtcblx0ICAgICAgICBpZiAodXBkYXRlZFBhcnRzLmFsbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LnZhbHVlcyhjYWNoZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBfYVtfaV07XG5cdCAgICAgICAgICAgICAgICBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBxdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHVwZGF0ZWRQYXJ0cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gL15pZGJcXDpcXC9cXC8oLiopXFwvKC4qKVxcLy8uZXhlYyhrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRiTmFtZSA9IHBhcnRzWzFdLCB0YWJsZU5hbWUgPSBwYXJ0c1syXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRibENhY2hlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBxdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBxdWVyaWVzVG9TaWduYWwuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gcmVxdWVyeSgpOyB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKHRibENhY2hlLCB1cGRhdGVkUGFydHMsIG91dFF1ZXJpZXNUb1NpZ25hbCwgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcblx0ICAgICAgICB2YXIgdXBkYXRlZEVudHJ5TGlzdHMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwgaW5kZXhOYW1lID0gX2JbMF0sIGVudHJpZXMgPSBfYlsxXTtcblx0ICAgICAgICAgICAgdmFyIGZpbHRlcmVkRW50cmllcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9jIDwgZW50cmllc18xLmxlbmd0aDsgX2MrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc18xW19jXTtcblx0ICAgICAgICAgICAgICAgIGlmIChvYnNTZXRzT3ZlcmxhcCh1cGRhdGVkUGFydHMsIGVudHJ5Lm9ic1NldCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBvdXRRdWVyaWVzVG9TaWduYWwuYWRkKHJlcXVlcnkpOyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRFbnRyaWVzLnB1c2goZW50cnkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcylcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWRFbnRyeUxpc3RzLnB1c2goW2luZGV4TmFtZSwgZmlsdGVyZWRFbnRyaWVzXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIHVwZGF0ZWRFbnRyeUxpc3RzXzEgPSB1cGRhdGVkRW50cnlMaXN0czsgX2QgPCB1cGRhdGVkRW50cnlMaXN0c18xLmxlbmd0aDsgX2QrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9lID0gdXBkYXRlZEVudHJ5TGlzdHNfMVtfZF0sIGluZGV4TmFtZSA9IF9lWzBdLCBmaWx0ZXJlZEVudHJpZXMgPSBfZVsxXTtcblx0ICAgICAgICAgICAgICAgIHRibENhY2hlLnF1ZXJpZXMucXVlcnlbaW5kZXhOYW1lXSA9IGZpbHRlcmVkRW50cmllcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZGV4aWVPcGVuKGRiKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZGIuX3N0YXRlO1xuXHQgICAgICAgIHZhciBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG5cdCAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQgfHwgZGIuaWRiZGIpXG5cdCAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlLmRiT3BlbkVycm9yID9cblx0ICAgICAgICAgICAgICAgIHJlamVjdGlvbihzdGF0ZS5kYk9wZW5FcnJvcikgOlxuXHQgICAgICAgICAgICAgICAgZGI7IH0pO1xuXHQgICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuXHQgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcblx0ICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgb3BlbkNhbmNlbGxlciA9IHN0YXRlLm9wZW5DYW5jZWxsZXI7XG5cdCAgICAgICAgdmFyIG5hdGl2ZVZlclRvT3BlbiA9IE1hdGgucm91bmQoZGIudmVybm8gKiAxMCk7XG5cdCAgICAgICAgdmFyIHNjaGVtYVBhdGNoTW9kZSA9IGZhbHNlO1xuXHQgICAgICAgIGZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoKSB7XG5cdCAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoJ2RiLm9wZW4oKSB3YXMgY2FuY2VsbGVkJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuXHQgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGwsIHdhc0NyZWF0ZWQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgdHJ5T3BlbkRCID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcblx0ICAgICAgICAgICAgaWYgKCFpbmRleGVkREIpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG5cdCAgICAgICAgICAgIHZhciBkYk5hbWUgPSBkYi5uYW1lO1xuXHQgICAgICAgICAgICB2YXIgcmVxID0gc3RhdGUuYXV0b1NjaGVtYSB8fCAhbmF0aXZlVmVyVG9PcGVuID9cblx0ICAgICAgICAgICAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSkgOlxuXHQgICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBuYXRpdmVWZXJUb09wZW4pO1xuXHQgICAgICAgICAgICBpZiAoIXJlcSlcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcblx0ICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHdyYXAoZGIuX2ZpcmVPbkJsb2NrZWQpO1xuXHQgICAgICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEgJiYgIWRiLl9vcHRpb25zLmFsbG93RW1wdHlEQikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcHJldmVudERlZmF1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLnJlc3VsdC5jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLk5vU3VjaERhdGFiYXNlKFwiRGF0YWJhc2UgXCIuY29uY2F0KGRiTmFtZSwgXCIgZG9lc250IGV4aXN0XCIpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24ub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIHdhc0NyZWF0ZWQgPSBvbGRWZXIgPCAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGRiLmlkYmRiID0gcmVxLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUGF0Y2hNb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoQ3VycmVudFZlcnNpb24oZGIsIHVwZ3JhZGVUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHZhciBpZGJkYiA9IGRiLmlkYmRiID0gcmVxLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqZWN0U3RvcmVOYW1lcy5sZW5ndGggPiAwKVxuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBUcmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgob2JqZWN0U3RvcmVOYW1lcyksICdyZWFkb25seScpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIGRiLl9kYlNjaGVtYSwgdG1wVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSAmJiAhc2NoZW1hUGF0Y2hNb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV4aWUgU2NoZW1hRGlmZjogU2NoZW1hIHdhcyBleHRlbmRlZCB3aXRob3V0IGluY3JlYXNpbmcgdGhlIG51bWJlciBwYXNzZWQgdG8gZGIudmVyc2lvbigpLiBEZXhpZSB3aWxsIGFkZCBtaXNzaW5nIHBhcnRzIGFuZCBpbmNyZW1lbnQgbmF0aXZlIHZlcnNpb24gbnVtYmVyIHRvIHdvcmthcm91bmQgdGhpcy5cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRiZGIuY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSBpZGJkYi52ZXJzaW9uICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQYXRjaE1vZGUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRyeU9wZW5EQigpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKGRiKTtcblx0ICAgICAgICAgICAgICAgIGlkYmRiLm9udmVyc2lvbmNoYW5nZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUudmNGaXJlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZGJkYi5vbmNsb3NlID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYi5vbihcImNsb3NlXCIpLmZpcmUoZXYpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAod2FzQ3JlYXRlZClcblx0ICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgIH0sIHJlamVjdCk7XG5cdCAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5uYW1lKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiVW5rbm93bkVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5QUjEzOThfbWF4TG9vcC0tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBXb3JrYXJvdW5kIGZvciBDaHJvbWUgVW5rbm93bkVycm9yIG9uIG9wZW4oKScpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcIlZlcnNpb25FcnJvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVWZXJUb09wZW4gPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVZlclRvT3BlbiA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlPcGVuREIoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICB9KTsgfTtcblx0ICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJhY2UoW1xuXHQgICAgICAgICAgICBvcGVuQ2FuY2VsbGVyLFxuXHQgICAgICAgICAgICAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBEZXhpZVByb21pc2UucmVzb2x2ZSgpIDogaWRiUmVhZHkoKSkudGhlbih0cnlPcGVuREIpXG5cdCAgICAgICAgXSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcblx0ICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcblx0ICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcChmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5vbi5yZWFkeS5maXJlKGRiLnZpcCk7IH0pKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyc18xID0gc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucmVkdWNlKHByb21pc2FibGVDaGFpbiwgbm9wKTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtYWluZGVyc18xKGRiLnZpcCk7IH0pKS50aGVuKGZpcmVSZW1haW5kZXJzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyID09PSBvcGVuQ2FuY2VsbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gZXJyO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uICYmIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG5cdCAgICAgICAgICAgIGlmIChvcGVuQ2FuY2VsbGVyID09PSBzdGF0ZS5vcGVuQ2FuY2VsbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG5cdCAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IHRydWU7XG5cdCAgICAgICAgICAgIHJlc29sdmVEYlJlYWR5KCk7XG5cdCAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh3YXNDcmVhdGVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlcnl0aGluZ18xID0ge307XG5cdCAgICAgICAgICAgICAgICBkYi50YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0YWJsZS5zY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5uYW1lKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvXCIpLmNvbmNhdChpZHgubmFtZSldID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi9cIildID0gZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvOmRlbHNcIildID0gbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tbXV1dKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKS5maXJlKGV2ZXJ5dGhpbmdfMSk7XG5cdCAgICAgICAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyhldmVyeXRoaW5nXzEsIHRydWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBkYjtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXdhaXRJdGVyYXRvcihpdGVyYXRvcikge1xuXHQgICAgICAgIHZhciBjYWxsTmV4dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGl0ZXJhdG9yLm5leHQocmVzdWx0KTsgfSwgZG9UaHJvdyA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaXRlcmF0b3IudGhyb3coZXJyb3IpOyB9LCBvblN1Y2Nlc3MgPSBzdGVwKGNhbGxOZXh0KSwgb25FcnJvciA9IHN0ZXAoZG9UaHJvdyk7XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChnZXROZXh0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGdldE5leHQodmFsKSwgdmFsdWUgPSBuZXh0LnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9uZSA/IHZhbHVlIDpcblx0ICAgICAgICAgICAgICAgICAgICAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZS50aGVuICE9PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgPyBQcm9taXNlLmFsbCh2YWx1ZSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpIDogb25TdWNjZXNzKHZhbHVlKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBleHRyYWN0VHJhbnNhY3Rpb25BcmdzKG1vZGUsIF90YWJsZUFyZ3NfLCBzY29wZUZ1bmMpIHtcblx0ICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKGkgPCAyKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJUb28gZmV3IGFyZ3VtZW50c1wiKTtcblx0ICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG5cdCAgICAgICAgd2hpbGUgKC0taSlcblx0ICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgc2NvcGVGdW5jID0gYXJncy5wb3AoKTtcblx0ICAgICAgICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTtcblx0ICAgICAgICByZXR1cm4gW21vZGUsIHRhYmxlcywgc2NvcGVGdW5jXTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYykge1xuXHQgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG5cdCAgICAgICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgdHJhbnMuZXhwbGljaXQgPSB0cnVlO1xuXHQgICAgICAgICAgICB2YXIgem9uZVByb3BzID0ge1xuXHQgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgdHJhbnNsZXNzOiB0cmFuc2xlc3Ncblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICB0cmFucy5pZGJ0cmFucyA9IHBhcmVudFRyYW5zYWN0aW9uLmlkYnRyYW5zO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFucy5pZGJ0cmFucy5fZXhwbGljaXQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSh7IGRpc2FibGVBdXRvT3BlbjogZmFsc2UgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIG51bGwsIHNjb3BlRnVuYyk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihzY29wZUZ1bmMpO1xuXHQgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuXHQgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWU7XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gc2NvcGVGdW5jLmNhbGwodHJhbnMsIHRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJldHVyblZhbHVlLm5leHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXRJdGVyYXRvcihyZXR1cm5WYWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LCB6b25lUHJvcHMpO1xuXHQgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS50aGVuKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0cmFucy5hY3RpdmUgP1xuXHQgICAgICAgICAgICAgICAgICAgIHhcblx0ICAgICAgICAgICAgICAgICAgICA6IHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5QcmVtYXR1cmVDb21taXQoXCJUcmFuc2FjdGlvbiBjb21taXR0ZWQgdG9vIGVhcmx5LiBTZWUgaHR0cDovL2JpdC5seS8ya2Rja01uXCIpKTsgfSlcblx0ICAgICAgICAgICAgICAgIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVmFsdWU7IH0pKS50aGVuKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuXHQgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYWQoYSwgdmFsdWUsIGNvdW50KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKVxuXHQgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmUoZG93bikge1xuXHQgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93biksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGRvd24udGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXhMb29rdXAgPSB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBhbGxWaXJ0dWFsSW5kZXhlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkVmlydHVhbEluZGV4ZXMoa2V5UGF0aCwga2V5VGFpbCwgbG93TGV2ZWxJbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4TGlzdCA9IChpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdID0gaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSB8fCBbXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleUxlbmd0aCA9IGtleVBhdGggPT0gbnVsbCA/IDAgOiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyAxIDoga2V5UGF0aC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlzVmlydHVhbCA9IGtleVRhaWwgPiAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2aXJ0dWFsSW5kZXggPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbG93TGV2ZWxJbmRleCksIHsgbmFtZTogaXNWaXJ0dWFsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KGtleVBhdGhBbGlhcywgXCIodmlydHVhbC1mcm9tOlwiKS5jb25jYXQobG93TGV2ZWxJbmRleC5uYW1lLCBcIilcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbG93TGV2ZWxJbmRleC5uYW1lLCBsb3dMZXZlbEluZGV4OiBsb3dMZXZlbEluZGV4LCBpc1ZpcnR1YWw6IGlzVmlydHVhbCwga2V5VGFpbDoga2V5VGFpbCwga2V5TGVuZ3RoOiBrZXlMZW5ndGgsIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSwgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4TGlzdC5wdXNoKHZpcnR1YWxJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGtleUxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGhbMF0gOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBrZXlMZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXModmlydHVhbEtleVBhdGgsIGtleVRhaWwgKyAxLCBsb3dMZXZlbEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhMaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEua2V5VGFpbCAtIGIua2V5VGFpbDsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gYWRkVmlydHVhbEluZGV4ZXMoc2NoZW1hLnByaW1hcnlLZXkua2V5UGF0aCwgMCwgc2NoZW1hLnByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICAgICAgaW5kZXhMb29rdXBbXCI6aWRcIl0gPSBbcHJpbWFyeUtleV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2NoZW1hLmluZGV4ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX2FbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRCZXN0SW5kZXgoa2V5UGF0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0WzBdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmFuZ2UocmFuZ2UsIGtleVRhaWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSAxICA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAyICA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS50eXBlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb3dlcjogcGFkKHJhbmdlLmxvd2VyLCByYW5nZS5sb3dlck9wZW4gPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb3dlck9wZW46IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyOiBwYWQocmFuZ2UudXBwZXIsIHJhbmdlLnVwcGVyT3BlbiA/IGRvd24uTUlOX0tFWSA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0KHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXguaXNWaXJ0dWFsID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsgcXVlcnk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleC5sb3dMZXZlbEluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSA6IHJlcTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IHNjaGVtYTogX19hc3NpZ24oX19hc3NpZ24oe30sIHNjaGVtYSksIHsgcHJpbWFyeUtleTogcHJpbWFyeUtleSwgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsIGdldEluZGV4QnlLZXlQYXRoOiBmaW5kQmVzdEluZGV4IH0pLCBjb3VudDogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuY291bnQodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUucXVlcnkodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCBvcGVuQ3Vyc29yOiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlcS5xdWVyeS5pbmRleCwga2V5VGFpbCA9IF9hLmtleVRhaWwsIGlzVmlydHVhbCA9IF9hLmlzVmlydHVhbCwga2V5TGVuZ3RoID0gX2Eua2V5TGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmlydHVhbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ICE9IG51bGwgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUocGFkKGtleSwgcmVxLnJldmVyc2UgPyBkb3duLk1BWF9LRVkgOiBkb3duLk1JTl9LRVksIGtleVRhaWwpKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKGN1cnNvci5rZXkuc2xpY2UoMCwga2V5TGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVxLnJldmVyc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEN1cnNvciA9IE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6IHsgdmFsdWU6IF9jb250aW51ZSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGtleSwgcHJpbWFyeUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleShwYWQoa2V5LCBkb3duLk1BWF9LRVksIGtleVRhaWwpLCBwcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TGVuZ3RoID09PSAxID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ3Vyc29yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHRyYW5zbGF0ZVJlcXVlc3QocmVxKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjdXJzb3IpIHsgcmV0dXJuIGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcik7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9IH0pO1xuXHQgICAgfVxuXHQgICAgdmFyIHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgPSB7XG5cdCAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG5cdCAgICAgICAgbmFtZTogXCJWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXCIsXG5cdCAgICAgICAgbGV2ZWw6IDEsXG5cdCAgICAgICAgY3JlYXRlOiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBnZXRPYmplY3REaWZmKGEsIGIsIHJ2LCBwcmZ4KSB7XG5cdCAgICAgICAgcnYgPSBydiB8fCB7fTtcblx0ICAgICAgICBwcmZ4ID0gcHJmeCB8fCAnJztcblx0ICAgICAgICBrZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcblx0ICAgICAgICAgICAgaWYgKCFoYXNPd24oYiwgcHJvcCkpIHtcblx0ICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBhcCA9IGFbcHJvcF0sIGJwID0gYltwcm9wXTtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBicCA9PT0gJ29iamVjdCcgJiYgYXAgJiYgYnApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYnBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGJwKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcFR5cGVOYW1lID09PSAnT2JqZWN0Jykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgJy4nKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuXHQgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBrZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcblx0ICAgICAgICAgICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcblx0ICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKSB7XG5cdCAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJylcblx0ICAgICAgICAgICAgcmV0dXJuIHJlcS5rZXlzO1xuXHQgICAgICAgIHJldHVybiByZXEua2V5cyB8fCByZXEudmFsdWVzLm1hcChwcmltYXJ5S2V5LmV4dHJhY3RLZXkpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaG9va3NNaWRkbGV3YXJlID0ge1xuXHQgICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuXHQgICAgICAgIG5hbWU6IFwiSG9va3NNaWRkbGV3YXJlXCIsXG5cdCAgICAgICAgbGV2ZWw6IDIsXG5cdCAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoZG93bkNvcmUpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93bkNvcmUpLCB7IHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gZG93bkNvcmUudGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gZG93blRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgdmFyIHRhYmxlTWlkZGxld2FyZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duVGFibGUpLCB7IG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhUcmFucyA9IFBTRC50cmFucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZHhUcmFucy50YWJsZSh0YWJsZU5hbWUpLmhvb2ssIGRlbGV0aW5nID0gX2EuZGVsZXRpbmcsIGNyZWF0aW5nID0gX2EuY3JlYXRpbmcsIHVwZGF0aW5nID0gX2EudXBkYXRpbmc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVxLnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHV0Jzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wICYmIHVwZGF0aW5nLmZpcmUgPT09IG5vcClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkUHV0T3JEZWxldGUocmVxKTsgfSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZVJhbmdlKHJlcSk7IH0sIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4VHJhbnMgPSBQU0QudHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHJlcS5rZXlzIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5cylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzIG1pc3NpbmdcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSByZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsga2V5czoga2V5cyB9KSA6IF9fYXNzaWduKHt9LCByZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSAnZGVsZXRlJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzID0gX19zcHJlYWRBcnJheShbXSwgcmVxLnZhbHVlcywgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLmtleXMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXMgPSBfX3NwcmVhZEFycmF5KFtdLCByZXEua2V5cywgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhpc3RpbmdWYWx1ZXMoZG93blRhYmxlLCByZXEsIGtleXMpLnRoZW4oZnVuY3Rpb24gKGV4aXN0aW5nVmFsdWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nVmFsdWVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0geyBvbmVycm9yOiBudWxsLCBvbnN1Y2Nlc3M6IG51bGwgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGVkUHJpbWFyeUtleSA9IGNyZWF0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgcmVxLnZhbHVlc1tpXSwgZHhUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG51bGwgJiYgZ2VuZXJhdGVkUHJpbWFyeUtleSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2VuZXJhdGVkUHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByaW1hcnlLZXkub3V0Ym91bmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYoZXhpc3RpbmdWYWx1ZSwgcmVxLnZhbHVlc1tpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbENoYW5nZXNfMSA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXNfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ZWRWYWx1ZV8xID0gcmVxLnZhbHVlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlQYXRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ocmVxdWVzdGVkVmFsdWVfMSwga2V5UGF0aCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZhbHVlXzFba2V5UGF0aF0gPSBhZGRpdGlvbmFsQ2hhbmdlc18xW2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcXVlc3RlZFZhbHVlXzEsIGtleVBhdGgsIGFkZGl0aW9uYWxDaGFuZ2VzXzFba2V5UGF0aF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSByZXN1bHRzID8gcmVzdWx0c1tpXSA6IGtleXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dHNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZmFpbHVyZXNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm9uc3VjY2VzcyAmJiBjdHgub25zdWNjZXNzKHJlcS50eXBlID09PSAncHV0JyAmJiBleGlzdGluZ1ZhbHVlc1tpXSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogZmFpbHVyZXMsIHJlc3VsdHM6IHJlc3VsdHMsIG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcywgbGFzdFJlc3VsdDogbGFzdFJlc3VsdCB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjdHgpIHsgcmV0dXJuIGN0eC5vbmVycm9yICYmIGN0eC5vbmVycm9yKGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsocmVxLnRyYW5zLCByZXEucmFuZ2UsIDEwMDAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIHJhbmdlLCBsaW1pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5xdWVyeSh7IHRyYW5zOiB0cmFucywgdmFsdWVzOiBmYWxzZSwgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlOiByYW5nZSB9LCBsaW1pdDogbGltaXQgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRQdXRPckRlbGV0ZSh7IHR5cGU6ICdkZWxldGUnLCBrZXlzOiByZXN1bHQsIHRyYW5zOiB0cmFucyB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCBsaW1pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXM6IFtdLCBudW1GYWlsdXJlczogMCwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHRyYW5zLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmFuZ2UpLCB7IGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWUgfSksIGxpbWl0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWlkZGxld2FyZTtcblx0ICAgICAgICAgICAgfSB9KSk7IH1cblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyh0YWJsZSwgcmVxLCBlZmZlY3RpdmVLZXlzKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG5cdCAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKFtdKVxuXHQgICAgICAgICAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgY2FjaGUsIGNsb25lKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKCFjYWNoZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICBpZiAoY2FjaGUua2V5cy5sZW5ndGggPCBrZXlzLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2xvbmUgPyBkZWVwQ2xvbmUoY2FjaGUudmFsdWVzW2ldKSA6IGNhY2hlLnZhbHVlc1tpXSk7XG5cdCAgICAgICAgICAgICAgICArK2o7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IGtleXMubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKF9hKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSA9IHtcblx0ICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcblx0ICAgICAgICBsZXZlbDogLTEsXG5cdCAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoY29yZSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXEuY2FjaGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKHJlcS5rZXlzLCByZXEudHJhbnNbXCJfY2FjaGVcIl0sIHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoY2FjaGVkUmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiByZXEua2V5cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gXCJhZGRcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gaXNDYWNoYWJsZUNvbnRleHQoY3R4LCB0YWJsZSkge1xuXHQgICAgICAgIHJldHVybiAoY3R4LnRyYW5zLm1vZGUgPT09ICdyZWFkb25seScgJiZcblx0ICAgICAgICAgICAgISFjdHguc3Vic2NyICYmXG5cdCAgICAgICAgICAgICFjdHgudHJhbnMuZXhwbGljaXQgJiZcblx0ICAgICAgICAgICAgY3R4LnRyYW5zLmRiLl9vcHRpb25zLmNhY2hlICE9PSAnZGlzYWJsZWQnICYmXG5cdCAgICAgICAgICAgICF0YWJsZS5zY2hlbWEucHJpbWFyeUtleS5vdXRib3VuZCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGlzQ2FjaGFibGVSZXF1ZXN0KHR5cGUsIHJlcSkge1xuXHQgICAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlICdxdWVyeSc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnZhbHVlcyAmJiAhcmVxLnVuaXF1ZTtcblx0ICAgICAgICAgICAgY2FzZSAnZ2V0Jzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgY2FzZSAnZ2V0TWFueSc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIGNhc2UgJ2NvdW50Jzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgY2FzZSAnb3BlbkN1cnNvcic6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgb2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUgPSB7XG5cdCAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG5cdCAgICAgICAgbGV2ZWw6IDAsXG5cdCAgICAgICAgbmFtZTogXCJPYnNlcnZhYmlsaXR5XCIsXG5cdCAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoY29yZSkge1xuXHQgICAgICAgICAgICB2YXIgZGJOYW1lID0gY29yZS5zY2hlbWEubmFtZTtcblx0ICAgICAgICAgICAgdmFyIEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuXHQgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGNvcmUpLCB7IHRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoc3RvcmVzLCBtb2RlLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFBTRC5zdWJzY3IgJiYgbW9kZSAhPT0gJ3JlYWRvbmx5Jykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlJlYWR3cml0ZSB0cmFuc2FjdGlvbiBpbiBsaXZlUXVlcnkgY29udGV4dC4gUXVlcmllciBzb3VyY2U6IFwiLmNvbmNhdChQU0QucXVlcmllcikpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS50cmFuc2FjdGlvbihzdG9yZXMsIG1vZGUsIG9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgICAgfSwgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IHNjaGVtYS5wcmltYXJ5S2V5LCBpbmRleGVzID0gc2NoZW1hLmluZGV4ZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhY3RLZXkgPSBwcmltYXJ5S2V5LmV4dHJhY3RLZXksIG91dGJvdW5kID0gcHJpbWFyeUtleS5vdXRib3VuZDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlc1dpdGhBdXRvSW5jUEsgPSBwcmltYXJ5S2V5LmF1dG9JbmNyZW1lbnQgJiYgaW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBpbmRleC5jb21wb3VuZCAmJiBpbmRleC5rZXlQYXRoLmluY2x1ZGVzKHByaW1hcnlLZXkua2V5UGF0aCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUNsb25lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IHJlcS50cmFucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkUGFydHMgPSByZXEubXV0YXRlZFBhcnRzIHx8IChyZXEubXV0YXRlZFBhcnRzID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlU2V0ID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSwgXCIvXCIpLmNvbmNhdChpbmRleE5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobXV0YXRlZFBhcnRzW3BhcnRdIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gcmVxLnR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZXEudHlwZSA9PT0gXCJkZWxldGVSYW5nZVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLnJhbmdlXVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnR5cGUgPT09IFwiZGVsZXRlXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbcmVxLmtleXNdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkOyB9KSwgcmVxLnZhbHVlc11cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW10sIGtleXMgPSBfYVswXSwgbmV3T2JqcyA9IF9hWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gcmVxLnRyYW5zW1wiX2NhY2hlXCJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE9ianMgPSB0eXBlID09PSAnZGVsZXRlJyB8fCBrZXlzLmxlbmd0aCA9PT0gbmV3T2Jqcy5sZW5ndGggPyBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBvbGRDYWNoZSkgOiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkT2Jqcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9ianMgfHwgbmV3T2Jqcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXlzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0geyBmcm9tOiBrZXlzLmxvd2VyLCB0bzoga2V5cy51cHBlciB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkKEZVTExfUkFOR0UpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlcy5yZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ZXNXaXRoQXV0b0luY1BLKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzV2l0aEF1dG9JbmNQSy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4VmFscyA9IHJlcS52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBpZHguZXh0cmFjdEtleSh2KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUG9zID0gaWR4LmtleVBhdGguZmluZEluZGV4KGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wID09PSBwcmltYXJ5S2V5LmtleVBhdGg7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5yZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHBrKSB7IHJldHVybiBpZHhWYWxzW3BrUG9zXSA9IHBrOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkS2V5cyhpZHhWYWxzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLm11dGF0ZWRQYXJ0cyA9IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodHJhbnMubXV0YXRlZFBhcnRzIHx8IHt9LCBtdXRhdGVkUGFydHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kID0gX2EucXVlcnksIGluZGV4ID0gX2QuaW5kZXgsIHJhbmdlID0gX2QucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZVNldCgoX2IgPSByYW5nZS5sb3dlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29yZS5NSU5fS0VZLCAoX2MgPSByYW5nZS51cHBlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29yZS5NQVhfS0VZKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWFkU3Vic2NyaWJlcnMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldChyZXEua2V5KV07IH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldE1hbnk6IGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS5rZXlzKV07IH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZXRSYW5nZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGdldFJhbmdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yOiBnZXRSYW5nZSxcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMocmVhZFN1YnNjcmliZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbG9uZVttZXRob2RdID0gZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjciA9IFBTRC5zdWJzY3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNMaXZlUXVlcnkgPSAhIXN1YnNjcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoYWJsZSA9IGlzQ2FjaGFibGVDb250ZXh0KFBTRCwgdGFibGUpICYmIGlzQ2FjaGFibGVSZXF1ZXN0KG1ldGhvZCwgcmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNTZXQgPSBjYWNoYWJsZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxLm9ic1NldCA9IHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdWJzY3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaXZlUXVlcnkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2VTZXQgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSwgXCIvXCIpLmNvbmNhdChpbmRleE5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9ic1NldFtwYXJ0XSB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9ic1NldFtwYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtSYW5nZVNldF8xID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHNSYW5nZVNldF8xID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZWFkU3Vic2NyaWJlcnNbbWV0aG9kXShyZXEpLCBxdWVyaWVkSW5kZXggPSBfYVswXSwgcXVlcmllZFJhbmdlcyA9IF9hWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdxdWVyeScgJiYgcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSAmJiAhcmVxLnZhbHVlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGQocXVlcmllZFJhbmdlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSYW5nZVNldChxdWVyaWVkSW5kZXgubmFtZSB8fCBcIlwiKS5hZGQocXVlcmllZFJhbmdlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNvdW50XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZChGVUxMX1JBTkdFKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzUHJvbWlzZV8xID0gbWV0aG9kID09PSBcInF1ZXJ5XCIgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5xdWVyeShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyB2YWx1ZXM6IGZhbHNlIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJxdWVyeVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCAmJiByZXEudmFsdWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1Byb21pc2VfMS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRpbmdLZXlzID0gX2EucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXRfMS5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcEtleXMgPSByZXEudmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlcy5yZXN1bHQubWFwKGV4dHJhY3RLZXkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcy5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudmFsdWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0XzEuYWRkS2V5cyhwS2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXlzKHBLZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09IFwib3BlbkN1cnNvclwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JfMSA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhbnRWYWx1ZXNfMSA9IHJlcS52YWx1ZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3Vyc29yXzEgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY3Vyc29yXzEsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXkoY3Vyc29yXzEucHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yXzEua2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwa2V5ID0gY3Vyc29yXzEucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleShwa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwa2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YW50VmFsdWVzXzEgJiYgcGtSYW5nZVNldF8xLmFkZEtleShjdXJzb3JfMS5wcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3JfMS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZUNsb25lO1xuXHQgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblx0ICAgIGZ1bmN0aW9uIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpIHtcblx0ICAgICAgICBmdW5jdGlvbiBhZGRBZmZlY3RlZEluZGV4KGl4KSB7XG5cdCAgICAgICAgICAgIHZhciByYW5nZVNldCA9IGdldFJhbmdlU2V0KGl4Lm5hbWUgfHwgXCJcIik7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBpeC5leHRyYWN0S2V5KG9iaikgOiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBhZGRLZXlPcktleXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBpeC5tdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuXHQgICAgICAgICAgICAgICAgPyBrZXkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiByYW5nZVNldC5hZGRLZXkoa2V5KTsgfSlcblx0ICAgICAgICAgICAgICAgIDogcmFuZ2VTZXQuYWRkS2V5KGtleSk7IH07XG5cdCAgICAgICAgICAgIChvbGRPYmpzIHx8IG5ld09ianMpLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvbGRLZXkgPSBvbGRPYmpzICYmIGV4dHJhY3RLZXkob2xkT2Jqc1tpXSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmV3S2V5ID0gbmV3T2JqcyAmJiBleHRyYWN0S2V5KG5ld09ianNbaV0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob2xkS2V5ICE9IG51bGwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhvbGRLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG5ld0tleSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGFkZEFmZmVjdGVkSW5kZXgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXEsIHJlcykge1xuXHQgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPT09IDApXG5cdCAgICAgICAgICAgIHJldHVybiByZXE7XG5cdCAgICAgICAgaWYgKHJlcS50eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbnVtQnVsa09wcyA9IHJlcS5rZXlzXG5cdCAgICAgICAgICAgID8gcmVxLmtleXMubGVuZ3RoXG5cdCAgICAgICAgICAgIDogJ3ZhbHVlcycgaW4gcmVxICYmIHJlcS52YWx1ZXNcblx0ICAgICAgICAgICAgICAgID8gcmVxLnZhbHVlcy5sZW5ndGhcblx0ICAgICAgICAgICAgICAgIDogMTtcblx0ICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID09PSBudW1CdWxrT3BzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY2xvbmUgPSBfX2Fzc2lnbih7fSwgcmVxKTtcblx0ICAgICAgICBpZiAoaXNBcnJheShjbG9uZS5rZXlzKSkge1xuXHQgICAgICAgICAgICBjbG9uZS5rZXlzID0gY2xvbmUua2V5cy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICEoaSBpbiByZXMuZmFpbHVyZXMpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCd2YWx1ZXMnIGluIGNsb25lICYmIGlzQXJyYXkoY2xvbmUudmFsdWVzKSkge1xuXHQgICAgICAgICAgICBjbG9uZS52YWx1ZXMgPSBjbG9uZS52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAhKGkgaW4gcmVzLmZhaWx1cmVzKTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaXNBYm92ZUxvd2VyKGtleSwgcmFuZ2UpIHtcblx0ICAgICAgICByZXR1cm4gcmFuZ2UubG93ZXIgPT09IHVuZGVmaW5lZFxuXHQgICAgICAgICAgICA/IHRydWVcblx0ICAgICAgICAgICAgOiByYW5nZS5sb3dlck9wZW5cblx0ICAgICAgICAgICAgICAgID8gY21wKGtleSwgcmFuZ2UubG93ZXIpID4gMFxuXHQgICAgICAgICAgICAgICAgOiBjbXAoa2V5LCByYW5nZS5sb3dlcikgPj0gMDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGlzQmVsb3dVcHBlcihrZXksIHJhbmdlKSB7XG5cdCAgICAgICAgcmV0dXJuIHJhbmdlLnVwcGVyID09PSB1bmRlZmluZWRcblx0ICAgICAgICAgICAgPyB0cnVlXG5cdCAgICAgICAgICAgIDogcmFuZ2UudXBwZXJPcGVuXG5cdCAgICAgICAgICAgICAgICA/IGNtcChrZXksIHJhbmdlLnVwcGVyKSA8IDBcblx0ICAgICAgICAgICAgICAgIDogY21wKGtleSwgcmFuZ2UudXBwZXIpIDw9IDA7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpc1dpdGhpblJhbmdlKGtleSwgcmFuZ2UpIHtcblx0ICAgICAgICByZXR1cm4gaXNBYm92ZUxvd2VyKGtleSwgcmFuZ2UpICYmIGlzQmVsb3dVcHBlcihrZXksIHJhbmdlKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXBwbHlPcHRpbWlzdGljT3BzKHJlc3VsdCwgcmVxLCBvcHMsIHRhYmxlLCBjYWNoZUVudHJ5LCBpbW11dGFibGUpIHtcblx0ICAgICAgICBpZiAoIW9wcyB8fCBvcHMubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIHZhciBpbmRleCA9IHJlcS5xdWVyeS5pbmRleDtcblx0ICAgICAgICB2YXIgbXVsdGlFbnRyeSA9IGluZGV4Lm11bHRpRW50cnk7XG5cdCAgICAgICAgdmFyIHF1ZXJ5UmFuZ2UgPSByZXEucXVlcnkucmFuZ2U7XG5cdCAgICAgICAgdmFyIHByaW1hcnlLZXkgPSB0YWJsZS5zY2hlbWEucHJpbWFyeUtleTtcblx0ICAgICAgICB2YXIgZXh0cmFjdFByaW1LZXkgPSBwcmltYXJ5S2V5LmV4dHJhY3RLZXk7XG5cdCAgICAgICAgdmFyIGV4dHJhY3RJbmRleCA9IGluZGV4LmV4dHJhY3RLZXk7XG5cdCAgICAgICAgdmFyIGV4dHJhY3RMb3dMZXZlbEluZGV4ID0gKGluZGV4Lmxvd0xldmVsSW5kZXggfHwgaW5kZXgpLmV4dHJhY3RLZXk7XG5cdCAgICAgICAgdmFyIGZpbmFsUmVzdWx0ID0gb3BzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBvcCkge1xuXHQgICAgICAgICAgICB2YXIgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgdmFyIGluY2x1ZGVkVmFsdWVzID0gW107XG5cdCAgICAgICAgICAgIGlmIChvcC50eXBlID09PSAnYWRkJyB8fCBvcC50eXBlID09PSAncHV0Jykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluY2x1ZGVkUEtzID0gbmV3IFJhbmdlU2V0KCk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3AudmFsdWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb3AudmFsdWVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwayA9IGV4dHJhY3RQcmltS2V5KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZWRQS3MuaGFzS2V5KHBrKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGV4dHJhY3RJbmRleCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpRW50cnkgJiYgaXNBcnJheShrZXkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8ga2V5LnNvbWUoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGlzV2l0aGluUmFuZ2UoaywgcXVlcnlSYW5nZSk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogaXNXaXRoaW5SYW5nZShrZXksIHF1ZXJ5UmFuZ2UpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkUEtzLmFkZEtleShwayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkVmFsdWVzLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5jb25jYXQocmVxLnZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IGluY2x1ZGVkVmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jbHVkZWRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAncHV0Jzpcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5U2V0XzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKFxuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAha2V5U2V0XzEuaGFzS2V5KHJlcS52YWx1ZXMgPyBleHRyYWN0UHJpbUtleShpdGVtKSA6IGl0ZW0pOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KFxuXHQgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgPyBpbmNsdWRlZFZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IGluY2x1ZGVkVmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNUb0RlbGV0ZV8xID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhvcC5rZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIWtleXNUb0RlbGV0ZV8xLmhhc0tleShyZXEudmFsdWVzID8gZXh0cmFjdFByaW1LZXkoaXRlbSkgOiBpdGVtKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlXzEgPSBvcC5yYW5nZTtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIWlzV2l0aGluUmFuZ2UoZXh0cmFjdFByaW1LZXkoaXRlbSksIHJhbmdlXzEpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbW9kaWZlZFJlc3VsdDtcblx0ICAgICAgICB9LCByZXN1bHQpO1xuXHQgICAgICAgIGlmIChmaW5hbFJlc3VsdCA9PT0gcmVzdWx0KVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIGZpbmFsUmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNtcChleHRyYWN0TG93TGV2ZWxJbmRleChhKSwgZXh0cmFjdExvd0xldmVsSW5kZXgoYikpIHx8XG5cdCAgICAgICAgICAgICAgICBjbXAoZXh0cmFjdFByaW1LZXkoYSksIGV4dHJhY3RQcmltS2V5KGIpKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAocmVxLmxpbWl0ICYmIHJlcS5saW1pdCA8IEluZmluaXR5KSB7XG5cdCAgICAgICAgICAgIGlmIChmaW5hbFJlc3VsdC5sZW5ndGggPiByZXEubGltaXQpIHtcblx0ICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0Lmxlbmd0aCA9IHJlcS5saW1pdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSByZXEubGltaXQgJiYgZmluYWxSZXN1bHQubGVuZ3RoIDwgcmVxLmxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICBjYWNoZUVudHJ5LmRpcnR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gaW1tdXRhYmxlID8gT2JqZWN0LmZyZWV6ZShmaW5hbFJlc3VsdCkgOiBmaW5hbFJlc3VsdDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXJlUmFuZ2VzRXF1YWwocjEsIHIyKSB7XG5cdCAgICAgICAgcmV0dXJuIChjbXAocjEubG93ZXIsIHIyLmxvd2VyKSA9PT0gMCAmJlxuXHQgICAgICAgICAgICBjbXAocjEudXBwZXIsIHIyLnVwcGVyKSA9PT0gMCAmJlxuXHQgICAgICAgICAgICAhIXIxLmxvd2VyT3BlbiA9PT0gISFyMi5sb3dlck9wZW4gJiZcblx0ICAgICAgICAgICAgISFyMS51cHBlck9wZW4gPT09ICEhcjIudXBwZXJPcGVuKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY29tcGFyZUxvd2Vycyhsb3dlcjEsIGxvd2VyMiwgbG93ZXJPcGVuMSwgbG93ZXJPcGVuMikge1xuXHQgICAgICAgIGlmIChsb3dlcjEgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgcmV0dXJuIGxvd2VyMiAhPT0gdW5kZWZpbmVkID8gLTEgOiAwO1xuXHQgICAgICAgIGlmIChsb3dlcjIgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgdmFyIGMgPSBjbXAobG93ZXIxLCBsb3dlcjIpO1xuXHQgICAgICAgIGlmIChjID09PSAwKSB7XG5cdCAgICAgICAgICAgIGlmIChsb3dlck9wZW4xICYmIGxvd2VyT3BlbjIpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgaWYgKGxvd2VyT3BlbjEpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgaWYgKGxvd2VyT3BlbjIpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY29tcGFyZVVwcGVycyh1cHBlcjEsIHVwcGVyMiwgdXBwZXJPcGVuMSwgdXBwZXJPcGVuMikge1xuXHQgICAgICAgIGlmICh1cHBlcjEgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgcmV0dXJuIHVwcGVyMiAhPT0gdW5kZWZpbmVkID8gMSA6IDA7XG5cdCAgICAgICAgaWYgKHVwcGVyMiA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgdmFyIGMgPSBjbXAodXBwZXIxLCB1cHBlcjIpO1xuXHQgICAgICAgIGlmIChjID09PSAwKSB7XG5cdCAgICAgICAgICAgIGlmICh1cHBlck9wZW4xICYmIHVwcGVyT3BlbjIpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgaWYgKHVwcGVyT3BlbjEpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgIGlmICh1cHBlck9wZW4yKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaXNTdXBlclJhbmdlKHIxLCByMikge1xuXHQgICAgICAgIHJldHVybiAoY29tcGFyZUxvd2VycyhyMS5sb3dlciwgcjIubG93ZXIsIHIxLmxvd2VyT3BlbiwgcjIubG93ZXJPcGVuKSA8PSAwICYmXG5cdCAgICAgICAgICAgIGNvbXBhcmVVcHBlcnMocjEudXBwZXIsIHIyLnVwcGVyLCByMS51cHBlck9wZW4sIHIyLnVwcGVyT3BlbikgPj0gMCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGZpbmRDb21wYXRpYmxlUXVlcnkoZGJOYW1lLCB0YWJsZU5hbWUsIHR5cGUsIHJlcSkge1xuXHQgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcblx0ICAgICAgICBpZiAoIXRibENhY2hlKVxuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgdmFyIHF1ZXJpZXMgPSB0YmxDYWNoZS5xdWVyaWVzW3R5cGVdO1xuXHQgICAgICAgIGlmICghcXVlcmllcylcblx0ICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBmYWxzZSwgdGJsQ2FjaGUsIG51bGxdO1xuXHQgICAgICAgIHZhciBpbmRleE5hbWUgPSByZXEucXVlcnkgPyByZXEucXVlcnkuaW5kZXgubmFtZSA6IG51bGw7XG5cdCAgICAgICAgdmFyIGVudHJpZXMgPSBxdWVyaWVzW2luZGV4TmFtZSB8fCAnJ107XG5cdCAgICAgICAgaWYgKCFlbnRyaWVzKVxuXHQgICAgICAgICAgICByZXR1cm4gW251bGwsIGZhbHNlLCB0YmxDYWNoZSwgbnVsbF07XG5cdCAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ3F1ZXJ5Jzpcblx0ICAgICAgICAgICAgICAgIHZhciBlcXVhbEVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5yZXEubGltaXQgPT09IHJlcS5saW1pdCAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXEudmFsdWVzID09PSByZXEudmFsdWVzICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZVJhbmdlc0VxdWFsKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVxdWFsRW50cnkpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWxFbnRyeSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdXBlckVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9ICdsaW1pdCcgaW4gZW50cnkucmVxID8gZW50cnkucmVxLmxpbWl0IDogSW5maW5pdHk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsaW1pdCA+PSByZXEubGltaXQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHJlcS52YWx1ZXMgPyBlbnRyeS5yZXEudmFsdWVzIDogdHJ1ZSkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXNTdXBlclJhbmdlKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbc3VwZXJFbnRyeSwgZmFsc2UsIHRibENhY2hlLCBlbnRyaWVzXTtcblx0ICAgICAgICAgICAgY2FzZSAnY291bnQnOlxuXHQgICAgICAgICAgICAgICAgdmFyIGNvdW50UXVlcnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZVJhbmdlc0VxdWFsKGVudHJ5LnJlcS5xdWVyeS5yYW5nZSwgcmVxLnF1ZXJ5LnJhbmdlKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtjb3VudFF1ZXJ5LCAhIWNvdW50UXVlcnksIHRibENhY2hlLCBlbnRyaWVzXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHN1YnNjcmliZVRvQ2FjaGVFbnRyeShjYWNoZUVudHJ5LCBjb250YWluZXIsIHJlcXVlcnksIHNpZ25hbCkge1xuXHQgICAgICAgIGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuYWRkKHJlcXVlcnkpO1xuXHQgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBjYWNoZUVudHJ5LnN1YnNjcmliZXJzLmRlbGV0ZShyZXF1ZXJ5KTtcblx0ICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgZW5xdWVGb3JEZWxldGlvbihjYWNoZUVudHJ5LCBjb250YWluZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBlbnF1ZUZvckRlbGV0aW9uKGNhY2hlRW50cnksIGNvbnRhaW5lcikge1xuXHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oY29udGFpbmVyLCBjYWNoZUVudHJ5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sIDMwMDApO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FjaGVNaWRkbGV3YXJlID0ge1xuXHQgICAgICAgIHN0YWNrOiAnZGJjb3JlJyxcblx0ICAgICAgICBsZXZlbDogMCxcblx0ICAgICAgICBuYW1lOiAnQ2FjaGUnLFxuXHQgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcblx0ICAgICAgICAgICAgdmFyIGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG5cdCAgICAgICAgICAgIHZhciBjb3JlTVcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29yZSksIHsgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzdG9yZXMsIG1vZGUsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWRidHJhbnMgPSBjb3JlLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSwgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY18xID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbmFsID0gYWNfMS5zaWduYWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh3YXNDb21taXR0ZWQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjXzEuYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZFN1YnNjcmliZXJzXzEgPSBuZXcgU2V0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdG9yZXNfMSA9IHN0b3JlczsgX2kgPCBzdG9yZXNfMS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHN0b3Jlc18xW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHN0b3JlTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGJsQ2FjaGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUoc3RvcmVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHMgPSB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLnRyYW5zID09PSBpZGJ0cmFuczsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRidHJhbnMuX2V4cGxpY2l0ICYmIHdhc0NvbW1pdHRlZCAmJiBpZGJ0cmFucy5tdXRhdGVkUGFydHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gT2JqZWN0LnZhbHVlcyh0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5KTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBfYltfYV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgX2QgPSBlbnRyaWVzLnNsaWNlKCk7IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfZFtfY107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JzU2V0c092ZXJsYXAoZW50cnkub2JzU2V0LCBpZGJ0cmFucy5tdXRhdGVkUGFydHMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBhZmZlY3RlZFN1YnNjcmliZXJzXzEuYWRkKHJlcXVlcnkpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcyA9IHRibENhY2hlLm9wdGltaXN0aWNPcHMuZmlsdGVyKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AudHJhbnMgIT09IGlkYnRyYW5zOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IDAsIF9mID0gT2JqZWN0LnZhbHVlcyh0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5KTsgX2UgPCBfZi5sZW5ndGg7IF9lKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBfZltfZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9nID0gMCwgX2ggPSBlbnRyaWVzLnNsaWNlKCk7IF9nIDwgX2gubGVuZ3RoOyBfZysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfaFtfZ107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVzICE9IG51bGwgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5tdXRhdGVkUGFydHNcblx0ICAgICkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YXNDb21taXR0ZWQgJiYgIWVudHJ5LmRpcnR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVlemVSZXN1bHRzID0gT2JqZWN0LmlzRnJvemVuKGVudHJ5LnJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RSZXMgPSBhcHBseU9wdGltaXN0aWNPcHMoZW50cnkucmVzLCBlbnRyeS5yZXEsIG9wcywgdGFibGUsIGVudHJ5LCBmcmVlemVSZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kUmVzICE9PSBlbnRyeS5yZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlcyA9IG1vZFJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZSh7IHJlc3VsdDogbW9kUmVzIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShlbnRyaWVzLCBlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiByZXF1ZXJ5KCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9OyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVuZFRyYW5zYWN0aW9uKGZhbHNlKSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGVuZFRyYW5zYWN0aW9uKHRydWUpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZGJ0cmFucztcblx0ICAgICAgICAgICAgICAgIH0sIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRvd25UYWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGRvd25UYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVNVyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duVGFibGUpLCB7IG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gUFNELnRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkub3V0Ym91bmQgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5kYi5fb3B0aW9ucy5jYWNoZSA9PT0gJ2Rpc2FibGVkJyB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmV4cGxpY2l0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YmxDYWNoZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcpICYmIChyZXEudmFsdWVzLmxlbmd0aCA+PSA1MCB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1LZXksIHJlcSkuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgPT0gbnVsbDsgfSkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVdpdGhSZXNvbHZlZEtleXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyB2YWx1ZXM6IHJlcS52YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVXaXRoS2V5ID0gKChfYSA9IHByaW1LZXkua2V5UGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCcuJykpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGVlcENsb25lKHZhbHVlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF9fYXNzaWduKHt9LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHZhbHVlV2l0aEtleSwgcHJpbUtleS5rZXlQYXRoLCByZXMucmVzdWx0c1tpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlV2l0aEtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRSZXEgPSBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXFXaXRoUmVzb2x2ZWRLZXlzLCByZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLnB1c2goYWRqdXN0ZWRSZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbSh0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCByZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkUmVxID0gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxLCByZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdGVkUmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKGFkanVzdGVkUmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKHRibENhY2hlLm9wdGltaXN0aWNPcHMsIHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnk6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWNoYWJsZUNvbnRleHQoUFNELCBkb3duVGFibGUpIHx8ICFpc0NhY2hhYmxlUmVxdWVzdChcInF1ZXJ5XCIsIHJlcSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5xdWVyeShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZWV6ZVJlc3VsdHMgPSAoKF9hID0gUFNELnRyYW5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGIuX29wdGlvbnMuY2FjaGUpID09PSAnaW1tdXRhYmxlJztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IFBTRCwgcmVxdWVyeSA9IF9iLnJlcXVlcnksIHNpZ25hbCA9IF9iLnNpZ25hbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGZpbmRDb21wYXRpYmxlUXVlcnkoZGJOYW1lLCB0YWJsZU5hbWUsICdxdWVyeScsIHJlcSksIGNhY2hlRW50cnkgPSBfY1swXSwgZXhhY3RNYXRjaCA9IF9jWzFdLCB0YmxDYWNoZSA9IF9jWzJdLCBjb250YWluZXIgPSBfY1szXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5ICYmIGV4YWN0TWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5Lm9ic1NldCA9IHJlcS5vYnNTZXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGRvd25UYWJsZS5xdWVyeShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5LnJlcyA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyZWV6ZVJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocmVzdWx0W2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5yZXN1bHQgPSBkZWVwQ2xvbmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyICYmIGNhY2hlRW50cnkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oY29udGFpbmVyLCBjYWNoZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNTZXQ6IHJlcS5vYnNTZXQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBuZXcgU2V0KCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdxdWVyeScsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcTogcmVxLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGNhY2hlRW50cnkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gW2NhY2hlRW50cnldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRibENhY2hlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7fSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHt9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqczogbmV3IE1hcCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNPcHM6IFtdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2lnbmFsZWRQYXJ0czoge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVtyZXEucXVlcnkuaW5kZXgubmFtZSB8fCAnJ10gPSBjb250YWluZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlVG9DYWNoZUVudHJ5KGNhY2hlRW50cnksIGNvbnRhaW5lciwgcmVxdWVyeSwgc2lnbmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhcHBseU9wdGltaXN0aWNPcHMocmVzLnJlc3VsdCwgcmVxLCB0YmxDYWNoZSA9PT0gbnVsbCB8fCB0YmxDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGJsQ2FjaGUub3B0aW1pc3RpY09wcywgZG93blRhYmxlLCBjYWNoZUVudHJ5LCBmcmVlemVSZXN1bHRzKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlTVc7XG5cdCAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gY29yZU1XO1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiB2aXBpZnkodGFyZ2V0LCB2aXBEYikge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnZGInKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBEYjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgRGV4aWUkMSA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIERleGllKG5hbWUsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMgPSB7fTtcblx0ICAgICAgICAgICAgdGhpcy52ZXJubyA9IDA7XG5cdCAgICAgICAgICAgIHZhciBkZXBzID0gRGV4aWUuZGVwZW5kZW5jaWVzO1xuXHQgICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyA9IF9fYXNzaWduKHtcblx0ICAgICAgICAgICAgICAgIGFkZG9uczogRGV4aWUuYWRkb25zLCBhdXRvT3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsIElEQktleVJhbmdlOiBkZXBzLklEQktleVJhbmdlLCBjYWNoZTogJ2Nsb25lZCcgfSwgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlcHMgPSB7XG5cdCAgICAgICAgICAgICAgICBpbmRleGVkREI6IG9wdGlvbnMuaW5kZXhlZERCLFxuXHQgICAgICAgICAgICAgICAgSURCS2V5UmFuZ2U6IG9wdGlvbnMuSURCS2V5UmFuZ2Vcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdmFyIGFkZG9ucyA9IG9wdGlvbnMuYWRkb25zO1xuXHQgICAgICAgICAgICB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuXHQgICAgICAgICAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9yZU5hbWVzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbFRhYmxlcyA9IHt9O1xuXHQgICAgICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fbm92aXAgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB7XG5cdCAgICAgICAgICAgICAgICBkYk9wZW5FcnJvcjogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGlzQmVpbmdPcGVuZWQ6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQ6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBvcGVuQ29tcGxldGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgZGJSZWFkeVJlc29sdmU6IG5vcCxcblx0ICAgICAgICAgICAgICAgIGRiUmVhZHlQcm9taXNlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgY2FuY2VsT3Blbjogbm9wLFxuXHQgICAgICAgICAgICAgICAgb3BlbkNhbmNlbGxlcjogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGF1dG9TY2hlbWE6IHRydWUsXG5cdCAgICAgICAgICAgICAgICBQUjEzOThfbWF4TG9vcDogMyxcblx0ICAgICAgICAgICAgICAgIGF1dG9PcGVuOiBvcHRpb25zLmF1dG9PcGVuLFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuXHQgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwicG9wdWxhdGVcIiwgXCJibG9ja2VkXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcImNsb3NlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSk7XG5cdCAgICAgICAgICAgIHRoaXMub24ucmVhZHkuc3Vic2NyaWJlID0gb3ZlcnJpZGUodGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUsIGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlciwgYlN0aWNreSkge1xuXHQgICAgICAgICAgICAgICAgICAgIERleGllLnZpcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5kYk9wZW5FcnJvcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3Vic2NyaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnB1c2goc3Vic2NyaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGJfMSA9IF90aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiU3RpY2t5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGJfMS5vbi5yZWFkeS51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGJfMS5vbi5yZWFkeS51bnN1YnNjcmliZSh1bnN1YnNjcmliZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLkNvbGxlY3Rpb24gPSBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuVGFibGUgPSBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLlRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5WZXJzaW9uID0gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLldoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5vbihcInZlcnNpb25jaGFuZ2VcIiwgZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXYubmV3VmVyc2lvbiA+IDApXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgdXBncmFkZS5cIikpO1xuXHQgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byBkZWxldGUgZGF0YWJhc2UgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuXCIpKTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMub24oXCJibG9ja2VkXCIsIGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRleGllLmRlbGV0ZSgnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJykgd2FzIGJsb2NrZWRcIikpO1xuXHQgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVwZ3JhZGUgJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiBcIikuY29uY2F0KGV2Lm9sZFZlcnNpb24gLyAxMCkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5fbWF4S2V5ID0gZ2V0TWF4S2V5KG9wdGlvbnMuSURCS2V5UmFuZ2UpO1xuXHQgICAgICAgICAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pIHsgcmV0dXJuIG5ldyBfdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgX3RoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7IH07XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpcmVPbkJsb2NrZWQgPSBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLm9uKFwiYmxvY2tlZFwiKS5maXJlKGV2KTtcblx0ICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5uYW1lID09PSBfdGhpcy5uYW1lICYmIGMgIT09IF90aGlzICYmICFjLl9zdGF0ZS52Y0ZpcmVkOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpOyB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy51c2UoY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUpO1xuXHQgICAgICAgICAgICB0aGlzLnVzZShjYWNoZU1pZGRsZXdhcmUpO1xuXHQgICAgICAgICAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG5cdCAgICAgICAgICAgIHRoaXMudXNlKHZpcnR1YWxJbmRleE1pZGRsZXdhcmUpO1xuXHQgICAgICAgICAgICB0aGlzLnVzZShob29rc01pZGRsZXdhcmUpO1xuXHQgICAgICAgICAgICB2YXIgdmlwREIgPSBuZXcgUHJveHkodGhpcywge1xuXHQgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoXywgcHJvcCwgcmVjZWl2ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ192aXAnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3RhYmxlJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJsZU5hbWUpIHsgcmV0dXJuIHZpcGlmeShfdGhpcy50YWJsZSh0YWJsZU5hbWUpLCB2aXBEQik7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gUmVmbGVjdC5nZXQoXywgcHJvcCwgcmVjZWl2ZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChydiBpbnN0YW5jZW9mIFRhYmxlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwaWZ5KHJ2LCB2aXBEQik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZXMnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnYubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB2aXBpZnkodCwgdmlwREIpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19jcmVhdGVUcmFuc2FjdGlvbicpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHggPSBydi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcGlmeSh0eCwgdmlwREIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMudmlwID0gdmlwREI7XG5cdCAgICAgICAgICAgIGFkZG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhZGRvbikgeyByZXR1cm4gYWRkb24oX3RoaXMpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLnZlcnNpb24gPSBmdW5jdGlvbiAodmVyc2lvbk51bWJlcikge1xuXHQgICAgICAgICAgICBpZiAoaXNOYU4odmVyc2lvbk51bWJlcikgfHwgdmVyc2lvbk51bWJlciA8IDAuMSlcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoXCJHaXZlbiB2ZXJzaW9uIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcblx0ICAgICAgICAgICAgdmVyc2lvbk51bWJlciA9IE1hdGgucm91bmQodmVyc2lvbk51bWJlciAqIDEwKSAvIDEwO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pZGJkYiB8fCB0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcblx0ICAgICAgICAgICAgdGhpcy52ZXJubyA9IE1hdGgubWF4KHRoaXMudmVybm8sIHZlcnNpb25OdW1iZXIpO1xuXHQgICAgICAgICAgICB2YXIgdmVyc2lvbnMgPSB0aGlzLl92ZXJzaW9ucztcblx0ICAgICAgICAgICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXI7IH0pWzBdO1xuXHQgICAgICAgICAgICBpZiAodmVyc2lvbkluc3RhbmNlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcblx0ICAgICAgICAgICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcblx0ICAgICAgICAgICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uSW5zdGFuY2UpO1xuXHQgICAgICAgICAgICB2ZXJzaW9ucy5zb3J0KGxvd2VyVmVyc2lvbkZpcnN0KTtcblx0ICAgICAgICAgICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWEgPSBmYWxzZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5fd2hlblJlYWR5ID0gZnVuY3Rpb24gKGZuKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKF90aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0YXRlLmF1dG9PcGVuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIF90aGlzLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oZm4pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgY3JlYXRlID0gX2EuY3JlYXRlLCBsZXZlbCA9IF9hLmxldmVsLCBuYW1lID0gX2EubmFtZTtcblx0ICAgICAgICAgICAgaWYgKG5hbWUpXG5cdCAgICAgICAgICAgICAgICB0aGlzLnVudXNlKHsgc3RhY2s6IHN0YWNrLCBuYW1lOiBuYW1lIH0pO1xuXHQgICAgICAgICAgICB2YXIgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcblx0ICAgICAgICAgICAgbWlkZGxld2FyZXMucHVzaCh7IHN0YWNrOiBzdGFjaywgY3JlYXRlOiBjcmVhdGUsIGxldmVsOiBsZXZlbCA9PSBudWxsID8gMTAgOiBsZXZlbCwgbmFtZTogbmFtZSB9KTtcblx0ICAgICAgICAgICAgbWlkZGxld2FyZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5sZXZlbCAtIGIubGV2ZWw7IH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS51bnVzZSA9IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBfYS5zdGFjaywgbmFtZSA9IF9hLm5hbWUsIGNyZWF0ZSA9IF9hLmNyZWF0ZTtcblx0ICAgICAgICAgICAgaWYgKHN0YWNrICYmIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdLmZpbHRlcihmdW5jdGlvbiAobXcpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID8gbXcubmFtZSAhPT0gbmFtZSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB1c2VQU0QoZ2xvYmFsUFNELFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBkZXhpZU9wZW4oX3RoaXMpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gY29ubmVjdGlvbnMuaW5kZXhPZih0aGlzKTtcblx0ICAgICAgICAgICAgaWYgKGlkeCA+PSAwKVxuXHQgICAgICAgICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlkYmRiKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaWRiZGIuY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgICAgICAgICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHsgZGlzYWJsZUF1dG9PcGVuOiB0cnVlIH0gOiBfYSwgZGlzYWJsZUF1dG9PcGVuID0gX2IuZGlzYWJsZUF1dG9PcGVuO1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgaWYgKGRpc2FibGVBdXRvT3Blbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmF1dG9PcGVuID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuYXV0b09wZW4gPSB0aGlzLl9vcHRpb25zLmF1dG9PcGVuIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZDtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGNsb3NlT3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICBpZiAoY2xvc2VPcHRpb25zID09PSB2b2lkIDApIHsgY2xvc2VPcHRpb25zID0geyBkaXNhYmxlQXV0b09wZW46IHRydWUgfTsgfVxuXHQgICAgICAgICAgICB2YXIgaGFzSW52YWxpZEFyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnO1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRvRGVsZXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKGNsb3NlT3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IF90aGlzLl9kZXBzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShfdGhpcy5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlRGVsZXRlZChfdGhpcy5fZGVwcywgX3RoaXMubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSBfdGhpcy5fZmlyZU9uQmxvY2tlZDtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFzSW52YWxpZEFyZ3VtZW50cylcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGNsb3NlT3B0aW9ucyBhcmd1bWVudCB0byBkYi5kZWxldGUoKVwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihkb0RlbGV0ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb0RlbGV0ZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5iYWNrZW5kREIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYmRiO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGIgIT09IG51bGw7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuaGFzQmVlbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGRiT3BlbkVycm9yID0gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3I7XG5cdCAgICAgICAgICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuaGFzRmFpbGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IgIT09IG51bGw7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuZHluYW1pY2FsbHlPcGVuZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERleGllLnByb3RvdHlwZSwgXCJ0YWJsZXNcIiwge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuX2FsbFRhYmxlc1tuYW1lXTsgfSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHRhYmxlcywgc2NvcGVGdW5jKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcblx0ICAgICAgICAgICAgaWYgKCFwYXJlbnRUcmFuc2FjdGlvbiB8fCBwYXJlbnRUcmFuc2FjdGlvbi5kYiAhPT0gdGhpcyB8fCBtb2RlLmluZGV4T2YoJyEnKSAhPT0gLTEpXG5cdCAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG5cdCAgICAgICAgICAgIHZhciBvbmx5SWZDb21wYXRpYmxlID0gbW9kZS5pbmRleE9mKCc/JykgIT09IC0xO1xuXHQgICAgICAgICAgICBtb2RlID0gbW9kZS5yZXBsYWNlKCchJywgJycpLnJlcGxhY2UoJz8nLCAnJyk7XG5cdCAgICAgICAgICAgIHZhciBpZGJNb2RlLCBzdG9yZU5hbWVzO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc3RvcmVOYW1lcyA9IHRhYmxlcy5tYXAoZnVuY3Rpb24gKHRhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHRhYmxlIGluc3RhbmNlb2YgX3RoaXMuVGFibGUgPyB0YWJsZS5uYW1lIDogdGFibGU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVOYW1lO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSBcInJcIiB8fCBtb2RlID09PSBSRUFET05MWSlcblx0ICAgICAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRE9OTFk7XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcblx0ICAgICAgICAgICAgICAgICAgICBpZGJNb2RlID0gUkVBRFdSSVRFO1xuXHQgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbi5tb2RlID09PSBSRUFET05MWSAmJiBpZGJNb2RlID09PSBSRUFEV1JJVEUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIkNhbm5vdCBlbnRlciBhIHN1Yi10cmFuc2FjdGlvbiB3aXRoIFJFQURXUklURSBtb2RlIHdoZW4gcGFyZW50IHRyYW5zYWN0aW9uIGlzIFJFQURPTkxZXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiAmJiBwYXJlbnRUcmFuc2FjdGlvbi5zdG9yZU5hbWVzLmluZGV4T2Yoc3RvcmVOYW1lKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJUYWJsZSBcIiArIHN0b3JlTmFtZSArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cblx0ICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShudWxsLCBmdW5jdGlvbiAoXywgcmVqZWN0KSB7IHJlamVjdChlKTsgfSkgOlxuXHQgICAgICAgICAgICAgICAgICAgIHJlamVjdGlvbihlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZW50ZXJUcmFuc2FjdGlvbiA9IGVudGVyVHJhbnNhY3Rpb25TY29wZS5iaW5kKG51bGwsIHRoaXMsIGlkYk1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpO1xuXHQgICAgICAgICAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cblx0ICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKGlkYk1vZGUsIGVudGVyVHJhbnNhY3Rpb24sIFwibG9ja1wiKSA6XG5cdCAgICAgICAgICAgICAgICBQU0QudHJhbnMgP1xuXHQgICAgICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pOyB9KSA6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5KGVudGVyVHJhbnNhY3Rpb24pKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoXCJUYWJsZSBcIi5jb25jYXQodGFibGVOYW1lLCBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIERleGllO1xuXHQgICAgfSgpKTtcblxuXHQgICAgdmFyIHN5bWJvbE9ic2VydmFibGUgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFwib2JzZXJ2YWJsZVwiIGluIFN5bWJvbFxuXHQgICAgICAgID8gU3ltYm9sLm9ic2VydmFibGVcblx0ICAgICAgICA6IFwiQEBvYnNlcnZhYmxlXCI7XG5cdCAgICB2YXIgT2JzZXJ2YWJsZSA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHgsIGVycm9yLCBjb21wbGV0ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKCF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yOiBlcnJvciwgY29tcGxldGU6IGNvbXBsZXRlIH0gOiB4KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIE9ic2VydmFibGUucHJvdG90eXBlW3N5bWJvbE9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBPYnNlcnZhYmxlO1xuXHQgICAgfSgpKTtcblxuXHQgICAgdmFyIGRvbURlcHM7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGRvbURlcHMgPSB7XG5cdCAgICAgICAgICAgIGluZGV4ZWREQjogX2dsb2JhbC5pbmRleGVkREIgfHwgX2dsb2JhbC5tb3pJbmRleGVkREIgfHwgX2dsb2JhbC53ZWJraXRJbmRleGVkREIgfHwgX2dsb2JhbC5tc0luZGV4ZWREQixcblx0ICAgICAgICAgICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgIGRvbURlcHMgPSB7IGluZGV4ZWREQjogbnVsbCwgSURCS2V5UmFuZ2U6IG51bGwgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gbGl2ZVF1ZXJ5KHF1ZXJpZXIpIHtcblx0ICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgY3VycmVudFZhbHVlO1xuXHQgICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG5cdCAgICAgICAgICAgIHZhciBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHF1ZXJpZXIpO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBleGVjdXRlKGN0eCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBuZXdTY29wZShxdWVyaWVyLCBjdHgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ2ID0gcnYuZmluYWxseShkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdhc1Jvb3RFeGVjICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyO1xuXHQgICAgICAgICAgICB2YXIgYWNjdW1NdXRzID0ge307XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50T2JzID0ge307XG5cdCAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG5cdCAgICAgICAgICAgICAgICBnZXQgY2xvc2VkKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZWQ7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRlZExpc3RlbmluZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLnVuc3Vic2NyaWJlKG11dGF0aW9uTGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgb2JzZXJ2ZXIuc3RhcnQgJiYgb2JzZXJ2ZXIuc3RhcnQoc3Vic2NyaXB0aW9uKTtcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGRvUXVlcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjSW5HbG9iYWxDb250ZXh0KF9kb1F1ZXJ5KTsgfTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkTm90aWZ5KCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9ic1NldHNPdmVybGFwKGN1cnJlbnRPYnMsIGFjY3VtTXV0cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG11dGF0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAocGFydHMpIHtcblx0ICAgICAgICAgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb1F1ZXJ5KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHZhciBfZG9RdWVyeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjbG9zZWQgfHxcblx0ICAgICAgICAgICAgICAgICAgICAhZG9tRGVwcy5pbmRleGVkREIpXG5cdCAgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnNjciA9IHt9O1xuXHQgICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcilcblx0ICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjdHggPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3Vic2NyOiBzdWJzY3IsXG5cdCAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlcnk6IGRvUXVlcnksXG5cdCAgICAgICAgICAgICAgICAgICAgcXVlcmllcjogcXVlcmllcixcblx0ICAgICAgICAgICAgICAgICAgICB0cmFuczogbnVsbFxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXQgPSBleGVjdXRlKGN0eCk7XG5cdCAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQgfHwgY3R4LnNpZ25hbC5hYm9ydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudE9icyA9IHN1YnNjcjtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdElzRW1wdHkoY3VycmVudE9icykgJiYgIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBtdXRhdGlvbkxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZExpc3RlbmluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGV4ZWNJbkdsb2JhbENvbnRleHQoZnVuY3Rpb24gKCkgeyByZXR1cm4gIWNsb3NlZCAmJiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQocmVzdWx0KTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIVsnRGF0YWJhc2VDbG9zZWRFcnJvcicsICdBYm9ydEVycm9yJ10uaW5jbHVkZXMoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0luR2xvYmFsQ29udGV4dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgc2V0VGltZW91dChkb1F1ZXJ5LCAwKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBvYnNlcnZhYmxlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzVmFsdWU7IH07XG5cdCAgICAgICAgb2JzZXJ2YWJsZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnJlbnRWYWx1ZTsgfTtcblx0ICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIERleGllID0gRGV4aWUkMTtcblx0ICAgIHByb3BzKERleGllLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZnVsbE5hbWVFeGNlcHRpb25zKSwge1xuXHQgICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGRhdGFiYXNlTmFtZSkge1xuXHQgICAgICAgICAgICB2YXIgZGIgPSBuZXcgRGV4aWUoZGF0YWJhc2VOYW1lLCB7IGFkZG9uczogW10gfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBkYi5kZWxldGUoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGV4aXN0czogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG5cdCAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH0pLmNhdGNoKCdOb1N1Y2hEYXRhYmFzZUVycm9yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0RGF0YWJhc2VOYW1lczogZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGF0YWJhc2VOYW1lcyhEZXhpZS5kZXBlbmRlbmNpZXMpLnRoZW4oY2IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZWZpbmVDbGFzczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIENsYXNzO1xuXHQgICAgICAgIH0sIGlnbm9yZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoc2NvcGVGdW5jKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuXHQgICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIHNjb3BlRnVuYykgOlxuXHQgICAgICAgICAgICAgICAgc2NvcGVGdW5jKCk7XG5cdCAgICAgICAgfSwgdmlwOiB2aXAsIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LCBzcGF3bjogZnVuY3Rpb24gKGdlbmVyYXRvckZuLCBhcmdzLCB0aGl6KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcblx0ICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHJ2KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUFNELnRyYW5zIHx8IG51bGw7IH1cblx0ICAgICAgICB9LCB3YWl0Rm9yOiBmdW5jdGlvbiAocHJvbWlzZU9yRnVuY3Rpb24sIG9wdGlvbmFsVGltZW91dCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG5cdCAgICAgICAgICAgICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihwcm9taXNlT3JGdW5jdGlvbikgOlxuXHQgICAgICAgICAgICAgICAgcHJvbWlzZU9yRnVuY3Rpb24pXG5cdCAgICAgICAgICAgICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApO1xuXHQgICAgICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cblx0ICAgICAgICAgICAgICAgIFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDpcblx0ICAgICAgICAgICAgICAgIHByb21pc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG5cdCAgICAgICAgZGVidWc6IHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWJ1ZzsgfSxcblx0ICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHNldERlYnVnKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZGVyaXZlOiBkZXJpdmUsIGV4dGVuZDogZXh0ZW5kLCBwcm9wczogcHJvcHMsIG92ZXJyaWRlOiBvdmVycmlkZSxcblx0ICAgICAgICBFdmVudHM6IEV2ZW50cywgb246IGdsb2JhbEV2ZW50cywgbGl2ZVF1ZXJ5OiBsaXZlUXVlcnksIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQ6IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQsXG5cdCAgICAgICAgZ2V0QnlLZXlQYXRoOiBnZXRCeUtleVBhdGgsIHNldEJ5S2V5UGF0aDogc2V0QnlLZXlQYXRoLCBkZWxCeUtleVBhdGg6IGRlbEJ5S2V5UGF0aCwgc2hhbGxvd0Nsb25lOiBzaGFsbG93Q2xvbmUsIGRlZXBDbG9uZTogZGVlcENsb25lLCBnZXRPYmplY3REaWZmOiBnZXRPYmplY3REaWZmLCBjbXA6IGNtcCwgYXNhcDogYXNhcCQxLFxuXHQgICAgICAgIG1pbktleTogbWluS2V5LFxuXHQgICAgICAgIGFkZG9uczogW10sXG5cdCAgICAgICAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuXHQgICAgICAgIGVycm5hbWVzOiBlcnJuYW1lcyxcblx0ICAgICAgICBkZXBlbmRlbmNpZXM6IGRvbURlcHMsIGNhY2hlOiBjYWNoZSxcblx0ICAgICAgICBzZW1WZXI6IERFWElFX1ZFUlNJT04sIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuXHQgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBwYXJzZUludChuKTsgfSlcblx0ICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocCwgYywgaSkgeyByZXR1cm4gcCArIChjIC8gTWF0aC5wb3coMTAsIGkgKiAyKSk7IH0pIH0pKTtcblx0ICAgIERleGllLm1heEtleSA9IGdldE1heEtleShEZXhpZS5kZXBlbmRlbmNpZXMuSURCS2V5UmFuZ2UpO1xuXG5cdCAgICBpZiAodHlwZW9mIGRpc3BhdGNoRXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgZnVuY3Rpb24gKHVwZGF0ZWRQYXJ0cykge1xuXHQgICAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzE7XG5cdCAgICAgICAgICAgICAgICBldmVudF8xID0gbmV3IEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGRldGFpbDogdXBkYXRlZFBhcnRzXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50XzEpO1xuXHQgICAgICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBhZGRFdmVudExpc3RlbmVyKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBkZXRhaWwgPSBfYS5kZXRhaWw7XG5cdCAgICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG5cdCAgICAgICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRldGFpbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUxvY2FsbHkodXBkYXRlUGFydHMpIHtcblx0ICAgICAgICB2YXIgd2FzTWUgPSBwcm9wYWdhdGluZ0xvY2FsbHk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUodXBkYXRlUGFydHMpO1xuXHQgICAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyh1cGRhdGVQYXJ0cywgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB3YXNNZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG5cblx0ICAgIHZhciBiYztcblx0ICAgIHZhciBjcmVhdGVCQyA9IGZ1bmN0aW9uICgpIHsgfTtcblx0ICAgIGlmICh0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBjcmVhdGVCQyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpO1xuXHQgICAgICAgICAgICBiYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIGV2LmRhdGEgJiYgcHJvcGFnYXRlTG9jYWxseShldi5kYXRhKTsgfTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGNyZWF0ZUJDKCk7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBiYy51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBiYy51bnJlZigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGZ1bmN0aW9uIChjaGFuZ2VkUGFydHMpIHtcblx0ICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcblx0ICAgICAgICAgICAgICAgIGJjLnBvc3RNZXNzYWdlKGNoYW5nZWRQYXJ0cyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmICghRGV4aWUkMS5kaXNhYmxlQmZDYWNoZSAmJiBldmVudC5wZXJzaXN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkZWJ1Zylcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXhpZTogaGFuZGxpbmcgcGVyc2lzdGVkIHBhZ2VoaWRlJyk7XG5cdCAgICAgICAgICAgICAgICBiYyA9PT0gbnVsbCB8fCBiYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmMuY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29ubmVjdGlvbnNfMSA9IGNvbm5lY3Rpb25zOyBfaSA8IGNvbm5lY3Rpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gY29ubmVjdGlvbnNfMVtfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKCFEZXhpZSQxLmRpc2FibGVCZkNhY2hlICYmIGV2ZW50LnBlcnNpc3RlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBoYW5kbGluZyBwZXJzaXN0ZWQgcGFnZXNob3cnKTtcblx0ICAgICAgICAgICAgICAgIGNyZWF0ZUJDKCk7XG5cdCAgICAgICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KHsgYWxsOiBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW11dKSB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BNb2RpZmljYXRpb24oeyBhZGQ6IHZhbHVlIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BNb2RpZmljYXRpb24oeyByZW1vdmU6IHZhbHVlIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByZXBsYWNlUHJlZml4KGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BNb2RpZmljYXRpb24oeyByZXBsYWNlUHJlZml4OiBbYSwgYl0gfSk7XG5cdCAgICB9XG5cblx0ICAgIERleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcblx0ICAgIHNldERlYnVnKGRlYnVnKTtcblxuXHQgICAgdmFyIG5hbWVkRXhwb3J0cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0ICAgICAgICBfX3Byb3RvX186IG51bGwsXG5cdCAgICAgICAgRGV4aWU6IERleGllJDEsXG5cdCAgICAgICAgbGl2ZVF1ZXJ5OiBsaXZlUXVlcnksXG5cdCAgICAgICAgRW50aXR5OiBFbnRpdHksXG5cdCAgICAgICAgY21wOiBjbXAsXG5cdCAgICAgICAgUHJvcE1vZFN5bWJvbDogUHJvcE1vZFN5bWJvbCxcblx0ICAgICAgICBQcm9wTW9kaWZpY2F0aW9uOiBQcm9wTW9kaWZpY2F0aW9uLFxuXHQgICAgICAgIHJlcGxhY2VQcmVmaXg6IHJlcGxhY2VQcmVmaXgsXG5cdCAgICAgICAgYWRkOiBhZGQsXG5cdCAgICAgICAgcmVtb3ZlOiByZW1vdmUsXG5cdCAgICAgICAgJ2RlZmF1bHQnOiBEZXhpZSQxLFxuXHQgICAgICAgIFJhbmdlU2V0OiBSYW5nZVNldCxcblx0ICAgICAgICBtZXJnZVJhbmdlczogbWVyZ2VSYW5nZXMsXG5cdCAgICAgICAgcmFuZ2VzT3ZlcmxhcDogcmFuZ2VzT3ZlcmxhcFxuXHQgICAgfSk7XG5cblx0ICAgIF9fYXNzaWduKERleGllJDEsIG5hbWVkRXhwb3J0cywgeyBkZWZhdWx0OiBEZXhpZSQxIH0pO1xuXG5cdCAgICByZXR1cm4gRGV4aWUkMTtcblxuXHR9KSk7XG5cdFxufSAoZGV4aWUpKTtcblxudmFyIGRleGllRXhwb3J0cyA9IGRleGllLmV4cG9ydHM7XG52YXIgX0RleGllID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGRleGllRXhwb3J0cyk7XG5cbi8vIE1ha2luZyB0aGUgbW9kdWxlIHZlcnNpb24gY29uc3VtYWJsZSB2aWEgcmVxdWlyZSAtIHRvIHByb2hpYml0XG4vLyBtdWx0aXBsZSBvY2N1cnJhbmNpZXMgb2YgdGhlIHNhbWUgbW9kdWxlIGluIHRoZSBzYW1lIGFwcFxuLy8gKGR1YWwgcGFja2FnZSBoYXphcmQsIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcGFja2FnZXMuaHRtbCNkdWFsLXBhY2thZ2UtaGF6YXJkKVxuY29uc3QgRGV4aWVTeW1ib2wgPSBTeW1ib2wuZm9yKFwiRGV4aWVcIik7XG5jb25zdCBEZXhpZSA9IGdsb2JhbFRoaXNbRGV4aWVTeW1ib2xdIHx8IChnbG9iYWxUaGlzW0RleGllU3ltYm9sXSA9IF9EZXhpZSk7XG5pZiAoX0RleGllLnNlbVZlciAhPT0gRGV4aWUuc2VtVmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUd28gZGlmZmVyZW50IHZlcnNpb25zIG9mIERleGllIGxvYWRlZCBpbiB0aGUgc2FtZSBhcHA6ICR7X0RleGllLnNlbVZlcn0gYW5kICR7RGV4aWUuc2VtVmVyfWApO1xufVxuXG4vLyBIZWxwZXIgZm9yIHVuZGVmaW5lZCB2YWx1ZXMsIGxpa2UgbWFwIGZvciBPcHRpb248VD4gaW4gUnVzdC5cbi8vIEEgYmV0dGVyIG5hbWUgZm9yIHRoaXMgaXMgd2VsY29tZS5cbmNvbnN0IG1hcE9wdGlvbiA9ICh2YWx1ZSwgZnVuYykgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQgPyBmdW5jKHZhbHVlKSA6IHVuZGVmaW5lZDtcbn07XG4vLyBBbnl0aGluZyBjYW4gYmUgdGhyb3duIGFzIGFuIGVycm9yIGluIHJhdyBKUyAoYWxzbyB0aGUgVFMgY29tcGlsZXIgY2FuJ3QgdHlwZS1jaGVjayBleGNlcHRpb25zKSxcbi8vIHNvIHdlIGFsbG93IGl0IGhlcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbG9nV2ViU3RvcmVFcnJvciA9IChlcnJvciwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRGV4aWUuRGV4aWVFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3JDb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2Vycm9yQ29udGV4dH06IEluZGV4ZGIgZXJyb3IgKCR7ZXJyb3IubmFtZX0pOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbmRleGRiIGVycm9yOiAoJHtlcnJvci5uYW1lfSk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBtYXBPcHRpb24oZXJyb3Iuc3RhY2ssIChzdGFjaykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU3RhY2t0cmFjZTogXFxuICR7c3RhY2t9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXBPcHRpb24oZXJyb3IuaW5uZXIsIChpbm5lckV4Y2VwdGlvbikgPT4gbG9nV2ViU3RvcmVFcnJvcihpbm5lckV4Y2VwdGlvbikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgYWNjZXNzaW5nIGluZGV4ZGI6ICR7ZXJyb3IudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgbWFwT3B0aW9uKGVycm9yLnN0YWNrLCAoc3RhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YWNrdHJhY2U6ICR7c3RhY2t9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgR290IGFuIGV4Y2VwdGlvbiB3aXRoIGEgbm9uLWVycm9yIHZhbHVlLCBhcyBKU09OOiBcXG4gJHtKU09OLnN0cmluZ2lmeShlcnJvcil9LiBBcyBTdHJpbmcgXFxuICR7U3RyaW5nKGVycm9yKX0gYCk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuY29uc3QgdWludDhBcnJheVRvQmFzZTY0ID0gKGJ5dGVzKSA9PiB7XG4gICAgY29uc3QgYmluYXJ5ID0gYnl0ZXMucmVkdWNlKChhY2MsIGJ5dGUpID0+IGFjYyArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksIFwiXCIpO1xuICAgIHJldHVybiBidG9hKGJpbmFyeSk7XG59O1xuXG5jb25zdCBEQVRBQkFTRV9OQU1FID0gXCJNaWRlbkNsaWVudERCXCI7XG5hc3luYyBmdW5jdGlvbiBvcGVuRGF0YWJhc2UoKSB7XG4gICAgY29uc29sZS5sb2coXCJPcGVuaW5nIGRhdGFiYXNlLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRiLm9wZW4oKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJEYXRhYmFzZSBvcGVuZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbnZhciBUYWJsZTtcbihmdW5jdGlvbiAoVGFibGUpIHtcbiAgICBUYWJsZVtcIkFjY291bnRDb2RlXCJdID0gXCJhY2NvdW50Q29kZVwiO1xuICAgIFRhYmxlW1wiQWNjb3VudFN0b3JhZ2VcIl0gPSBcImFjY291bnRTdG9yYWdlXCI7XG4gICAgVGFibGVbXCJBY2NvdW50QXNzZXRzXCJdID0gXCJhY2NvdW50QXNzZXRzXCI7XG4gICAgVGFibGVbXCJTdG9yYWdlTWFwRW50cmllc1wiXSA9IFwic3RvcmFnZU1hcEVudHJpZXNcIjtcbiAgICBUYWJsZVtcIkFjY291bnRBdXRoXCJdID0gXCJhY2NvdW50QXV0aFwiO1xuICAgIFRhYmxlW1wiQWNjb3VudHNcIl0gPSBcImFjY291bnRzXCI7XG4gICAgVGFibGVbXCJBZGRyZXNzZXNcIl0gPSBcImFkZHJlc3Nlc1wiO1xuICAgIFRhYmxlW1wiVHJhbnNhY3Rpb25zXCJdID0gXCJ0cmFuc2FjdGlvbnNcIjtcbiAgICBUYWJsZVtcIlRyYW5zYWN0aW9uU2NyaXB0c1wiXSA9IFwidHJhbnNhY3Rpb25TY3JpcHRzXCI7XG4gICAgVGFibGVbXCJJbnB1dE5vdGVzXCJdID0gXCJpbnB1dE5vdGVzXCI7XG4gICAgVGFibGVbXCJPdXRwdXROb3Rlc1wiXSA9IFwib3V0cHV0Tm90ZXNcIjtcbiAgICBUYWJsZVtcIk5vdGVzU2NyaXB0c1wiXSA9IFwibm90ZXNTY3JpcHRzXCI7XG4gICAgVGFibGVbXCJTdGF0ZVN5bmNcIl0gPSBcInN0YXRlU3luY1wiO1xuICAgIFRhYmxlW1wiQmxvY2tIZWFkZXJzXCJdID0gXCJibG9ja0hlYWRlcnNcIjtcbiAgICBUYWJsZVtcIlBhcnRpYWxCbG9ja2NoYWluTm9kZXNcIl0gPSBcInBhcnRpYWxCbG9ja2NoYWluTm9kZXNcIjtcbiAgICBUYWJsZVtcIlRhZ3NcIl0gPSBcInRhZ3NcIjtcbiAgICBUYWJsZVtcIkZvcmVpZ25BY2NvdW50Q29kZVwiXSA9IFwiZm9yZWlnbkFjY291bnRDb2RlXCI7XG4gICAgVGFibGVbXCJTZXR0aW5nc1wiXSA9IFwic2V0dGluZ3NcIjtcbiAgICBUYWJsZVtcIlRyYWNrZWRBY2NvdW50c1wiXSA9IFwidHJhY2tlZEFjY291bnRzXCI7XG59KShUYWJsZSB8fCAoVGFibGUgPSB7fSkpO1xuY29uc3QgZGIgPSBuZXcgRGV4aWUoREFUQUJBU0VfTkFNRSk7XG5kYi52ZXJzaW9uKDEpLnN0b3Jlcyh7XG4gICAgW1RhYmxlLkFjY291bnRDb2RlXTogaW5kZXhlcyhcInJvb3RcIiksXG4gICAgW1RhYmxlLkFjY291bnRTdG9yYWdlXTogaW5kZXhlcyhcIltjb21taXRtZW50K3Nsb3RJbmRleF1cIiwgXCJjb21taXRtZW50XCIpLFxuICAgIFtUYWJsZS5TdG9yYWdlTWFwRW50cmllc106IGluZGV4ZXMoXCJbcm9vdCtrZXldXCIsIFwicm9vdFwiKSxcbiAgICBbVGFibGUuQWNjb3VudEFzc2V0c106IGluZGV4ZXMoXCJbcm9vdCt2YXVsdEtleV1cIiwgXCJyb290XCIsIFwiZmF1Y2V0SWRQcmVmaXhcIiksXG4gICAgW1RhYmxlLkFjY291bnRBdXRoXTogaW5kZXhlcyhcInB1YktleVwiKSxcbiAgICBbVGFibGUuQWNjb3VudHNdOiBpbmRleGVzKFwiJmFjY291bnRDb21taXRtZW50XCIsIFwiaWRcIiwgXCJbaWQrbm9uY2VdXCIsIFwiY29kZVJvb3RcIiwgXCJzdG9yYWdlUm9vdFwiLCBcInZhdWx0Um9vdFwiKSxcbiAgICBbVGFibGUuQWRkcmVzc2VzXTogaW5kZXhlcyhcImFkZHJlc3NcIiwgXCJpZFwiKSxcbiAgICBbVGFibGUuVHJhbnNhY3Rpb25zXTogaW5kZXhlcyhcImlkXCIsIFwic3RhdHVzVmFyaWFudFwiKSxcbiAgICBbVGFibGUuVHJhbnNhY3Rpb25TY3JpcHRzXTogaW5kZXhlcyhcInNjcmlwdFJvb3RcIiksXG4gICAgW1RhYmxlLklucHV0Tm90ZXNdOiBpbmRleGVzKFwibm90ZUlkXCIsIFwibnVsbGlmaWVyXCIsIFwic3RhdGVEaXNjcmltaW5hbnRcIiksXG4gICAgW1RhYmxlLk91dHB1dE5vdGVzXTogaW5kZXhlcyhcIm5vdGVJZFwiLCBcInJlY2lwaWVudERpZ2VzdFwiLCBcInN0YXRlRGlzY3JpbWluYW50XCIsIFwibnVsbGlmaWVyXCIpLFxuICAgIFtUYWJsZS5Ob3Rlc1NjcmlwdHNdOiBpbmRleGVzKFwic2NyaXB0Um9vdFwiKSxcbiAgICBbVGFibGUuU3RhdGVTeW5jXTogaW5kZXhlcyhcImlkXCIpLFxuICAgIFtUYWJsZS5CbG9ja0hlYWRlcnNdOiBpbmRleGVzKFwiYmxvY2tOdW1cIiwgXCJoYXNDbGllbnROb3Rlc1wiKSxcbiAgICBbVGFibGUuUGFydGlhbEJsb2NrY2hhaW5Ob2Rlc106IGluZGV4ZXMoXCJpZFwiKSxcbiAgICBbVGFibGUuVGFnc106IGluZGV4ZXMoXCJpZCsrXCIsIFwidGFnXCIsIFwic291cmNlX25vdGVfaWRcIiwgXCJzb3VyY2VfYWNjb3VudF9pZFwiKSxcbiAgICBbVGFibGUuRm9yZWlnbkFjY291bnRDb2RlXTogaW5kZXhlcyhcImFjY291bnRJZFwiKSxcbiAgICBbVGFibGUuU2V0dGluZ3NdOiBpbmRleGVzKFwia2V5XCIpLFxuICAgIFtUYWJsZS5UcmFja2VkQWNjb3VudHNdOiBpbmRleGVzKFwiJmlkXCIpLFxufSk7XG5mdW5jdGlvbiBpbmRleGVzKC4uLml0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLmpvaW4oXCIsXCIpO1xufVxuZGIub24oXCJwb3B1bGF0ZVwiLCAoKSA9PiB7XG4gICAgLy8gUG9wdWxhdGUgdGhlIHN0YXRlU3luYyB0YWJsZSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgc3RhdGVTeW5jXG4gICAgICAgIC5wdXQoeyBpZDogMSwgYmxvY2tOdW06IFwiMFwiIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gcG9wdWxhdGUgREJcIikpO1xufSk7XG5jb25zdCBhY2NvdW50Q29kZXMgPSBkYi50YWJsZShUYWJsZS5BY2NvdW50Q29kZSk7XG5jb25zdCBhY2NvdW50U3RvcmFnZXMgPSBkYi50YWJsZShUYWJsZS5BY2NvdW50U3RvcmFnZSk7XG5jb25zdCBzdG9yYWdlTWFwRW50cmllcyA9IGRiLnRhYmxlKFRhYmxlLlN0b3JhZ2VNYXBFbnRyaWVzKTtcbmNvbnN0IGFjY291bnRBc3NldHMgPSBkYi50YWJsZShUYWJsZS5BY2NvdW50QXNzZXRzKTtcbmNvbnN0IGFjY291bnRBdXRocyA9IGRiLnRhYmxlKFRhYmxlLkFjY291bnRBdXRoKTtcbmNvbnN0IGFjY291bnRzID0gZGIudGFibGUoVGFibGUuQWNjb3VudHMpO1xuY29uc3QgYWRkcmVzc2VzID0gZGIudGFibGUoVGFibGUuQWRkcmVzc2VzKTtcbmNvbnN0IHRyYW5zYWN0aW9ucyA9IGRiLnRhYmxlKFRhYmxlLlRyYW5zYWN0aW9ucyk7XG5jb25zdCB0cmFuc2FjdGlvblNjcmlwdHMgPSBkYi50YWJsZShUYWJsZS5UcmFuc2FjdGlvblNjcmlwdHMpO1xuY29uc3QgaW5wdXROb3RlcyA9IGRiLnRhYmxlKFRhYmxlLklucHV0Tm90ZXMpO1xuY29uc3Qgb3V0cHV0Tm90ZXMgPSBkYi50YWJsZShUYWJsZS5PdXRwdXROb3Rlcyk7XG5jb25zdCBub3Rlc1NjcmlwdHMgPSBkYi50YWJsZShUYWJsZS5Ob3Rlc1NjcmlwdHMpO1xuY29uc3Qgc3RhdGVTeW5jID0gZGIudGFibGUoVGFibGUuU3RhdGVTeW5jKTtcbmNvbnN0IGJsb2NrSGVhZGVycyA9IGRiLnRhYmxlKFRhYmxlLkJsb2NrSGVhZGVycyk7XG5jb25zdCBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzID0gZGIudGFibGUoVGFibGUuUGFydGlhbEJsb2NrY2hhaW5Ob2Rlcyk7XG5jb25zdCB0YWdzID0gZGIudGFibGUoVGFibGUuVGFncyk7XG5jb25zdCBmb3JlaWduQWNjb3VudENvZGUgPSBkYi50YWJsZShUYWJsZS5Gb3JlaWduQWNjb3VudENvZGUpO1xuY29uc3Qgc2V0dGluZ3MgPSBkYi50YWJsZShUYWJsZS5TZXR0aW5ncyk7XG5jb25zdCB0cmFja2VkQWNjb3VudHMgPSBkYi50YWJsZShUYWJsZS5UcmFja2VkQWNjb3VudHMpO1xuXG4vLyBHRVQgRlVOQ1RJT05TXG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50SWRzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyYWNrZWQgPSBhd2FpdCB0cmFja2VkQWNjb3VudHMudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gdHJhY2tlZC5tYXAoKGVudHJ5KSA9PiBlbnRyeS5pZCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkVycm9yIHdoaWxlIGZldGNoaW5nIGFjY291bnQgSURzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBbGxBY2NvdW50SGVhZGVycygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBVc2UgYSBNYXAgdG8gdHJhY2sgdGhlIGxhdGVzdCByZWNvcmQgZm9yIGVhY2ggaWQgYmFzZWQgb24gbm9uY2VcbiAgICAgICAgY29uc3QgbGF0ZXN0UmVjb3Jkc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgYXdhaXQgYWNjb3VudHMuZWFjaCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JlY29yZCA9IGxhdGVzdFJlY29yZHNNYXAuZ2V0KHJlY29yZC5pZCk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nUmVjb3JkIHx8XG4gICAgICAgICAgICAgICAgQmlnSW50KHJlY29yZC5ub25jZSkgPiBCaWdJbnQoZXhpc3RpbmdSZWNvcmQubm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0UmVjb3Jkc01hcC5zZXQocmVjb3JkLmlkLCByZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgbGF0ZXN0IHJlY29yZHMgZnJvbSB0aGUgTWFwXG4gICAgICAgIGNvbnN0IGxhdGVzdFJlY29yZHMgPSBBcnJheS5mcm9tKGxhdGVzdFJlY29yZHNNYXAudmFsdWVzKCkpO1xuICAgICAgICBjb25zdCByZXN1bHRPYmplY3QgPSBhd2FpdCBQcm9taXNlLmFsbChsYXRlc3RSZWNvcmRzLm1hcCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWNjb3VudFNlZWRCYXNlNjQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLmFjY291bnRTZWVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VlZEFzQnl0ZXMgPSBuZXcgVWludDhBcnJheShyZWNvcmQuYWNjb3VudFNlZWQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVkQXNCeXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRTZWVkQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHNlZWRBc0J5dGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiByZWNvcmQuaWQsXG4gICAgICAgICAgICAgICAgbm9uY2U6IHJlY29yZC5ub25jZSxcbiAgICAgICAgICAgICAgICB2YXVsdFJvb3Q6IHJlY29yZC52YXVsdFJvb3QsIC8vIEZhbGxiYWNrIGlmIG1pc3NpbmdcbiAgICAgICAgICAgICAgICBzdG9yYWdlUm9vdDogcmVjb3JkLnN0b3JhZ2VSb290IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgY29kZVJvb3Q6IHJlY29yZC5jb2RlUm9vdCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFjY291bnRTZWVkOiBhY2NvdW50U2VlZEJhc2U2NCwgLy8gbnVsbCBvciBiYXNlNjQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbG9ja2VkOiByZWNvcmQubG9ja2VkLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZDogcmVjb3JkLmNvbW1pdHRlZCwgLy8gVXNlIGFjdHVhbCB2YWx1ZSBvciBkZWZhdWx0XG4gICAgICAgICAgICAgICAgYWNjb3VudENvbW1pdG1lbnQ6IHJlY29yZC5hY2NvdW50Q29tbWl0bWVudCB8fCBcIlwiLCAvLyBLZWVwIG9yaWdpbmFsIGZpZWxkIG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9iamVjdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRXJyb3Igd2hpbGUgZmV0Y2hpbmcgYWNjb3VudCBoZWFkZXJzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRIZWFkZXIoYWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGlkXG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGFjY291bnRzXG4gICAgICAgICAgICAud2hlcmUoXCJpZFwiKVxuICAgICAgICAgICAgLmVxdWFscyhhY2NvdW50SWQpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBpZiAoYWxsTWF0Y2hpbmdSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBhY2NvdW50IGhlYWRlciByZWNvcmQgZm91bmQgZm9yIGdpdmVuIElELlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgbm9uY2UgdG8gQmlnSW50IGFuZCBzb3J0XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgYXNzdW1lcyBhbGwgbm9uY2VzIGFyZSB2YWxpZCBCaWdJbnQgc3RyaW5ncy5cbiAgICAgICAgY29uc3Qgc29ydGVkUmVjb3JkcyA9IGFsbE1hdGNoaW5nUmVjb3Jkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnRBID0gQmlnSW50KGEubm9uY2UpO1xuICAgICAgICAgICAgY29uc3QgYmlnSW50QiA9IEJpZ0ludChiLm5vbmNlKTtcbiAgICAgICAgICAgIHJldHVybiBiaWdJbnRBID4gYmlnSW50QiA/IC0xIDogYmlnSW50QSA8IGJpZ0ludEIgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBmaXJzdCByZWNvcmQgaXMgdGhlIG1vc3QgcmVjZW50IG9uZSBkdWUgdG8gdGhlIHNvcnRpbmdcbiAgICAgICAgY29uc3QgbW9zdFJlY2VudFJlY29yZCA9IHNvcnRlZFJlY29yZHNbMF07XG4gICAgICAgIGlmIChtb3N0UmVjZW50UmVjb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2NvdW50U2VlZEJhc2U2NCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1vc3RSZWNlbnRSZWNvcmQuYWNjb3VudFNlZWQpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhY2NvdW50U2VlZCBpcyBwcm9jZXNzZWQgYXMgYSBVaW50OEFycmF5IGFuZCBjb252ZXJ0ZWQgdG8gQmFzZTY0XG4gICAgICAgICAgICBpZiAobW9zdFJlY2VudFJlY29yZC5hY2NvdW50U2VlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFNlZWRCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobW9zdFJlY2VudFJlY29yZC5hY2NvdW50U2VlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQWNjb3VudEhlYWRlciA9IHtcbiAgICAgICAgICAgIGlkOiBtb3N0UmVjZW50UmVjb3JkLmlkLFxuICAgICAgICAgICAgbm9uY2U6IG1vc3RSZWNlbnRSZWNvcmQubm9uY2UsXG4gICAgICAgICAgICB2YXVsdFJvb3Q6IG1vc3RSZWNlbnRSZWNvcmQudmF1bHRSb290LFxuICAgICAgICAgICAgc3RvcmFnZVJvb3Q6IG1vc3RSZWNlbnRSZWNvcmQuc3RvcmFnZVJvb3QsXG4gICAgICAgICAgICBjb2RlUm9vdDogbW9zdFJlY2VudFJlY29yZC5jb2RlUm9vdCxcbiAgICAgICAgICAgIGFjY291bnRTZWVkOiBhY2NvdW50U2VlZEJhc2U2NCxcbiAgICAgICAgICAgIGxvY2tlZDogbW9zdFJlY2VudFJlY29yZC5sb2NrZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBY2NvdW50SGVhZGVyO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIHdoaWxlIGZldGNoaW5nIGFjY291bnQgaGVhZGVyIGZvciBpZDogJHthY2NvdW50SWR9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEhlYWRlckJ5Q29tbWl0bWVudChhY2NvdW50Q29tbWl0bWVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiBjb21taXRtZW50XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGFjY291bnRzXG4gICAgICAgICAgICAud2hlcmUoXCJhY2NvdW50Q29tbWl0bWVudFwiKVxuICAgICAgICAgICAgLmVxdWFscyhhY2NvdW50Q29tbWl0bWVudClcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGlmIChhbGxNYXRjaGluZ1JlY29yZHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIG1hdGNoXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUmVjb3JkID0gYWxsTWF0Y2hpbmdSZWNvcmRzWzBdO1xuICAgICAgICBpZiAobWF0Y2hpbmdSZWNvcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBhY2NvdW50IGhlYWRlciByZWNvcmQgZm91bmQgZm9yIGdpdmVuIGNvbW1pdG1lbnQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjY291bnRTZWVkQmFzZTY0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWF0Y2hpbmdSZWNvcmQuYWNjb3VudFNlZWQpIHtcbiAgICAgICAgICAgIGFjY291bnRTZWVkQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG1hdGNoaW5nUmVjb3JkLmFjY291bnRTZWVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBBY2NvdW50SGVhZGVyID0ge1xuICAgICAgICAgICAgaWQ6IG1hdGNoaW5nUmVjb3JkLmlkLFxuICAgICAgICAgICAgbm9uY2U6IG1hdGNoaW5nUmVjb3JkLm5vbmNlLFxuICAgICAgICAgICAgdmF1bHRSb290OiBtYXRjaGluZ1JlY29yZC52YXVsdFJvb3QsXG4gICAgICAgICAgICBzdG9yYWdlUm9vdDogbWF0Y2hpbmdSZWNvcmQuc3RvcmFnZVJvb3QsXG4gICAgICAgICAgICBjb2RlUm9vdDogbWF0Y2hpbmdSZWNvcmQuY29kZVJvb3QsXG4gICAgICAgICAgICBhY2NvdW50U2VlZDogYWNjb3VudFNlZWRCYXNlNjQsXG4gICAgICAgICAgICBsb2NrZWQ6IG1hdGNoaW5nUmVjb3JkLmxvY2tlZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRIZWFkZXI7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgZmV0Y2hpbmcgYWNjb3VudCBoZWFkZXIgZm9yIGNvbW1pdG1lbnQgJHthY2NvdW50Q29tbWl0bWVudH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50Q29kZShjb2RlUm9vdCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiByb290XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGFjY291bnRDb2Rlc1xuICAgICAgICAgICAgLndoZXJlKFwicm9vdFwiKVxuICAgICAgICAgICAgLmVxdWFscyhjb2RlUm9vdClcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIC8vIFRoZSBmaXJzdCByZWNvcmQgaXMgdGhlIG9ubHkgb25lIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjb25zdHJhaW50XG4gICAgICAgIGNvbnN0IGNvZGVSZWNvcmQgPSBhbGxNYXRjaGluZ1JlY29yZHNbMF07XG4gICAgICAgIGlmIChjb2RlUmVjb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gcmVjb3JkcyBmb3VuZCBmb3IgZ2l2ZW4gY29kZSByb290LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGNvZGUgQmxvYiB0byBhbiBBcnJheUJ1ZmZlclxuICAgICAgICBjb25zdCBjb2RlQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KGNvZGVSZWNvcmQuY29kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiBjb2RlUmVjb3JkLnJvb3QsXG4gICAgICAgICAgICBjb2RlOiBjb2RlQmFzZTY0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGZldGNoaW5nIGFjY291bnQgY29kZSBmb3Igcm9vdCAke2NvZGVSb290fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRTdG9yYWdlKHN0b3JhZ2VDb21taXRtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYWNjb3VudFN0b3JhZ2VzXG4gICAgICAgICAgICAud2hlcmUoXCJjb21taXRtZW50XCIpXG4gICAgICAgICAgICAuZXF1YWxzKHN0b3JhZ2VDb21taXRtZW50KVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSBhbGxNYXRjaGluZ1JlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2xvdEluZGV4OiByZWNvcmQuc2xvdEluZGV4LFxuICAgICAgICAgICAgICAgIHNsb3RWYWx1ZTogcmVjb3JkLnNsb3RWYWx1ZSxcbiAgICAgICAgICAgICAgICBzbG90VHlwZTogcmVjb3JkLnNsb3RUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzbG90cztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBmZXRjaGluZyBhY2NvdW50IHN0b3JhZ2UgZm9yIGNvbW1pdG1lbnQgJHtzdG9yYWdlQ29tbWl0bWVudH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50U3RvcmFnZU1hcHMocm9vdHMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBzdG9yYWdlTWFwRW50cmllc1xuICAgICAgICAgICAgLndoZXJlKFwicm9vdFwiKVxuICAgICAgICAgICAgLmFueU9mKHJvb3RzKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoaW5nUmVjb3JkcztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBmZXRjaGluZyBhY2NvdW50IHN0b3JhZ2UgbWFwcyBmb3Igcm9vdHMgJHtyb290cy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudFZhdWx0QXNzZXRzKHZhdWx0Um9vdCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiByb290XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGFjY291bnRBc3NldHNcbiAgICAgICAgICAgIC53aGVyZShcInJvb3RcIilcbiAgICAgICAgICAgIC5lcXVhbHModmF1bHRSb290KVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgLy8gTWFwIHRoZSByZWNvcmRzIHRvIHRoZWlyIGFzc2V0IHZhbHVlc1xuICAgICAgICBjb25zdCBhc3NldHMgPSBhbGxNYXRjaGluZ1JlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXNzZXQ6IHJlY29yZC5hc3NldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGZldGNoaW5nIGFjY291bnQgdmF1bHQgZm9yIHJvb3QgJHt2YXVsdFJvb3R9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEF1dGhCeVB1YktleShwdWJLZXkpIHtcbiAgICAvLyBUcnkgdG8gZ2V0IHRoZSBhY2NvdW50IGF1dGggZnJvbSB0aGUgc3RvcmVcbiAgICBjb25zdCBhY2NvdW50U2VjcmV0S2V5ID0gYXdhaXQgYWNjb3VudEF1dGhzXG4gICAgICAgIC53aGVyZShcInB1YktleVwiKVxuICAgICAgICAuZXF1YWxzKHB1YktleSlcbiAgICAgICAgLmZpcnN0KCk7XG4gICAgLy8gSWYgaXQncyBub3QgaW4gdGhlIGNhY2hlLCB0aHJvdyBhbiBlcnJvclxuICAgIGlmICghYWNjb3VudFNlY3JldEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2NvdW50IGF1dGggbm90IGZvdW5kIGluIGNhY2hlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgc2VjcmV0S2V5OiBhY2NvdW50U2VjcmV0S2V5LnNlY3JldEtleSxcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEFkZHJlc3NlcyhhY2NvdW50SWQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4gYWNjb3VudElkXG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGFkZHJlc3Nlc1xuICAgICAgICAgICAgLndoZXJlKFwiaWRcIilcbiAgICAgICAgICAgIC5lcXVhbHMoYWNjb3VudElkKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKGFsbE1hdGNoaW5nUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gYWRkcmVzcyByZWNvcmRzIGZvdW5kIGZvciBnaXZlbiBhY2NvdW50IElELlwiKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsTWF0Y2hpbmdSZWNvcmRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIHdoaWxlIGZldGNoaW5nIGFjY291bnQgYWRkcmVzc2VzIGZvciBpZDogJHthY2NvdW50SWR9YCk7XG4gICAgfVxufVxuLy8gSU5TRVJUIEZVTkNUSU9OU1xuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0QWNjb3VudENvZGUoY29kZVJvb3QsIGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBkYXRhIG9iamVjdCB0byBpbnNlcnRcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJvb3Q6IGNvZGVSb290LCAvLyBVc2luZyBjb2RlUm9vdCBhcyB0aGUga2V5XG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbnNlcnQgdXNpbmcgRGV4aWVcbiAgICAgICAgYXdhaXQgYWNjb3VudENvZGVzLnB1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgY29kZSB3aXRoIHJvb3Q6ICR7Y29kZVJvb3R9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0QWNjb3VudFN0b3JhZ2Uoc3RvcmFnZVNsb3RzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb2Nlc3NlZFNsb3RzID0gc3RvcmFnZVNsb3RzLm1hcCgoc2xvdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb21taXRtZW50OiBzbG90LmNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgc2xvdEluZGV4OiBzbG90LnNsb3RJbmRleCxcbiAgICAgICAgICAgICAgICBzbG90VmFsdWU6IHNsb3Quc2xvdFZhbHVlLFxuICAgICAgICAgICAgICAgIHNsb3RUeXBlOiBzbG90LnNsb3RUeXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGFjY291bnRTdG9yYWdlcy5idWxrUHV0KHByb2Nlc3NlZFNsb3RzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgc3RvcmFnZSBzbG90c2ApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydFN0b3JhZ2VNYXBFbnRyaWVzKGVudHJpZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvY2Vzc2VkRW50cmllcyA9IGVudHJpZXMubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb290OiBlbnRyeS5yb290LFxuICAgICAgICAgICAgICAgIGtleTogZW50cnkua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBzdG9yYWdlTWFwRW50cmllcy5idWxrUHV0KHByb2Nlc3NlZEVudHJpZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBzdG9yYWdlIG1hcCBlbnRyaWVzYCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0VmF1bHRBc3NldHMoYXNzZXRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb2Nlc3NlZEFzc2V0cyA9IGFzc2V0cy5tYXAoKGFzc2V0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvb3Q6IGFzc2V0LnJvb3QsXG4gICAgICAgICAgICAgICAgdmF1bHRLZXk6IGFzc2V0LnZhdWx0S2V5LFxuICAgICAgICAgICAgICAgIGZhdWNldElkUHJlZml4OiBhc3NldC5mYXVjZXRJZFByZWZpeCxcbiAgICAgICAgICAgICAgICBhc3NldDogYXNzZXQuYXNzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgYWNjb3VudEFzc2V0cy5idWxrUHV0KHByb2Nlc3NlZEFzc2V0cyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIGFzc2V0c2ApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydEFjY291bnRSZWNvcmQoYWNjb3VudElkLCBjb2RlUm9vdCwgc3RvcmFnZVJvb3QsIHZhdWx0Um9vdCwgbm9uY2UsIGNvbW1pdHRlZCwgY29tbWl0bWVudCwgYWNjb3VudFNlZWQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgaWQ6IGFjY291bnRJZCxcbiAgICAgICAgICAgIGNvZGVSb290LFxuICAgICAgICAgICAgc3RvcmFnZVJvb3QsXG4gICAgICAgICAgICB2YXVsdFJvb3QsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIGNvbW1pdHRlZCxcbiAgICAgICAgICAgIGFjY291bnRTZWVkLFxuICAgICAgICAgICAgYWNjb3VudENvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICBsb2NrZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBhY2NvdW50cy5wdXQoZGF0YSk7XG4gICAgICAgIGF3YWl0IHRyYWNrZWRBY2NvdW50cy5wdXQoeyBpZDogYWNjb3VudElkIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBhY2NvdW50OiAke2FjY291bnRJZH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbnNlcnRBY2NvdW50QXV0aChwdWJLZXksIHNlY3JldEtleSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGRhdGEgb2JqZWN0IHRvIGluc2VydFxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcHViS2V5OiBwdWJLZXksXG4gICAgICAgICAgICBzZWNyZXRLZXk6IHNlY3JldEtleSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5zZXJ0IHVzaW5nIERleGllXG4gICAgICAgIGF3YWl0IGFjY291bnRBdXRocy5hZGQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIGFjY291bnQgYXV0aCBmb3IgcHViS2V5OiAke3B1YktleX1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbnNlcnRBY2NvdW50QWRkcmVzcyhhZGRyZXNzLCBhY2NvdW50SWQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBkYXRhIG9iamVjdCB0byBpbnNlcnRcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBpZDogYWNjb3VudElkLFxuICAgICAgICB9O1xuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbnNlcnQgdXNpbmcgRGV4aWVcbiAgICAgICAgYXdhaXQgYWRkcmVzc2VzLnB1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgYWRkcmVzcyB3aXRoIHZhbHVlOiAke1N0cmluZyhhZGRyZXNzKX0gZm9yIHRoZSBhY2NvdW50IElEICR7YWNjb3VudElkfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZUFjY291bnRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBQZXJmb3JtIHRoZSBkZWxldGUgdXNpbmcgRGV4aWVcbiAgICAgICAgYXdhaXQgYWRkcmVzc2VzLndoZXJlKFwiYWRkcmVzc1wiKS5lcXVhbHMoYWRkcmVzcykuZGVsZXRlKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgcmVtb3ZpbmcgYWRkcmVzcyB3aXRoIHZhbHVlOiAke1N0cmluZyhhZGRyZXNzKX1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRGb3JlaWduQWNjb3VudENvZGUoYWNjb3VudElkLCBjb2RlLCBjb2RlUm9vdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHVwc2VydEFjY291bnRDb2RlKGNvZGVSb290LCBjb2RlKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgIGNvZGVSb290LFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBmb3JlaWduQWNjb3VudENvZGUucHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIHVwc2VydGluZyBmb3JlaWduIGFjY291bnQgY29kZSBmb3IgYWNjb3VudDogJHthY2NvdW50SWR9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Rm9yZWlnbkFjY291bnRDb2RlKGFjY291bnRJZHMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmb3JlaWduQWNjb3VudHMgPSBhd2FpdCBmb3JlaWduQWNjb3VudENvZGVcbiAgICAgICAgICAgIC53aGVyZShcImFjY291bnRJZFwiKVxuICAgICAgICAgICAgLmFueU9mKGFjY291bnRJZHMpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBpZiAoZm9yZWlnbkFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyByZWNvcmRzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gYWNjb3VudCBJRHMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIHJlY29yZHMgZm91bmRcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlUm9vdHMgPSBmb3JlaWduQWNjb3VudHMubWFwKChhY2NvdW50KSA9PiBhY2NvdW50LmNvZGVSb290KTtcbiAgICAgICAgY29uc3QgYWNjb3VudENvZGUgPSBhd2FpdCBhY2NvdW50Q29kZXNcbiAgICAgICAgICAgIC53aGVyZShcInJvb3RcIilcbiAgICAgICAgICAgIC5hbnlPZihjb2RlUm9vdHMpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb2RlID0gZm9yZWlnbkFjY291bnRzXG4gICAgICAgICAgICAubWFwKChmb3JlaWduQWNjb3VudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdDb2RlID0gYWNjb3VudENvZGUuZmluZCgoY29kZSkgPT4gY29kZS5yb290ID09PSBmb3JlaWduQWNjb3VudC5jb2RlUm9vdCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChtYXRjaGluZ0NvZGUuY29kZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjY291bnRJZDogZm9yZWlnbkFjY291bnQuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVCYXNlNjQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigobWF0Y2hpbmdDb2RlKSA9PiBtYXRjaGluZ0NvZGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRDb2RlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJFcnJvciBmZXRjaGluZyBmb3JlaWduIGFjY291bnQgY29kZVwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBsb2NrQWNjb3VudChhY2NvdW50SWQpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBhY2NvdW50cy53aGVyZShcImlkXCIpLmVxdWFscyhhY2NvdW50SWQpLm1vZGlmeSh7IGxvY2tlZDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBsb2NraW5nIGFjY291bnQ6ICR7YWNjb3VudElkfWApO1xuICAgIH1cbn1cbi8vIERlbGV0ZSBmdW5jdGlvbnNcbmFzeW5jIGZ1bmN0aW9uIHVuZG9BY2NvdW50U3RhdGVzKGFjY291bnRDb21taXRtZW50cykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGFjY291bnRzXG4gICAgICAgICAgICAud2hlcmUoXCJhY2NvdW50Q29tbWl0bWVudFwiKVxuICAgICAgICAgICAgLmFueU9mKGFjY291bnRDb21taXRtZW50cylcbiAgICAgICAgICAgIC5kZWxldGUoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciB1bmRvaW5nIGFjY291bnQgc3RhdGVzOiAke2FjY291bnRDb21taXRtZW50cy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG59XG5cbi8vIElOU0VSVCBGVU5DVElPTlNcbmFzeW5jIGZ1bmN0aW9uIGluc2VydEJsb2NrSGVhZGVyKGJsb2NrTnVtLCBoZWFkZXIsIHBhcnRpYWxCbG9ja2NoYWluUGVha3MsIGhhc0NsaWVudE5vdGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtOiBibG9ja051bSxcbiAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgIHBhcnRpYWxCbG9ja2NoYWluUGVha3MsXG4gICAgICAgICAgICBoYXNDbGllbnROb3RlczogaGFzQ2xpZW50Tm90ZXMudG9TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdCbG9ja0hlYWRlciA9IGF3YWl0IGJsb2NrSGVhZGVycy5nZXQoYmxvY2tOdW0pO1xuICAgICAgICBpZiAoIWV4aXN0aW5nQmxvY2tIZWFkZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IGJsb2NrSGVhZGVycy5hZGQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkJsb2NrIGhlYWRlciBhbHJlYWR5IGV4aXN0cywgY2hlY2tpbmcgZm9yIHVwZGF0ZS5cIik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc0NsaWVudE5vdGVzIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBmYWxzZVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQmxvY2tIZWFkZXIuaGFzQ2xpZW50Tm90ZXMgPT09IFwiZmFsc2VcIiAmJiBoYXNDbGllbnROb3Rlcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGJsb2NrSGVhZGVycy51cGRhdGUoYmxvY2tOdW0sIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2xpZW50Tm90ZXM6IGhhc0NsaWVudE5vdGVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkIGhhc0NsaWVudE5vdGVzIHRvIHRydWUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyB1cGRhdGUgbmVlZGVkIGZvciBoYXNDbGllbnROb3Rlcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0UGFydGlhbEJsb2NrY2hhaW5Ob2RlcyhpZHMsIG5vZGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5cyBhcmUgbm90IG9mIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgICBpZiAoaWRzLmxlbmd0aCAhPT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZHMgYW5kIG5vZGVzIGFycmF5cyBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhcnJheSBvZiBvYmplY3RzIHdpdGggaWQgYW5kIG5vZGVcbiAgICAgICAgY29uc3QgZGF0YSA9IG5vZGVzLm1hcCgobm9kZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICBpZDogaWRzW2luZGV4XSxcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVXNlIGJ1bGtQdXQgdG8gYWRkL292ZXJ3cml0ZSB0aGUgZW50cmllc1xuICAgICAgICBhd2FpdCBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzLmJ1bGtQdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGluc2VydCBwYXJ0aWFsIGJsb2NrY2hhaW4gbm9kZXNcIik7XG4gICAgfVxufVxuLy8gR0VUIEZVTkNUSU9OU1xuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvY2tIZWFkZXJzKGJsb2NrTnVtYmVycykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBibG9ja0hlYWRlcnMuYnVsa0dldChibG9ja051bWJlcnMpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQocmVzdWx0LmhlYWRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbEJsb2NrY2hhaW5QZWFrc0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChyZXN1bHQucGFydGlhbEJsb2NrY2hhaW5QZWFrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW06IHJlc3VsdC5ibG9ja051bSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBoZWFkZXJCYXNlNjQsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxCbG9ja2NoYWluUGVha3M6IHBhcnRpYWxCbG9ja2NoYWluUGVha3NCYXNlNjQsXG4gICAgICAgICAgICAgICAgICAgIGhhc0NsaWVudE5vdGVzOiByZXN1bHQuaGFzQ2xpZW50Tm90ZXMgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZFJlc3VsdHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBibG9jayBoZWFkZXJzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFRyYWNrZWRCbG9ja0hlYWRlcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHJvb3RcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYmxvY2tIZWFkZXJzXG4gICAgICAgICAgICAud2hlcmUoXCJoYXNDbGllbnROb3Rlc1wiKVxuICAgICAgICAgICAgLmVxdWFscyhcInRydWVcIilcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIC8vIFByb2Nlc3MgYWxsIHJlY29yZHMgd2l0aCBhc3luYyBvcGVyYXRpb25zXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFJlY29yZHMgPSBhd2FpdCBQcm9taXNlLmFsbChhbGxNYXRjaGluZ1JlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChyZWNvcmQuaGVhZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxCbG9ja2NoYWluUGVha3NCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQocmVjb3JkLnBhcnRpYWxCbG9ja2NoYWluUGVha3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBibG9ja051bTogcmVjb3JkLmJsb2NrTnVtLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogaGVhZGVyQmFzZTY0LFxuICAgICAgICAgICAgICAgIHBhcnRpYWxCbG9ja2NoYWluUGVha3M6IHBhcnRpYWxCbG9ja2NoYWluUGVha3NCYXNlNjQsXG4gICAgICAgICAgICAgICAgaGFzQ2xpZW50Tm90ZXM6IHJlY29yZC5oYXNDbGllbnROb3RlcyA9PT0gXCJ0cnVlXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRSZWNvcmRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgdHJhY2tlZCBibG9jayBoZWFkZXJzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFBhcnRpYWxCbG9ja2NoYWluUGVha3NCeUJsb2NrTnVtKGJsb2NrTnVtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2tIZWFkZXIgPSBhd2FpdCBibG9ja0hlYWRlcnMuZ2V0KGJsb2NrTnVtKTtcbiAgICAgICAgaWYgKGJsb2NrSGVhZGVyID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwZWFrczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KGJsb2NrSGVhZGVyLnBhcnRpYWxCbG9ja2NoYWluUGVha3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGVha3M6IHBhcnRpYWxCbG9ja2NoYWluUGVha3NCYXNlNjQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBwYXJ0aWFsIGJsb2NrY2hhaW4gcGVha3NcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlc0FsbCgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzQWxsID0gYXdhaXQgcGFydGlhbEJsb2NrY2hhaW5Ob2Rlcy50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzQWxsO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgcGFydGlhbCBibG9ja2NoYWluIG5vZGVzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFBhcnRpYWxCbG9ja2NoYWluTm9kZXMoaWRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHBhcnRpYWxCbG9ja2NoYWluTm9kZXMuYnVsa0dldChpZHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IHBhcnRpYWwgYmxvY2tjaGFpbiBub2Rlc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBwcnVuZUlycmVsZXZhbnRCbG9ja3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3luY0hlaWdodCA9IGF3YWl0IHN0YXRlU3luYy5nZXQoMSk7XG4gICAgICAgIGlmIChzeW5jSGVpZ2h0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTeW5jSGVpZ2h0IGlzIHVuZGVmaW5lZCAtLSBpcyB0aGUgc3RhdGUgc3luYyB0YWJsZSBlbXB0eT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYmxvY2tIZWFkZXJzXG4gICAgICAgICAgICAud2hlcmUoXCJoYXNDbGllbnROb3Rlc1wiKVxuICAgICAgICAgICAgLmVxdWFscyhcImZhbHNlXCIpXG4gICAgICAgICAgICAuYW5kKChyZWNvcmQpID0+IHJlY29yZC5ibG9ja051bSAhPT0gXCIwXCIgJiYgcmVjb3JkLmJsb2NrTnVtICE9PSBzeW5jSGVpZ2h0LmJsb2NrTnVtKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgYXdhaXQgYmxvY2tIZWFkZXJzLmJ1bGtEZWxldGUoYWxsTWF0Y2hpbmdSZWNvcmRzLm1hcCgocikgPT4gci5ibG9ja051bSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBwcnVuZSBpcnJlbGV2YW50IGJsb2Nrc1wiKTtcbiAgICB9XG59XG5cbi8vIERpc2FibGluZyBgYW55YCBjaGVja3Mgc2luY2UgdGhpcyBmaWxlIG1vc3RseSBkZWFscyB3aXRoIGV4cG9ydGluZyBEQiB0eXBlcy5cbi8qIGVzbGludC1kaXNhYmxlICBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cbi8qIGVzbGludC1kaXNhYmxlICBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgKi9cbmFzeW5jIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9yRXhwb3J0KG9iaikge1xuICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKG9iai52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJCbG9iXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9fdHlwZTogXCJCbG9iXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogdWludDhBcnJheVRvQmFzZTY0KG5ldyBVaW50OEFycmF5KGF3YWl0IG9iai52YWx1ZS5hcnJheUJ1ZmZlcigpKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChvYmoudmFsdWUubWFwKCh2KSA9PiByZWN1cnNpdmVseVRyYW5zZm9ybUZvckV4cG9ydCh7IHR5cGU6IGdldElucHV0VHlwZSh2KSwgdmFsdWU6IHYgfSkpKTtcbiAgICAgICAgY2FzZSBcIlJlY29yZFwiOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhvYmoudmFsdWUpLm1hcChhc3luYyAoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGF3YWl0IHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9yRXhwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0SW5wdXRUeXBlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKSkpO1xuICAgICAgICBjYXNlIFwiUHJpbWl0aXZlXCI6XG4gICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldElucHV0VHlwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBcIlVpbnQ4QXJyYXlcIjtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKVxuICAgICAgICByZXR1cm4gXCJCbG9iXCI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gXCJBcnJheVwiO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBcIlJlY29yZFwiO1xuICAgIHJldHVybiBcIlByaW1pdGl2ZVwiO1xufVxuYXN5bmMgZnVuY3Rpb24gdHJhbnNmb3JtRm9yRXhwb3J0KG9iaikge1xuICAgIHJldHVybiByZWN1cnNpdmVseVRyYW5zZm9ybUZvckV4cG9ydCh7IHR5cGU6IGdldElucHV0VHlwZShvYmopLCB2YWx1ZTogb2JqIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhwb3J0U3RvcmUoKSB7XG4gICAgY29uc3QgZGJKc29uID0ge307XG4gICAgZm9yIChjb25zdCB0YWJsZSBvZiBkYi50YWJsZXMpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IGF3YWl0IHRhYmxlLnRvQXJyYXkoKTtcbiAgICAgICAgZGJKc29uW3RhYmxlLm5hbWVdID0gYXdhaXQgUHJvbWlzZS5hbGwocmVjb3Jkcy5tYXAodHJhbnNmb3JtRm9yRXhwb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYkpzb24pO1xufVxuXG4vLyBEaXNhYmxpbmcgYGFueWAgY2hlY2tzIHNpbmNlIHRoaXMgZmlsZSBtb3N0bHkgZGVhbHNcbi8vIHdpdGggaW1wb3J0aW5nIERCIHR5cGVzIGFuZCB3ZSdyZSB0ZXN0aW5nIHRoaXMgd2hpY2hcbi8vIHNob3VsZCBiZSBlbm91Z2ggKyB0aGUgVFMgY29tcGlsZXIuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuYXN5bmMgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JJbXBvcnQob2JqKSB7XG4gICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICBjYXNlIFwiQmxvYlwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtiYXNlNjRUb1VpbnQ4QXJyYXkob2JqLnZhbHVlLmRhdGEpXSk7XG4gICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKG9iai52YWx1ZS5tYXAoKHYpID0+IHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9ySW1wb3J0KHsgdHlwZTogZ2V0SW1wb3J0VHlwZSh2KSwgdmFsdWU6IHYgfSkpKTtcbiAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhvYmoudmFsdWUpLm1hcChhc3luYyAoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGF3YWl0IHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9ySW1wb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0SW1wb3J0VHlwZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkpKTtcbiAgICAgICAgY2FzZSBcIlByaW1pdGl2ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG9iai52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbXBvcnRUeXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS5fX3R5cGUgPT09IFwiQmxvYlwiKSB7XG4gICAgICAgIHJldHVybiBcIkJsb2JcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gXCJBcnJheVwiO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBcIk9iamVjdFwiO1xuICAgIHJldHVybiBcIlByaW1pdGl2ZVwiO1xufVxuYXN5bmMgZnVuY3Rpb24gdHJhbnNmb3JtRm9ySW1wb3J0KG9iaikge1xuICAgIHJldHVybiByZWN1cnNpdmVseVRyYW5zZm9ybUZvckltcG9ydCh7XG4gICAgICAgIHR5cGU6IGdldEltcG9ydFR5cGUob2JqKSxcbiAgICAgICAgdmFsdWU6IG9iaixcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZvcmNlSW1wb3J0U3RvcmUoanNvblN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZGIuaXNPcGVuKSB7XG4gICAgICAgICAgICBhd2FpdCBvcGVuRGF0YWJhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGJKc29uID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYkpzb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRiSnNvbiA9IEpTT04ucGFyc2UoZGJKc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uVGFibGVOYW1lcyA9IE9iamVjdC5rZXlzKGRiSnNvbik7XG4gICAgICAgIGNvbnN0IGRiVGFibGVOYW1lcyA9IGRiLnRhYmxlcy5tYXAoKHQpID0+IHQubmFtZSk7XG4gICAgICAgIGlmIChqc29uVGFibGVOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRhYmxlcyBmb3VuZCBpbiB0aGUgcHJvdmlkZWQgSlNPTi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZGIudHJhbnNhY3Rpb24oXCJyd1wiLCBkYlRhYmxlTmFtZXMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRiLnRhYmxlcy5tYXAoKHQpID0+IHQuY2xlYXIoKSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YganNvblRhYmxlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGRiLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYlRhYmxlTmFtZXMuaW5jbHVkZXModGFibGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRhYmxlIFwiJHt0YWJsZU5hbWV9XCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGRhdGFiYXNlIHNjaGVtYS4gU2tpcHBpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRzID0gZGJKc29uW3RhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRSZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVjb3Jkcy5tYXAodHJhbnNmb3JtRm9ySW1wb3J0KSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGFibGUuYnVsa1B1dCh0cmFuc2Zvcm1lZFJlY29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdG9yZSBpbXBvcnRlZCBzdWNjZXNzZnVsbHkuXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0KSB7XG4gICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeVN0cmluZy5sZW5ndGg7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRPdXRwdXROb3RlcyhzdGF0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgbm90ZXMgPSBzdGF0ZXMubGVuZ3RoID09IDBcbiAgICAgICAgICAgID8gYXdhaXQgb3V0cHV0Tm90ZXMudG9BcnJheSgpXG4gICAgICAgICAgICA6IGF3YWl0IG91dHB1dE5vdGVzLndoZXJlKFwic3RhdGVEaXNjcmltaW5hbnRcIikuYW55T2Yoc3RhdGVzKS50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzT3V0cHV0Tm90ZXMobm90ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgb3V0cHV0IG5vdGVzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldElucHV0Tm90ZXMoc3RhdGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG5vdGVzO1xuICAgICAgICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbm90ZXMgPSBhd2FpdCBpbnB1dE5vdGVzLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vdGVzID0gYXdhaXQgaW5wdXROb3Rlc1xuICAgICAgICAgICAgICAgIC53aGVyZShcInN0YXRlRGlzY3JpbWluYW50XCIpXG4gICAgICAgICAgICAgICAgLmFueU9mKHN0YXRlcylcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzSW5wdXROb3Rlcyhub3Rlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBpbnB1dCBub3Rlc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJbnB1dE5vdGVzRnJvbUlkcyhub3RlSWRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG5vdGVzID0gYXdhaXQgaW5wdXROb3Rlcy53aGVyZShcIm5vdGVJZFwiKS5hbnlPZihub3RlSWRzKS50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzSW5wdXROb3Rlcyhub3Rlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBpbnB1dCBub3RlcyBmcm9tIElEc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJbnB1dE5vdGVzRnJvbU51bGxpZmllcnMobnVsbGlmaWVycykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3RlcyA9IGF3YWl0IGlucHV0Tm90ZXMud2hlcmUoXCJudWxsaWZpZXJcIikuYW55T2YobnVsbGlmaWVycykudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc0lucHV0Tm90ZXMobm90ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgaW5wdXQgbm90ZXMgZnJvbSBudWxsaWZpZXJzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE91dHB1dE5vdGVzRnJvbU51bGxpZmllcnMobnVsbGlmaWVycykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3RlcyA9IGF3YWl0IG91dHB1dE5vdGVzXG4gICAgICAgICAgICAud2hlcmUoXCJudWxsaWZpZXJcIilcbiAgICAgICAgICAgIC5hbnlPZihudWxsaWZpZXJzKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NPdXRwdXROb3Rlcyhub3Rlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBvdXRwdXQgbm90ZXMgZnJvbSBudWxsaWZpZXJzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE91dHB1dE5vdGVzRnJvbUlkcyhub3RlSWRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG5vdGVzID0gYXdhaXQgb3V0cHV0Tm90ZXMud2hlcmUoXCJub3RlSWRcIikuYW55T2Yobm90ZUlkcykudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc091dHB1dE5vdGVzKG5vdGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IG91dHB1dCBub3RlcyBmcm9tIElEc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRVbnNwZW50SW5wdXROb3RlTnVsbGlmaWVycygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBub3RlcyA9IGF3YWl0IGlucHV0Tm90ZXNcbiAgICAgICAgICAgIC53aGVyZShcInN0YXRlRGlzY3JpbWluYW50XCIpXG4gICAgICAgICAgICAuYW55T2YoWzIsIDQsIDVdKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG5vdGVzLm1hcCgobm90ZSkgPT4gbm90ZS5udWxsaWZpZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgdW5zcGVudCBpbnB1dCBub3RlIG51bGxpZmllcnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Tm90ZVNjcmlwdChzY3JpcHRSb290KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgbm90ZVNjcmlwdCA9IGF3YWl0IG5vdGVzU2NyaXB0c1xuICAgICAgICAgICAgLndoZXJlKFwic2NyaXB0Um9vdFwiKVxuICAgICAgICAgICAgLmVxdWFscyhzY3JpcHRSb290KVxuICAgICAgICAgICAgLmZpcnN0KCk7XG4gICAgICAgIHJldHVybiBub3RlU2NyaXB0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgbm90ZSBzY3JpcHQgZnJvbSByb290XCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydElucHV0Tm90ZShub3RlSWQsIGFzc2V0cywgc2VyaWFsTnVtYmVyLCBpbnB1dHMsIHNjcmlwdFJvb3QsIHNlcmlhbGl6ZWROb3RlU2NyaXB0LCBudWxsaWZpZXIsIHNlcmlhbGl6ZWRDcmVhdGVkQXQsIHN0YXRlRGlzY3JpbWluYW50LCBzdGF0ZSkge1xuICAgIHJldHVybiBkYi50cmFuc2FjdGlvbihcInJ3XCIsIGlucHV0Tm90ZXMsIG5vdGVzU2NyaXB0cywgYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIG5vdGVJZCxcbiAgICAgICAgICAgICAgICBhc3NldHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsTnVtYmVyLFxuICAgICAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgICAgICBzY3JpcHRSb290LFxuICAgICAgICAgICAgICAgIG51bGxpZmllcixcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICBzdGF0ZURpc2NyaW1pbmFudCxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkQ3JlYXRlZEF0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IHR4LmlucHV0Tm90ZXMucHV0KGRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgbm90ZVNjcmlwdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Um9vdCxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm90ZVNjcmlwdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0eC5ub3Rlc1NjcmlwdHMucHV0KG5vdGVTY3JpcHREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgbm90ZTogJHtub3RlSWR9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydE91dHB1dE5vdGUobm90ZUlkLCBhc3NldHMsIHJlY2lwaWVudERpZ2VzdCwgbWV0YWRhdGEsIG51bGxpZmllciwgZXhwZWN0ZWRIZWlnaHQsIHN0YXRlRGlzY3JpbWluYW50LCBzdGF0ZSkge1xuICAgIHJldHVybiBkYi50cmFuc2FjdGlvbihcInJ3XCIsIG91dHB1dE5vdGVzLCBub3Rlc1NjcmlwdHMsIGFzeW5jICh0eCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBub3RlSWQsXG4gICAgICAgICAgICAgICAgYXNzZXRzLFxuICAgICAgICAgICAgICAgIHJlY2lwaWVudERpZ2VzdCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBudWxsaWZpZXI6IG51bGxpZmllciA/IG51bGxpZmllciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZEhlaWdodCxcbiAgICAgICAgICAgICAgICBzdGF0ZURpc2NyaW1pbmFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0eC5vdXRwdXROb3Rlcy5wdXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIG5vdGU6ICR7bm90ZUlkfWApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzSW5wdXROb3Rlcyhub3Rlcykge1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChub3Rlcy5tYXAoYXN5bmMgKG5vdGUpID0+IHtcbiAgICAgICAgY29uc3QgYXNzZXRzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUuYXNzZXRzKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsTnVtYmVyQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUuc2VyaWFsTnVtYmVyKTtcbiAgICAgICAgY29uc3QgaW5wdXRzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUuaW5wdXRzKTtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWROb3RlU2NyaXB0QmFzZTY0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobm90ZS5zY3JpcHRSb290KSB7XG4gICAgICAgICAgICBsZXQgcmVjb3JkID0gYXdhaXQgbm90ZXNTY3JpcHRzLmdldChub3RlLnNjcmlwdFJvb3QpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb3RlU2NyaXB0QmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHJlY29yZC5zZXJpYWxpemVkTm90ZVNjcmlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGVCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3NldHM6IGFzc2V0c0Jhc2U2NCxcbiAgICAgICAgICAgIHNlcmlhbE51bWJlcjogc2VyaWFsTnVtYmVyQmFzZTY0LFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNCYXNlNjQsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5vdGUuc2VyaWFsaXplZENyZWF0ZWRBdCxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWROb3RlU2NyaXB0OiBzZXJpYWxpemVkTm90ZVNjcmlwdEJhc2U2NCxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUJhc2U2NCxcbiAgICAgICAgfTtcbiAgICB9KSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzT3V0cHV0Tm90ZXMobm90ZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwobm90ZXMubWFwKChub3RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2V0c0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLmFzc2V0cyk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUubWV0YWRhdGEpO1xuICAgICAgICBjb25zdCBzdGF0ZUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzc2V0czogYXNzZXRzQmFzZTY0LFxuICAgICAgICAgICAgcmVjaXBpZW50RGlnZXN0OiBub3RlLnJlY2lwaWVudERpZ2VzdCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YUJhc2U2NCxcbiAgICAgICAgICAgIGV4cGVjdGVkSGVpZ2h0OiBub3RlLmV4cGVjdGVkSGVpZ2h0LFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlQmFzZTY0LFxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydE5vdGVTY3JpcHQoc2NyaXB0Um9vdCwgc2VyaWFsaXplZE5vdGVTY3JpcHQpIHtcbiAgICByZXR1cm4gZGIudHJhbnNhY3Rpb24oXCJyd1wiLCBvdXRwdXROb3Rlcywgbm90ZXNTY3JpcHRzLCBhc3luYyAodHgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVTY3JpcHREYXRhID0ge1xuICAgICAgICAgICAgICAgIHNjcmlwdFJvb3QsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vdGVTY3JpcHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXdhaXQgdHgubm90ZXNTY3JpcHRzLnB1dChub3RlU2NyaXB0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIG5vdGUgc2NyaXB0OiAke3NjcmlwdFJvb3R9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2V0dGluZyhrZXkpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4ga2V5XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IHNldHRpbmdzXG4gICAgICAgICAgICAud2hlcmUoXCJrZXlcIilcbiAgICAgICAgICAgIC5lcXVhbHMoa2V5KVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKGFsbE1hdGNoaW5nUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2V0dGluZyByZWNvcmQgZm91bmQgZm9yIGdpdmVuIGtleS5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgb25seSBvbmUgbWF0Y2hcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdSZWNvcmQgPSBhbGxNYXRjaGluZ1JlY29yZHNbMF07XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHNldHRpbmcgdmFsdWUgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IHZhbHVlQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG1hdGNoaW5nUmVjb3JkLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogbWF0Y2hpbmdSZWNvcmQua2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlQmFzZTY0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIHdoaWxlIGZldGNoaW5nIHNldHRpbmcga2V5OiAke2tleX1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbnNlcnRTZXR0aW5nKGtleSwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHNldHRpbmdzLnB1dChzZXR0aW5nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgc2V0dGluZyB3aXRoIGtleTogJHtrZXl9IGFuZCB2YWx1ZShiYXNlNjQpOiAke3VpbnQ4QXJyYXlUb0Jhc2U2NCh2YWx1ZSl9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlU2V0dGluZyhrZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBzZXR0aW5ncy53aGVyZShcImtleVwiKS5lcXVhbHMoa2V5KS5kZWxldGUoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBkZWxldGluZyBzZXR0aW5nIHdpdGgga2V5OiAke2tleX1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBsaXN0U2V0dGluZ0tleXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IHNldHRpbmdzXG4gICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICAgICAudGhlbigoc2V0dGluZ3MpID0+IHNldHRpbmdzLm1hcCgoc2V0dGluZykgPT4gc2V0dGluZy5rZXkpKTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgbGlzdGluZyBzZXR0aW5nIGtleXNgKTtcbiAgICB9XG59XG5cbmNvbnN0IElEU19GSUxURVJfUFJFRklYID0gXCJJZHM6XCI7XG5jb25zdCBFWFBJUkVEX0JFRk9SRV9GSUxURVJfUFJFRklYID0gXCJFeHBpcmVkUGVuZGluZzpcIjtcbmNvbnN0IFNUQVRVU19DT01NSVRURURfVkFSSUFOVCA9IDE7XG5jb25zdCBTVEFUVVNfRElTQ0FSREVEX1ZBUklBTlQgPSAyO1xuYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zKGZpbHRlcikge1xuICAgIGxldCB0cmFuc2FjdGlvblJlY29yZHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoZmlsdGVyID09PSBcIlVuY29tbWl0dGVkXCIpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uUmVjb3JkcyA9IGF3YWl0IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC5zdGF0dXNWYXJpYW50ICE9PSBTVEFUVVNfQ09NTUlUVEVEX1ZBUklBTlQpXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXIuc3RhcnRzV2l0aChJRFNfRklMVEVSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkc1N0cmluZyA9IGZpbHRlci5zdWJzdHJpbmcoSURTX0ZJTFRFUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IGlkc1N0cmluZy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblJlY29yZHMgPSBhd2FpdCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKFwiaWRcIilcbiAgICAgICAgICAgICAgICAgICAgLmFueU9mKGlkcylcbiAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uUmVjb3JkcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlci5zdGFydHNXaXRoKEVYUElSRURfQkVGT1JFX0ZJTFRFUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bVN0cmluZyA9IGZpbHRlci5zdWJzdHJpbmcoRVhQSVJFRF9CRUZPUkVfRklMVEVSX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW0gPSBwYXJzZUludChibG9ja051bVN0cmluZyk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblJlY29yZHMgPSBhd2FpdCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguYmxvY2tOdW0gPCBibG9ja051bSAmJlxuICAgICAgICAgICAgICAgIHR4LnN0YXR1c1ZhcmlhbnQgIT09IFNUQVRVU19DT01NSVRURURfVkFSSUFOVCAmJlxuICAgICAgICAgICAgICAgIHR4LnN0YXR1c1ZhcmlhbnQgIT09IFNUQVRVU19ESVNDQVJERURfVkFSSUFOVClcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25SZWNvcmRzID0gYXdhaXQgdHJhbnNhY3Rpb25zLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb25SZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcmlwdFJvb3RzID0gdHJhbnNhY3Rpb25SZWNvcmRzXG4gICAgICAgICAgICAubWFwKCh0cmFuc2FjdGlvblJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3Q7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChzY3JpcHRSb290KSA9PiBzY3JpcHRSb290ICE9IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHNjcmlwdHMgPSBhd2FpdCB0cmFuc2FjdGlvblNjcmlwdHNcbiAgICAgICAgICAgIC53aGVyZShcInNjcmlwdFJvb3RcIilcbiAgICAgICAgICAgIC5hbnlPZihzY3JpcHRSb290cylcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBzY3JpcHRSb290IHRvIHNjcmlwdCBmb3IgcXVpY2sgbG9va3VwXG4gICAgICAgIGNvbnN0IHNjcmlwdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JpcHQudHhTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRNYXAuc2V0KHNjcmlwdC5zY3JpcHRSb290LCBzY3JpcHQudHhTY3JpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVHJhbnNhY3Rpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25SZWNvcmRzLm1hcCgodHJhbnNhY3Rpb25SZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eFNjcmlwdEJhc2U2NCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhTY3JpcHQgPSBzY3JpcHRNYXAuZ2V0KHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3QpO1xuICAgICAgICAgICAgICAgIGlmICh0eFNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICB0eFNjcmlwdEJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NCh0eFNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0YWlsc0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NCh0cmFuc2FjdGlvblJlY29yZC5kZXRhaWxzKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NCh0cmFuc2FjdGlvblJlY29yZC5zdGF0dXMpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogdHJhbnNhY3Rpb25SZWNvcmQuaWQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlsc0Jhc2U2NCxcbiAgICAgICAgICAgICAgICBzY3JpcHRSb290OiB0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290LFxuICAgICAgICAgICAgICAgIHR4U2NyaXB0OiB0eFNjcmlwdEJhc2U2NCxcbiAgICAgICAgICAgICAgICBibG9ja051bTogdHJhbnNhY3Rpb25SZWNvcmQuYmxvY2tOdW0udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNWYXJpYW50OiB0cmFuc2FjdGlvblJlY29yZC5zdGF0dXNWYXJpYW50LFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzQmFzZTY0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRUcmFuc2FjdGlvbnM7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0VHJhbnNhY3Rpb25TY3JpcHQoc2NyaXB0Um9vdCwgdHhTY3JpcHQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzY3JpcHRSb290QXJyYXkgPSBuZXcgVWludDhBcnJheShzY3JpcHRSb290KTtcbiAgICAgICAgY29uc3Qgc2NyaXB0Um9vdEJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChzY3JpcHRSb290QXJyYXkpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc2NyaXB0Um9vdDogc2NyaXB0Um9vdEJhc2U2NCxcbiAgICAgICAgICAgIHR4U2NyaXB0OiBtYXBPcHRpb24odHhTY3JpcHQsICh0eFNjcmlwdCkgPT4gbmV3IFVpbnQ4QXJyYXkodHhTY3JpcHQpKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb25TY3JpcHRzLnB1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIGluc2VydCB0cmFuc2FjdGlvbiBzY3JpcHRcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0VHJhbnNhY3Rpb25SZWNvcmQodHJhbnNhY3Rpb25JZCwgZGV0YWlscywgYmxvY2tOdW0sIHN0YXR1c1ZhcmlhbnQsIHN0YXR1cywgc2NyaXB0Um9vdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBpZDogdHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgICBzY3JpcHRSb290OiBtYXBPcHRpb24oc2NyaXB0Um9vdCwgKHJvb3QpID0+IHVpbnQ4QXJyYXlUb0Jhc2U2NChyb290KSksXG4gICAgICAgICAgICBibG9ja051bTogcGFyc2VJbnQoYmxvY2tOdW0sIDEwKSxcbiAgICAgICAgICAgIHN0YXR1c1ZhcmlhbnQsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRyYW5zYWN0aW9ucy5wdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGluc2VydCBwcm92ZW4gdHJhbnNhY3Rpb24gZGF0YVwiKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE5vdGVUYWdzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gYXdhaXQgdGFncy50b0FycmF5KCk7XG4gICAgICAgIGxldCBwcm9jZXNzZWRSZWNvcmRzID0gcmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmVjb3JkLnNvdXJjZU5vdGVJZCA9XG4gICAgICAgICAgICAgICAgcmVjb3JkLnNvdXJjZU5vdGVJZCA9PSBcIlwiID8gdW5kZWZpbmVkIDogcmVjb3JkLnNvdXJjZU5vdGVJZDtcbiAgICAgICAgICAgIHJlY29yZC5zb3VyY2VBY2NvdW50SWQgPVxuICAgICAgICAgICAgICAgIHJlY29yZC5zb3VyY2VBY2NvdW50SWQgPT0gXCJcIiA/IHVuZGVmaW5lZCA6IHJlY29yZC5zb3VyY2VBY2NvdW50SWQ7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZFJlY29yZHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkVycm9yIGZldGNoIHRhZyByZWNvcmRcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3luY0hlaWdodCgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSBhd2FpdCBzdGF0ZVN5bmMuZ2V0KDEpOyAvLyBTaW5jZSBpZCBpcyB0aGUgcHJpbWFyeSBrZXkgYW5kIGFsd2F5cyAxXG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtOiByZWNvcmQuYmxvY2tOdW0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJFcnJvciBmZXRjaGluZyBzeW5jIGhlaWdodFwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGROb3RlVGFnKHRhZywgc291cmNlTm90ZUlkLCBzb3VyY2VBY2NvdW50SWQpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdGFnQXJyYXkgPSBuZXcgVWludDhBcnJheSh0YWcpO1xuICAgICAgICBsZXQgdGFnQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHRhZ0FycmF5KTtcbiAgICAgICAgYXdhaXQgdGFncy5hZGQoe1xuICAgICAgICAgICAgdGFnOiB0YWdCYXNlNjQsXG4gICAgICAgICAgICBzb3VyY2VOb3RlSWQ6IHNvdXJjZU5vdGVJZCA/IHNvdXJjZU5vdGVJZCA6IFwiXCIsXG4gICAgICAgICAgICBzb3VyY2VBY2NvdW50SWQ6IHNvdXJjZUFjY291bnRJZCA/IHNvdXJjZUFjY291bnRJZCA6IFwiXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gYWRkIG5vdGUgdGFnXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZU5vdGVUYWcodGFnLCBzb3VyY2VOb3RlSWQsIHNvdXJjZUFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB0YWdBcnJheSA9IG5ldyBVaW50OEFycmF5KHRhZyk7XG4gICAgICAgIGxldCB0YWdCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQodGFnQXJyYXkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGFnc1xuICAgICAgICAgICAgLndoZXJlKHtcbiAgICAgICAgICAgIHRhZzogdGFnQmFzZTY0LFxuICAgICAgICAgICAgc291cmNlTm90ZUlkOiBzb3VyY2VOb3RlSWQgPyBzb3VyY2VOb3RlSWQgOiBcIlwiLFxuICAgICAgICAgICAgc291cmNlQWNjb3VudElkOiBzb3VyY2VBY2NvdW50SWQgPyBzb3VyY2VBY2NvdW50SWQgOiBcIlwiLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmRlbGV0ZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gcmVtb3ZlIG5vdGUgdGFnXCIpO1xuICAgIH1cbn1cbi8qXG4gKiBUYWtlcyBhIGBKc1N0YXRlU3luY1VwZGF0ZWAgb2JqZWN0IGFuZCB3cml0ZXMgdGhlIHN0YXRlIHVwZGF0ZSBpbnRvIHRoZSBzdG9yZS5cbiAqIEBwYXJhbSB7SnNTdGF0ZVN5bmNVcGRhdGV9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5U3RhdGVTeW5jKHN0YXRlVXBkYXRlKSB7XG4gICAgY29uc3QgeyBibG9ja051bSwgLy8gVGFyZ2V0IGJsb2NrIG51bWJlciBmb3IgdGhpcyBzeW5jXG4gICAgZmxhdHRlbmVkTmV3QmxvY2tIZWFkZXJzLCAvLyBTZXJpYWxpemVkIGJsb2NrIGhlYWRlcnMgdG8gYmUgcmVjb25zdHJ1Y3RlZFxuICAgIGZsYXR0ZW5lZFBhcnRpYWxCbG9ja0NoYWluUGVha3MsIC8vIFNlcmlhbGl6ZWQgYmxvY2tjaGFpbiBwZWFrcyBmb3IgdmVyaWZpY2F0aW9uXG4gICAgbmV3QmxvY2tOdW1zLCAvLyBCbG9jayBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gbmV3IGhlYWRlcnNcbiAgICBibG9ja0hhc1JlbGV2YW50Tm90ZXMsIC8vIEZsYWdzIGluZGljYXRpbmcgd2hpY2ggYmxvY2tzIGhhdmUgcmVsZXZhbnQgbm90ZXNcbiAgICBzZXJpYWxpemVkTm9kZUlkcywgLy8gSURzIGZvciBuZXcgYXV0aGVudGljYXRpb24gbm9kZXNcbiAgICBzZXJpYWxpemVkTm9kZXMsIC8vIEF1dGhlbnRpY2F0aW9uIG5vZGUgZGF0YSBmb3IgbWVya2xlIHByb29mc1xuICAgIGNvbW1pdHRlZE5vdGVJZHMsIC8vIE5vdGUgdGFncyB0byBiZSBjbGVhbmVkIHVwL3JlbW92ZWRcbiAgICBzZXJpYWxpemVkSW5wdXROb3RlcywgLy8gSW5wdXQgbm90ZXMgY29uc3VtZWQgaW4gdHJhbnNhY3Rpb25zXG4gICAgc2VyaWFsaXplZE91dHB1dE5vdGVzLCAvLyBPdXRwdXQgbm90ZXMgY3JlYXRlZCBpbiB0cmFuc2FjdGlvbnNcbiAgICBhY2NvdW50VXBkYXRlcywgLy8gQWNjb3VudCBzdGF0ZSBjaGFuZ2VzXG4gICAgdHJhbnNhY3Rpb25VcGRhdGVzLCAvLyBUcmFuc2FjdGlvbiByZWNvcmRzIGFuZCBzY3JpcHRzXG4gICAgIH0gPSBzdGF0ZVVwZGF0ZTtcbiAgICAvLyBCbG9jayBoZWFkZXJzIGFuZCBCbG9ja2NoYWluIHBlYWtzIGFyZSBmbGF0dGVuZWQgYmVmb3JlIGNhbGxpbmdcbiAgICAvLyB0aGlzIGZ1bmN0aW9uLCBoZXJlIHdlIHJlYnVpbGQgdGhlbS5cbiAgICBjb25zdCBuZXdCbG9ja0hlYWRlcnMgPSByZWNvbnN0cnVjdEZsYXR0ZW5lZFZlYyhmbGF0dGVuZWROZXdCbG9ja0hlYWRlcnMpO1xuICAgIGNvbnN0IHBhcnRpYWxCbG9ja2NoYWluUGVha3MgPSByZWNvbnN0cnVjdEZsYXR0ZW5lZFZlYyhmbGF0dGVuZWRQYXJ0aWFsQmxvY2tDaGFpblBlYWtzKTtcbiAgICAvLyBDcmVhdGUgcHJvbWlzZXMgdG8gaW5zZXJ0IGVhY2ggaW5wdXQgbm90ZS4gRWFjaCBub3RlIHdpbGwgaGF2ZSBpdHMgb3duIHRyYW5zYWN0aW9uLFxuICAgIC8vIGFuZCB0aGVyZWZvcmUsIG5lc3RlZCBpbnNpZGUgdGhlIGZpbmFsIHRyYW5zYWN0aW9uIGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxuICAgIGxldCBpbnB1dE5vdGVzV3JpdGVPcCA9IFByb21pc2UuYWxsKHNlcmlhbGl6ZWRJbnB1dE5vdGVzLm1hcCgobm90ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXBzZXJ0SW5wdXROb3RlKG5vdGUubm90ZUlkLCBub3RlLm5vdGVBc3NldHMsIG5vdGUuc2VyaWFsTnVtYmVyLCBub3RlLmlucHV0cywgbm90ZS5ub3RlU2NyaXB0Um9vdCwgbm90ZS5ub3RlU2NyaXB0LCBub3RlLm51bGxpZmllciwgbm90ZS5jcmVhdGVkQXQsIG5vdGUuc3RhdGVEaXNjcmltaW5hbnQsIG5vdGUuc3RhdGUpO1xuICAgIH0pKTtcbiAgICAvLyBTZWUgY29tbWVudCBhYm92ZSwgdGhlIHNhbWUgdGhpbmcgYXBwbGllcyBoZXJlLCBidXQgZm9yIE91dHB1dCBOb3Rlcy5cbiAgICBsZXQgb3V0cHV0Tm90ZXNXcml0ZU9wID0gUHJvbWlzZS5hbGwoc2VyaWFsaXplZE91dHB1dE5vdGVzLm1hcCgobm90ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXBzZXJ0T3V0cHV0Tm90ZShub3RlLm5vdGVJZCwgbm90ZS5ub3RlQXNzZXRzLCBub3RlLnJlY2lwaWVudERpZ2VzdCwgbm90ZS5tZXRhZGF0YSwgbm90ZS5udWxsaWZpZXIsIG5vdGUuZXhwZWN0ZWRIZWlnaHQsIG5vdGUuc3RhdGVEaXNjcmltaW5hbnQsIG5vdGUuc3RhdGUpO1xuICAgIH0pKTtcbiAgICAvLyBQcm9taXNlcyB0byBpbnNlcnQgZWFjaCB0cmFuc2FjdGlvbiB1cGRhdGUuXG4gICAgbGV0IHRyYW5zYWN0aW9uV3JpdGVPcCA9IFByb21pc2UuYWxsKHRyYW5zYWN0aW9uVXBkYXRlcy5tYXAoKHRyYW5zYWN0aW9uUmVjb3JkKSA9PiB7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgIHVwc2VydFRyYW5zYWN0aW9uUmVjb3JkKHRyYW5zYWN0aW9uUmVjb3JkLmlkLCB0cmFuc2FjdGlvblJlY29yZC5kZXRhaWxzLCB0cmFuc2FjdGlvblJlY29yZC5ibG9ja051bSwgdHJhbnNhY3Rpb25SZWNvcmQuc3RhdHVzVmFyaWFudCwgdHJhbnNhY3Rpb25SZWNvcmQuc3RhdHVzLCB0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290KSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3QgJiYgdHJhbnNhY3Rpb25SZWNvcmQudHhTY3JpcHQpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5zZXJ0VHJhbnNhY3Rpb25TY3JpcHQodHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdCwgdHJhbnNhY3Rpb25SZWNvcmQudHhTY3JpcHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pKTtcbiAgICAvLyBQcm9taXNlcyB0byBpbnNlcnQgZWFjaCBhY2NvdW50IHVwZGF0ZS5cbiAgICBsZXQgYWNjb3VudFVwZGF0ZXNXcml0ZU9wID0gUHJvbWlzZS5hbGwoYWNjb3VudFVwZGF0ZXMuZmxhdE1hcCgoYWNjb3VudFVwZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdXBzZXJ0QWNjb3VudFN0b3JhZ2UoYWNjb3VudFVwZGF0ZS5zdG9yYWdlU2xvdHMpLFxuICAgICAgICAgICAgdXBzZXJ0U3RvcmFnZU1hcEVudHJpZXMoYWNjb3VudFVwZGF0ZS5zdG9yYWdlTWFwRW50cmllcyksXG4gICAgICAgICAgICB1cHNlcnRWYXVsdEFzc2V0cyhhY2NvdW50VXBkYXRlLmFzc2V0cyksXG4gICAgICAgICAgICB1cHNlcnRBY2NvdW50UmVjb3JkKGFjY291bnRVcGRhdGUuYWNjb3VudElkLCBhY2NvdW50VXBkYXRlLmNvZGVSb290LCBhY2NvdW50VXBkYXRlLnN0b3JhZ2VSb290LCBhY2NvdW50VXBkYXRlLmFzc2V0VmF1bHRSb290LCBhY2NvdW50VXBkYXRlLm5vbmNlLCBhY2NvdW50VXBkYXRlLmNvbW1pdHRlZCwgYWNjb3VudFVwZGF0ZS5hY2NvdW50Q29tbWl0bWVudCwgYWNjb3VudFVwZGF0ZS5hY2NvdW50U2VlZCksXG4gICAgICAgIF07XG4gICAgfSkpO1xuICAgIGNvbnN0IHRhYmxlc1RvQWNjZXNzID0gW1xuICAgICAgICBzdGF0ZVN5bmMsXG4gICAgICAgIGlucHV0Tm90ZXMsXG4gICAgICAgIG91dHB1dE5vdGVzLFxuICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgIGJsb2NrSGVhZGVycyxcbiAgICAgICAgcGFydGlhbEJsb2NrY2hhaW5Ob2RlcyxcbiAgICAgICAgdGFncyxcbiAgICBdO1xuICAgIC8vIFdyaXRlIGV2ZXJ5dGhpbmcgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBhdG9taWNhbGx5IGRvIHRoZSBvcGVyYXRpb25zXG4gICAgLy8gYmVsb3csIHNpbmNlIGV2ZXJ5IG9wZXJhdGlvbiBoZXJlIChvciBhdCBsZWFzdCwgbW9zdCBvZiB0aGVtKSwgaXMgZG9uZSBpbiBhIG5lc3RlZCB0cmFuc2FjdGlvbi5cbiAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGlzLCBjaGVjazogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9EZXhpZS9EZXhpZS50cmFuc2FjdGlvbigpXG4gICAgcmV0dXJuIGF3YWl0IGRiLnRyYW5zYWN0aW9uKFwicndcIiwgdGFibGVzVG9BY2Nlc3MsIGFzeW5jICh0eCkgPT4ge1xuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIHVuZGVyIGEgc2luZ2xlIHByb21pc2Ugc2luY2Ugb3RoZXJ3aXNlIHRoZSB0eCBleHBpcmVzLlxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBpbnB1dE5vdGVzV3JpdGVPcCxcbiAgICAgICAgICAgIG91dHB1dE5vdGVzV3JpdGVPcCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uV3JpdGVPcCxcbiAgICAgICAgICAgIGFjY291bnRVcGRhdGVzV3JpdGVPcCxcbiAgICAgICAgICAgIHVwZGF0ZVN5bmNIZWlnaHQodHgsIGJsb2NrTnVtKSxcbiAgICAgICAgICAgIHVwZGF0ZVBhcnRpYWxCbG9ja2NoYWluTm9kZXModHgsIHNlcmlhbGl6ZWROb2RlSWRzLCBzZXJpYWxpemVkTm9kZXMpLFxuICAgICAgICAgICAgdXBkYXRlQ29tbWl0dGVkTm90ZVRhZ3ModHgsIGNvbW1pdHRlZE5vdGVJZHMpLFxuICAgICAgICAgICAgUHJvbWlzZS5hbGwobmV3QmxvY2tIZWFkZXJzLm1hcCgobmV3QmxvY2tIZWFkZXIsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlQmxvY2tIZWFkZXIodHgsIG5ld0Jsb2NrTnVtc1tpXSwgbmV3QmxvY2tIZWFkZXIsIHBhcnRpYWxCbG9ja2NoYWluUGVha3NbaV0sIGJsb2NrSGFzUmVsZXZhbnROb3Rlc1tpXSA9PSAxKTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVTeW5jSGVpZ2h0KHR4LCBibG9ja051bSkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHR4LnN0YXRlU3luYy51cGRhdGUoMSwgeyBibG9ja051bTogYmxvY2tOdW0gfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkZhaWxlZCB0byB1cGRhdGUgc3luYyBoZWlnaHRcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQmxvY2tIZWFkZXIodHgsIGJsb2NrTnVtLCBibG9ja0hlYWRlciwgcGFydGlhbEJsb2NrY2hhaW5QZWFrcywgaGFzQ2xpZW50Tm90ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYmxvY2tOdW06IGJsb2NrTnVtLFxuICAgICAgICAgICAgaGVhZGVyOiBibG9ja0hlYWRlcixcbiAgICAgICAgICAgIHBhcnRpYWxCbG9ja2NoYWluUGVha3MsXG4gICAgICAgICAgICBoYXNDbGllbnROb3RlczogaGFzQ2xpZW50Tm90ZXMudG9TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdCbG9ja0hlYWRlciA9IGF3YWl0IHR4LmJsb2NrSGVhZGVycy5nZXQoYmxvY2tOdW0pO1xuICAgICAgICBpZiAoIWV4aXN0aW5nQmxvY2tIZWFkZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHR4LmJsb2NrSGVhZGVycy5hZGQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gaW5zZXJ0IGJsb2NrIGhlYWRlclwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKHR4LCBub2RlSW5kZXhlcywgbm9kZXMpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJyYXlzIGFyZSBub3Qgb2YgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgIGlmIChub2RlSW5kZXhlcy5sZW5ndGggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZUluZGV4ZXMgYW5kIG5vZGVzIGFycmF5cyBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZUluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGFycmF5IG9mIG9iamVjdHMgd2l0aCBpZCBhbmQgbm9kZVxuICAgICAgICBjb25zdCBkYXRhID0gbm9kZXMubWFwKChub2RlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIGlkOiBub2RlSW5kZXhlc1tpbmRleF0sXG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFVzZSBidWxrUHV0IHRvIGFkZC9vdmVyd3JpdGUgdGhlIGVudHJpZXNcbiAgICAgICAgYXdhaXQgdHgucGFydGlhbEJsb2NrY2hhaW5Ob2Rlcy5idWxrUHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byB1cGRhdGUgcGFydGlhbCBibG9ja2NoYWluIG5vZGVzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUNvbW1pdHRlZE5vdGVUYWdzKHR4LCBpbnB1dE5vdGVJZHMpIHtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Tm90ZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm90ZUlkID0gaW5wdXROb3RlSWRzW2ldO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG5vdGUgdGFnc1xuICAgICAgICAgICAgYXdhaXQgdHgudGFncy53aGVyZShcInNvdXJjZV9ub3RlX2lkXCIpLmVxdWFscyhub3RlSWQpLmRlbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBwdWRhdGUgY29tbWl0dGVkIG5vdGUgdGFnc1wiKTtcbiAgICB9XG59XG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcmVjb25zdHJ1Y3QgYXJyYXlzIGZyb20gZmxhdHRlbmVkIGRhdGFcbmZ1bmN0aW9uIHJlY29uc3RydWN0RmxhdHRlbmVkVmVjKGZsYXR0ZW5lZFZlYykge1xuICAgIGNvbnN0IGRhdGEgPSBmbGF0dGVuZWRWZWMuZGF0YSgpO1xuICAgIGNvbnN0IGxlbmd0aHMgPSBmbGF0dGVuZWRWZWMubGVuZ3RocygpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGVuZ3Rocy5mb3JFYWNoKChsZW5ndGgpID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGF0YS5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpKTtcbiAgICAgICAgaW5kZXggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmxldCB3YXNtO1xuXG5sZXQgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OEFycmF5TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkVWludDhBcnJheU1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OEFycmF5TWVtb3J5MDtcbn1cblxubGV0IGNhY2hlZFRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KTtcblxuY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG5cbmNvbnN0IE1BWF9TQUZBUklfREVDT0RFX0JZVEVTID0gMjE0NjQzNTA3MjtcbmxldCBudW1CeXRlc0RlY29kZWQgPSAwO1xuZnVuY3Rpb24gZGVjb2RlVGV4dChwdHIsIGxlbikge1xuICAgIG51bUJ5dGVzRGVjb2RlZCArPSBsZW47XG4gICAgaWYgKG51bUJ5dGVzRGVjb2RlZCA+PSBNQVhfU0FGQVJJX0RFQ09ERV9CWVRFUykge1xuICAgICAgICBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpO1xuICAgICAgICBudW1CeXRlc0RlY29kZWQgPSBsZW47XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGRlY29kZVRleHQocHRyLCBsZW4pO1xufVxuXG5sZXQgaGVhcCA9IG5ldyBBcnJheSgxMjgpLmZpbGwodW5kZWZpbmVkKTtcblxuaGVhcC5wdXNoKHVuZGVmaW5lZCwgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xuXG5sZXQgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5cbmZ1bmN0aW9uIGFkZEhlYXBPYmplY3Qob2JqKSB7XG4gICAgaWYgKGhlYXBfbmV4dCA9PT0gaGVhcC5sZW5ndGgpIGhlYXAucHVzaChoZWFwLmxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGlkeCA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG5cbiAgICBoZWFwW2lkeF0gPSBvYmo7XG4gICAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmxldCBXQVNNX1ZFQ1RPUl9MRU4gPSAwO1xuXG5jb25zdCBjYWNoZWRUZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG5pZiAoISgnZW5jb2RlSW50bycgaW4gY2FjaGVkVGV4dEVuY29kZXIpKSB7XG4gICAgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgICAgIHZpZXcuc2V0KGJ1Zik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICAgICAgd3JpdHRlbjogYnVmLmxlbmd0aFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhc3NTdHJpbmdUb1dhc20wKGFyZywgbWFsbG9jLCByZWFsbG9jKSB7XG5cbiAgICBpZiAocmVhbGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgICAgICBjb25zdCBwdHIgPSBtYWxsb2MoYnVmLmxlbmd0aCwgMSkgPj4+IDA7XG4gICAgICAgIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBidWYubGVuZ3RoKS5zZXQoYnVmKTtcbiAgICAgICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBsZXQgcHRyID0gbWFsbG9jKGxlbiwgMSkgPj4+IDA7XG5cbiAgICBjb25zdCBtZW0gPSBnZXRVaW50OEFycmF5TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMywgMSkgPj4+IDA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciArIG9mZnNldCwgcHRyICsgbGVuKTtcbiAgICAgICAgY29uc3QgcmV0ID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgb2Zmc2V0LCAxKSA+Pj4gMDtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldERhdGFWaWV3TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkRGF0YVZpZXdNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZERhdGFWaWV3TWVtb3J5MC5idWZmZXIuZGV0YWNoZWQgPT09IHRydWUgfHwgKGNhY2hlZERhdGFWaWV3TWVtb3J5MC5idWZmZXIuZGV0YWNoZWQgPT09IHVuZGVmaW5lZCAmJiBjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyICE9PSB3YXNtLm1lbW9yeS5idWZmZXIpKSB7XG4gICAgICAgIGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9IG5ldyBEYXRhVmlldyh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkRGF0YVZpZXdNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlYnVnU3RyaW5nKHZhbCkge1xuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAgYCR7dmFsfWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbH1cImA7XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdzeW1ib2wnKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdTeW1ib2wnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWwubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmIG5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGBGdW5jdGlvbigke25hbWV9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvYmplY3RzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWwubGVuZ3RoO1xuICAgICAgICBsZXQgZGVidWcgPSAnWyc7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSBkZWJ1Z1N0cmluZyh2YWxbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVidWcgKz0gJywgJyArIGRlYnVnU3RyaW5nKHZhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcgKz0gJ10nO1xuICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIGJ1aWx0LWluXG4gICAgY29uc3QgYnVpbHRJbk1hdGNoZXMgPSAvXFxbb2JqZWN0IChbXlxcXV0rKVxcXS8uZXhlYyh0b1N0cmluZy5jYWxsKHZhbCkpO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKGJ1aWx0SW5NYXRjaGVzICYmIGJ1aWx0SW5NYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gYnVpbHRJbk1hdGNoZXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFpbGVkIHRvIG1hdGNoIHRoZSBzdGFuZGFyZCAnW29iamVjdCBDbGFzc05hbWVdJ1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lID09ICdPYmplY3QnKSB7XG4gICAgICAgIC8vIHdlJ3JlIGEgdXNlciBkZWZpbmVkIGNsYXNzIG9yIE9iamVjdFxuICAgICAgICAvLyBKU09OLnN0cmluZ2lmeSBhdm9pZHMgcHJvYmxlbXMgd2l0aCBjeWNsZXMsIGFuZCBpcyBnZW5lcmFsbHkgbXVjaFxuICAgICAgICAvLyBlYXNpZXIgdGhhbiBsb29waW5nIHRocm91Z2ggb3duUHJvcGVydGllcyBvZiBgdmFsYC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0KCcgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgJyknO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXJyb3JzXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWwubmFtZX06ICR7dmFsLm1lc3NhZ2V9XFxuJHt2YWwuc3RhY2t9YDtcbiAgICB9XG4gICAgLy8gVE9ETyB3ZSBjb3VsZCB0ZXN0IGZvciBtb3JlIHRoaW5ncyBoZXJlLCBsaWtlIGBTZXRgcyBhbmQgYE1hcGBzLlxuICAgIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmZ1bmN0aW9uIGRyb3BPYmplY3QoaWR4KSB7XG4gICAgaWYgKGlkeCA8IDEzMikgcmV0dXJuO1xuICAgIGhlYXBbaWR4XSA9IGhlYXBfbmV4dDtcbiAgICBoZWFwX25leHQgPSBpZHg7XG59XG5cbmZ1bmN0aW9uIHRha2VPYmplY3QoaWR4KSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGlkeCk7XG4gICAgZHJvcE9iamVjdChpZHgpO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VThGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gMSwgcHRyIC8gMSArIGxlbik7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGYsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQ0KGFkZEhlYXBPYmplY3QoZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIGNvbnN0IG1lbSA9IGdldERhdGFWaWV3TWVtb3J5MCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBwdHI7IGkgPCBwdHIgKyA0ICogbGVuOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGFrZU9iamVjdChtZW0uZ2V0VWludDMyKGksIHRydWUpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IENMT1NVUkVfRFRPUlMgPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoc3RhdGUgPT4gc3RhdGUuZHRvcihzdGF0ZS5hLCBzdGF0ZS5iKSk7XG5cbmZ1bmN0aW9uIG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIGR0b3IsIGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgYTogYXJnMCwgYjogYXJnMSwgY250OiAxLCBkdG9yIH07XG4gICAgY29uc3QgcmVhbCA9ICguLi5hcmdzKSA9PiB7XG5cbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICBjb25zdCBhID0gc3RhdGUuYTtcbiAgICAgICAgc3RhdGUuYSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZihhLCBzdGF0ZS5iLCAuLi5hcmdzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN0YXRlLmEgPSBhO1xuICAgICAgICAgICAgcmVhbC5fd2JnX2NiX3VucmVmKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwuX3diZ19jYl91bnJlZiA9ICgpID0+IHtcbiAgICAgICAgaWYgKC0tc3RhdGUuY250ID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5kdG9yKHN0YXRlLmEsIHN0YXRlLmIpO1xuICAgICAgICAgICAgc3RhdGUuYSA9IDA7XG4gICAgICAgICAgICBDTE9TVVJFX0RUT1JTLnVucmVnaXN0ZXIoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDTE9TVVJFX0RUT1JTLnJlZ2lzdGVyKHJlYWwsIHN0YXRlLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHJlYWw7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzcyhpbnN0YW5jZSwga2xhc3MpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGluc3RhbmNlIG9mICR7a2xhc3MubmFtZX1gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhc3NBcnJheThUb1dhc20wKGFyZywgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFyZy5sZW5ndGggKiAxLCAxKSA+Pj4gMDtcbiAgICBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDEpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IHN0YWNrX3BvaW50ZXIgPSAxMjg7XG5cbmZ1bmN0aW9uIGFkZEJvcnJvd2VkT2JqZWN0KG9iaikge1xuICAgIGlmIChzdGFja19wb2ludGVyID09IDEpIHRocm93IG5ldyBFcnJvcignb3V0IG9mIGpzIHN0YWNrJyk7XG4gICAgaGVhcFstLXN0YWNrX3BvaW50ZXJdID0gb2JqO1xuICAgIHJldHVybiBzdGFja19wb2ludGVyO1xufVxuXG5mdW5jdGlvbiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcnJheSwgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFycmF5Lmxlbmd0aCAqIDQsIDQpID4+PiAwO1xuICAgIGNvbnN0IG1lbSA9IGdldERhdGFWaWV3TWVtb3J5MCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVtLnNldFVpbnQzMihwdHIgKyA0ICogaSwgYWRkSGVhcE9iamVjdChhcnJheVtpXSksIHRydWUpO1xuICAgIH1cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IGNhY2hlZEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkQmlnVWludDY0QXJyYXlNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZEJpZ1VpbnQ2NEFycmF5TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCA9IG5ldyBCaWdVaW50NjRBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkQmlnVWludDY0QXJyYXlNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBwYXNzQXJyYXk2NFRvV2FzbTAoYXJnLCBtYWxsb2MpIHtcbiAgICBjb25zdCBwdHIgPSBtYWxsb2MoYXJnLmxlbmd0aCAqIDgsIDgpID4+PiAwO1xuICAgIGdldEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDgpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVNjRGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGdldEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDgsIHB0ciAvIDggKyBsZW4pO1xufVxuXG5sZXQgY2FjaGVkVWludDMyQXJyYXlNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0VWludDMyQXJyYXlNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50MzJBcnJheU1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkVWludDMyQXJyYXlNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkVWludDMyQXJyYXlNZW1vcnkwID0gbmV3IFVpbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50MzJBcnJheU1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VTMyRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBnZXRVaW50MzJBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyA0LCBwdHIgLyA0ICsgbGVuKTtcbn1cbmZ1bmN0aW9uIF9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85Mzc1KGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85Mzc1KGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMikpO1xufVxuXG5mdW5jdGlvbiBfX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTMwOShhcmcwLCBhcmcxKSB7XG4gICAgd2FzbS5fX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTMwOShhcmcwLCBhcmcxKTtcbn1cblxuZnVuY3Rpb24gX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzM2NzcoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHdhc20uX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzM2NzcoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSwgYWRkSGVhcE9iamVjdChhcmczKSk7XG59XG5cbi8qKlxuICogQGVudW0gezB9XG4gKi9cbmNvbnN0IEFjY291bnRJbnRlcmZhY2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICBCYXNpY1dhbGxldDogMCwgXCIwXCI6IFwiQmFzaWNXYWxsZXRcIixcbn0pO1xuLyoqXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgM31cbiAqL1xuY29uc3QgQWNjb3VudFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBGdW5naWJsZUZhdWNldDogMCwgXCIwXCI6IFwiRnVuZ2libGVGYXVjZXRcIixcbiAgICBOb25GdW5naWJsZUZhdWNldDogMSwgXCIxXCI6IFwiTm9uRnVuZ2libGVGYXVjZXRcIixcbiAgICBSZWd1bGFyQWNjb3VudEltbXV0YWJsZUNvZGU6IDIsIFwiMlwiOiBcIlJlZ3VsYXJBY2NvdW50SW1tdXRhYmxlQ29kZVwiLFxuICAgIFJlZ3VsYXJBY2NvdW50VXBkYXRhYmxlQ29kZTogMywgXCIzXCI6IFwiUmVndWxhckFjY291bnRVcGRhdGFibGVDb2RlXCIsXG59KTtcbi8qKlxuICogQGVudW0gezAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOH1cbiAqL1xuY29uc3QgSW5wdXROb3RlU3RhdGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBFeHBlY3RlZDogMCwgXCIwXCI6IFwiRXhwZWN0ZWRcIixcbiAgICBVbnZlcmlmaWVkOiAxLCBcIjFcIjogXCJVbnZlcmlmaWVkXCIsXG4gICAgQ29tbWl0dGVkOiAyLCBcIjJcIjogXCJDb21taXR0ZWRcIixcbiAgICBJbnZhbGlkOiAzLCBcIjNcIjogXCJJbnZhbGlkXCIsXG4gICAgUHJvY2Vzc2luZ0F1dGhlbnRpY2F0ZWQ6IDQsIFwiNFwiOiBcIlByb2Nlc3NpbmdBdXRoZW50aWNhdGVkXCIsXG4gICAgUHJvY2Vzc2luZ1VuYXV0aGVudGljYXRlZDogNSwgXCI1XCI6IFwiUHJvY2Vzc2luZ1VuYXV0aGVudGljYXRlZFwiLFxuICAgIENvbnN1bWVkQXV0aGVudGljYXRlZExvY2FsOiA2LCBcIjZcIjogXCJDb25zdW1lZEF1dGhlbnRpY2F0ZWRMb2NhbFwiLFxuICAgIENvbnN1bWVkVW5hdXRoZW50aWNhdGVkTG9jYWw6IDcsIFwiN1wiOiBcIkNvbnN1bWVkVW5hdXRoZW50aWNhdGVkTG9jYWxcIixcbiAgICBDb25zdW1lZEV4dGVybmFsOiA4LCBcIjhcIjogXCJDb25zdW1lZEV4dGVybmFsXCIsXG59KTtcbi8qKlxuICogQGVudW0gezAgfCAxIHwgMn1cbiAqL1xuY29uc3QgTmV0d29ya0lkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgTWFpbm5ldDogMCwgXCIwXCI6IFwiTWFpbm5ldFwiLFxuICAgIFRlc3RuZXQ6IDEsIFwiMVwiOiBcIlRlc3RuZXRcIixcbiAgICBEZXZuZXQ6IDIsIFwiMlwiOiBcIkRldm5ldFwiLFxufSk7XG4vKipcbiAqIEBlbnVtIHswIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDh9XG4gKi9cbmNvbnN0IE5vdGVGaWx0ZXJUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIEFsbDogMCwgXCIwXCI6IFwiQWxsXCIsXG4gICAgQ29uc3VtZWQ6IDEsIFwiMVwiOiBcIkNvbnN1bWVkXCIsXG4gICAgQ29tbWl0dGVkOiAyLCBcIjJcIjogXCJDb21taXR0ZWRcIixcbiAgICBFeHBlY3RlZDogMywgXCIzXCI6IFwiRXhwZWN0ZWRcIixcbiAgICBQcm9jZXNzaW5nOiA0LCBcIjRcIjogXCJQcm9jZXNzaW5nXCIsXG4gICAgTGlzdDogNSwgXCI1XCI6IFwiTGlzdFwiLFxuICAgIFVuaXF1ZTogNiwgXCI2XCI6IFwiVW5pcXVlXCIsXG4gICAgTnVsbGlmaWVyczogNywgXCI3XCI6IFwiTnVsbGlmaWVyc1wiLFxuICAgIFVudmVyaWZpZWQ6IDgsIFwiOFwiOiBcIlVudmVyaWZpZWRcIixcbn0pO1xuLyoqXG4gKiBAZW51bSB7MiB8IDMgfCAxfVxuICovXG5jb25zdCBOb3RlVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8qKlxuICAgICAqIE5vdGVzIHdpdGggdGhpcyB0eXBlIGhhdmUgb25seSB0aGVpciBoYXNoIHB1Ymxpc2hlZCB0byB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBQcml2YXRlOiAyLCBcIjJcIjogXCJQcml2YXRlXCIsXG4gICAgLyoqXG4gICAgICogTm90ZXMgd2l0aCB0aGlzIHR5cGUgYXJlIHNoYXJlZCB3aXRoIHRoZSBuZXR3b3JrIGVuY3J5cHRlZC5cbiAgICAgKi9cbiAgICBFbmNyeXB0ZWQ6IDMsIFwiM1wiOiBcIkVuY3J5cHRlZFwiLFxuICAgIC8qKlxuICAgICAqIE5vdGVzIHdpdGggdGhpcyB0eXBlIGFyZSBmdWxseSBzaGFyZWQgd2l0aCB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBQdWJsaWM6IDEsIFwiMVwiOiBcIlB1YmxpY1wiLFxufSk7XG4vKipcbiAqIEBlbnVtIHswIHwgMSB8IDJ9XG4gKi9cbmNvbnN0IFNpZ25pbmdJbnB1dHNUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgVHJhbnNhY3Rpb25TdW1tYXJ5OiAwLCBcIjBcIjogXCJUcmFuc2FjdGlvblN1bW1hcnlcIixcbiAgICBBcmJpdHJhcnk6IDEsIFwiMVwiOiBcIkFyYml0cmFyeVwiLFxuICAgIEJsaW5kOiAyLCBcIjJcIjogXCJCbGluZFwiLFxufSk7XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9BZGRyZXNzSW50ZXJmYWNlID0gW1wiQmFzaWNXYWxsZXRcIl07XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZWFkYWJsZVN0cmVhbVR5cGUgPSBbXCJieXRlc1wiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX1JlZmVycmVyUG9saWN5ID0gW1wiXCIsIFwibm8tcmVmZXJyZXJcIiwgXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiLCBcIm9yaWdpblwiLCBcIm9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLCBcInVuc2FmZS11cmxcIiwgXCJzYW1lLW9yaWdpblwiLCBcInN0cmljdC1vcmlnaW5cIiwgXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdENhY2hlID0gW1wiZGVmYXVsdFwiLCBcIm5vLXN0b3JlXCIsIFwicmVsb2FkXCIsIFwibm8tY2FjaGVcIiwgXCJmb3JjZS1jYWNoZVwiLCBcIm9ubHktaWYtY2FjaGVkXCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdENyZWRlbnRpYWxzID0gW1wib21pdFwiLCBcInNhbWUtb3JpZ2luXCIsIFwiaW5jbHVkZVwiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX1JlcXVlc3RNb2RlID0gW1wic2FtZS1vcmlnaW5cIiwgXCJuby1jb3JzXCIsIFwiY29yc1wiLCBcIm5hdmlnYXRlXCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdFJlZGlyZWN0ID0gW1wiZm9sbG93XCIsIFwiZXJyb3JcIiwgXCJtYW51YWxcIl07XG5cbmNvbnN0IEFjY291bnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBBY2NvdW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgbm9uY2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9ub25jZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXNzZXRWYXVsdH1cbiAgICAgKi9cbiAgICB2YXVsdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X3ZhdWx0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFzc2V0VmF1bHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZX1cbiAgICAgKi9cbiAgICBzdG9yYWdlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfc3RvcmFnZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRDb2RlfVxuICAgICAqL1xuICAgIGNvZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9jb2RlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRDb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZhdWNldCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzRmF1Y2V0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWd1bGFyQWNjb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzUmVndWxhckFjY291bnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1VwZGF0YWJsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzVXBkYXRhYmxlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQdWJsaWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc1B1YmxpYyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUHJpdmF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzUHJpdmF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzTmV0d29yayh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTmV3KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNOZXcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0FjY291bnR9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudF9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkW119XG4gICAgICovXG4gICAgZ2V0UHVibGljS2V5cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50X2dldFB1YmxpY0tleXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50QXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50W10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBBY2NvdW50QXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudH1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50YXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtBY2NvdW50fSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBBY2NvdW50KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50fSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBBY2NvdW50KTtcbiAgICAgICAgd2FzbS5hY2NvdW50YXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudEFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50QnVpbGRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50YnVpbGRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50QnVpbGRlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudEJ1aWxkZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudEJ1aWxkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudEJ1aWxkZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRidWlsZGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbml0X3NlZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0X3NlZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGluaXRfc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50YnVpbGRlcl9uZXcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByMCA+Pj4gMDtcbiAgICAgICAgICAgIEFjY291bnRCdWlsZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRUeXBlfSBhY2NvdW50X3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEJ1aWxkZXJ9XG4gICAgICovXG4gICAgYWNjb3VudFR5cGUoYWNjb3VudF90eXBlKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJfYWNjb3VudFR5cGUocHRyLCBhY2NvdW50X3R5cGUpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudFN0b3JhZ2VNb2RlfSBzdG9yYWdlX21vZGVcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEJ1aWxkZXJ9XG4gICAgICovXG4gICAgc3RvcmFnZU1vZGUoc3RvcmFnZV9tb2RlKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yYWdlX21vZGUsIEFjY291bnRTdG9yYWdlTW9kZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJfc3RvcmFnZU1vZGUocHRyLCBzdG9yYWdlX21vZGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRDb21wb25lbnR9IGFjY291bnRfY29tcG9uZW50XG4gICAgICogQHJldHVybnMge0FjY291bnRCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhDb21wb25lbnQoYWNjb3VudF9jb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfY29tcG9uZW50LCBBY2NvdW50Q29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcl93aXRoQ29tcG9uZW50KHB0ciwgYWNjb3VudF9jb21wb25lbnQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRDb21wb25lbnR9IGFjY291bnRfY29tcG9uZW50XG4gICAgICogQHJldHVybnMge0FjY291bnRCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhBdXRoQ29tcG9uZW50KGFjY291bnRfY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2NvbXBvbmVudCwgQWNjb3VudENvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJfd2l0aEF1dGhDb21wb25lbnQocHRyLCBhY2NvdW50X2NvbXBvbmVudC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoTm9BdXRoQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVyX3dpdGhOb0F1dGhDb21wb25lbnQocHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEJ1aWxkZXJSZXN1bHR9XG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRidWlsZGVyX2J1aWxkKHJldHB0ciwgcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRCdWlsZGVyUmVzdWx0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50QnVpbGRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudEJ1aWxkZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRCdWlsZGVyUmVzdWx0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRidWlsZGVycmVzdWx0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRCdWlsZGVyUmVzdWx0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50QnVpbGRlclJlc3VsdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50QnVpbGRlclJlc3VsdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50QnVpbGRlclJlc3VsdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGJ1aWxkZXJyZXN1bHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudH1cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcnJlc3VsdF9hY2NvdW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGdldCBzZWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVycmVzdWx0X3NlZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRCdWlsZGVyUmVzdWx0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50QnVpbGRlclJlc3VsdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudENvZGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGNvZGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudENvZGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRDb2RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRDb2RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRDb2RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50Y29kZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG1hc3Rfcm9vdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1Byb2NlZHVyZShtYXN0X3Jvb3QpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG1hc3Rfcm9vdCwgV29yZCk7XG4gICAgICAgIHZhciBwdHIwID0gbWFzdF9yb290Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2hhc1Byb2NlZHVyZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50Q29kZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudENvZGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRDb21wb25lbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGNvbXBvbmVudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50Q29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50Q29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRDb21wb25lbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudENvbXBvbmVudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGNvbXBvbmVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50X2NvZGVcbiAgICAgKiBAcGFyYW0ge1NjcmlwdEJ1aWxkZXJ9IGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VTbG90W119IHN0b3JhZ2Vfc2xvdHNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudENvbXBvbmVudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShhY2NvdW50X2NvZGUsIGJ1aWxkZXIsIHN0b3JhZ2Vfc2xvdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFjY291bnRfY29kZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhidWlsZGVyLCBTY3JpcHRCdWlsZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChzdG9yYWdlX3Nsb3RzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFjY291bnRjb21wb25lbnRfY29tcGlsZShyZXRwdHIsIHB0cjAsIGxlbjAsIGJ1aWxkZXIuX193YmdfcHRyLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRDb21wb25lbnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRDb21wb25lbnR9XG4gICAgICovXG4gICAgd2l0aFN1cHBvcnRzQWxsVHlwZXMoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvbXBvbmVudF93aXRoU3VwcG9ydHNBbGxUeXBlcyhwdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudENvbXBvbmVudC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2NlZHVyZV9uYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRQcm9jZWR1cmVIYXNoKHByb2NlZHVyZV9uYW1lKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvY2VkdXJlX25hbWUsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFjY291bnRjb21wb25lbnRfZ2V0UHJvY2VkdXJlSGFzaChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwdHIyID0gcjA7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHIxO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQzXzAgPSBwdHIyO1xuICAgICAgICAgICAgZGVmZXJyZWQzXzEgPSBsZW4yO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDNfMCwgZGVmZXJyZWQzXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbVtdfVxuICAgICAqL1xuICAgIGdldFByb2NlZHVyZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGNvbXBvbmVudF9nZXRQcm9jZWR1cmVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NlY3JldEtleX0gc2VjcmV0X2tleVxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50Q29tcG9uZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBdXRoQ29tcG9uZW50KHNlY3JldF9rZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNlY3JldF9rZXksIFNlY3JldEtleSk7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRjb21wb25lbnRfY3JlYXRlQXV0aENvbXBvbmVudChyZXRwdHIsIHNlY3JldF9rZXkuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRDb21wb25lbnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQYWNrYWdlfSBfcGFja2FnZVxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVNsb3RBcnJheX0gc3RvcmFnZV9zbG90c1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50Q29tcG9uZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGFja2FnZShfcGFja2FnZSwgc3RvcmFnZV9zbG90cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoX3BhY2thZ2UsIFBhY2thZ2UpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JhZ2Vfc2xvdHMsIFN0b3JhZ2VTbG90QXJyYXkpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50Y29tcG9uZW50X2Zyb21QYWNrYWdlKHJldHB0ciwgX3BhY2thZ2UuX193YmdfcHRyLCBzdG9yYWdlX3Nsb3RzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50Q29tcG9uZW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50Q29tcG9uZW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50Q29tcG9uZW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50RGVsdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGRlbHRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnREZWx0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudERlbHRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnREZWx0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50RGVsdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRkZWx0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50RGVsdGF9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGRlbHRhX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnREZWx0YS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX2lzRW1wdHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VEZWx0YX1cbiAgICAgKi9cbiAgICBzdG9yYWdlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9zdG9yYWdlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlRGVsdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50VmF1bHREZWx0YX1cbiAgICAgKi9cbiAgICB2YXVsdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfdmF1bHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFZhdWx0RGVsdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIG5vbmNlRGVsdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX25vbmNlRGVsdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnREZWx0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudERlbHRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50RmlsZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50ZmlsZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50RmlsZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudEZpbGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudEZpbGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudEZpbGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRmaWxlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgYEFjY291bnRGaWxlYCBpbnRvIGEgYnl0ZSBhcnJheVxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZmlsZV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZXMgYSBieXRlIGFycmF5IGludG8gYW4gYEFjY291bnRGaWxlYFxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEZpbGV9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGZpbGVfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudEZpbGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRGaWxlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50RmlsZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudEhlYWRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50aGVhZGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRIZWFkZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRIZWFkZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudEhlYWRlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50SGVhZGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50aGVhZGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgbm9uY2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9ub25jZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICB2YXVsdENvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdG9yYWdlQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX3N0b3JhZ2VDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvZGVDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfY29kZUNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRIZWFkZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRIZWFkZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRJZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50aWRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudElkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50SWQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudElkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgQWNjb3VudElkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50SWRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRpZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaGV4LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX2Zyb21IZXgocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmF1Y2V0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9pc0ZhdWNldCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVndWxhckFjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX2lzUmVndWxhckFjY291bnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1B1YmxpYygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfaXNQdWJsaWModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ByaXZhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX2lzUHJpdmF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfaXNOZXR3b3JrKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGlkX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHR1cm4gdGhlIEFjY291bnQgSUQgaW50byBpdHMgYmVjaDMyIHN0cmluZyByZXByZXNlbnRhdGlvbi4gVG8gYXZvaWQgYSBwb3RlbnRpYWxcbiAgICAgKiB3cm9uZ2Z1bCBlbmNvZGluZywgdGhpcyBmdW5jdGlvbiB3aWxsIGV4cGVjdCBvbmx5IElEcyBmb3IgZWl0aGVyIG1haW5uZXQgKFwibW1cIiksXG4gICAgICogdGVzdG5ldCAoXCJtdHN0XCIpIG9yIGRldm5ldCAoXCJtZGV2XCIpLiBUbyB1c2UgYSBjdXN0b20gYmVjaDMyIHByZWZpeCwgc2VlXG4gICAgICogYFNlbGY6OnRvX2JlY2hfMzJfY3VzdG9tYC5cbiAgICAgKiBAcGFyYW0ge05ldHdvcmtJZH0gbmV0d29ya19pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudEludGVyZmFjZX0gYWNjb3VudF9pbnRlcmZhY2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvQmVjaDMyKG5ldHdvcmtfaWQsIGFjY291bnRfaW50ZXJmYWNlKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRpZF90b0JlY2gzMihyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBuZXR3b3JrX2lkLCBhY2NvdW50X2ludGVyZmFjZSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gcHRyMTtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gbGVuMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUdXJuIHRoaXMgQWNjb3VudCBJRCBpbnRvIGl0cyBiZWNoMzIgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGEgY3VzdG9tXG4gICAgICogbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VzdG9tX25ldHdvcmtfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJbnRlcmZhY2V9IGFjY291bnRfaW50ZXJmYWNlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0JlY2gzMkN1c3RvbShjdXN0b21fbmV0d29ya19pZCwgYWNjb3VudF9pbnRlcmZhY2UpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkM18wO1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjdXN0b21fbmV0d29ya19pZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGlkX3RvQmVjaDMyQ3VzdG9tKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIGFjY291bnRfaW50ZXJmYWNlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwdHIyID0gcjA7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHIxO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgcHRyMiA9IDA7IGxlbjIgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQzXzAgPSBwdHIyO1xuICAgICAgICAgICAgZGVmZXJyZWQzXzEgPSBsZW4yO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIyLCBsZW4yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDNfMCwgZGVmZXJyZWQzXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIHByZWZpeCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfcHJlZml4KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIHN1ZmZpeCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfc3VmZml4KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50SWQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRJZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudElkQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGlkYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudElkQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50SWRBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGlkYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZFtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBBY2NvdW50SWRBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGlkYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGlkYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgQWNjb3VudElkKTtcbiAgICAgICAgd2FzbS5hY2NvdW50aWRhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZGFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50SWRBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudElkQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRTdG9yYWdlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRTdG9yYWdlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50U3RvcmFnZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50U3RvcmFnZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50U3RvcmFnZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2VfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0SXRlbShpbmRleCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlX2dldEl0ZW0odGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7V29yZH0ga2V5XG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0TWFwSXRlbShpbmRleCwga2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhrZXksIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlX2dldE1hcEl0ZW0odGhpcy5fX3diZ19wdHIsIGluZGV4LCBrZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gdGhlIG1hcCBzbG90IGF0IGBpbmRleGAuXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc2xvdCBpc24ndCBhIG1hcCBvciBgaW5kZXhgIGlzIG91dCBvZiBib3VuZHMgKDAtMjU1KS5cbiAgICAgKiBSZXR1cm5zIGBbXWAgaWYgdGhlIG1hcCBleGlzdHMgYnV0IGlzIGVtcHR5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtKc1N0b3JhZ2VNYXBFbnRyeVtdIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldE1hcEVudHJpZXMoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50c3RvcmFnZV9nZXRNYXBFbnRyaWVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRTdG9yYWdlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50U3RvcmFnZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudFN0b3JhZ2VEZWx0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZWRlbHRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRTdG9yYWdlRGVsdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRTdG9yYWdlRGVsdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VEZWx0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50U3RvcmFnZURlbHRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZWRlbHRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlZGVsdGFfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZURlbHRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRzdG9yYWdlZGVsdGFfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VEZWx0YS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlZGVsdGFfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkW119XG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRzdG9yYWdlZGVsdGFfdmFsdWVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudFN0b3JhZ2VEZWx0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudFN0b3JhZ2VEZWx0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudFN0b3JhZ2VNb2RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlbW9kZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50U3RvcmFnZU1vZGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRTdG9yYWdlTW9kZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50U3RvcmFnZU1vZGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VNb2RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZW1vZGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VNb2RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBwcml2YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV9wcml2YXRlKCk7XG4gICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZU1vZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZU1vZGV9XG4gICAgICovXG4gICAgc3RhdGljIHB1YmxpYygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfcHVibGljKCk7XG4gICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZU1vZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZU1vZGV9XG4gICAgICovXG4gICAgc3RhdGljIG5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX25ldHdvcmsoKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlTW9kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VNb2RlfVxuICAgICAqL1xuICAgIHN0YXRpYyB0cnlGcm9tU3RyKHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHMsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV90cnlGcm9tU3RyKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZU1vZGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBhc1N0cigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX2FzU3RyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudFN0b3JhZ2VNb2RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50U3RvcmFnZU1vZGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlcmVxdWlyZW1lbnRzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2VyZXF1aXJlbWVudHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZXJlcXVpcmVtZW50c19uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2xvdEFuZEtleXNbXX0gc2xvdHNfYW5kX2tleXNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHN9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21TbG90QW5kS2V5c0FycmF5KHNsb3RzX2FuZF9rZXlzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChzbG90c19hbmRfa2V5cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50c3RvcmFnZXJlcXVpcmVtZW50c19mcm9tU2xvdEFuZEtleXNBcnJheShyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudFZhdWx0RGVsdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudHZhdWx0ZGVsdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudFZhdWx0RGVsdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRWYXVsdERlbHRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRWYXVsdERlbHRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRWYXVsdERlbHRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50dmF1bHRkZWx0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50dmF1bHRkZWx0YV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0FjY291bnRWYXVsdERlbHRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnR2YXVsdGRlbHRhX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRWYXVsdERlbHRhLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VkZWx0YV9pc0VtcHR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXREZWx0YX1cbiAgICAgKi9cbiAgICBmdW5naWJsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50dmF1bHRkZWx0YV9mdW5naWJsZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGdW5naWJsZUFzc2V0RGVsdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0W119XG4gICAgICovXG4gICAgYWRkZWRGdW5naWJsZUFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50dmF1bHRkZWx0YV9hZGRlZEZ1bmdpYmxlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldFtdfVxuICAgICAqL1xuICAgIHJlbW92ZWRGdW5naWJsZUFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50dmF1bHRkZWx0YV9yZW1vdmVkRnVuZ2libGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50VmF1bHREZWx0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudFZhdWx0RGVsdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFkZHJlc3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWRkcmVzc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBZGRyZXNzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBZGRyZXNzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFkZHJlc3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWRkcmVzc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWRkcmVzc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbX2ludGVyZmFjZV1cbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUFjY291bnRJZChhY2NvdW50X2lkLCBfaW50ZXJmYWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKF9pbnRlcmZhY2UpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKF9pbnRlcmZhY2UsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hZGRyZXNzX2Zyb21BY2NvdW50SWQocmV0cHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiZWNoMzJcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJlY2gzMihiZWNoMzIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGJlY2gzMiwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWRkcmVzc19mcm9tQmVjaDMyKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzSW50ZXJmYWNlfVxuICAgICAqL1xuICAgIGludGVyZmFjZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hZGRyZXNzX2ludGVyZmFjZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fd2JpbmRnZW5fZW51bV9BZGRyZXNzSW50ZXJmYWNlW3IwXTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBhY2NvdW50SWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWRkcmVzc19hY2NvdW50SWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgdG9Ob3RlVGFnKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFkZHJlc3NfdG9Ob3RlVGFnKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmV0d29ya0lkfSBuZXR3b3JrX2lkXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0JlY2gzMihuZXR3b3JrX2lkKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFkZHJlc3NfdG9CZWNoMzIocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgbmV0d29ya19pZCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gcHRyMTtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gbGVuMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWRkcmVzcy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWRkcmVzcy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWR2aWNlSW5wdXRzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FkdmljZWlucHV0c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBZHZpY2VJbnB1dHMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFkdmljZUlucHV0cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBZHZpY2VJbnB1dHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWR2aWNlSW5wdXRzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hZHZpY2VpbnB1dHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIHN0YWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFkdmljZWlucHV0c19zdGFjayhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG1hcHBlZFZhbHVlcyhrZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGtleSwgV29yZCk7XG4gICAgICAgICAgICB3YXNtLmFkdmljZWlucHV0c19tYXBwZWRWYWx1ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwga2V5Ll9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBZHZpY2VJbnB1dHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFkdmljZUlucHV0cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWR2aWNlTWFwRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FkdmljZW1hcF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBZHZpY2VNYXAge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBZHZpY2VNYXBGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FkdmljZW1hcF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlcmVxdWlyZW1lbnRzX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQWR2aWNlTWFwRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0ga2V5XG4gICAgICogQHBhcmFtIHtGZWx0QXJyYXl9IHZhbHVlXG4gICAgICogQHJldHVybnMge0ZlbHRbXSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moa2V5LCBXb3JkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh2YWx1ZSwgRmVsdEFycmF5KTtcbiAgICAgICAgICAgIHdhc20uYWR2aWNlbWFwX2luc2VydChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBrZXkuX193YmdfcHRyLCB2YWx1ZS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWR2aWNlTWFwLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBZHZpY2VNYXAucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFzc2V0VmF1bHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYXNzZXR2YXVsdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBc3NldFZhdWx0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBc3NldFZhdWx0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFzc2V0VmF1bHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQXNzZXRWYXVsdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYXNzZXR2YXVsdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZmF1Y2V0X2lkXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBnZXRCYWxhbmNlKGZhdWNldF9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFzc2V0dmF1bHRfZ2V0QmFsYW5jZSh0aGlzLl9fd2JnX3B0ciwgZmF1Y2V0X2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXRbXX1cbiAgICAgKi9cbiAgICBmdW5naWJsZUFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hc3NldHZhdWx0X2Z1bmdpYmxlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQXNzZXRWYXVsdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQXNzZXRWYXVsdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQXV0aFNlY3JldEtleUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hdXRoc2VjcmV0a2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEF1dGhTZWNyZXRLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEF1dGhTZWNyZXRLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQXV0aFNlY3JldEtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBdXRoU2VjcmV0S2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hdXRoc2VjcmV0a2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgZ2V0UnBvRmFsY29uNTEyUHVibGljS2V5QXNXb3JkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmF1dGhzZWNyZXRrZXlfZ2V0UnBvRmFsY29uNTEyUHVibGljS2V5QXNXb3JkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgZ2V0UnBvRmFsY29uNTEyU2VjcmV0S2V5QXNGZWx0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hdXRoc2VjcmV0a2V5X2dldFJwb0ZhbGNvbjUxMlNlY3JldEtleUFzRmVsdHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGdldEVjZHNhSzI1NktlY2Nha1B1YmxpY0tleUFzV29yZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hdXRoc2VjcmV0a2V5X2dldEVjZHNhSzI1NktlY2Nha1B1YmxpY0tleUFzV29yZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIGdldEVjZHNhSzI1NktlY2Nha1NlY3JldEtleUFzRmVsdHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYXV0aHNlY3JldGtleV9nZXRFY2RzYUsyNTZLZWNjYWtTZWNyZXRLZXlBc0ZlbHRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQXV0aFNlY3JldEtleS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQXV0aFNlY3JldEtleS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19iYXNpY2Z1bmdpYmxlZmF1Y2V0Y29tcG9uZW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19iYXNpY2Z1bmdpYmxlZmF1Y2V0Y29tcG9uZW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50fSBhY2NvdW50XG4gICAgICogQHJldHVybnMge0Jhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21BY2NvdW50KGFjY291bnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnQsIEFjY291bnQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBhY2NvdW50Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5iYXNpY2Z1bmdpYmxlZmF1Y2V0Y29tcG9uZW50X2Zyb21BY2NvdW50KHJldHB0ciwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUb2tlblN5bWJvbH1cbiAgICAgKi9cbiAgICBzeW1ib2woKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX3ByZWZpeCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUb2tlblN5bWJvbC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBkZWNpbWFscygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5iYXNpY2Z1bmdpYmxlZmF1Y2V0Y29tcG9uZW50X2RlY2ltYWxzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgbWF4U3VwcGx5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9zdWZmaXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEJsb2NrSGVhZGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Jsb2NraGVhZGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEJsb2NrSGVhZGVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCbG9ja0hlYWRlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBCbG9ja0hlYWRlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBCbG9ja0hlYWRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmxvY2toZWFkZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfdmVyc2lvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdWJDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX3N1YkNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcHJldkJsb2NrQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmxvY2tOdW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfYmxvY2tOdW0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjaGFpbkNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9zdG9yYWdlQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBhY2NvdW50Um9vdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX2NvZGVDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIG51bGxpZmllclJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfbnVsbGlmaWVyUm9vdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBub3RlUm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl9ub3RlUm9vdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICB0eENvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfdHhDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHR4S2VybmVsQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcnJlc3VsdF9zZWVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHByb29mQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl9wcm9vZkNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICB0aW1lc3RhbXAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfdGltZXN0YW1wKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEJsb2NrSGVhZGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBCbG9ja0hlYWRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQ29uc3VtYWJsZU5vdGVSZWNvcmRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfY29uc3VtYWJsZW5vdGVyZWNvcmRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQ29uc3VtYWJsZU5vdGVSZWNvcmQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKENvbnN1bWFibGVOb3RlUmVjb3JkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIENvbnN1bWFibGVOb3RlUmVjb3JkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIENvbnN1bWFibGVOb3RlUmVjb3JkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19jb25zdW1hYmxlbm90ZXJlY29yZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SW5wdXROb3RlUmVjb3JkfSBpbnB1dF9ub3RlX3JlY29yZFxuICAgICAqIEBwYXJhbSB7Tm90ZUNvbnN1bWFiaWxpdHlbXX0gbm90ZV9jb25zdW1hYmlsaXR5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5wdXRfbm90ZV9yZWNvcmQsIG5vdGVfY29uc3VtYWJpbGl0eSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaW5wdXRfbm90ZV9yZWNvcmQsIElucHV0Tm90ZVJlY29yZCk7XG4gICAgICAgIHZhciBwdHIwID0gaW5wdXRfbm90ZV9yZWNvcmQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChub3RlX2NvbnN1bWFiaWxpdHksIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNvbnN1bWFibGVub3RlcmVjb3JkX25ldyhwdHIwLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIENvbnN1bWFibGVOb3RlUmVjb3JkRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGVSZWNvcmR9XG4gICAgICovXG4gICAgaW5wdXROb3RlUmVjb3JkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNvbnN1bWFibGVub3RlcmVjb3JkX2lucHV0Tm90ZVJlY29yZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBJbnB1dE5vdGVSZWNvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlQ29uc3VtYWJpbGl0eVtdfVxuICAgICAqL1xuICAgIG5vdGVDb25zdW1hYmlsaXR5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmNvbnN1bWFibGVub3RlcmVjb3JkX25vdGVDb25zdW1hYmlsaXR5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQ29uc3VtYWJsZU5vdGVSZWNvcmQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IENvbnN1bWFibGVOb3RlUmVjb3JkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBFbmRwb2ludEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19lbmRwb2ludF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbmV0d29yayBlbmRwb2ludCBmb3IgY29ubmVjdGluZyB0byBNaWRlbiBub2Rlcy5cbiAqXG4gKiBBbiBlbmRwb2ludCBjb25zaXN0cyBvZiBhIHByb3RvY29sIChodHRwL2h0dHBzKSwgaG9zdCwgYW5kIG9wdGlvbmFsIHBvcnQuXG4gKiBQcm92aWRlcyBjb252ZW5pZW50IGNvbnN0cnVjdG9ycyBmb3IgY29tbW9uIG5ldHdvcmsgY29uZmlndXJhdGlvbnMuXG4gKi9cbmNsYXNzIEVuZHBvaW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFbmRwb2ludC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFbmRwb2ludEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBFbmRwb2ludEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZW5kcG9pbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVuZHBvaW50IGZyb20gYSBVUkwgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgc3RyaW5nIChlLmcuLCA8aHR0cHM6Ly9sb2NhbGhvc3Q6NTcyOTE+KVxuICAgICAqIEB0aHJvd3MgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBVUkwgaXMgaW52YWxpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHVybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZW5kcG9pbnRfbmV3KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX193YmdfcHRyID0gcjAgPj4+IDA7XG4gICAgICAgICAgICBFbmRwb2ludEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW5kcG9pbnQgZm9yIHRoZSBNaWRlbiB0ZXN0bmV0LlxuICAgICAqIEByZXR1cm5zIHtFbmRwb2ludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdG5ldCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lbmRwb2ludF90ZXN0bmV0KCk7XG4gICAgICAgIHJldHVybiBFbmRwb2ludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW5kcG9pbnQgZm9yIHRoZSBNaWRlbiBkZXZuZXQuXG4gICAgICogQHJldHVybnMge0VuZHBvaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXZuZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5kcG9pbnRfZGV2bmV0KCk7XG4gICAgICAgIHJldHVybiBFbmRwb2ludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW5kcG9pbnQgZm9yIGEgbG9jYWwgTWlkZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIFVzZXMgPGh0dHA6Ly9sb2NhbGhvc3Q6NTcyOTE+XG4gICAgICogQHJldHVybnMge0VuZHBvaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBsb2NhbGhvc3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5kcG9pbnRfbG9jYWxob3N0KCk7XG4gICAgICAgIHJldHVybiBFbmRwb2ludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvdG9jb2wgb2YgdGhlIGVuZHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5lbmRwb2ludF9wcm90b2NvbChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9zdCBvZiB0aGUgZW5kcG9pbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaG9zdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZW5kcG9pbnRfaG9zdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9ydCBvZiB0aGUgZW5kcG9pbnQuXG4gICAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgcG9ydCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lbmRwb2ludF9wb3J0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMHhGRkZGRkYgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW5kcG9pbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZW5kcG9pbnRfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBFbmRwb2ludC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRW5kcG9pbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEV4ZWN1dGVkVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZXhlY3V0ZWR0cmFuc2FjdGlvbl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBFeGVjdXRlZFRyYW5zYWN0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFeGVjdXRlZFRyYW5zYWN0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEV4ZWN1dGVkVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRXhlY3V0ZWRUcmFuc2FjdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZXhlY3V0ZWR0cmFuc2FjdGlvbl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbklkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25faWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBhY2NvdW50SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9hY2NvdW50SWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEhlYWRlcn1cbiAgICAgKi9cbiAgICBpbml0aWFsQWNjb3VudEhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2luaXRpYWxBY2NvdW50SGVhZGVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRIZWFkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SGVhZGVyfVxuICAgICAqL1xuICAgIGZpbmFsQWNjb3VudEhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2ZpbmFsQWNjb3VudEhlYWRlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SGVhZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3Rlc31cbiAgICAgKi9cbiAgICBpbnB1dE5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25faW5wdXROb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBJbnB1dE5vdGVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZXN9XG4gICAgICovXG4gICAgb3V0cHV0Tm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9vdXRwdXROb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3Rlcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQXJnc31cbiAgICAgKi9cbiAgICB0eEFyZ3MoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl90eEFyZ3ModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25BcmdzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QmxvY2tIZWFkZXJ9XG4gICAgICovXG4gICAgYmxvY2tIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9ibG9ja0hlYWRlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCbG9ja0hlYWRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnREZWx0YX1cbiAgICAgKi9cbiAgICBhY2NvdW50RGVsdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9hY2NvdW50RGVsdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudERlbHRhLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRXhlY3V0ZWRUcmFuc2FjdGlvbi5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRXhlY3V0ZWRUcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRmVsdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mZWx0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZlbHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZlbHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRmVsdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEZlbHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZlbHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ZlbHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZlbHRfbmV3KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEZlbHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBhc0ludCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZWx0X2FzSW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mZWx0X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRmVsdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRmVsdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRmVsdEFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ZlbHRhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGZWx0QXJyYXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZlbHRBcnJheS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGZWx0QXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRmVsdEFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mZWx0YXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZlbHRbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmVsdGFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEZlbHRBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZlbHRhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0ZlbHR9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIEZlbHQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5mZWx0YXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZlbHR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIEZlbHQpO1xuICAgICAgICB3YXNtLmZlbHRhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZlbHRhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRmVsdEFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGZWx0QXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZldGNoZWROb3RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ZldGNoZWRub3RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBub3RlIGZldGNoZWQgZnJvbSBhIE1pZGVuIG5vZGUgdmlhIFJQQy5cbiAqL1xuY2xhc3MgRmV0Y2hlZE5vdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZldGNoZWROb3RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZldGNoZWROb3RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZldGNoZWROb3RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mZXRjaGVkbm90ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5vdGUgd2l0aCBhbiBvcHRpb25hbCBgSW5wdXROb3RlYC5cbiAgICAgKiBAcGFyYW0ge05vdGVJZH0gbm90ZV9pZFxuICAgICAqIEBwYXJhbSB7Tm90ZU1ldGFkYXRhfSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7SW5wdXROb3RlIHwgbnVsbH0gW2lucHV0X25vdGVdXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZV9pZCwgbWV0YWRhdGEsIGlucHV0X25vdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfaWQsIE5vdGVJZCk7XG4gICAgICAgIHZhciBwdHIwID0gbm90ZV9pZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG1ldGFkYXRhLCBOb3RlTWV0YWRhdGEpO1xuICAgICAgICB2YXIgcHRyMSA9IG1ldGFkYXRhLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBsZXQgcHRyMiA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShpbnB1dF9ub3RlKSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGlucHV0X25vdGUsIElucHV0Tm90ZSk7XG4gICAgICAgICAgICBwdHIyID0gaW5wdXRfbm90ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZldGNoZWRub3RlX25ldyhwdHIwLCBwdHIxLCBwdHIyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEZldGNoZWROb3RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgbm90ZS5cbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGdldCBub3RlSWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmV0Y2hlZG5vdGVfbm90ZUlkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5vdGUncyBtZXRhZGF0YSwgaW5jbHVkaW5nIHNlbmRlciwgdGFnLCBhbmQgb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBBdmFpbGFibGUgZm9yIGJvdGggcHJpdmF0ZSBhbmQgcHVibGljIG5vdGVzLlxuICAgICAqIEByZXR1cm5zIHtOb3RlTWV0YWRhdGF9XG4gICAgICovXG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZldGNoZWRub3RlX21ldGFkYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgW2BJbnB1dE5vdGVgXSB3aXRoIGluY2x1c2lvbiBwcm9vZi5cbiAgICAgKlxuICAgICAqIEZvciBwdWJsaWMgbm90ZXMsIGl0IGNvbnRhaW5zIHRoZSBjb21wbGV0ZSBub3RlIGRhdGEgYW5kIGluY2x1c2lvbiBwcm9vZi5cbiAgICAgKiBGb3IgcHJpdmF0ZSBub3RlcywgaXQgd2lsbCBiZSBgYE5vbmVgLlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGUgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGlucHV0Tm90ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZXRjaGVkbm90ZV9pbnB1dE5vdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogSW5wdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVR5cGV9XG4gICAgICovXG4gICAgZ2V0IG5vdGVUeXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZldGNoZWRub3RlX25vdGVUeXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZldGNoZWROb3RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGZXRjaGVkTm90ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRmxhdHRlbmVkVThWZWNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZmxhdHRlbmVkdTh2ZWNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRmxhdHRlbmVkVThWZWMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZsYXR0ZW5lZFU4VmVjLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZsYXR0ZW5lZFU4VmVjRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZsYXR0ZW5lZFU4VmVjRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mbGF0dGVuZWR1OHZlY19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRhdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZmxhdHRlbmVkdTh2ZWNfZGF0YShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50MzJBcnJheX1cbiAgICAgKi9cbiAgICBsZW5ndGhzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZsYXR0ZW5lZHU4dmVjX2xlbmd0aHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVUzMkZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1faW5uZXJfdmVjcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mbGF0dGVuZWR1OHZlY19udW1faW5uZXJfdmVjcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGbGF0dGVuZWRVOFZlYy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRmxhdHRlbmVkVThWZWMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZvcmVpZ25BY2NvdW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ZvcmVpZ25hY2NvdW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZvcmVpZ25BY2NvdW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGb3JlaWduQWNjb3VudC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGb3JlaWduQWNjb3VudEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEZvcmVpZ25BY2NvdW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGb3JlaWduQWNjb3VudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZm9yZWlnbmFjY291bnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHN9IHN0b3JhZ2VfcmVxdWlyZW1lbnRzXG4gICAgICogQHJldHVybnMge0ZvcmVpZ25BY2NvdW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBwdWJsaWMoYWNjb3VudF9pZCwgc3RvcmFnZV9yZXF1aXJlbWVudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGFjY291bnRfaWQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmFnZV9yZXF1aXJlbWVudHMsIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gc3RvcmFnZV9yZXF1aXJlbWVudHMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmZvcmVpZ25hY2NvdW50X3B1YmxpYyhyZXRwdHIsIHB0cjAsIHB0cjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRm9yZWlnbkFjY291bnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzfVxuICAgICAqL1xuICAgIHN0b3JhZ2Vfc2xvdF9yZXF1aXJlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZm9yZWlnbmFjY291bnRfc3RvcmFnZV9zbG90X3JlcXVpcmVtZW50cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBhY2NvdW50X2lkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZvcmVpZ25hY2NvdW50X2FjY291bnRfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRm9yZWlnbkFjY291bnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZvcmVpZ25BY2NvdW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGb3JlaWduQWNjb3VudEFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ZvcmVpZ25hY2NvdW50YXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRm9yZWlnbkFjY291bnRBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZvcmVpZ25BY2NvdW50QXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ZvcmVpZ25hY2NvdW50YXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZvcmVpZ25BY2NvdW50W10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZvcmVpZ25hY2NvdW50YXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRm9yZWlnbkFjY291bnRBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtGb3JlaWduQWNjb3VudH1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mb3JlaWduYWNjb3VudGFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGb3JlaWduQWNjb3VudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0ZvcmVpZ25BY2NvdW50fSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBGb3JlaWduQWNjb3VudCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmZvcmVpZ25hY2NvdW50YXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZvcmVpZ25BY2NvdW50fSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBGb3JlaWduQWNjb3VudCk7XG4gICAgICAgIHdhc20uZm9yZWlnbmFjY291bnRhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZvcmVpZ25hY2NvdW50YXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZvcmVpZ25BY2NvdW50QXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZvcmVpZ25BY2NvdW50QXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZ1bmdpYmxlQXNzZXRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZnVuZ2libGVhc3NldF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGdW5naWJsZUFzc2V0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGdW5naWJsZUFzc2V0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBGdW5naWJsZUFzc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGdW5naWJsZUFzc2V0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mdW5naWJsZWFzc2V0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBhbW91bnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmYXVjZXRfaWQsIGFtb3VudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRfbmV3KGZhdWNldF9pZC5fX3diZ19wdHIsIGFtb3VudCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBGdW5naWJsZUFzc2V0RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgZmF1Y2V0SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBhbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldF9hbW91bnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGludG9Xb3JkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRfaW50b1dvcmQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZ1bmdpYmxlQXNzZXQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZ1bmdpYmxlQXNzZXQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZ1bmdpYmxlQXNzZXREZWx0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mdW5naWJsZWFzc2V0ZGVsdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRnVuZ2libGVBc3NldERlbHRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGdW5naWJsZUFzc2V0RGVsdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRnVuZ2libGVBc3NldERlbHRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXREZWx0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZnVuZ2libGVhc3NldGRlbHRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRkZWx0YV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXREZWx0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mdW5naWJsZWFzc2V0ZGVsdGFfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRnVuZ2libGVBc3NldERlbHRhLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldGRlbHRhX2lzRW1wdHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZmF1Y2V0X2lkXG4gICAgICogQHJldHVybnMge2JpZ2ludCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBhbW91bnQoZmF1Y2V0X2lkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB3YXNtLmZ1bmdpYmxlYXNzZXRkZWx0YV9hbW91bnQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgZmF1Y2V0X2lkLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRCaWdJbnQ2NChyZXRwdHIgKyA4ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiByMjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1Bc3NldHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldGRlbHRhX251bUFzc2V0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0RGVsdGFJdGVtW119XG4gICAgICovXG4gICAgYXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZ1bmdpYmxlYXNzZXRkZWx0YV9hc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGdW5naWJsZUFzc2V0RGVsdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZ1bmdpYmxlQXNzZXREZWx0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRnVuZ2libGVBc3NldERlbHRhSXRlbUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mdW5naWJsZWFzc2V0ZGVsdGFpdGVtX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW0ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW0ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRnVuZ2libGVBc3NldERlbHRhSXRlbUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGdW5naWJsZUFzc2V0RGVsdGFJdGVtRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mdW5naWJsZWFzc2V0ZGVsdGFpdGVtX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBnZXQgZmF1Y2V0SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRfYW1vdW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW0ucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW0ucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEdldFByb2NlZHVyZXNSZXN1bHRJdGVtRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2dldHByb2NlZHVyZXNyZXN1bHRpdGVtX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEdldFByb2NlZHVyZXNSZXN1bHRJdGVtIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZ2V0cHJvY2VkdXJlc3Jlc3VsdGl0ZW1fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBnZXQgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzQXV0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5nZXRwcm9jZWR1cmVzcmVzdWx0aXRlbV9pc0F1dGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW0ucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEdldFByb2NlZHVyZXNSZXN1bHRJdGVtLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBJbnB1dE5vdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW5wdXRub3RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIElucHV0Tm90ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSW5wdXROb3RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIElucHV0Tm90ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbnB1dE5vdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2lucHV0bm90ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGV9XG4gICAgICovXG4gICAgbm90ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVfbm90ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSW5jbHVzaW9uUHJvb2YgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgcHJvb2YoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlX3Byb29mKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IE5vdGVJbmNsdXNpb25Qcm9vZi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVMb2NhdGlvbiB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBsb2NhdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVfbG9jYXRpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTm90ZUxvY2F0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSW5wdXROb3RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBJbnB1dE5vdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IElucHV0Tm90ZVJlY29yZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbnB1dG5vdGVyZWNvcmRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgSW5wdXROb3RlUmVjb3JkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShJbnB1dE5vdGVSZWNvcmQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSW5wdXROb3RlUmVjb3JkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIElucHV0Tm90ZVJlY29yZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfaW5wdXRub3RlcmVjb3JkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3RlU3RhdGV9XG4gICAgICovXG4gICAgc3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX3N0YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVEZXRhaWxzfVxuICAgICAqL1xuICAgIGRldGFpbHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2RldGFpbHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZURldGFpbHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTWV0YWRhdGEgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgbWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX21ldGFkYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IE5vdGVNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUluY2x1c2lvblByb29mIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGluY2x1c2lvblByb29mKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9pbmNsdXNpb25Qcm9vZih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBOb3RlSW5jbHVzaW9uUHJvb2YuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgY29uc3VtZXJUcmFuc2FjdGlvbklkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmlucHV0bm90ZXJlY29yZF9jb25zdW1lclRyYW5zYWN0aW9uSWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgbnVsbGlmaWVyKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5pbnB1dG5vdGVyZWNvcmRfbnVsbGlmaWVyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2lzQXV0aGVudGljYXRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29uc3VtZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2lzQ29uc3VtZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1Byb2Nlc3NpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2lzUHJvY2Vzc2luZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGV9XG4gICAgICovXG4gICAgdG9JbnB1dE5vdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uaW5wdXRub3RlcmVjb3JkX3RvSW5wdXROb3RlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSW5wdXROb3RlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBJbnB1dE5vdGVSZWNvcmQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IElucHV0Tm90ZVJlY29yZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSW5wdXROb3Rlc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbnB1dG5vdGVzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIElucHV0Tm90ZXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKElucHV0Tm90ZXMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSW5wdXROb3Rlc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbnB1dE5vdGVzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbnB1dG5vdGVzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtTm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3Rlc19udW1Ob3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3Rlc19pc0VtcHR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZX1cbiAgICAgKi9cbiAgICBnZXROb3RlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3Rlc19nZXROb3RlKHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBJbnB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGVbXX1cbiAgICAgKi9cbiAgICBub3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5pbnB1dG5vdGVzX25vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSW5wdXROb3Rlcy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSW5wdXROb3Rlcy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSW50b1VuZGVybHlpbmdCeXRlU291cmNlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2Uge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2VGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbVR5cGV9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdieXRlc291cmNlX3R5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gX193YmluZGdlbl9lbnVtX1JlYWRhYmxlU3RyZWFtVHlwZVtyZXRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBhdXRvQWxsb2NhdGVDaHVua1NpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdieXRlc291cmNlX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0gY29udHJvbGxlclxuICAgICAqL1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgd2FzbS5pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2Vfc3RhcnQodGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoY29udHJvbGxlcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV9wdWxsKHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGNvbnRyb2xsZXIpKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLmludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV9jYW5jZWwocHRyKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEludG9VbmRlcmx5aW5nQnl0ZVNvdXJjZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSW50b1VuZGVybHlpbmdCeXRlU291cmNlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBJbnRvVW5kZXJseWluZ1NpbmtGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW50b3VuZGVybHlpbmdzaW5rX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEludG9VbmRlcmx5aW5nU2luayB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEludG9VbmRlcmx5aW5nU2lua0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfaW50b3VuZGVybHlpbmdzaW5rX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGNodW5rXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB3cml0ZShjaHVuaykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nc2lua193cml0ZSh0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChjaHVuaykpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nc2lua19jbG9zZShwdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gcmVhc29uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ3NpbmtfYWJvcnQocHRyLCBhZGRIZWFwT2JqZWN0KHJlYXNvbikpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSW50b1VuZGVybHlpbmdTaW5rLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBJbnRvVW5kZXJseWluZ1NpbmsucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEludG9VbmRlcmx5aW5nU291cmNlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ludG91bmRlcmx5aW5nc291cmNlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEludG9VbmRlcmx5aW5nU291cmNlIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW50b1VuZGVybHlpbmdTb3VyY2VGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ludG91bmRlcmx5aW5nc291cmNlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ3NvdXJjZV9wdWxsKHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGNvbnRyb2xsZXIpKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLmludG91bmRlcmx5aW5nc291cmNlX2NhbmNlbChwdHIpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSW50b1VuZGVybHlpbmdTb3VyY2UucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEludG9VbmRlcmx5aW5nU291cmNlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBKc0FjY291bnRVcGRhdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfanNhY2NvdW50dXBkYXRlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gdXBkYXRlIHRvIGEgc2luZ2xlIGFjY291bnQncyBzdGF0ZS5cbiAqL1xuY2xhc3MgSnNBY2NvdW50VXBkYXRlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKc0FjY291bnRVcGRhdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSnNBY2NvdW50VXBkYXRlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgSnNBY2NvdW50VXBkYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcmFnZVJvb3Q6IHRoaXMuc3RvcmFnZVJvb3QsXG4gICAgICAgICAgICBzdG9yYWdlU2xvdHM6IHRoaXMuc3RvcmFnZVNsb3RzLFxuICAgICAgICAgICAgc3RvcmFnZU1hcEVudHJpZXM6IHRoaXMuc3RvcmFnZU1hcEVudHJpZXMsXG4gICAgICAgICAgICBhc3NldFZhdWx0Um9vdDogdGhpcy5hc3NldFZhdWx0Um9vdCxcbiAgICAgICAgICAgIGFzc2V0czogdGhpcy5hc3NldHMsXG4gICAgICAgICAgICBhY2NvdW50SWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgY29kZVJvb3Q6IHRoaXMuY29kZVJvb3QsXG4gICAgICAgICAgICBjb21taXR0ZWQ6IHRoaXMuY29tbWl0dGVkLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBhY2NvdW50Q29tbWl0bWVudDogdGhpcy5hY2NvdW50Q29tbWl0bWVudCxcbiAgICAgICAgICAgIGFjY291bnRTZWVkOiB0aGlzLmFjY291bnRTZWVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBKc0FjY291bnRVcGRhdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzYWNjb3VudHVwZGF0ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgYWNjb3VudCdzIHN0b3JhZ2UgdHJpZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlUm9vdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSBhY2NvdW50J3Mgc3RvcmFnZSB0cmllLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0b3JhZ2VSb290KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplZCBzdG9yYWdlIHNsb3QgZGF0YSBmb3IgdGhpcyBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtKc1N0b3JhZ2VTbG90W119XG4gICAgICovXG4gICAgZ2V0IHN0b3JhZ2VTbG90cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VTbG90cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplZCBzdG9yYWdlIHNsb3QgZGF0YSBmb3IgdGhpcyBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7SnNTdG9yYWdlU2xvdFtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0b3JhZ2VTbG90cyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VTbG90cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgc3RvcmFnZSBtYXAgZW50cmllcyBmb3IgdGhpcyBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtKc1N0b3JhZ2VNYXBFbnRyeVtdfVxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlTWFwRW50cmllcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VNYXBFbnRyaWVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIHN0b3JhZ2UgbWFwIGVudHJpZXMgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0ge0pzU3RvcmFnZU1hcEVudHJ5W119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RvcmFnZU1hcEVudHJpZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlTWFwRW50cmllcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgYWNjb3VudCdzIGFzc2V0IHZhdWx0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGFzc2V0VmF1bHRSb290KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2Fzc2V0VmF1bHRSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIGFjY291bnQncyBhc3NldCB2YXVsdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBhc3NldFZhdWx0Um9vdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hc3NldFZhdWx0Um9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY2NvdW50J3MgYXNzZXQgdmF1bHQuXG4gICAgICogQHJldHVybnMge0pzVmF1bHRBc3NldFtdfVxuICAgICAqL1xuICAgIGdldCBhc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY2NvdW50J3MgYXNzZXQgdmF1bHQuXG4gICAgICogQHBhcmFtIHtKc1ZhdWx0QXNzZXRbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBhc3NldHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hc3NldHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJRCBmb3IgdGhpcyBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGFjY291bnRJZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50SWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElEIGZvciB0aGlzIGFjY291bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYWNjb3VudElkKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRJZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgYWNjb3VudCdzIGV4ZWN1dGFibGUgY29kZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjb2RlUm9vdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9jb2RlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSBhY2NvdW50J3MgZXhlY3V0YWJsZSBjb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNvZGVSb290KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2NvZGVSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGFjY291bnQgdXBkYXRlIGhhcyBiZWVuIGNvbW1pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tbWl0dGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfY29tbWl0dGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGFjY291bnQgdXBkYXRlIGhhcyBiZWVuIGNvbW1pdHRlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgY29tbWl0dGVkKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2NvbW1pdHRlZCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY2NvdW50J3MgdHJhbnNhY3Rpb24gbm9uY2UgYXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbm9uY2UoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfbm9uY2UocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY2NvdW50J3MgdHJhbnNhY3Rpb24gbm9uY2UgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm9uY2UoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfbm9uY2UodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3J5cHRvZ3JhcGhpYyBjb21taXRtZW50IHJlcHJlc2VudGluZyB0aGlzIGFjY291bnQncyBjdXJyZW50IHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGFjY291bnRDb21taXRtZW50KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRDb21taXRtZW50KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3J5cHRvZ3JhcGhpYyBjb21taXRtZW50IHJlcHJlc2VudGluZyB0aGlzIGFjY291bnQncyBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGFjY291bnRDb21taXRtZW50KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRDb21taXRtZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgc2VlZCBkYXRhIGZvciB0aGUgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudFNlZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50U2VlZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIHNlZWQgZGF0YSBmb3IgdGhlIGFjY291bnQuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IGFjY291bnRTZWVkKGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRTZWVkKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEpzQWNjb3VudFVwZGF0ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSnNBY2NvdW50VXBkYXRlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBKc1N0YXRlU3luY1VwZGF0ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19qc3N0YXRlc3luY3VwZGF0ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkYXRhIGZvciBhIHN5bmMgdXBkYXRlLFxuICogd2hpY2ggd2lsbCBiZSByZWNlaXZlZCBieSB0aGUgYXBwbHlTdGF0ZVN5bmMgSlMgZnVuY3Rpb24uXG4gKiB1bmRlciBzeW5jLmpzXG4gKi9cbmNsYXNzIEpzU3RhdGVTeW5jVXBkYXRlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKc1N0YXRlU3luY1VwZGF0ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBKc1N0YXRlU3luY1VwZGF0ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBKc1N0YXRlU3luY1VwZGF0ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNzdGF0ZXN5bmN1cGRhdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2sgbnVtYmVyIGZvciB0aGlzIHVwZGF0ZSwgc3RvcmVkIGFzIGEgc3RyaW5nIHNpbmNlIGl0IHdpbGwgYmVcbiAgICAgKiBwZXJzaXN0ZWQgaW4gYEluZGV4ZWREQmAuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYmxvY2tOdW0oKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBibG9jayBudW1iZXIgZm9yIHRoaXMgdXBkYXRlLCBzdG9yZWQgYXMgYSBzdHJpbmcgc2luY2UgaXQgd2lsbCBiZVxuICAgICAqIHBlcnNpc3RlZCBpbiBgSW5kZXhlZERCYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBibG9ja051bShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgYmxvY2sgaGVhZGVycyBmb3IgdGhpcyBzdGF0ZSB1cGRhdGUsIHNlcmlhbGl6ZWQgaW50byBhIGZsYXR0ZW5lZCBieXRlIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGbGF0dGVuZWRVOFZlY31cbiAgICAgKi9cbiAgICBnZXQgZmxhdHRlbmVkTmV3QmxvY2tIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9mbGF0dGVuZWROZXdCbG9ja0hlYWRlcnModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmxhdHRlbmVkVThWZWMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgYmxvY2sgaGVhZGVycyBmb3IgdGhpcyBzdGF0ZSB1cGRhdGUsIHNlcmlhbGl6ZWQgaW50byBhIGZsYXR0ZW5lZCBieXRlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RmxhdHRlbmVkVThWZWN9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgZmxhdHRlbmVkTmV3QmxvY2tIZWFkZXJzKGFyZzApIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFyZzAsIEZsYXR0ZW5lZFU4VmVjKTtcbiAgICAgICAgdmFyIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9mbGF0dGVuZWROZXdCbG9ja0hlYWRlcnModGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2sgbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggaGVhZGVyIGluIGBmbGF0dGVuZWRfbmV3X2Jsb2NrX2hlYWRlcnNgLlxuICAgICAqIFRoaXMgdmVjIHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIGhlYWRlcnMsIHdpdGggZWFjaCBpbmRleFxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgYmxvY2sgbnVtYmVyIGZvciB0aGUgaGVhZGVyIGF0IHRoYXQgc2FtZSBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IG5ld0Jsb2NrTnVtcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfbmV3QmxvY2tOdW1zKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2sgbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggaGVhZGVyIGluIGBmbGF0dGVuZWRfbmV3X2Jsb2NrX2hlYWRlcnNgLlxuICAgICAqIFRoaXMgdmVjIHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIGhlYWRlcnMsIHdpdGggZWFjaCBpbmRleFxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgYmxvY2sgbnVtYmVyIGZvciB0aGUgaGVhZGVyIGF0IHRoYXQgc2FtZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5ld0Jsb2NrTnVtcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfbmV3QmxvY2tOdW1zKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhdHRlbmVkIGJ5dGUgYXJyYXkgY29udGFpbmluZyBwYXJ0aWFsIGJsb2NrY2hhaW4gcGVha3MgdXNlZCBmb3IgbWVya2xlIHRyZWVcbiAgICAgKiB2ZXJpZmljYXRpb24uXG4gICAgICogQHJldHVybnMge0ZsYXR0ZW5lZFU4VmVjfVxuICAgICAqL1xuICAgIGdldCBmbGF0dGVuZWRQYXJ0aWFsQmxvY2tDaGFpblBlYWtzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9mbGF0dGVuZWRQYXJ0aWFsQmxvY2tDaGFpblBlYWtzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZsYXR0ZW5lZFU4VmVjLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0dGVuZWQgYnl0ZSBhcnJheSBjb250YWluaW5nIHBhcnRpYWwgYmxvY2tjaGFpbiBwZWFrcyB1c2VkIGZvciBtZXJrbGUgdHJlZVxuICAgICAqIHZlcmlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0ZsYXR0ZW5lZFU4VmVjfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGZsYXR0ZW5lZFBhcnRpYWxCbG9ja0NoYWluUGVha3MoYXJnMCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgRmxhdHRlbmVkVThWZWMpO1xuICAgICAgICB2YXIgcHRyMCA9IGFyZzAuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX2ZsYXR0ZW5lZFBhcnRpYWxCbG9ja0NoYWluUGVha3ModGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBibG9jayBpbiB0aGlzIHVwZGF0ZSwgc3RvcmVzIGEgYm9vbGVhbiAoYXMgdTgpIGluZGljYXRpbmcgd2hldGhlclxuICAgICAqIHRoYXQgYmxvY2sgY29udGFpbnMgbm90ZXMgcmVsZXZhbnQgdG8gdGhpcyBjbGllbnQuIEluZGV4IGkgY29ycmVzcG9uZHMgdG9cbiAgICAgKiB0aGUgaXRoIGJsb2NrLCB3aXRoIDEgbWVhbmluZyByZWxldmFudCBhbmQgMCBtZWFuaW5nIG5vdCByZWxldmFudC5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgYmxvY2tIYXNSZWxldmFudE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9ibG9ja0hhc1JlbGV2YW50Tm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBibG9jayBpbiB0aGlzIHVwZGF0ZSwgc3RvcmVzIGEgYm9vbGVhbiAoYXMgdTgpIGluZGljYXRpbmcgd2hldGhlclxuICAgICAqIHRoYXQgYmxvY2sgY29udGFpbnMgbm90ZXMgcmVsZXZhbnQgdG8gdGhpcyBjbGllbnQuIEluZGV4IGkgY29ycmVzcG9uZHMgdG9cbiAgICAgKiB0aGUgaXRoIGJsb2NrLCB3aXRoIDEgbWVhbmluZyByZWxldmFudCBhbmQgMCBtZWFuaW5nIG5vdCByZWxldmFudC5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYmxvY2tIYXNSZWxldmFudE5vdGVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9ibG9ja0hhc1JlbGV2YW50Tm90ZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIElEcyBmb3IgbmV3IGF1dGhlbnRpY2F0aW9uIG5vZGVzIHJlcXVpcmVkIHRvIHZlcmlmeSBibG9jayBoZWFkZXJzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZE5vZGVJZHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWROb2RlSWRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIElEcyBmb3IgbmV3IGF1dGhlbnRpY2F0aW9uIG5vZGVzIHJlcXVpcmVkIHRvIHZlcmlmeSBibG9jayBoZWFkZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2VyaWFsaXplZE5vZGVJZHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWROb2RlSWRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjdHVhbCBhdXRoZW50aWNhdGlvbiBub2RlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgSURzIGFib3ZlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZE5vZGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkTm9kZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY3R1YWwgYXV0aGVudGljYXRpb24gbm9kZSBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdGhlIElEcyBhYm92ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlcmlhbGl6ZWROb2RlcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZE5vZGVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSURzIG9mIG5vdGUgdGFncyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIGNsaWVudCdzIGxvY2FsIHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXQgY29tbWl0dGVkTm90ZUlkcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfY29tbWl0dGVkTm90ZUlkcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSURzIG9mIG5vdGUgdGFncyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIGNsaWVudCdzIGxvY2FsIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgY29tbWl0dGVkTm90ZUlkcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfY29tbWl0dGVkTm90ZUlkcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElucHV0IG5vdGVzIGZvciB0aGlzIHN0YXRlIHVwZGF0ZSBpbiBzZXJpYWxpemVkIGZvcm0uXG4gICAgICogQHJldHVybnMge1NlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhW119XG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWRJbnB1dE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkSW5wdXROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5wdXQgbm90ZXMgZm9yIHRoaXMgc3RhdGUgdXBkYXRlIGluIHNlcmlhbGl6ZWQgZm9ybS5cbiAgICAgKiBAcGFyYW0ge1NlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2VyaWFsaXplZElucHV0Tm90ZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWRJbnB1dE5vdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3V0cHV0IG5vdGVzIGNyZWF0ZWQgaW4gdGhpcyBzdGF0ZSB1cGRhdGUgaW4gc2VyaWFsaXplZCBmb3JtLlxuICAgICAqIEByZXR1cm5zIHtTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGFbXX1cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZE91dHB1dE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkT3V0cHV0Tm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91dHB1dCBub3RlcyBjcmVhdGVkIGluIHRoaXMgc3RhdGUgdXBkYXRlIGluIHNlcmlhbGl6ZWQgZm9ybS5cbiAgICAgKiBAcGFyYW0ge1NlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YVtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlcmlhbGl6ZWRPdXRwdXROb3RlcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZE91dHB1dE5vdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjb3VudCBzdGF0ZSB1cGRhdGVzIGluY2x1ZGVkIGluIHRoaXMgc3luYy5cbiAgICAgKiBAcmV0dXJucyB7SnNBY2NvdW50VXBkYXRlW119XG4gICAgICovXG4gICAgZ2V0IGFjY291bnRVcGRhdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9hY2NvdW50VXBkYXRlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjb3VudCBzdGF0ZSB1cGRhdGVzIGluY2x1ZGVkIGluIHRoaXMgc3luYy5cbiAgICAgKiBAcGFyYW0ge0pzQWNjb3VudFVwZGF0ZVtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGFjY291bnRVcGRhdGVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9hY2NvdW50VXBkYXRlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zYWN0aW9uIGRhdGEgZm9yIHRyYW5zYWN0aW9ucyBpbmNsdWRlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7U2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YVtdfVxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX3RyYW5zYWN0aW9uVXBkYXRlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNhY3Rpb24gZGF0YSBmb3IgdHJhbnNhY3Rpb25zIGluY2x1ZGVkIGluIHRoaXMgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7U2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YVtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHRyYW5zYWN0aW9uVXBkYXRlcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfdHJhbnNhY3Rpb25VcGRhdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEpzU3RhdGVTeW5jVXBkYXRlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBKc1N0YXRlU3luY1VwZGF0ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSnNTdG9yYWdlTWFwRW50cnlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfanNzdG9yYWdlbWFwZW50cnlfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGEgc3RvcmFnZSBtYXAgZW50cnkgaW4gYW4gYWNjb3VudC5cbiAqL1xuY2xhc3MgSnNTdG9yYWdlTWFwRW50cnkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpzU3RvcmFnZU1hcEVudHJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEpzU3RvcmFnZU1hcEVudHJ5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgSnNTdG9yYWdlTWFwRW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiB0aGlzLnJvb3QsXG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEpzU3RvcmFnZU1hcEVudHJ5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc3N0b3JhZ2VtYXBlbnRyeV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG9mIHRoZSBzdG9yYWdlIG1hcCBlbnRyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vdCBvZiB0aGUgc3RvcmFnZSBtYXAgZW50cnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgcm9vdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgb2YgdGhlIHN0b3JhZ2UgbWFwIGVudHJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGtleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X2tleShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGtleSBvZiB0aGUgc3RvcmFnZSBtYXAgZW50cnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQga2V5KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBzdG9yYWdlIG1hcCBlbnRyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0b3JhZ2UgbWFwIGVudHJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHZhbHVlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSnNTdG9yYWdlTWFwRW50cnkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEpzU3RvcmFnZU1hcEVudHJ5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBKc1N0b3JhZ2VTbG90RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2pzc3RvcmFnZXNsb3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGEgc3RvcmFnZSBzbG90IGluIGFuIGFjY291bnQuXG4gKi9cbmNsYXNzIEpzU3RvcmFnZVNsb3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpzU3RvcmFnZVNsb3QucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSnNTdG9yYWdlU2xvdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEpzU3RvcmFnZVNsb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21taXRtZW50OiB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgICAgICBzbG90SW5kZXg6IHRoaXMuc2xvdEluZGV4LFxuICAgICAgICAgICAgc2xvdFZhbHVlOiB0aGlzLnNsb3RWYWx1ZSxcbiAgICAgICAgICAgIHNsb3RUeXBlOiB0aGlzLnNsb3RUeXBlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBKc1N0b3JhZ2VTbG90RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc3N0b3JhZ2VzbG90X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tbWl0bWVudCBvZiB0aGUgd2hvbGUgYWNjb3VudCBzdG9yYWdlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY29tbWl0bWVudCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tbWl0bWVudCBvZiB0aGUgd2hvbGUgYWNjb3VudCBzdG9yYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgY29tbWl0bWVudChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc3RvcmFnZSBzbG90LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNsb3RJbmRleCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlc2xvdF9zbG90SW5kZXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHN0b3JhZ2Ugc2xvdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzbG90SW5kZXgoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VzbG90X3Nsb3RJbmRleCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBzdG9yZWQgaW4gdGhlIHN0b3JhZ2Ugc2xvdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzbG90VmFsdWUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV9rZXkocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBzdG9yZWQgaW4gdGhlIHN0b3JhZ2Ugc2xvdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBzbG90VmFsdWUoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV9rZXkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc3RvcmFnZSBzbG90LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNsb3RUeXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VzbG90X3Nsb3RUeXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHN0b3JhZ2Ugc2xvdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzbG90VHlwZShhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZXNsb3Rfc2xvdFR5cGUodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSnNTdG9yYWdlU2xvdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSnNTdG9yYWdlU2xvdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSnNWYXVsdEFzc2V0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2pzdmF1bHRhc3NldF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHNlcmlhbGl6ZWQgdmF1bHQgYXNzZXRcbiAqL1xuY2xhc3MgSnNWYXVsdEFzc2V0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKc1ZhdWx0QXNzZXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSnNWYXVsdEFzc2V0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgSnNWYXVsdEFzc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICAgICAgdmF1bHRLZXk6IHRoaXMudmF1bHRLZXksXG4gICAgICAgICAgICBmYXVjZXRJZFByZWZpeDogdGhpcy5mYXVjZXRJZFByZWZpeCxcbiAgICAgICAgICAgIGFzc2V0OiB0aGlzLmFzc2V0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBKc1ZhdWx0QXNzZXRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzdmF1bHRhc3NldF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgdmF1bHQncyBhc3NldHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSB2YXVsdCdzIGFzc2V0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCByb290KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhdWx0IGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2V0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHZhdWx0S2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfa2V5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmF1bHQga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgdmF1bHRLZXkoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV9rZXkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NldCdzIGZhdWNldCBJRCBwcmVmaXguXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZmF1Y2V0SWRQcmVmaXgoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZXQncyBmYXVjZXQgSUQgcHJlZml4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGZhdWNldElkUHJlZml4KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXb3JkIHJlcHJlc2VudGluZyB0aGUgYXNzZXQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYXNzZXQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYXNzZXRWYXVsdFJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdvcmQgcmVwcmVzZW50aW5nIHRoZSBhc3NldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBhc3NldChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hc3NldFZhdWx0Um9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBKc1ZhdWx0QXNzZXQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEpzVmF1bHRBc3NldC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTGlicmFyeUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19saWJyYXJ5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIExpYnJhcnkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKExpYnJhcnkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTGlicmFyeUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBMaWJyYXJ5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19saWJyYXJ5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIExpYnJhcnkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IExpYnJhcnkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE1lcmtsZVBhdGhGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfbWVya2xlcGF0aF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBNZXJrbGVQYXRoIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShNZXJrbGVQYXRoLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE1lcmtsZVBhdGhGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTWVya2xlUGF0aEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfbWVya2xlcGF0aF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZGVwdGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWVya2xlcGF0aF9kZXB0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkW119XG4gICAgICovXG4gICAgbm9kZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubWVya2xlcGF0aF9ub2RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGluZGV4XG4gICAgICogQHBhcmFtIHtXb3JkfSBub2RlXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tcHV0ZVJvb3QoaW5kZXgsIG5vZGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vZGUsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1lcmtsZXBhdGhfY29tcHV0ZVJvb3QodGhpcy5fX3diZ19wdHIsIGluZGV4LCBub2RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHJvb3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2ZXJpZnkoaW5kZXgsIG5vZGUsIHJvb3QpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vZGUsIFdvcmQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mocm9vdCwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWVya2xlcGF0aF92ZXJpZnkodGhpcy5fX3diZ19wdHIsIGluZGV4LCBub2RlLl9fd2JnX3B0ciwgcm9vdC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTWVya2xlUGF0aC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTWVya2xlUGF0aC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlQXNzZXRzfSBub3RlX2Fzc2V0c1xuICAgICAqIEBwYXJhbSB7Tm90ZU1ldGFkYXRhfSBub3RlX21ldGFkYXRhXG4gICAgICogQHBhcmFtIHtOb3RlUmVjaXBpZW50fSBub3RlX3JlY2lwaWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGVfYXNzZXRzLCBub3RlX21ldGFkYXRhLCBub3RlX3JlY2lwaWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9hc3NldHMsIE5vdGVBc3NldHMpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9tZXRhZGF0YSwgTm90ZU1ldGFkYXRhKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfcmVjaXBpZW50LCBOb3RlUmVjaXBpZW50KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX25ldyhub3RlX2Fzc2V0cy5fX3diZ19wdHIsIG5vdGVfbWV0YWRhdGEuX193YmdfcHRyLCBub3RlX3JlY2lwaWVudC5fX3diZ19wdHIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge05vdGV9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTWV0YWRhdGF9XG4gICAgICovXG4gICAgbWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9tZXRhZGF0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlUmVjaXBpZW50fVxuICAgICAqL1xuICAgIHJlY2lwaWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX3JlY2lwaWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlUmVjaXBpZW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUFzc2V0c31cbiAgICAgKi9cbiAgICBhc3NldHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9hc3NldHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUFzc2V0cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgc2NyaXB0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfc2NyaXB0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBzZW5kZXJcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtOb3RlQXNzZXRzfSBhc3NldHNcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge0ZlbHR9IGF1eFxuICAgICAqIEByZXR1cm5zIHtOb3RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQMklETm90ZShzZW5kZXIsIHRhcmdldCwgYXNzZXRzLCBub3RlX3R5cGUsIGF1eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VuZGVyLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRhcmdldCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhc3NldHMsIE5vdGVBc3NldHMpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGF1eCwgRmVsdCk7XG4gICAgICAgICAgICB3YXNtLm5vdGVfY3JlYXRlUDJJRE5vdGUocmV0cHRyLCBzZW5kZXIuX193YmdfcHRyLCB0YXJnZXQuX193YmdfcHRyLCBhc3NldHMuX193YmdfcHRyLCBub3RlX3R5cGUsIGF1eC5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gc2VuZGVyXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Tm90ZUFzc2V0c30gYXNzZXRzXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSByZWNsYWltX2hlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gdGltZWxvY2tfaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtGZWx0fSBhdXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUDJJREVOb3RlKHNlbmRlciwgdGFyZ2V0LCBhc3NldHMsIHJlY2xhaW1faGVpZ2h0LCB0aW1lbG9ja19oZWlnaHQsIG5vdGVfdHlwZSwgYXV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzZW5kZXIsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModGFyZ2V0LCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFzc2V0cywgTm90ZUFzc2V0cyk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXV4LCBGZWx0KTtcbiAgICAgICAgICAgIHdhc20ubm90ZV9jcmVhdGVQMklERU5vdGUocmV0cHRyLCBzZW5kZXIuX193YmdfcHRyLCB0YXJnZXQuX193YmdfcHRyLCBhc3NldHMuX193YmdfcHRyLCBpc0xpa2VOb25lKHJlY2xhaW1faGVpZ2h0KSA/IDB4MTAwMDAwMDAxIDogKHJlY2xhaW1faGVpZ2h0KSA+Pj4gMCwgaXNMaWtlTm9uZSh0aW1lbG9ja19oZWlnaHQpID8gMHgxMDAwMDAwMDEgOiAodGltZWxvY2tfaGVpZ2h0KSA+Pj4gMCwgbm90ZV90eXBlLCBhdXguX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVBbmRBcmdzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVhbmRhcmdzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVBbmRBcmdzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlQW5kQXJncy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlQW5kQXJnc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE5vdGVBbmRBcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlQW5kQXJnc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWFuZGFyZ3NfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGV9IG5vdGVcbiAgICAgKiBAcGFyYW0ge1dvcmQgfCBudWxsfSBbYXJnc11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlLCBhcmdzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlLCBOb3RlKTtcbiAgICAgICAgdmFyIHB0cjAgPSBub3RlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBsZXQgcHRyMSA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShhcmdzKSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFyZ3MsIFdvcmQpO1xuICAgICAgICAgICAgcHRyMSA9IGFyZ3MuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlYW5kYXJnc19uZXcocHRyMCwgcHRyMSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlQW5kQXJnc0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUFuZEFyZ3MucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVBbmRBcmdzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlQW5kQXJnc0FycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVhbmRhcmdzYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUFuZEFyZ3NBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVBbmRBcmdzQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVhbmRhcmdzYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVBbmRBcmdzW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVhbmRhcmdzYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUFuZEFyZ3NBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOb3RlQW5kQXJnc31cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlYW5kYXJnc2FycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlQW5kQXJncy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge05vdGVBbmRBcmdzfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBOb3RlQW5kQXJncyk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLm5vdGVhbmRhcmdzYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVBbmRBcmdzfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBOb3RlQW5kQXJncyk7XG4gICAgICAgIHdhc20ubm90ZWFuZGFyZ3NhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVhbmRhcmdzYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVBbmRBcmdzQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVBbmRBcmdzQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVBc3NldHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWFzc2V0c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlQXNzZXRzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlQXNzZXRzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVBc3NldHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUFzc2V0c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWFzc2V0c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuZ2libGVBc3NldFtdIHwgbnVsbH0gW2Fzc2V0c19hcnJheV1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihhc3NldHNfYXJyYXkpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFzc2V0c19hcnJheSkgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXNzZXRzX2FycmF5LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWFzc2V0c19uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlQXNzZXRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuZ2libGVBc3NldH0gYXNzZXRcbiAgICAgKi9cbiAgICBwdXNoKGFzc2V0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhc3NldCwgRnVuZ2libGVBc3NldCk7XG4gICAgICAgIHdhc20ubm90ZWFzc2V0c19wdXNoKHRoaXMuX193YmdfcHRyLCBhc3NldC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldFtdfVxuICAgICAqL1xuICAgIGZ1bmdpYmxlQXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVhc3NldHNfZnVuZ2libGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlQXNzZXRzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlQXNzZXRzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlQ29uc3VtYWJpbGl0eUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlY29uc3VtYWJpbGl0eV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlQ29uc3VtYWJpbGl0eSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUNvbnN1bWFiaWxpdHkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUNvbnN1bWFiaWxpdHlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBOb3RlQ29uc3VtYWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUNvbnN1bWFiaWxpdHlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVjb25zdW1hYmlsaXR5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBhY2NvdW50SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWNvbnN1bWFiaWxpdHlfYWNjb3VudElkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBjb25zdW1hYmxlQWZ0ZXJCbG9jaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlY29uc3VtYWJpbGl0eV9jb25zdW1hYmxlQWZ0ZXJCbG9jayh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDB4MTAwMDAwMDAxID8gdW5kZWZpbmVkIDogcmV0O1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUNvbnN1bWFiaWxpdHkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVDb25zdW1hYmlsaXR5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRGV0YWlsc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZGV0YWlsc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlRGV0YWlscyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZURldGFpbHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZURldGFpbHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZURldGFpbHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVkZXRhaWxzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlQXNzZXRzfSBub3RlX2Fzc2V0c1xuICAgICAqIEBwYXJhbSB7Tm90ZVJlY2lwaWVudH0gbm90ZV9yZWNpcGllbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlX2Fzc2V0cywgbm90ZV9yZWNpcGllbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfYXNzZXRzLCBOb3RlQXNzZXRzKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfcmVjaXBpZW50LCBOb3RlUmVjaXBpZW50KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc19uZXcobm90ZV9hc3NldHMuX193YmdfcHRyLCBub3RlX3JlY2lwaWVudC5fX3diZ19wdHIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZURldGFpbHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc19pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlQXNzZXRzfVxuICAgICAqL1xuICAgIGFzc2V0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc19hc3NldHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUFzc2V0cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVSZWNpcGllbnR9XG4gICAgICovXG4gICAgcmVjaXBpZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzX3JlY2lwaWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlUmVjaXBpZW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZURldGFpbHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVEZXRhaWxzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRGV0YWlsc0FuZFRhZ0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZGV0YWlsc2FuZHRhZ19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlRGV0YWlsc0FuZFRhZyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZURldGFpbHNBbmRUYWcucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZURldGFpbHNBbmRUYWdGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBOb3RlRGV0YWlsc0FuZFRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZURldGFpbHNBbmRUYWdGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVkZXRhaWxzYW5kdGFnX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRGV0YWlsc30gbm90ZV9kZXRhaWxzXG4gICAgICogQHBhcmFtIHtOb3RlVGFnfSB0YWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlX2RldGFpbHMsIHRhZykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9kZXRhaWxzLCBOb3RlRGV0YWlscyk7XG4gICAgICAgIHZhciBwdHIwID0gbm90ZV9kZXRhaWxzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModGFnLCBOb3RlVGFnKTtcbiAgICAgICAgdmFyIHB0cjEgPSB0YWcuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNhbmR0YWdfbmV3KHB0cjAsIHB0cjEpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZURldGFpbHNBbmRUYWdGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVEZXRhaWxzfVxuICAgICAqL1xuICAgIGdldCBub3RlRGV0YWlscygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ19ub3RlRGV0YWlscyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRGV0YWlscy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgZ2V0IHRhZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ190YWcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVEZXRhaWxzQW5kVGFnLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRGV0YWlsc0FuZFRhZy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZURldGFpbHNBbmRUYWdBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRGV0YWlsc0FuZFRhZ1tdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZURldGFpbHNBbmRUYWd9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWRldGFpbHNhbmR0YWdhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZURldGFpbHNBbmRUYWcuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOb3RlRGV0YWlsc0FuZFRhZ30gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgTm90ZURldGFpbHNBbmRUYWcpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRGV0YWlsc0FuZFRhZ30gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgTm90ZURldGFpbHNBbmRUYWcpO1xuICAgICAgICB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRXhlY3V0aW9uSGludEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZXhlY3V0aW9uaGludF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlRXhlY3V0aW9uSGludCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUV4ZWN1dGlvbkhpbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUV4ZWN1dGlvbkhpbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUV4ZWN1dGlvbkhpbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVleGVjdXRpb25oaW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25IaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBub25lKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVleGVjdXRpb25oaW50X25vbmUoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25IaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbkhpbnR9XG4gICAgICovXG4gICAgc3RhdGljIGFsd2F5cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZXhlY3V0aW9uaGludF9hbHdheXMoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25IaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tfbnVtXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25IaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBhZnRlckJsb2NrKGJsb2NrX251bSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVleGVjdXRpb25oaW50X2FmdGVyQmxvY2soYmxvY2tfbnVtKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25IaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXBvY2hfbGVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3RfbGVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNsb3Rfb2Zmc2V0XG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25IaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBvbkJsb2NrU2xvdChlcG9jaF9sZW4sIHNsb3RfbGVuLCBzbG90X29mZnNldCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVleGVjdXRpb25oaW50X29uQmxvY2tTbG90KGVwb2NoX2xlbiwgc2xvdF9sZW4sIHNsb3Rfb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25IaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWRcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbkhpbnR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21QYXJ0cyh0YWcsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZXhlY3V0aW9uaGludF9mcm9tUGFydHModGFnLCBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25IaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tfbnVtXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuQmVDb25zdW1lZChibG9ja19udW0pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZXhlY3V0aW9uaGludF9jYW5CZUNvbnN1bWVkKHRoaXMuX193YmdfcHRyLCBibG9ja19udW0pO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUV4ZWN1dGlvbkhpbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVFeGVjdXRpb25IaW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRXhlY3V0aW9uTW9kZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZXhlY3V0aW9ubW9kZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlRXhlY3V0aW9uTW9kZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUV4ZWN1dGlvbk1vZGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUV4ZWN1dGlvbk1vZGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUV4ZWN1dGlvbk1vZGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVleGVjdXRpb25tb2RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25Nb2RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdMb2NhbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfbmV0d29yaygpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbk1vZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3TmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfcHVibGljKCk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uTW9kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWV4ZWN1dGlvbm1vZGVfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRXhlY3V0aW9uTW9kZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUV4ZWN1dGlvbk1vZGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVGaWxlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVmaWxlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBhIG5vdGUuXG4gKi9cbmNsYXNzIE5vdGVGaWxlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlRmlsZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlRmlsZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRmlsZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWZpbGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgYE5vdGVGaWxlYCdzIHR5cGVzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgbm90ZVR5cGUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVmaWxlX25vdGVUeXBlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUdXJuIGEgbm90ZWZpbGUgaW50byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWZpbGVfc2VyaWFsaXplKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB2YWxpZCBieXRlIHJlcHJlc2VudGF0aW9uIG9mIGEgYE5vdGVGaWxlYCxcbiAgICAgKiByZXR1cm4gaXQgYXMgYSBzdHJ1Y3QuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtOb3RlRmlsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGJ5dGVzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLm5vdGVmaWxlX2Rlc2VyaWFsaXplKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlRmlsZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lucHV0Tm90ZX0gbm90ZVxuICAgICAqIEByZXR1cm5zIHtOb3RlRmlsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUlucHV0Tm90ZShub3RlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlLCBJbnB1dE5vdGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVmaWxlX2Zyb21JbnB1dE5vdGUobm90ZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUZpbGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZX0gbm90ZVxuICAgICAqIEByZXR1cm5zIHtOb3RlRmlsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU91dHB1dE5vdGUobm90ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZSwgT3V0cHV0Tm90ZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWZpbGVfZnJvbU91dHB1dE5vdGUobm90ZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUZpbGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZURldGFpbHN9IG5vdGVfZGV0YWlsc1xuICAgICAqIEByZXR1cm5zIHtOb3RlRmlsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU5vdGVEZXRhaWxzKG5vdGVfZGV0YWlscykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9kZXRhaWxzLCBOb3RlRGV0YWlscyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWZpbGVfZnJvbU5vdGVEZXRhaWxzKG5vdGVfZGV0YWlscy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUZpbGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkfSBub3RlX2RldGFpbHNcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUZpbGV9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21Ob3RlSWQobm90ZV9kZXRhaWxzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2RldGFpbHMsIE5vdGVJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWZpbGVfZnJvbU5vdGVJZChub3RlX2RldGFpbHMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVGaWxlLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUZpbGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVGaWxlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRmlsdGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVmaWx0ZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUZpbHRlciB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVGaWx0ZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVmaWx0ZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVGaWx0ZXJUeXBlc30gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtOb3RlSWRbXSB8IG51bGx9IFtub3RlX2lkc11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlX3R5cGUsIG5vdGVfaWRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShub3RlX2lkcykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobm90ZV9pZHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZmlsdGVyX25ldyhub3RlX3R5cGUsIHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUZpbHRlckZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUZpbHRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUZpbHRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUhlYWRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlaGVhZGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVIZWFkZXIge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlSGVhZGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlaGVhZGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaGVhZGVyX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBtZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaGVhZGVyX21ldGFkYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaGVhZGVyX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVIZWFkZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVIZWFkZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVJZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlaWRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUlkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlSWQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUlkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgTm90ZUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlSWRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVpZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gcmVjaXBpZW50X2RpZ2VzdFxuICAgICAqIEBwYXJhbSB7V29yZH0gYXNzZXRfY29tbWl0bWVudF9kaWdlc3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWNpcGllbnRfZGlnZXN0LCBhc3NldF9jb21taXRtZW50X2RpZ2VzdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmVjaXBpZW50X2RpZ2VzdCwgV29yZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhc3NldF9jb21taXRtZW50X2RpZ2VzdCwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWlkX25ldyhyZWNpcGllbnRfZGlnZXN0Ll9fd2JnX3B0ciwgYXNzZXRfY29tbWl0bWVudF9kaWdlc3QuX193YmdfcHRyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVJZEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGhleCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ubm90ZWlkX2Zyb21IZXgocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlaWRfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlSWQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVJZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUlkQW5kQXJnc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlaWRhbmRhcmdzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVJZEFuZEFyZ3Mge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVJZEFuZEFyZ3MucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUlkQW5kQXJnc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE5vdGVJZEFuZEFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVJZEFuZEFyZ3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVpZGFuZGFyZ3NfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVJZH0gbm90ZV9pZFxuICAgICAqIEBwYXJhbSB7V29yZCB8IG51bGx9IFthcmdzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGVfaWQsIGFyZ3MpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfaWQsIE5vdGVJZCk7XG4gICAgICAgIHZhciBwdHIwID0gbm90ZV9pZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgbGV0IHB0cjEgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYXJncykpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhcmdzLCBXb3JkKTtcbiAgICAgICAgICAgIHB0cjEgPSBhcmdzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWlkYW5kYXJnc19uZXcocHRyMCwgcHRyMSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlSWRBbmRBcmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlSWRBbmRBcmdzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlSWRBbmRBcmdzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlSWRBbmRBcmdzQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWlkYW5kYXJnc2FycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVJZEFuZEFyZ3NBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVJZEFuZEFyZ3NBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWlkYW5kYXJnc2FycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSWRBbmRBcmdzW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpZGFuZGFyZ3NhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlSWRBbmRBcmdzQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkQW5kQXJnc31cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlaWRhbmRhcmdzYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVJZEFuZEFyZ3MuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOb3RlSWRBbmRBcmdzfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBOb3RlSWRBbmRBcmdzKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ubm90ZWlkYW5kYXJnc2FycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSWRBbmRBcmdzfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBOb3RlSWRBbmRBcmdzKTtcbiAgICAgICAgd2FzbS5ub3RlaWRhbmRhcmdzYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaWRhbmRhcmdzYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVJZEFuZEFyZ3NBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUlkQW5kQXJnc0FycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlSW5jbHVzaW9uUHJvb2ZGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWluY2x1c2lvbnByb29mX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVJbmNsdXNpb25Qcm9vZiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUluY2x1c2lvblByb29mLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVJbmNsdXNpb25Qcm9vZkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlSW5jbHVzaW9uUHJvb2ZGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVpbmNsdXNpb25wcm9vZl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTG9jYXRpb259XG4gICAgICovXG4gICAgbG9jYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWluY2x1c2lvbnByb29mX2xvY2F0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVMb2NhdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01lcmtsZVBhdGh9XG4gICAgICovXG4gICAgbm90ZVBhdGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWluY2x1c2lvbnByb29mX25vdGVQYXRoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE1lcmtsZVBhdGguX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlSW5jbHVzaW9uUHJvb2YucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVJbmNsdXNpb25Qcm9vZi5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUlucHV0c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlaW5wdXRzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVJbnB1dHMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVJbnB1dHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUlucHV0c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlSW5wdXRzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlaW5wdXRzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWx0QXJyYXl9IGZlbHRfYXJyYXlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmZWx0X2FycmF5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmZWx0X2FycmF5LCBGZWx0QXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpbnB1dHNfbmV3KGZlbHRfYXJyYXkuX193YmdfcHRyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVJbnB1dHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWlucHV0c192YWx1ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlSW5wdXRzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlSW5wdXRzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlTG9jYXRpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWxvY2F0aW9uX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVMb2NhdGlvbiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUxvY2F0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVMb2NhdGlvbkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlTG9jYXRpb25GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVsb2NhdGlvbl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmxvY2tOdW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWxvY2F0aW9uX2Jsb2NrTnVtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBub2RlSW5kZXhJbkJsb2NrKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVsb2NhdGlvbl9ub2RlSW5kZXhJbkJsb2NrKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVMb2NhdGlvbi5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUxvY2F0aW9uLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlTWV0YWRhdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZW1ldGFkYXRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVNZXRhZGF0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZU1ldGFkYXRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVNZXRhZGF0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlTWV0YWRhdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVtZXRhZGF0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBzZW5kZXJcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge05vdGVUYWd9IG5vdGVfdGFnXG4gICAgICogQHBhcmFtIHtOb3RlRXhlY3V0aW9uSGludH0gbm90ZV9leGVjdXRpb25faGludFxuICAgICAqIEBwYXJhbSB7RmVsdCB8IG51bGx9IFthdXhdXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VuZGVyLCBub3RlX3R5cGUsIG5vdGVfdGFnLCBub3RlX2V4ZWN1dGlvbl9oaW50LCBhdXgpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNlbmRlciwgQWNjb3VudElkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfdGFnLCBOb3RlVGFnKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfZXhlY3V0aW9uX2hpbnQsIE5vdGVFeGVjdXRpb25IaW50KTtcbiAgICAgICAgbGV0IHB0cjAgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYXV4KSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGF1eCwgRmVsdCk7XG4gICAgICAgICAgICBwdHIwID0gYXV4Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZW1ldGFkYXRhX25ldyhzZW5kZXIuX193YmdfcHRyLCBub3RlX3R5cGUsIG5vdGVfdGFnLl9fd2JnX3B0ciwgbm90ZV9leGVjdXRpb25faGludC5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZU1ldGFkYXRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgc2VuZGVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVtZXRhZGF0YV9zZW5kZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICB0YWcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNhbmR0YWdfdGFnKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlVHlwZX1cbiAgICAgKi9cbiAgICBub3RlVHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlbWV0YWRhdGFfbm90ZVR5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZU1ldGFkYXRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlTWV0YWRhdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVSZWNpcGllbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZXJlY2lwaWVudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlUmVjaXBpZW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlUmVjaXBpZW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVSZWNpcGllbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBOb3RlUmVjaXBpZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlUmVjaXBpZW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlcmVjaXBpZW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBzZXJpYWxfbnVtXG4gICAgICogQHBhcmFtIHtOb3RlU2NyaXB0fSBub3RlX3NjcmlwdFxuICAgICAqIEBwYXJhbSB7Tm90ZUlucHV0c30gaW5wdXRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VyaWFsX251bSwgbm90ZV9zY3JpcHQsIGlucHV0cykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VyaWFsX251bSwgV29yZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX3NjcmlwdCwgTm90ZVNjcmlwdCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhpbnB1dHMsIE5vdGVJbnB1dHMpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVyZWNpcGllbnRfbmV3KHNlcmlhbF9udW0uX193YmdfcHRyLCBub3RlX3NjcmlwdC5fX3diZ19wdHIsIGlucHV0cy5fX3diZ19wdHIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZVJlY2lwaWVudEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9zdG9yYWdlQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzZXJpYWxOdW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBzY3JpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXJlY2lwaWVudF9zY3JpcHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJbnB1dHN9XG4gICAgICovXG4gICAgaW5wdXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVyZWNpcGllbnRfaW5wdXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJbnB1dHMuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlUmVjaXBpZW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlUmVjaXBpZW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlUmVjaXBpZW50QXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZXJlY2lwaWVudGFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVSZWNpcGllbnRBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVSZWNpcGllbnRBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZXJlY2lwaWVudGFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlUmVjaXBpZW50W10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVyZWNpcGllbnRhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlUmVjaXBpZW50QXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVJlY2lwaWVudH1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlcmVjaXBpZW50YXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVSZWNpcGllbnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOb3RlUmVjaXBpZW50fSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBOb3RlUmVjaXBpZW50KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ubm90ZXJlY2lwaWVudGFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlUmVjaXBpZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBOb3RlUmVjaXBpZW50KTtcbiAgICAgICAgd2FzbS5ub3RlcmVjaXBpZW50YXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlcmVjaXBpZW50YXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVSZWNpcGllbnRBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZVJlY2lwaWVudEFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlU2NyaXB0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVzY3JpcHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZVNjcmlwdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZVNjcmlwdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlU2NyaXB0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVTY3JpcHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVzY3JpcHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludCB0aGUgTUFTVCBzb3VyY2UgZm9yIHRoaXMgc2NyaXB0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVzY3JpcHRfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3Rlc2NyaXB0X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3Rlc2NyaXB0X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgc3RhdGljIHAyaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXNjcmlwdF9wMmlkKCk7XG4gICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgcDJpZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXNjcmlwdF9wMmlkZSgpO1xuICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgc3RhdGljIHN3YXAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXNjcmlwdF9zd2FwKCk7XG4gICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICByb290KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVzY3JpcHRfcm9vdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZVNjcmlwdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZVNjcmlwdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZVRhZ0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RldGFnX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVUYWcge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVUYWcucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZVRhZ0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlVGFnRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RldGFnX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUFjY291bnRJZChhY2NvdW50X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGV0YWdfZnJvbUFjY291bnRJZChhY2NvdW50X2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXNlX2Nhc2VfaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7Tm90ZUV4ZWN1dGlvbk1vZGV9IGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JQdWJsaWNVc2VDYXNlKHVzZV9jYXNlX2lkLCBwYXlsb2FkLCBleGVjdXRpb24pIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGV4ZWN1dGlvbiwgTm90ZUV4ZWN1dGlvbk1vZGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGV0YWdfZm9yUHVibGljVXNlQ2FzZSh1c2VfY2FzZV9pZCwgcGF5bG9hZCwgZXhlY3V0aW9uLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXNlX2Nhc2VfaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZFxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JMb2NhbFVzZUNhc2UodXNlX2Nhc2VfaWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RldGFnX2ZvckxvY2FsVXNlQ2FzZSh1c2VfY2FzZV9pZCwgcGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NpbmdsZVRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RldGFnX2lzU2luZ2xlVGFyZ2V0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25Nb2RlfVxuICAgICAqL1xuICAgIGV4ZWN1dGlvbk1vZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXRhZ19leGVjdXRpb25Nb2RlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25Nb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGFzVTMyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGV0YWdfYXNVMzIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZVRhZy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZVRhZy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgT3V0cHV0Tm90ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19vdXRwdXRub3RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE91dHB1dE5vdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE91dHB1dE5vdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgT3V0cHV0Tm90ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE91dHB1dE5vdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE91dHB1dE5vdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX291dHB1dG5vdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGV9IG5vdGVcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnVsbChub3RlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlLCBOb3RlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX2Z1bGwobm90ZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsTm90ZX0gcGFydGlhbF9ub3RlXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGV9XG4gICAgICovXG4gICAgc3RhdGljIHBhcnRpYWwocGFydGlhbF9ub3RlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwYXJ0aWFsX25vdGUsIFBhcnRpYWxOb3RlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX3BhcnRpYWwocGFydGlhbF9ub3RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVIZWFkZXJ9IG5vdGVfaGVhZGVyXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGV9XG4gICAgICovXG4gICAgc3RhdGljIGhlYWRlcihub3RlX2hlYWRlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9oZWFkZXIsIE5vdGVIZWFkZXIpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfaGVhZGVyKG5vdGVfaGVhZGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUFzc2V0cyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBhc3NldHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9hc3NldHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTm90ZUFzc2V0cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgcmVjaXBpZW50RGlnZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfcmVjaXBpZW50RGlnZXN0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTWV0YWRhdGF9XG4gICAgICovXG4gICAgbWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9tZXRhZGF0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlfVxuICAgICAqL1xuICAgIHNocmluaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX3Nocmluayh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBpbnRvRnVsbCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX2ludG9GdWxsKHB0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBOb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgT3V0cHV0Tm90ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gT3V0cHV0Tm90ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgT3V0cHV0Tm90ZUFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX291dHB1dG5vdGVhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBPdXRwdXROb3RlQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPdXRwdXROb3RlQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX291dHB1dG5vdGVhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZVtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgT3V0cHV0Tm90ZUFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge091dHB1dE5vdGV9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ub3V0cHV0bm90ZWFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPdXRwdXROb3RlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZX0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgT3V0cHV0Tm90ZSk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLm91dHB1dG5vdGVhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZX0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgT3V0cHV0Tm90ZSk7XG4gICAgICAgIHdhc20ub3V0cHV0bm90ZWFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZWFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBPdXRwdXROb3RlQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE91dHB1dE5vdGVBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgT3V0cHV0Tm90ZXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfb3V0cHV0bm90ZXNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgT3V0cHV0Tm90ZXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE91dHB1dE5vdGVzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE91dHB1dE5vdGVzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgT3V0cHV0Tm90ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE91dHB1dE5vdGVzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vdXRwdXRub3Rlc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bU5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVzX251bU5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3Rlc19pc0VtcHR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge091dHB1dE5vdGV9XG4gICAgICovXG4gICAgZ2V0Tm90ZShpbmRleCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVzX2dldE5vdGUodGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlW119XG4gICAgICovXG4gICAgbm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ub3V0cHV0bm90ZXNfbm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBPdXRwdXROb3Rlcy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gT3V0cHV0Tm90ZXMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE91dHB1dE5vdGVzQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfb3V0cHV0bm90ZXNhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBPdXRwdXROb3Rlc0FycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgT3V0cHV0Tm90ZXNBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfb3V0cHV0bm90ZXNhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZXNbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZXNhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBPdXRwdXROb3Rlc0FycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVzfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm91dHB1dG5vdGVzYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE91dHB1dE5vdGVzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZXN9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIE91dHB1dE5vdGVzKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ub3V0cHV0bm90ZXNhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZXN9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIE91dHB1dE5vdGVzKTtcbiAgICAgICAgd2FzbS5vdXRwdXRub3Rlc2FycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZXNhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgT3V0cHV0Tm90ZXNBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gT3V0cHV0Tm90ZXNBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgUGFja2FnZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19wYWNrYWdlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFBhY2thZ2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFBhY2thZ2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUGFja2FnZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQYWNrYWdlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wYWNrYWdlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnBhY2thZ2Vfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtQYWNrYWdlfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBhY2thZ2VfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGFja2FnZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgUGFja2FnZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gUGFja2FnZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgUGFydGlhbE5vdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcGFydGlhbG5vdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgUGFydGlhbE5vdGUge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQYXJ0aWFsTm90ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcGFydGlhbG5vdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnBhcnRpYWxub3RlX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBtZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX21ldGFkYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcmVjaXBpZW50RGlnZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVBc3NldHN9XG4gICAgICovXG4gICAgYXNzZXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnBhcnRpYWxub3RlX2Fzc2V0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlQXNzZXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgUGFydGlhbE5vdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFBhcnRpYWxOb3RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBQcm92ZW5UcmFuc2FjdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19wcm92ZW50cmFuc2FjdGlvbl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBXQVNNIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgW2BQcm92ZW5UcmFuc2FjdGlvbmBdLlxuICovXG5jbGFzcyBQcm92ZW5UcmFuc2FjdGlvbiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUHJvdmVuVHJhbnNhY3Rpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUHJvdmVuVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUHJvdmVuVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Byb3ZlbnRyYW5zYWN0aW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgcHJvdmVuIHRyYW5zYWN0aW9uIGludG8gYnl0ZXMuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhIHByb3ZlbiB0cmFuc2FjdGlvbiBmcm9tIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvdmVuVHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucHJvdmVudHJhbnNhY3Rpb25fZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvdmVuVHJhbnNhY3Rpb24uX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gSUQuXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25faWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWNjb3VudCBJRCB0aGUgdHJhbnNhY3Rpb24gd2FzIGV4ZWN1dGVkIGFnYWluc3QuXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBhY2NvdW50SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25fYWNjb3VudElkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIGJsb2NrIG51bWJlciB1c2VkIGR1cmluZyBleGVjdXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICByZWZCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9yZWZCbG9ja051bWJlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJsb2NrIG51bWJlciBhdCB3aGljaCB0aGUgdHJhbnNhY3Rpb24gZXhwaXJlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGV4cGlyYXRpb25CbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9leHBpcmF0aW9uQmxvY2tOdW1iZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5vdGVzIGNyZWF0ZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZXN9XG4gICAgICovXG4gICAgb3V0cHV0Tm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25fb3V0cHV0Tm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbW1pdG1lbnQgb2YgdGhlIHJlZmVyZW5jZSBibG9jay5cbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICByZWZCbG9ja0NvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25fcmVmQmxvY2tDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bGxpZmllcnMgb2YgdGhlIGNvbnN1bWVkIGlucHV0IG5vdGVzLlxuICAgICAqIEByZXR1cm5zIHtXb3JkW119XG4gICAgICovXG4gICAgbnVsbGlmaWVycygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9udWxsaWZpZXJzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgUHJvdmVuVHJhbnNhY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFByb3ZlblRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBQdWJsaWNLZXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcHVibGlja2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFB1YmxpY0tleSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUHVibGljS2V5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFB1YmxpY0tleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQdWJsaWNLZXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3B1YmxpY2tleV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wdWJsaWNrZXlfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucHVibGlja2V5X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MobWVzc2FnZSwgV29yZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduYXR1cmUsIFNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHVibGlja2V5X3ZlcmlmeSh0aGlzLl9fd2JnX3B0ciwgbWVzc2FnZS5fX3diZ19wdHIsIHNpZ25hdHVyZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICB0b0NvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHVibGlja2V5X3RvQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge1B1YmxpY0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlckZyb20obWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhtZXNzYWdlLCBXb3JkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzaWduYXR1cmUsIFNpZ25hdHVyZSk7XG4gICAgICAgICAgICB3YXNtLnB1YmxpY2tleV9yZWNvdmVyRnJvbShyZXRwdHIsIG1lc3NhZ2UuX193YmdfcHRyLCBzaWduYXR1cmUuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NpZ25pbmdJbnB1dHN9IHNpZ25pbmdfaW5wdXRzXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZlcmlmeURhdGEoc2lnbmluZ19pbnB1dHMsIHNpZ25hdHVyZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2lnbmluZ19pbnB1dHMsIFNpZ25pbmdJbnB1dHMpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2lnbmF0dXJlLCBTaWduYXR1cmUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnB1YmxpY2tleV92ZXJpZnlEYXRhKHRoaXMuX193YmdfcHRyLCBzaWduaW5nX2lucHV0cy5fX3diZ19wdHIsIHNpZ25hdHVyZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgUHVibGljS2V5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBQdWJsaWNLZXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFJwY0NsaWVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ycGNjbGllbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogUlBDIENsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBNaWRlbiBub2RlcyBkaXJlY3RseS5cbiAqL1xuY2xhc3MgUnBjQ2xpZW50IHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUnBjQ2xpZW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ycGNjbGllbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJQQyBjbGllbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5kcG9pbnQgLSBFbmRwb2ludCB0byBjb25uZWN0IHRvLlxuICAgICAqIEBwYXJhbSB7RW5kcG9pbnR9IGVuZHBvaW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5kcG9pbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVuZHBvaW50LCBFbmRwb2ludCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVuZHBvaW50Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5ycGNjbGllbnRfbmV3KHJldHB0ciwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX193YmdfcHRyID0gcjAgPj4+IDA7XG4gICAgICAgICAgICBScGNDbGllbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgbm90ZXMgYnkgdGhlaXIgSURzIGZyb20gdGhlIGNvbm5lY3RlZCBNaWRlbiBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vdGVfaWRzIC0gQXJyYXkgb2YgW2BOb3RlSWRgXSBvYmplY3RzIHRvIGZldGNoXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvICBkaWZmZXJlbnQgZGF0YSBkZXBlbmRpbmcgb24gdGhlIG5vdGUgdHlwZTpcbiAgICAgKiAtIFByaXZhdGUgbm90ZXM6IFJldHVybnMgb25seSBgbm90ZV9pZGAgYW5kIGBtZXRhZGF0YWAuIFRoZSBgaW5wdXRfbm90ZWAgZmllbGQgd2lsbCBiZVxuICAgICAqICAgYG51bGxgLlxuICAgICAqIC0gUHVibGljIG5vdGVzOiBSZXR1cm5zIHRoZSBmdWxsIGBpbnB1dF9ub3RlYCB3aXRoIGluY2x1c2lvbiBwcm9vZiwgYWxvbmdzaWRlIG1ldGFkYXRhIGFuZFxuICAgICAqICAgSUQuXG4gICAgICogQHBhcmFtIHtOb3RlSWRbXX0gbm90ZV9pZHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaGVkTm90ZVtdPn1cbiAgICAgKi9cbiAgICBnZXROb3Rlc0J5SWQobm90ZV9pZHMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKG5vdGVfaWRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ycGNjbGllbnRfZ2V0Tm90ZXNCeUlkKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIG5vdGUgc2NyaXB0IGJ5IGl0cyByb290IGhhc2ggZnJvbSB0aGUgY29ubmVjdGVkIE1pZGVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYHNjcmlwdF9yb290YCBUaGUgcm9vdCBoYXNoIG9mIHRoZSBub3RlIHNjcmlwdCB0byBmZXRjaFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYE5vdGVTY3JpcHRgXG4gICAgICogQHBhcmFtIHtXb3JkfSBzY3JpcHRfcm9vdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGVTY3JpcHQ+fVxuICAgICAqL1xuICAgIGdldE5vdGVTY3JpcHRCeVJvb3Qoc2NyaXB0X3Jvb3QpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNjcmlwdF9yb290LCBXb3JkKTtcbiAgICAgICAgdmFyIHB0cjAgPSBzY3JpcHRfcm9vdC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ycGNjbGllbnRfZ2V0Tm90ZVNjcmlwdEJ5Um9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBScGNDbGllbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFJwY0NsaWVudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgUnBvMjU2RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3JwbzI1Nl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBScG8yNTYge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBScG8yNTZGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3JwbzI1Nl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmVsdEFycmF5fSBmZWx0X2FycmF5XG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc3RhdGljIGhhc2hFbGVtZW50cyhmZWx0X2FycmF5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmZWx0X2FycmF5LCBGZWx0QXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJwbzI1Nl9oYXNoRWxlbWVudHMoZmVsdF9hcnJheS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFJwbzI1Ni5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gUnBvMjU2LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTY3JpcHRCdWlsZGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NjcmlwdGJ1aWxkZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2NyaXB0QnVpbGRlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2NyaXB0QnVpbGRlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTY3JpcHRCdWlsZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNjcmlwdEJ1aWxkZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NjcmlwdGJ1aWxkZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG1vZHVsZSBwYXRoIChzb21ldGhpbmcgbGlrZSBgbXlfbGliOjptb2R1bGVgKSBhbmQgc291cmNlIGNvZGUsIHRoaXMgd2lsbFxuICAgICAqIHN0YXRpY2FsbHkgbGluayBpdCBmb3IgdXNlIHdpdGggc2NyaXB0cyB0byBiZSBidWlsdCB3aXRoIHRoaXMgYnVpbGRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlX3BhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlX2NvZGVcbiAgICAgKi9cbiAgICBsaW5rTW9kdWxlKG1vZHVsZV9wYXRoLCBtb2R1bGVfY29kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobW9kdWxlX3BhdGgsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAobW9kdWxlX2NvZGUsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNjcmlwdGJ1aWxkZXJfbGlua01vZHVsZShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWNhbGx5IGxpbmtzIHRoZSBnaXZlbiBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogU3RhdGljIGxpbmtpbmcgbWVhbnMgdGhlIGxpYnJhcnkgY29kZSBpcyBjb3BpZWQgaW50byB0aGUgc2NyaXB0IGNvZGUuXG4gICAgICogVXNlIHRoaXMgZm9yIG1vc3QgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGUgb24tY2hhaW4uXG4gICAgICpcbiAgICAgKiBSZWNlaXZlcyBhcyBhcmd1bWVudCB0aGUgbGlicmFyeSB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7TGlicmFyeX0gbGlicmFyeVxuICAgICAqL1xuICAgIGxpbmtTdGF0aWNMaWJyYXJ5KGxpYnJhcnkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGxpYnJhcnksIExpYnJhcnkpO1xuICAgICAgICAgICAgd2FzbS5zY3JpcHRidWlsZGVyX2xpbmtTdGF0aWNMaWJyYXJ5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGxpYnJhcnkuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBkeW5hbWljYWxseSBsaW5rIHRoZSBbYExpYnJhcnlgXSBvZiBhIGZvcmVpZ24gYWNjb3VudFxuICAgICAqIHRoYXQgaXMgaW52b2tlZCB1c2luZyBmb3JlaWduIHByb2NlZHVyZSBpbnZvY2F0aW9uIChGUEkpLiBJdHMgY29kZSBpcyBhdmFpbGFibGVcbiAgICAgKiBvbi1jaGFpbiBhbmQgc28gaXQgZG9lcyBub3QgaGF2ZSB0byBiZSBjb3BpZWQgaW50byB0aGUgc2NyaXB0IGNvZGUuXG4gICAgICpcbiAgICAgKiBGb3IgYWxsIG90aGVyIHVzZSBjYXNlcyBub3QgaW52b2x2aW5nIEZQSSwgbGluayB0aGUgbGlicmFyeSBzdGF0aWNhbGx5LlxuICAgICAqIFJlY2VpdmVzIGFzIGFyZ3VtZW50IHRoZSBsaWJyYXJ5IHRvIGJlIGxpbmtlZC5cbiAgICAgKiBAcGFyYW0ge0xpYnJhcnl9IGxpYnJhcnlcbiAgICAgKi9cbiAgICBsaW5rRHluYW1pY0xpYnJhcnkobGlicmFyeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MobGlicmFyeSwgTGlicmFyeSk7XG4gICAgICAgICAgICB3YXNtLnNjcmlwdGJ1aWxkZXJfbGlua0R5bmFtaWNMaWJyYXJ5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGxpYnJhcnkuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIFRyYW5zYWN0aW9uIFNjcmlwdCdzIHNvdXJjZSBjb2RlLCBjb21waWxlcyBpdCB3aXRoIHRoZSBhdmFpbGFibGVcbiAgICAgKiBtb2R1bGVzIHVuZGVyIHRoaXMgYnVpbGRlci4gUmV0dXJucyB0aGUgY29tcGlsZWQgc2NyaXB0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eF9zY3JpcHRcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TY3JpcHR9XG4gICAgICovXG4gICAgY29tcGlsZVR4U2NyaXB0KHR4X3NjcmlwdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodHhfc2NyaXB0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5zY3JpcHRidWlsZGVyX2NvbXBpbGVUeFNjcmlwdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU2NyaXB0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgTm90ZSBTY3JpcHQncyBzb3VyY2UgY29kZSwgY29tcGlsZXMgaXQgd2l0aCB0aGUgYXZhaWxhYmxlXG4gICAgICogbW9kdWxlcyB1bmRlciB0aGlzIGJ1aWxkZXIuIFJldHVybnMgdGhlIGNvbXBpbGVkIHNjcmlwdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIGNvbXBpbGVOb3RlU2NyaXB0KHByb2dyYW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHByb2dyYW0sIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNjcmlwdGJ1aWxkZXJfY29tcGlsZU5vdGVTY3JpcHQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgTGlicmFyeSBQYXRoLCBhbmQgYSBzb3VyY2UgY29kZSwgdHVybiBpdCBpbnRvIGEgTGlicmFyeS5cbiAgICAgKiBFLmcuIEEgcGF0aCBsaWJyYXJ5IGNhbiBiZSBgbWlkZW46Om15X2NvbnRyYWN0YC4gV2hlbiB0dXJuZWQgaW50byBhIGxpYnJhcnksXG4gICAgICogdGhpcyBjYW4gYmUgdXNlZCBmcm9tIGFub3RoZXIgc2NyaXB0IHdpdGggYW4gaW1wb3J0IHN0YXRlbWVudCwgZm9sbG93aW5nIHRoZVxuICAgICAqIHByZXZpb3VzIGV4YW1wbGU6IGB1c2UubWlkZW46Om15X2NvbnRyYWN0Jy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGlicmFyeV9wYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZV9jb2RlXG4gICAgICogQHJldHVybnMge0xpYnJhcnl9XG4gICAgICovXG4gICAgYnVpbGRMaWJyYXJ5KGxpYnJhcnlfcGF0aCwgc291cmNlX2NvZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGxpYnJhcnlfcGF0aCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChzb3VyY2VfY29kZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uc2NyaXB0YnVpbGRlcl9idWlsZExpYnJhcnkocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBMaWJyYXJ5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTY3JpcHRCdWlsZGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTY3JpcHRCdWlsZGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTZWNyZXRLZXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2VjcmV0a2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNlY3JldEtleSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2VjcmV0S2V5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNlY3JldEtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTZWNyZXRLZXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NlY3JldGtleV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZWVkXVxuICAgICAqIEByZXR1cm5zIHtTZWNyZXRLZXl9XG4gICAgICovXG4gICAgc3RhdGljIHJwb0ZhbGNvbldpdGhSTkcoc2VlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoc2VlZCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uc2VjcmV0a2V5X3Jwb0ZhbGNvbldpdGhSTkcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNlY3JldEtleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VlZF1cbiAgICAgKiBAcmV0dXJucyB7U2VjcmV0S2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBlY2RzYVdpdGhSTkcoc2VlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoc2VlZCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uc2VjcmV0a2V5X2VjZHNhV2l0aFJORyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2VjcmV0S2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9XG4gICAgICovXG4gICAgcHVibGljS2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldGtleV9wdWJsaWNLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUHVibGljS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfVxuICAgICAqL1xuICAgIHNpZ24obWVzc2FnZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MobWVzc2FnZSwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2VjcmV0a2V5X3NpZ24odGhpcy5fX3diZ19wdHIsIG1lc3NhZ2UuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTaWduaW5nSW5wdXRzfSBzaWduaW5nX2lucHV0c1xuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmV9XG4gICAgICovXG4gICAgc2lnbkRhdGEoc2lnbmluZ19pbnB1dHMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNpZ25pbmdfaW5wdXRzLCBTaWduaW5nSW5wdXRzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZWNyZXRrZXlfc2lnbkRhdGEodGhpcy5fX3diZ19wdHIsIHNpZ25pbmdfaW5wdXRzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZWNyZXRrZXlfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtTZWNyZXRLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2VjcmV0a2V5X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNlY3JldEtleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2VjcmV0S2V5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTZWNyZXRLZXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTZXJpYWxpemVkSW5wdXROb3RlRGF0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTZXJpYWxpemVkSW5wdXROb3RlRGF0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTZXJpYWxpemVkSW5wdXROb3RlRGF0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBub3RlSWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vdGVJZChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBub3RlQXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vdGVBc3NldHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVBc3NldHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsTnVtYmVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9zZXJpYWxOdW1iZXIocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2VyaWFsTnVtYmVyKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9zZXJpYWxOdW1iZXIodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgaW5wdXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9pbnB1dHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgaW5wdXRzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9pbnB1dHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBub3RlU2NyaXB0Um9vdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVTY3JpcHRSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBub3RlU2NyaXB0Um9vdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVTY3JpcHRSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG5vdGVTY3JpcHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVTY3JpcHQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm90ZVNjcmlwdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZVNjcmlwdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG51bGxpZmllcigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9jb2RlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbnVsbGlmaWVyKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2NvZGVSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3RhdGVEaXNjcmltaW5hbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3N0YXRlRGlzY3JpbWluYW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RhdGVEaXNjcmltaW5hbnQoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9zdGF0ZURpc2NyaW1pbmFudCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfc3RhdGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RhdGUoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3N0YXRlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY3JlYXRlZEF0KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRDb21taXRtZW50KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBjcmVhdGVkQXQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudENvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2VyaWFsaXplZElucHV0Tm90ZURhdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBub3RlSWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vdGVJZChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBub3RlQXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vdGVBc3NldHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVBc3NldHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCByZWNpcGllbnREaWdlc3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgcmVjaXBpZW50RGlnZXN0KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2lucHV0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBtZXRhZGF0YShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfaW5wdXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgbnVsbGlmaWVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfbnVsbGlmaWVyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBudWxsaWZpZXIoYXJnMCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX251bGxpZmllcih0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV4cGVjdGVkSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfZXhwZWN0ZWRIZWlnaHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBleHBlY3RlZEhlaWdodChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9leHBlY3RlZEhlaWdodCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHN0YXRlRGlzY3JpbWluYW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfc3RhdGVEaXNjcmltaW5hbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdGF0ZURpc2NyaW1pbmFudChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9zdGF0ZURpc2NyaW1pbmFudCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX3N0YXRlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0YXRlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfc3RhdGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGlkKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGRldGFpbHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgZGV0YWlscyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZUFzc2V0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBzY3JpcHRSb290KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3NjcmlwdFJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgc2NyaXB0Um9vdChhcmcwKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfc2NyaXB0Um9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCB0eFNjcmlwdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV90eFNjcmlwdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCB0eFNjcmlwdChhcmcwKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfdHhTY3JpcHQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBibG9ja051bSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBibG9ja051bShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzVmFyaWFudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9zdGF0dXNWYXJpYW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RhdHVzVmFyaWFudChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfc3RhdHVzVmFyaWFudCh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2lucHV0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdGF0dXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2lucHV0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTaWduYXR1cmVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2lnbmF0dXJlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNpZ25hdHVyZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2lnbmF0dXJlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNpZ25hdHVyZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTaWduYXR1cmVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NpZ25hdHVyZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduYXR1cmVfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmV9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2lnbmF0dXJlX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIHRvUHJlcGFyZWRTaWduYXR1cmUobWVzc2FnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MobWVzc2FnZSwgV29yZCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IG1lc3NhZ2UuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnNpZ25hdHVyZV90b1ByZXBhcmVkU2lnbmF0dXJlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYyID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2lnbmF0dXJlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTaWduYXR1cmUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNpZ25pbmdJbnB1dHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2lnbmluZ2lucHV0c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTaWduaW5nSW5wdXRzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaWduaW5nSW5wdXRzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNpZ25pbmdJbnB1dHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2lnbmluZ0lucHV0c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2lnbmluZ2lucHV0c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TdW1tYXJ5fSBzdW1tYXJ5XG4gICAgICogQHJldHVybnMge1NpZ25pbmdJbnB1dHN9XG4gICAgICovXG4gICAgc3RhdGljIG5ld1RyYW5zYWN0aW9uU3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzdW1tYXJ5LCBUcmFuc2FjdGlvblN1bW1hcnkpO1xuICAgICAgICB2YXIgcHRyMCA9IHN1bW1hcnkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c19uZXdUcmFuc2FjdGlvblN1bW1hcnkocHRyMCk7XG4gICAgICAgIHJldHVybiBTaWduaW5nSW5wdXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZlbHRbXX0gZmVsdHNcbiAgICAgKiBAcmV0dXJucyB7U2lnbmluZ0lucHV0c31cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3QXJiaXRyYXJ5KGZlbHRzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChmZWx0cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c19uZXdBcmJpdHJhcnkocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBTaWduaW5nSW5wdXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHdvcmRcbiAgICAgKiBAcmV0dXJucyB7U2lnbmluZ0lucHV0c31cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3QmxpbmQod29yZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mod29yZCwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c19uZXdCbGluZCh3b3JkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTaWduaW5nSW5wdXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdW1tYXJ5fVxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uU3VtbWFyeVBheWxvYWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2lnbmluZ2lucHV0c190cmFuc2FjdGlvblN1bW1hcnlQYXlsb2FkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdW1tYXJ5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0QXJyYXl9XG4gICAgICovXG4gICAgYXJiaXRyYXJ5UGF5bG9hZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zaWduaW5naW5wdXRzX2FyYml0cmFyeVBheWxvYWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGZWx0QXJyYXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgYmxpbmRQYXlsb2FkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNpZ25pbmdpbnB1dHNfYmxpbmRQYXlsb2FkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U2lnbmluZ0lucHV0c1R5cGV9XG4gICAgICovXG4gICAgZ2V0IHZhcmlhbnRUeXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfdmFyaWFudFR5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICB0b0NvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c190b0NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRBcnJheX1cbiAgICAgKi9cbiAgICB0b0VsZW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfdG9FbGVtZW50cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0QXJyYXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7U2lnbmluZ0lucHV0c31cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zaWduaW5naW5wdXRzX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNpZ25pbmdJbnB1dHMuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNpZ25pbmdJbnB1dHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNpZ25pbmdJbnB1dHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNsb3RBbmRLZXlzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Nsb3RhbmRrZXlzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNsb3RBbmRLZXlzIHtcblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBTbG90QW5kS2V5cykpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2xvdEFuZEtleXNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Nsb3RhbmRrZXlzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0b3JhZ2Vfc2xvdF9pbmRleFxuICAgICAqIEBwYXJhbSB7V29yZFtdfSBzdG9yYWdlX21hcF9rZXlzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZV9zbG90X2luZGV4LCBzdG9yYWdlX21hcF9rZXlzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChzdG9yYWdlX21hcF9rZXlzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zbG90YW5ka2V5c19uZXcoc3RvcmFnZV9zbG90X2luZGV4LCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFNsb3RBbmRLZXlzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgc3RvcmFnZV9zbG90X2luZGV4KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNsb3RhbmRrZXlzX3N0b3JhZ2Vfc2xvdF9pbmRleCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkW119XG4gICAgICovXG4gICAgc3RvcmFnZV9tYXBfa2V5cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zbG90YW5ka2V5c19zdG9yYWdlX21hcF9rZXlzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2xvdEFuZEtleXMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNsb3RBbmRLZXlzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTdG9yYWdlTWFwRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3N0b3JhZ2VtYXBfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU3RvcmFnZU1hcCB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFN0b3JhZ2VNYXBGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3N0b3JhZ2VtYXBfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlbWFwX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgU3RvcmFnZU1hcEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IGtleVxuICAgICAqIEBwYXJhbSB7V29yZH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moa2V5LCBXb3JkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHZhbHVlLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlbWFwX2luc2VydCh0aGlzLl9fd2JnX3B0ciwga2V5Ll9fd2JnX3B0ciwgdmFsdWUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTdG9yYWdlTWFwLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTdG9yYWdlTWFwLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTdG9yYWdlU2xvdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zdG9yYWdlc2xvdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTdG9yYWdlU2xvdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU3RvcmFnZVNsb3QucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU3RvcmFnZVNsb3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBTdG9yYWdlU2xvdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU3RvcmFnZVNsb3RGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3N0b3JhZ2VzbG90X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdG9yYWdlU2xvdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2YWx1ZSwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZXNsb3RfZnJvbVZhbHVlKHZhbHVlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTdG9yYWdlU2xvdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0b3JhZ2VTbG90fVxuICAgICAqL1xuICAgIHN0YXRpYyBlbXB0eVZhbHVlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VzbG90X2VtcHR5VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIFN0b3JhZ2VTbG90Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VNYXB9IHN0b3JhZ2VfbWFwXG4gICAgICogQHJldHVybnMge1N0b3JhZ2VTbG90fVxuICAgICAqL1xuICAgIHN0YXRpYyBtYXAoc3RvcmFnZV9tYXApIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JhZ2VfbWFwLCBTdG9yYWdlTWFwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlc2xvdF9tYXAoc3RvcmFnZV9tYXAuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFN0b3JhZ2VTbG90Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU3RvcmFnZVNsb3QucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFN0b3JhZ2VTbG90LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTdG9yYWdlU2xvdEFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3N0b3JhZ2VzbG90YXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU3RvcmFnZVNsb3RBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFN0b3JhZ2VTbG90QXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3N0b3JhZ2VzbG90YXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VTbG90W10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VzbG90YXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgU3RvcmFnZVNsb3RBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtTdG9yYWdlU2xvdH1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zdG9yYWdlc2xvdGFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlU2xvdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VTbG90fSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBTdG9yYWdlU2xvdCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnN0b3JhZ2VzbG90YXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VTbG90fSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBTdG9yYWdlU2xvdCk7XG4gICAgICAgIHdhc20uc3RvcmFnZXNsb3RhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VzbG90YXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFN0b3JhZ2VTbG90QXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFN0b3JhZ2VTbG90QXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFN5bmNTdW1tYXJ5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3N5bmNzdW1tYXJ5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFN5bmNTdW1tYXJ5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTeW5jU3VtbWFyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTeW5jU3VtbWFyeUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTeW5jU3VtbWFyeUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc3luY3N1bW1hcnlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJsb2NrTnVtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN5bmNzdW1tYXJ5X2Jsb2NrTnVtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZFtdfVxuICAgICAqL1xuICAgIGNvbW1pdHRlZE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnN5bmNzdW1tYXJ5X2NvbW1pdHRlZE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkW119XG4gICAgICovXG4gICAgY29uc3VtZWROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zeW5jc3VtbWFyeV9jb25zdW1lZE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkW119XG4gICAgICovXG4gICAgdXBkYXRlZEFjY291bnRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnN5bmNzdW1tYXJ5X3VwZGF0ZWRBY2NvdW50cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uSWRbXX1cbiAgICAgKi9cbiAgICBjb21taXR0ZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc3luY3N1bW1hcnlfY29tbWl0dGVkVHJhbnNhY3Rpb25zKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3luY3N1bW1hcnlfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtTeW5jU3VtbWFyeX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zeW5jc3VtbWFyeV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTeW5jU3VtbWFyeS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU3luY1N1bW1hcnkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFN5bmNTdW1tYXJ5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUZXN0VXRpbHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdGVzdHV0aWxzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRlc3RVdGlscyB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRlc3RVdGlsc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdGVzdHV0aWxzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTW9ja0FjY291bnRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50ZXN0dXRpbHNfY3JlYXRlTW9ja0FjY291bnRJZCgpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTW9ja1NlcmlhbGl6ZWRQYWNrYWdlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRlc3R1dGlsc19jcmVhdGVNb2NrU2VyaWFsaXplZFBhY2thZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRlc3RVdGlscy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVGVzdFV0aWxzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUb2tlblN5bWJvbEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190b2tlbnN5bWJvbF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUb2tlblN5bWJvbCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVG9rZW5TeW1ib2wucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVG9rZW5TeW1ib2xGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVG9rZW5TeW1ib2xGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Rva2Vuc3ltYm9sX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc3ltYm9sLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS50b2tlbnN5bWJvbF9uZXcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByMCA+Pj4gMDtcbiAgICAgICAgICAgIFRva2VuU3ltYm9sRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50b2tlbnN5bWJvbF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBsZW4xO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUb2tlblN5bWJvbC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVG9rZW5TeW1ib2wucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uQXJnc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbmFyZ3NfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25BcmdzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvbkFyZ3MucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25BcmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uQXJnc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25hcmdzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU2NyaXB0IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHR4U2NyaXB0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uYXJnc190eFNjcmlwdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBUcmFuc2FjdGlvblNjcmlwdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSWR9IG5vdGVfaWRcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXROb3RlQXJncyhub3RlX2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2lkLCBOb3RlSWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uYXJnc19nZXROb3RlQXJncyh0aGlzLl9fd2JnX3B0ciwgbm90ZV9pZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FkdmljZUlucHV0c31cbiAgICAgKi9cbiAgICBhZHZpY2VJbnB1dHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25hcmdzX2FkdmljZUlucHV0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBZHZpY2VJbnB1dHMuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvbkFyZ3MucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uQXJncy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25GaWx0ZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25maWx0ZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25GaWx0ZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uRmlsdGVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uRmlsdGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uRmlsdGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbmZpbHRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkZpbHRlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYWxsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uZmlsdGVyX2FsbCgpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25GaWx0ZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25JZFtdfSBpZHNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25GaWx0ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGlkcyhpZHMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGlkcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25maWx0ZXJfaWRzKHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25GaWx0ZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkZpbHRlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgdW5jb21taXR0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25maWx0ZXJfdW5jb21taXR0ZWQoKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmlsdGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tfbnVtXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uRmlsdGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBleHBpcmVkQmVmb3JlKGJsb2NrX251bSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uZmlsdGVyX2V4cGlyZWRCZWZvcmUoYmxvY2tfbnVtKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmlsdGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25GaWx0ZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uRmlsdGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvbklkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uaWRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25JZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25JZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvbklkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb25JZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25JZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25pZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgYXNFbGVtZW50cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbmlkX2FzRWxlbWVudHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGFzQnl0ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25pZF9hc0J5dGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0hleCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25pZF90b0hleChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgaW5uZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25JZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25JZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25Qcm92ZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25wcm92ZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25Qcm92ZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uUHJvdmVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uUHJvdmVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uUHJvdmVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnByb3Zlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblByb3Zlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3TG9jYWxQcm92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25wcm92ZXJfbmV3TG9jYWxQcm92ZXIoKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUHJvdmVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25Qcm92ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIG5ld1JlbW90ZVByb3ZlcihlbmRwb2ludCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZW5kcG9pbnQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnByb3Zlcl9uZXdSZW1vdGVQcm92ZXIocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblByb3Zlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucHJvdmVyX3NlcmlhbGl6ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3Zlcl90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbZW5kcG9pbnRdXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUHJvdmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShwcm92ZXJfdHlwZSwgZW5kcG9pbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHByb3Zlcl90eXBlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKGVuZHBvaW50KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChlbmRwb2ludCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucHJvdmVyX2Rlc2VyaWFsaXplKHJldHB0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblByb3Zlci5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGVuZHBvaW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucHJvdmVyX2VuZHBvaW50KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25Qcm92ZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uUHJvdmVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblJlY29yZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlY29yZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblJlY29yZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25SZWNvcmQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25SZWNvcmRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25SZWNvcmRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVjb3JkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGFjY291bnRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF9hY2NvdW50SWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBpbml0QWNjb3VudFN0YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX2luaXRBY2NvdW50U3RhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgZmluYWxBY2NvdW50U3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfZmluYWxBY2NvdW50U3RhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmRbXX1cbiAgICAgKi9cbiAgICBpbnB1dE5vdGVOdWxsaWZpZXJzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX2lucHV0Tm90ZU51bGxpZmllcnMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3Rlc31cbiAgICAgKi9cbiAgICBvdXRwdXROb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF9vdXRwdXROb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3Rlcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBibG9ja051bSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF9ibG9ja051bSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN0YXR1c31cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvblN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF90cmFuc2FjdGlvblN0YXR1cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBjcmVhdGlvblRpbWVzdGFtcCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF9jcmVhdGlvblRpbWVzdGFtcCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uUmVjb3JkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblJlY29yZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25SZXF1ZXN0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVxdWVzdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblJlcXVlc3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblJlcXVlc3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXF1ZXN0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlcXVlc3RfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdF9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3QuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVbXX1cbiAgICAgKi9cbiAgICBleHBlY3RlZE91dHB1dE93bk5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdF9leHBlY3RlZE91dHB1dE93bk5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRGV0YWlsc0FuZFRhZ1tdfVxuICAgICAqL1xuICAgIGV4cGVjdGVkRnV0dXJlTm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0X2V4cGVjdGVkRnV0dXJlTm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgc2NyaXB0QXJnKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdF9zY3JpcHRBcmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgYXV0aEFyZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RfYXV0aEFyZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25SZXF1ZXN0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblJlcXVlc3QucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUFuZEFyZ3NBcnJheX0gbm90ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoVW5hdXRoZW50aWNhdGVkSW5wdXROb3Rlcyhub3Rlcykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZXMsIE5vdGVBbmRBcmdzQXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aFVuYXV0aGVudGljYXRlZElucHV0Tm90ZXMocHRyLCBub3Rlcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSWRBbmRBcmdzQXJyYXl9IG5vdGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEF1dGhlbnRpY2F0ZWRJbnB1dE5vdGVzKG5vdGVzKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlcywgTm90ZUlkQW5kQXJnc0FycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhBdXRoZW50aWNhdGVkSW5wdXROb3RlcyhwdHIsIG5vdGVzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGVBcnJheX0gbm90ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoT3duT3V0cHV0Tm90ZXMobm90ZXMpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVzLCBPdXRwdXROb3RlQXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aE93bk91dHB1dE5vdGVzKHB0ciwgbm90ZXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TY3JpcHR9IHNjcmlwdFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhDdXN0b21TY3JpcHQoc2NyaXB0KSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzY3JpcHQsIFRyYW5zYWN0aW9uU2NyaXB0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhDdXN0b21TY3JpcHQocHRyLCBzY3JpcHQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZVJlY2lwaWVudEFycmF5fSByZWNpcGllbnRzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEV4cGVjdGVkT3V0cHV0UmVjaXBpZW50cyhyZWNpcGllbnRzKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyZWNpcGllbnRzLCBOb3RlUmVjaXBpZW50QXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aEV4cGVjdGVkT3V0cHV0UmVjaXBpZW50cyhwdHIsIHJlY2lwaWVudHMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZURldGFpbHNBbmRUYWdBcnJheX0gbm90ZV9kZXRhaWxzX2FuZF90YWdcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoRXhwZWN0ZWRGdXR1cmVOb3Rlcyhub3RlX2RldGFpbHNfYW5kX3RhZykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9kZXRhaWxzX2FuZF90YWcsIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aEV4cGVjdGVkRnV0dXJlTm90ZXMocHRyLCBub3RlX2RldGFpbHNfYW5kX3RhZy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBZHZpY2VNYXB9IGFkdmljZV9tYXBcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICBleHRlbmRBZHZpY2VNYXAoYWR2aWNlX21hcCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWR2aWNlX21hcCwgQWR2aWNlTWFwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX2V4dGVuZEFkdmljZU1hcChwdHIsIGFkdmljZV9tYXAuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Rm9yZWlnbkFjY291bnRBcnJheX0gZm9yZWlnbl9hY2NvdW50c1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhGb3JlaWduQWNjb3VudHMoZm9yZWlnbl9hY2NvdW50cykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZm9yZWlnbl9hY2NvdW50cywgRm9yZWlnbkFjY291bnRBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoRm9yZWlnbkFjY291bnRzKHB0ciwgZm9yZWlnbl9hY2NvdW50cy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBzY3JpcHRfYXJnXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aFNjcmlwdEFyZyhzY3JpcHRfYXJnKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzY3JpcHRfYXJnLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhTY3JpcHRBcmcocHRyLCBzY3JpcHRfYXJnLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IGF1dGhfYXJnXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEF1dGhBcmcoYXV0aF9hcmcpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGF1dGhfYXJnLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhBdXRoQXJnKHB0ciwgYXV0aF9hcmcuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl9idWlsZChwdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25SZXN1bHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25yZXN1bHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogV0FTTSB3cmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIFtgVHJhbnNhY3Rpb25SZXN1bHRgXS5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25SZXN1bHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uUmVzdWx0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVzdWx0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVzdWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlc3VsdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25JZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtFeGVjdXRlZFRyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIGV4ZWN1dGVkVHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXN1bHRfZXhlY3V0ZWRUcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBFeGVjdXRlZFRyYW5zYWN0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5vdGVzIHRoYXQgYXJlIGV4cGVjdGVkIHRvIGJlIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgZm9sbG93LXVwIGV4ZWN1dGlvbnMuXG4gICAgICogQHJldHVybnMge05vdGVEZXRhaWxzQW5kVGFnW119XG4gICAgICovXG4gICAgZnV0dXJlTm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25yZXN1bHRfZnV0dXJlTm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIHRyYW5zYWN0aW9uIHJlc3VsdCBpbnRvIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlc3VsdF9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZXMgYSB0cmFuc2FjdGlvbiByZXN1bHQgZnJvbSBieXRlcy5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVzdWx0fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucmVzdWx0X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVzdWx0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblJlc3VsdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25SZXN1bHQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uU2NyaXB0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uU2NyaXB0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblNjcmlwdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25zY3JpcHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICByb290KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVzY3JpcHRfcm9vdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25TY3JpcHQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uU2NyaXB0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcikpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSB3b3JkXG4gICAgICogQHBhcmFtIHtGZWx0QXJyYXl9IGZlbHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod29yZCwgZmVsdHMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHdvcmQsIFdvcmQpO1xuICAgICAgICB2YXIgcHRyMCA9IHdvcmQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmZWx0cywgRmVsdEFycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcl9uZXcocHRyMCwgZmVsdHMuX193YmdfcHRyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHdvcmQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdEFycmF5fVxuICAgICAqL1xuICAgIGZlbHRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyX2ZlbHRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHRBcnJheS5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcmFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcmFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcltdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcmFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJ9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcn0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcmFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcn0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIpO1xuICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3Rlc2FycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblN0YXR1c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnN0YXR1c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblN0YXR1cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25TdGF0dXMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25TdGF0dXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TdGF0dXNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc3RhdHVzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3RhdHVzfVxuICAgICAqL1xuICAgIHN0YXRpYyBwZW5kaW5nKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX3BlbmRpbmcoKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tfbnVtXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGNvbW1pdF90aW1lc3RhbXBcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdGF0dXN9XG4gICAgICovXG4gICAgc3RhdGljIGNvbW1pdHRlZChibG9ja19udW0sIGNvbW1pdF90aW1lc3RhbXApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19jb21taXR0ZWQoYmxvY2tfbnVtLCBjb21taXRfdGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F1c2VcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdGF0dXN9XG4gICAgICovXG4gICAgc3RhdGljIGRpc2NhcmRlZChjYXVzZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY2F1c2UsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19kaXNjYXJkZWQocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQZW5kaW5nKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2lzUGVuZGluZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29tbWl0dGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2lzQ29tbWl0dGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNEaXNjYXJkZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfaXNEaXNjYXJkZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEJsb2NrTnVtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2dldEJsb2NrTnVtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMHgxMDAwMDAwMDEgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0Q29tbWl0VGltZXN0YW1wKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2dldENvbW1pdFRpbWVzdGFtcChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEJpZ0ludDY0KHJldHB0ciArIDggKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IEJpZ0ludC5hc1VpbnROKDY0LCByMik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblN0YXR1cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25TdGF0dXMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uU3RvcmVVcGRhdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblN0b3JlVXBkYXRlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblN0b3JlVXBkYXRlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFeGVjdXRlZFRyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIGV4ZWN1dGVkVHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9leGVjdXRlZFRyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEV4ZWN1dGVkVHJhbnNhY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgc3VibWlzc2lvbkhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX3N1Ym1pc3Npb25IZWlnaHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZXN9XG4gICAgICovXG4gICAgY3JlYXRlZE5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfY3JlYXRlZE5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudERlbHRhfVxuICAgICAqL1xuICAgIGFjY291bnREZWx0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX2FjY291bnREZWx0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50RGVsdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRGV0YWlsc0FuZFRhZ1tdfVxuICAgICAqL1xuICAgIGZ1dHVyZU5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfZnV0dXJlTm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdG9yZVVwZGF0ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uU3VtbWFyeUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnN1bW1hcnlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25TdW1tYXJ5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblN1bW1hcnkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25TdW1tYXJ5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU3VtbWFyeUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25zdW1tYXJ5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3VtbWFyeV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3VtbWFyeX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN1bW1hcnlfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdW1tYXJ5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50RGVsdGF9XG4gICAgICovXG4gICAgYWNjb3VudERlbHRhKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3VtbWFyeV9hY2NvdW50RGVsdGEocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50RGVsdGEuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZXN9XG4gICAgICovXG4gICAgaW5wdXROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN1bW1hcnlfaW5wdXROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElucHV0Tm90ZXMuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVzfVxuICAgICAqL1xuICAgIG91dHB1dE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3VtbWFyeV9vdXRwdXROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE91dHB1dE5vdGVzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHNhbHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdW1tYXJ5X3NhbHQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblN1bW1hcnkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uU3VtbWFyeS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgV2ViQ2xpZW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3dlYmNsaWVudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBXZWJDbGllbnQge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBXZWJDbGllbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3dlYmNsaWVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnRIZWFkZXJbXT59XG4gICAgICovXG4gICAgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldEFjY291bnRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50IHwgdW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50KGFjY291bnRfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldEFjY291bnQodGhpcy5fX3diZ19wdHIsIGFjY291bnRfaWQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBwdWJfa2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aFNlY3JldEtleT59XG4gICAgICovXG4gICAgZ2V0QWNjb3VudEF1dGhCeVB1YktleShwdWJfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwdWJfa2V5LCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0QWNjb3VudEF1dGhCeVB1YktleSh0aGlzLl9fd2JnX3B0ciwgcHViX2tleS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGluc2VydEFjY291bnRBZGRyZXNzKGFjY291bnRfaWQsIGFkZHJlc3MpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhZGRyZXNzLCBBZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfaW5zZXJ0QWNjb3VudEFkZHJlc3ModGhpcy5fX3diZ19wdHIsIGFjY291bnRfaWQuX193YmdfcHRyLCBhZGRyZXNzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVtb3ZlQWNjb3VudEFkZHJlc3MoYWNjb3VudF9pZCwgYWRkcmVzcykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFkZHJlc3MsIEFkZHJlc3MpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9yZW1vdmVBY2NvdW50QWRkcmVzcyh0aGlzLl9fd2JnX3B0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIsIGFkZHJlc3MuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5vdGVfaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwb3J0X3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3RlRmlsZT59XG4gICAgICovXG4gICAgZXhwb3J0Tm90ZUZpbGUobm90ZV9pZCwgZXhwb3J0X3R5cGUpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG5vdGVfaWQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKGV4cG9ydF90eXBlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2V4cG9ydE5vdGVGaWxlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbnRpcmUgdW5kZXJseWluZyB3ZWIgc3RvcmUgYW5kIHJldHVybnMgaXQgYXMgYSBgSnNWYWx1ZWBcbiAgICAgKlxuICAgICAqIE1lYW50IHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYGZvcmNlX2ltcG9ydF9zdG9yZWAgbWV0aG9kXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBleHBvcnRTdG9yZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZXhwb3J0U3RvcmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnRGaWxlPn1cbiAgICAgKi9cbiAgICBleHBvcnRBY2NvdW50RmlsZShhY2NvdW50X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICB2YXIgcHRyMCA9IGFjY291bnRfaWQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2V4cG9ydEFjY291bnRGaWxlKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50RmlsZX0gYWNjb3VudF9maWxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBpbXBvcnRBY2NvdW50RmlsZShhY2NvdW50X2ZpbGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfZmlsZSwgQWNjb3VudEZpbGUpO1xuICAgICAgICB2YXIgcHRyMCA9IGFjY291bnRfZmlsZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfaW1wb3J0QWNjb3VudEZpbGUodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGluaXRfc2VlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdXRoX3NjaGVtZV9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnQ+fVxuICAgICAqL1xuICAgIGltcG9ydFB1YmxpY0FjY291bnRGcm9tU2VlZChpbml0X3NlZWQsIG11dGFibGUsIGF1dGhfc2NoZW1lX2lkKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChpbml0X3NlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9pbXBvcnRQdWJsaWNBY2NvdW50RnJvbVNlZWQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIG11dGFibGUsIGF1dGhfc2NoZW1lX2lkKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGltcG9ydEFjY291bnRCeUlkKGFjY291bnRfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ltcG9ydEFjY291bnRCeUlkKHRoaXMuX193YmdfcHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUZpbGV9IG5vdGVfZmlsZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGVJZD59XG4gICAgICovXG4gICAgaW1wb3J0Tm90ZUZpbGUobm90ZV9maWxlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2ZpbGUsIE5vdGVGaWxlKTtcbiAgICAgICAgdmFyIHB0cjAgPSBub3RlX2ZpbGUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ltcG9ydE5vdGVGaWxlKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IHN0b3JlX2R1bXBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGZvcmNlSW1wb3J0U3RvcmUoc3RvcmVfZHVtcCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9mb3JjZUltcG9ydFN0b3JlKHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KHN0b3JlX2R1bXApKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGllbnQgd2l0aCBhIG1vY2sgUlBDIEFQSS4gVXNlZnVsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCBwcm9vZi1vZi1jb25jZXB0XG4gICAgICogYXBwbGljYXRpb25zIGFzIGl0IHVzZXMgYSBtb2NrIGNoYWluIHRoYXQgc2ltdWxhdGVzIHRoZSBiZWhhdmlvciBvZiBhIHJlYWwgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VlZF1cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VyaWFsaXplZF9tb2NrX2NoYWluXVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZXJpYWxpemVkX21vY2tfbm90ZV90cmFuc3BvcnRfbm9kZV1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGNyZWF0ZU1vY2tDbGllbnQoc2VlZCwgc2VyaWFsaXplZF9tb2NrX2NoYWluLCBzZXJpYWxpemVkX21vY2tfbm90ZV90cmFuc3BvcnRfbm9kZSkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoc2VlZCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUoc2VyaWFsaXplZF9tb2NrX2NoYWluKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZXJpYWxpemVkX21vY2tfY2hhaW4sIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjIgPSBpc0xpa2VOb25lKHNlcmlhbGl6ZWRfbW9ja19ub3RlX3RyYW5zcG9ydF9ub2RlKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZXJpYWxpemVkX21vY2tfbm90ZV90cmFuc3BvcnRfbm9kZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9jcmVhdGVNb2NrQ2xpZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5uZXIgc2VyaWFsaXplZCBtb2NrIGNoYWluIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemVNb2NrQ2hhaW4oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X3NlcmlhbGl6ZU1vY2tDaGFpbihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5uZXIgc2VyaWFsaXplZCBtb2NrIG5vdGUgdHJhbnNwb3J0IG5vZGUgaWYgaXQgZXhpc3RzLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZU1vY2tOb3RlVHJhbnNwb3J0Tm9kZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfc2VyaWFsaXplTW9ja05vdGVUcmFuc3BvcnROb2RlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm92ZUJsb2NrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9wcm92ZUJsb2NrKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHVzZXNNb2NrQ2hhaW4oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3VzZXNNb2NrQ2hhaW4odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRTdG9yYWdlTW9kZX0gc3RvcmFnZV9tb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdXRhYmxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1dGhfc2NoZW1lX2lkXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW2luaXRfc2VlZF1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50Pn1cbiAgICAgKi9cbiAgICBuZXdXYWxsZXQoc3RvcmFnZV9tb2RlLCBtdXRhYmxlLCBhdXRoX3NjaGVtZV9pZCwgaW5pdF9zZWVkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yYWdlX21vZGUsIEFjY291bnRTdG9yYWdlTW9kZSk7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShpbml0X3NlZWQpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKGluaXRfc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9uZXdXYWxsZXQodGhpcy5fX3diZ19wdHIsIHN0b3JhZ2VfbW9kZS5fX3diZ19wdHIsIG11dGFibGUsIGF1dGhfc2NoZW1lX2lkLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50U3RvcmFnZU1vZGV9IHN0b3JhZ2VfbW9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9uX2Z1bmdpYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuX3N5bWJvbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsc1xuICAgICAqIEBwYXJhbSB7YmlnaW50fSBtYXhfc3VwcGx5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1dGhfc2NoZW1lX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudD59XG4gICAgICovXG4gICAgbmV3RmF1Y2V0KHN0b3JhZ2VfbW9kZSwgbm9uX2Z1bmdpYmxlLCB0b2tlbl9zeW1ib2wsIGRlY2ltYWxzLCBtYXhfc3VwcGx5LCBhdXRoX3NjaGVtZV9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmFnZV9tb2RlLCBBY2NvdW50U3RvcmFnZU1vZGUpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodG9rZW5fc3ltYm9sLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X25ld0ZhdWNldCh0aGlzLl9fd2JnX3B0ciwgc3RvcmFnZV9tb2RlLl9fd2JnX3B0ciwgbm9uX2Z1bmdpYmxlLCBwdHIwLCBsZW4wLCBkZWNpbWFscywgbWF4X3N1cHBseSwgYXV0aF9zY2hlbWVfaWQpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnR9IGFjY291bnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIG5ld0FjY291bnQoYWNjb3VudCwgb3ZlcndyaXRlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50LCBBY2NvdW50KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfbmV3QWNjb3VudCh0aGlzLl9fd2JnX3B0ciwgYWNjb3VudC5fX3diZ19wdHIsIG92ZXJ3cml0ZSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2VjcmV0S2V5fSBzZWNyZXRfa2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYWRkQWNjb3VudFNlY3JldEtleVRvV2ViU3RvcmUoc2VjcmV0X2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VjcmV0X2tleSwgU2VjcmV0S2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfYWRkQWNjb3VudFNlY3JldEtleVRvV2ViU3RvcmUodGhpcy5fX3diZ19wdHIsIHNlY3JldF9rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSB0cmFuc2FjdGlvbiBzcGVjaWZpZWQgYnkgdGhlIHJlcXVlc3QgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIGFjY291bnQsXG4gICAgICogcHJvdmVzIGl0LCBzdWJtaXRzIGl0IHRvIHRoZSBuZXR3b3JrLCBhbmQgdXBkYXRlcyB0aGUgbG9jYWwgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdHJhbnNhY3Rpb24gdXRpbGl6ZXMgZm9yZWlnbiBhY2NvdW50IGRhdGEsIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgdGhlIGNsaWVudCBkb2Vzbid0XG4gICAgICogaGF2ZSB0aGUgcmVxdWlyZWQgYmxvY2sgaGVhZGVyIGluIHRoZSBsb2NhbCBkYXRhYmFzZS4gSW4gdGhlc2Ugc2NlbmFyaW9zLCBhIHN5bmMgdG9cbiAgICAgKiB0aGUgY2hhaW4gdGlwIGlzIHBlcmZvcm1lZCwgYW5kIHRoZSByZXF1aXJlZCBibG9jayBoZWFkZXIgaXMgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlcXVlc3R9IHRyYW5zYWN0aW9uX3JlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbklkPn1cbiAgICAgKi9cbiAgICBzdWJtaXROZXdUcmFuc2FjdGlvbihhY2NvdW50X2lkLCB0cmFuc2FjdGlvbl9yZXF1ZXN0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNhY3Rpb25fcmVxdWVzdCwgVHJhbnNhY3Rpb25SZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfc3VibWl0TmV3VHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIsIGFjY291bnRfaWQuX193YmdfcHRyLCB0cmFuc2FjdGlvbl9yZXF1ZXN0Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgdHJhbnNhY3Rpb24gc3BlY2lmaWVkIGJ5IHRoZSByZXF1ZXN0IGFnYWluc3QgdGhlIHNwZWNpZmllZCBhY2NvdW50IGJ1dCBkb2VzIG5vdFxuICAgICAqIHN1Ym1pdCBpdCB0byB0aGUgbmV0d29yayBub3IgdXBkYXRlIHRoZSBsb2NhbCBkYXRhYmFzZS4gVGhlIHJldHVybmVkIFtgVHJhbnNhY3Rpb25SZXN1bHRgXVxuICAgICAqIHJldGFpbnMgdGhlIGV4ZWN1dGlvbiBhcnRpZmFjdHMgbmVlZGVkIHRvIGNvbnRpbnVlIHdpdGggdGhlIHRyYW5zYWN0aW9uIGxpZmVjeWNsZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0cmFuc2FjdGlvbiB1dGlsaXplcyBmb3JlaWduIGFjY291bnQgZGF0YSwgdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGUgY2xpZW50IGRvZXNuJ3RcbiAgICAgKiBoYXZlIHRoZSByZXF1aXJlZCBibG9jayBoZWFkZXIgaW4gdGhlIGxvY2FsIGRhdGFiYXNlLiBJbiB0aGVzZSBzY2VuYXJpb3MsIGEgc3luYyB0b1xuICAgICAqIHRoZSBjaGFpbiB0aXAgaXMgcGVyZm9ybWVkLCBhbmQgdGhlIHJlcXVpcmVkIGJsb2NrIGhlYWRlciBpcyByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVxdWVzdH0gdHJhbnNhY3Rpb25fcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uUmVzdWx0Pn1cbiAgICAgKi9cbiAgICBleGVjdXRlVHJhbnNhY3Rpb24oYWNjb3VudF9pZCwgdHJhbnNhY3Rpb25fcmVxdWVzdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zYWN0aW9uX3JlcXVlc3QsIFRyYW5zYWN0aW9uUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2V4ZWN1dGVUcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIsIHRyYW5zYWN0aW9uX3JlcXVlc3QuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdHJhbnNhY3Rpb24gcHJvb2YgdXNpbmcgZWl0aGVyIHRoZSBwcm92aWRlZCBwcm92ZXIgb3IgdGhlIGNsaWVudCdzIGRlZmF1bHRcbiAgICAgKiBwcm92ZXIgaWYgbm9uZSBpcyBzdXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVzdWx0fSB0cmFuc2FjdGlvbl9yZXN1bHRcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUHJvdmVyIHwgbnVsbH0gW3Byb3Zlcl1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm92ZW5UcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgcHJvdmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbl9yZXN1bHQsIHByb3Zlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNhY3Rpb25fcmVzdWx0LCBUcmFuc2FjdGlvblJlc3VsdCk7XG4gICAgICAgIGxldCBwdHIwID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKHByb3ZlcikpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhwcm92ZXIsIFRyYW5zYWN0aW9uUHJvdmVyKTtcbiAgICAgICAgICAgIHB0cjAgPSBwcm92ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfcHJvdmVUcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0ciwgdHJhbnNhY3Rpb25fcmVzdWx0Ll9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UHJvdmVuVHJhbnNhY3Rpb259IHByb3Zlbl90cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZXN1bHR9IHRyYW5zYWN0aW9uX3Jlc3VsdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgc3VibWl0UHJvdmVuVHJhbnNhY3Rpb24ocHJvdmVuX3RyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbl9yZXN1bHQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHByb3Zlbl90cmFuc2FjdGlvbiwgUHJvdmVuVHJhbnNhY3Rpb24pO1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNhY3Rpb25fcmVzdWx0LCBUcmFuc2FjdGlvblJlc3VsdCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3N1Ym1pdFByb3ZlblRyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyLCBwcm92ZW5fdHJhbnNhY3Rpb24uX193YmdfcHRyLCB0cmFuc2FjdGlvbl9yZXN1bHQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlc3VsdH0gdHJhbnNhY3Rpb25fcmVzdWx0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1Ym1pc3Npb25faGVpZ2h0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TdG9yZVVwZGF0ZT59XG4gICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbl9yZXN1bHQsIHN1Ym1pc3Npb25faGVpZ2h0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2FjdGlvbl9yZXN1bHQsIFRyYW5zYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfYXBwbHlUcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0ciwgdHJhbnNhY3Rpb25fcmVzdWx0Ll9fd2JnX3B0ciwgc3VibWlzc2lvbl9oZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gdGFyZ2V0X2FjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGFtb3VudFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgbmV3TWludFRyYW5zYWN0aW9uUmVxdWVzdCh0YXJnZXRfYWNjb3VudF9pZCwgZmF1Y2V0X2lkLCBub3RlX3R5cGUsIGFtb3VudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModGFyZ2V0X2FjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfbmV3TWludFRyYW5zYWN0aW9uUmVxdWVzdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCB0YXJnZXRfYWNjb3VudF9pZC5fX3diZ19wdHIsIGZhdWNldF9pZC5fX3diZ19wdHIsIG5vdGVfdHlwZSwgYW1vdW50KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gc2VuZGVyX2FjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gdGFyZ2V0X2FjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGFtb3VudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW3JlY2FsbF9oZWlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbdGltZWxvY2tfaGVpZ2h0XVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgbmV3U2VuZFRyYW5zYWN0aW9uUmVxdWVzdChzZW5kZXJfYWNjb3VudF9pZCwgdGFyZ2V0X2FjY291bnRfaWQsIGZhdWNldF9pZCwgbm90ZV90eXBlLCBhbW91bnQsIHJlY2FsbF9oZWlnaHQsIHRpbWVsb2NrX2hlaWdodCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VuZGVyX2FjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModGFyZ2V0X2FjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfbmV3U2VuZFRyYW5zYWN0aW9uUmVxdWVzdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBzZW5kZXJfYWNjb3VudF9pZC5fX3diZ19wdHIsIHRhcmdldF9hY2NvdW50X2lkLl9fd2JnX3B0ciwgZmF1Y2V0X2lkLl9fd2JnX3B0ciwgbm90ZV90eXBlLCBhbW91bnQsIGlzTGlrZU5vbmUocmVjYWxsX2hlaWdodCkgPyAweDEwMDAwMDAwMSA6IChyZWNhbGxfaGVpZ2h0KSA+Pj4gMCwgaXNMaWtlTm9uZSh0aW1lbG9ja19oZWlnaHQpID8gMHgxMDAwMDAwMDEgOiAodGltZWxvY2tfaGVpZ2h0KSA+Pj4gMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3QuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGlzdF9vZl9ub3RlX2lkc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgbmV3Q29uc3VtZVRyYW5zYWN0aW9uUmVxdWVzdChsaXN0X29mX25vdGVfaWRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChsaXN0X29mX25vdGVfaWRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9uZXdDb25zdW1lVHJhbnNhY3Rpb25SZXF1ZXN0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBzZW5kZXJfYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBvZmZlcmVkX2Fzc2V0X2Ftb3VudFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSByZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IHJlcXVlc3RlZF9hc3NldF9hbW91bnRcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBwYXliYWNrX25vdGVfdHlwZVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgbmV3U3dhcFRyYW5zYWN0aW9uUmVxdWVzdChzZW5kZXJfYWNjb3VudF9pZCwgb2ZmZXJlZF9hc3NldF9mYXVjZXRfaWQsIG9mZmVyZWRfYXNzZXRfYW1vdW50LCByZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkLCByZXF1ZXN0ZWRfYXNzZXRfYW1vdW50LCBub3RlX3R5cGUsIHBheWJhY2tfbm90ZV90eXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzZW5kZXJfYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfbmV3U3dhcFRyYW5zYWN0aW9uUmVxdWVzdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBzZW5kZXJfYWNjb3VudF9pZC5fX3diZ19wdHIsIG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkLl9fd2JnX3B0ciwgb2ZmZXJlZF9hc3NldF9hbW91bnQsIHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWQuX193YmdfcHRyLCByZXF1ZXN0ZWRfYXNzZXRfYW1vdW50LCBub3RlX3R5cGUsIHBheWJhY2tfbm90ZV90eXBlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgcHJpdmF0ZSBub3RlIHZpYSB0aGUgbm90ZSB0cmFuc3BvcnQgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge05vdGV9IG5vdGVcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBzZW5kUHJpdmF0ZU5vdGUobm90ZSwgYWRkcmVzcykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZSwgTm90ZSk7XG4gICAgICAgIHZhciBwdHIwID0gbm90ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFkZHJlc3MsIEFkZHJlc3MpO1xuICAgICAgICB2YXIgcHRyMSA9IGFkZHJlc3MuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3NlbmRQcml2YXRlTm90ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgcHRyMSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHByaXZhdGUgbm90ZXMgZnJvbSB0aGUgbm90ZSB0cmFuc3BvcnQgbGF5ZXJcbiAgICAgKlxuICAgICAqIFVzZXMgYW4gaW50ZXJuYWwgcGFnaW5hdGlvbiBtZWNoYW5pc20gdG8gYXZvaWQgZmV0Y2hpbmcgZHVwbGljYXRlIG5vdGVzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGZldGNoUHJpdmF0ZU5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9mZXRjaFByaXZhdGVOb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFsbCBwcml2YXRlIG5vdGVzIGZyb20gdGhlIG5vdGUgdHJhbnNwb3J0IGxheWVyXG4gICAgICpcbiAgICAgKiBGZXRjaGVzIGFsbCBub3RlcyBzdG9yZWQgaW4gdGhlIHRyYW5zcG9ydCBsYXllciwgd2l0aCBubyBwYWdpbmF0aW9uLlxuICAgICAqIFByZWZlciB1c2luZyBbYFdlYkNsaWVudDo6ZmV0Y2hfcHJpdmF0ZV9ub3Rlc2BdIGZvciBhIG1vcmUgZWZmaWNpZW50LCBvbi1nb2luZyxcbiAgICAgKiBmZXRjaGluZyBtZWNoYW5pc20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgZmV0Y2hBbGxQcml2YXRlTm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ZldGNoQWxsUHJpdmF0ZU5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRmlsdGVyfSBmaWx0ZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnB1dE5vdGVSZWNvcmRbXT59XG4gICAgICovXG4gICAgZ2V0SW5wdXROb3RlcyhmaWx0ZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZpbHRlciwgTm90ZUZpbHRlcik7XG4gICAgICAgIHZhciBwdHIwID0gZmlsdGVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRJbnB1dE5vdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5vdGVfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnB1dE5vdGVSZWNvcmQgfCB1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGdldElucHV0Tm90ZShub3RlX2lkKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChub3RlX2lkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldElucHV0Tm90ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUZpbHRlcn0gZmlsdGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRPdXRwdXROb3RlcyhmaWx0ZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZpbHRlciwgTm90ZUZpbHRlcik7XG4gICAgICAgIHZhciBwdHIwID0gZmlsdGVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRPdXRwdXROb3Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBub3RlX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRPdXRwdXROb3RlKG5vdGVfaWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG5vdGVfaWQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0T3V0cHV0Tm90ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkIHwgbnVsbH0gW2FjY291bnRfaWRdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29uc3VtYWJsZU5vdGVSZWNvcmRbXT59XG4gICAgICovXG4gICAgZ2V0Q29uc3VtYWJsZU5vdGVzKGFjY291bnRfaWQpIHtcbiAgICAgICAgbGV0IHB0cjAgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYWNjb3VudF9pZCkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgcHRyMCA9IGFjY291bnRfaWQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0Q29uc3VtYWJsZU5vdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzZXR0aW5nIHZhbHVlIGZvciBga2V5YCwgb3IgYE5vbmVgIGlmIGl0IGhhc27igJl0IGJlZW4gc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnkgfCB1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGdldFNldHRpbmcoa2V5KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChrZXksIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0U2V0dGluZyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBzZXR0aW5nIGtleS12YWx1ZSBpbiB0aGUgc3RvcmUuIEl0IGNhbiB0aGVuIGJlIHJldHJpZXZlZCB1c2luZyBgZ2V0X3NldHRpbmdgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBzZXRTZXR0aW5nKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGtleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9zZXRTZXR0aW5nKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBhZGRIZWFwT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBzZXR0aW5nIGtleS12YWx1ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVtb3ZlU2V0dGluZyhrZXkpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGtleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9yZW1vdmVTZXR0aW5nKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGV4aXN0aW5nIHNldHRpbmcga2V5cyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59XG4gICAgICovXG4gICAgbGlzdFNldHRpbmdLZXlzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9saXN0U2V0dGluZ0tleXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTeW5jU3VtbWFyeT59XG4gICAgICovXG4gICAgc3luY1N0YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9zeW5jU3RhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgICAqL1xuICAgIGdldFN5bmNIZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldFN5bmNIZWlnaHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gb2ZmZXJlZF9hc3NldF9mYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gb2ZmZXJlZF9hc3NldF9hbW91bnRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gcmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7YmlnaW50fSByZXF1ZXN0ZWRfYXNzZXRfYW1vdW50XG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkU3dhcFRhZyhub3RlX3R5cGUsIG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkLCBvZmZlcmVkX2Fzc2V0X2Ftb3VudCwgcmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZCwgcmVxdWVzdGVkX2Fzc2V0X2Ftb3VudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Mob2ZmZXJlZF9hc3NldF9mYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X2J1aWxkU3dhcFRhZyhyZXRwdHIsIG5vdGVfdHlwZSwgb2ZmZXJlZF9hc3NldF9mYXVjZXRfaWQuX193YmdfcHRyLCBvZmZlcmVkX2Fzc2V0X2Ftb3VudCwgcmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZC5fX3diZ19wdHIsIHJlcXVlc3RlZF9hc3NldF9hbW91bnQpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYWRkVGFnKHRhZykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodGFnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2FkZFRhZyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICByZW1vdmVUYWcodGFnKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0YWcsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfcmVtb3ZlVGFnKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBsaXN0VGFncygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfbGlzdFRhZ3ModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uRmlsdGVyfSB0cmFuc2FjdGlvbl9maWx0ZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblJlY29yZFtdPn1cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25fZmlsdGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2FjdGlvbl9maWx0ZXIsIFRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICAgICAgdmFyIHB0cjAgPSB0cmFuc2FjdGlvbl9maWx0ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldFRyYW5zYWN0aW9ucyh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFdlYkNsaWVudEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsaWVudCB3aXRoIHRoZSBnaXZlbiBub2RlIFVSTCBhbmQgb3B0aW9uYWwgc2VlZC5cbiAgICAgKiBJZiBgbm9kZV91cmxgIGlzIGBOb25lYCwgaXQgZGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbbm9kZV91cmxdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbbm9kZV9ub3RlX3RyYW5zcG9ydF91cmxdXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlZWRdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjcmVhdGVDbGllbnQobm9kZV91cmwsIG5vZGVfbm90ZV90cmFuc3BvcnRfdXJsLCBzZWVkKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShub2RlX3VybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAobm9kZV91cmwsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShub2RlX25vdGVfdHJhbnNwb3J0X3VybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAobm9kZV9ub3RlX3RyYW5zcG9ydF91cmwsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShzZWVkKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2NyZWF0ZUNsaWVudCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xpZW50IHdpdGggdGhlIGdpdmVuIG5vZGUgVVJMLCBvcHRpb25hbCBzZWVkLCBhbmQgZXh0ZXJuYWwga2V5c3RvcmVcbiAgICAgKiBjYWxsYmFja3MuIElmIGBub2RlX3VybGAgaXMgYE5vbmVgLCBpdCBkZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtub2RlX3VybF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtub2RlX25vdGVfdHJhbnNwb3J0X3VybF1cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VlZF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgbnVsbH0gW2dldF9rZXlfY2JdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbiB8IG51bGx9IFtpbnNlcnRfa2V5X2NiXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBudWxsfSBbc2lnbl9jYl1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGNyZWF0ZUNsaWVudFdpdGhFeHRlcm5hbEtleXN0b3JlKG5vZGVfdXJsLCBub2RlX25vdGVfdHJhbnNwb3J0X3VybCwgc2VlZCwgZ2V0X2tleV9jYiwgaW5zZXJ0X2tleV9jYiwgc2lnbl9jYikge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUobm9kZV91cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKG5vZGVfdXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUobm9kZV9ub3RlX3RyYW5zcG9ydF91cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKG5vZGVfbm90ZV90cmFuc3BvcnRfdXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUoc2VlZCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9jcmVhdGVDbGllbnRXaXRoRXh0ZXJuYWxLZXlzdG9yZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMiwgaXNMaWtlTm9uZShnZXRfa2V5X2NiKSA/IDAgOiBhZGRIZWFwT2JqZWN0KGdldF9rZXlfY2IpLCBpc0xpa2VOb25lKGluc2VydF9rZXlfY2IpID8gMCA6IGFkZEhlYXBPYmplY3QoaW5zZXJ0X2tleV9jYiksIGlzTGlrZU5vbmUoc2lnbl9jYikgPyAwIDogYWRkSGVhcE9iamVjdChzaWduX2NiKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTY3JpcHRCdWlsZGVyfVxuICAgICAqL1xuICAgIGNyZWF0ZVNjcmlwdEJ1aWxkZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X2NyZWF0ZVNjcmlwdEJ1aWxkZXIocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTY3JpcHRCdWlsZGVyLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBXZWJDbGllbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFdlYkNsaWVudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgV29yZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ193b3JkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFdvcmQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFdvcmQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgV29yZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFdvcmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFdvcmRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3dvcmRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0JpZ1VpbnQ2NEFycmF5fSB1NjRfdmVjXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodTY0X3ZlYykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5NjRUb1dhc20wKHU2NF92ZWMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndvcmRfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgV29yZEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgV29yZCBmcm9tIGEgaGV4IHN0cmluZy5cbiAgICAgKiBGYWlscyBpZiB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIGhleCByZXByZXNlbnRhdGlvbiBvZiBhIFdvcmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaGV4LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS53b3JkX2Zyb21IZXgocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWx0W119IGZlbHRfdmVjXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc3RhdGljIG5ld0Zyb21GZWx0cyhmZWx0X3ZlYykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZmVsdF92ZWMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndvcmRfbmV3RnJvbUZlbHRzKHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0hleCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25pZF90b0hleChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndvcmRfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLndvcmRfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QmlnVWludDY0QXJyYXl9XG4gICAgICovXG4gICAgdG9VNjRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLndvcmRfdG9VNjRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVNjRGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogOCwgOCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgdG9GZWx0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbmlkX2FzRWxlbWVudHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBXb3JkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBXb3JkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBFWFBFQ1RFRF9SRVNQT05TRV9UWVBFUyA9IG5ldyBTZXQoWydiYXNpYycsICdjb3JzJywgJ2RlZmF1bHQnXSk7XG5cbmFzeW5jIGZ1bmN0aW9uIF9fd2JnX2xvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRSZXNwb25zZSA9IG1vZHVsZS5vayAmJiBFWFBFQ1RFRF9SRVNQT05TRV9UWVBFUy5oYXMobW9kdWxlLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkUmVzcG9uc2UgJiYgbW9kdWxlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAhPT0gJ2FwcGxpY2F0aW9uL3dhc20nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgV2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxuXCIsIGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IG1vZHVsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZSwgbW9kdWxlIH07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gX193YmdfZ2V0X2ltcG9ydHMoKSB7XG4gICAgY29uc3QgaW1wb3J0cyA9IHt9O1xuICAgIGltcG9ydHMud2JnID0ge307XG4gICAgaW1wb3J0cy53YmcuX193YmdfRXJyb3JfZTgzOTg3ZjY2NWNmNTUwNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX051bWJlcl9iYjQ4Y2ExMmYzOTVjZDA4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOdW1iZXIoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX1N0cmluZ184ZjBlYjM5YTRhNGMyZjY2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBTdHJpbmcoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9iaWdpbnRfZ2V0X2FzX2k2NF9mM2ViYzVhNzU1MDAwYWZkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodikgPT09ICdiaWdpbnQnID8gdiA6IHVuZGVmaW5lZDtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0QmlnSW50NjQoYXJnMCArIDggKiAxLCBpc0xpa2VOb25lKHJldCkgPyBCaWdJbnQoMCkgOiByZXQsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsICFpc0xpa2VOb25lKHJldCksIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9ib29sZWFuX2dldF82ZDVhMWVlNjViYWI1ZjY4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodikgPT09ICdib29sZWFuJyA/IHYgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAweEZGRkZGRiA6IHJldCA/IDEgOiAwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9kZWJ1Z19zdHJpbmdfZGY0N2ZmYjVlMzVlNjc2MyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZGVidWdTdHJpbmcoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9pbl9iYjkzM2JkOWUxYjNiYzBmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgaW4gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9pc19iaWdpbnRfY2IzMjA3MDdkY2QzNWYwYiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKGdldE9iamVjdChhcmcwKSkgPT09ICdiaWdpbnQnO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9pc19mdW5jdGlvbl9lZThhNmM1ODMzYzkwMzc3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5faXNfbnVsbF81ZTY5ZjcyZTkwNmNjNTdjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2lzX29iamVjdF9jODE4MjYxZDIxZjI4M2E0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2lzX3VuZGVmaW5lZF8yZDQ3Mjg2MmJkMjlhNDc4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fanN2YWxfZXFfNmIxM2FiODM0NzhiMWM1MCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09PSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2pzdmFsX2xvb3NlX2VxX2I2NjRiMzhhMmY1ODIxNDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX251bWJlcl9nZXRfYTIwYmY5Yjg1MzQxNDQ5ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcicgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEZsb2F0NjQoYXJnMCArIDggKiAxLCBpc0xpa2VOb25lKHJldCkgPyAwIDogcmV0LCB0cnVlKTtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCAhaXNMaWtlTm9uZShyZXQpLCB0cnVlKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fc3RyaW5nX2dldF9lNGYwNmM5MDQ4OWFkMDFiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnc3RyaW5nJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl90aHJvd19iODU1NDQ1ZmY2YTk0Mjk1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX193YmdfY2JfdW5yZWZfMjQ1NGE1MzllYTU3OTBkOSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLl93YmdfY2JfdW5yZWYoKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Fib3J0XzI4YWQ1NWM1ODI1YjAwNGQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5hYm9ydChnZXRPYmplY3QoYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWJvcnRfZTdlYjA1OWY3MmY5ZWQwYyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmFib3J0KCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hY2NvdW50X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQWNjb3VudC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hY2NvdW50X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQWNjb3VudC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FjY291bnRmaWxlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQWNjb3VudEZpbGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWNjb3VudGhlYWRlcl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFjY291bnRIZWFkZXIuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWNjb3VudGlkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQWNjb3VudElkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FjY291bnRpZF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFjY291bnRJZC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FkZE5vdGVUYWdfOTQ4YWI0Y2M3ZDNkNzg0YiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKGFyZzIgIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHYyO1xuICAgICAgICBpZiAoYXJnNCAhPT0gMCkge1xuICAgICAgICAgICAgdjIgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNCwgYXJnNSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzQsIGFyZzUgKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBhZGROb3RlVGFnKHYwLCB2MSwgdjIpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYXBwZW5kX2I1NzdlYjNhMTc3YmMwZmEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5hcHBlbmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMywgYXJnNCkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hcHBseVN0YXRlU3luY182ODc0MTVkMWJjZjRkZDhhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBhcHBseVN0YXRlU3luYyhKc1N0YXRlU3luY1VwZGF0ZS5fX3dyYXAoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYXV0aHNlY3JldGtleV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEF1dGhTZWNyZXRLZXkuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYm9keV81ODc1NDJiMmZkOGUwNmMwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYm9keTtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19idWZmZXJfY2NjNDUyMGIzNmQzY2NmNCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2J5b2JSZXF1ZXN0XzIzNDRlNjk3NWYyNzQ1NmUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ieW9iUmVxdWVzdDtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ieXRlTGVuZ3RoX2JjZDQyZTQwMjUyOTk3ODggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYnl0ZU9mZnNldF9jYTNhNmNmNzk0NGIzNjRiID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYnl0ZU9mZnNldDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfNTI1NDQwZjcyZmJmYzBlYSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsX2U0NWQyY2Y5ZmM5MjVmY2YgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpLCBnZXRPYmplY3QoYXJnMykpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsX2U3NjJjMzlmYThlYTM2YmYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbmNlbF80OGFiNmY5ZGMzNjZlMzY5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FuY2VsKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYXRjaF85NDM4MzZmYWE1ZDI5YmZiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2F0Y2goZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NsZWFyVGltZW91dF8yZTJjNDkzOTM4OGNkZmJiID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBjbGVhclRpbWVvdXQodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jbG9zZV81YTZjYWVkMzIzMWI2OGNkID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuY2xvc2UoKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xvc2VfNjk1NmRmODQ1NDc4NTYxYSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNsb3NlKCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NvbnN1bWFibGVub3RlcmVjb3JkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQ29uc3VtYWJsZU5vdGVSZWNvcmQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZG9uZV8yMDQyYWEyNjcwZmIxZGIxID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZG9uZTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2VucXVldWVfN2IxOGE2NTBhZWM3Nzg5OCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmVucXVldWUoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZXhwb3J0U3RvcmVfMTNiNTI3NGI0NTM2NzI2OSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBleHBvcnRTdG9yZSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmVsdF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZlbHQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmVsdF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZlbHQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mZXRjaF81M2VlZjdkZjdiNDM5YTQ5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBmZXRjaChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mZXRjaF84NzI1ODY1ZmY0N2U3ZmNjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZmV0Y2goZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmV0Y2hlZG5vdGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGZXRjaGVkTm90ZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mb3JjZUltcG9ydFN0b3JlX2U0ZjE0MzdkNmI0Y2ZmMGUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGZvcmNlSW1wb3J0U3RvcmUodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mb3JlaWduYWNjb3VudF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZvcmVpZ25BY2NvdW50Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZnVuZ2libGVhc3NldF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZ1bmdpYmxlQXNzZXQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZnVuZ2libGVhc3NldF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZ1bmdpYmxlQXNzZXQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mdW5naWJsZWFzc2V0ZGVsdGFpdGVtX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRnVuZ2libGVBc3NldERlbHRhSXRlbS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50QWRkcmVzc2VzXzU3ZGNhZjA0NDAzZmZmZjYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudEFkZHJlc3NlcyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRBdXRoQnlQdWJLZXlfYTk5MjY4YTBjNWU3ODFmYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50QXV0aEJ5UHViS2V5KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudENvZGVfMjU1YzQ3ODgwMDI3NjA0ZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50Q29kZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRIZWFkZXJCeUNvbW1pdG1lbnRfMjQ1N2IzODEyNzhhY2Q5ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50SGVhZGVyQnlDb21taXRtZW50KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudEhlYWRlcl8zZTNjMGZkMTZjZTc4MDQ2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRIZWFkZXIoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50SWRzXzFkYzNjYzliZWIwMGRhYzQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudElkcygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudFN0b3JhZ2VNYXBzXzUyZDM5MGY1OWQzOTg3MGEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRTdG9yYWdlTWFwcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50U3RvcmFnZV9lN2UzMTRkM2E4YzY4MTg4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRTdG9yYWdlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudFZhdWx0QXNzZXRzXzA1OGFhN2EzZTg1ZjlkN2UgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudFZhdWx0QXNzZXRzKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWxsQWNjb3VudEhlYWRlcnNfMjFhZTU4ZmJkNzRiYzIwNyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRBbGxBY2NvdW50SGVhZGVycygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QmxvY2tIZWFkZXJzX2ZmYmU2Mjk0MTllNDlmMjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldEJsb2NrSGVhZGVycyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRGb3JlaWduQWNjb3VudENvZGVfODRmODFhOWZiMjY0YjJhOCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0Rm9yZWlnbkFjY291bnRDb2RlKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldElucHV0Tm90ZXNGcm9tSWRzX2E0ODE0ZmYzZWU2ODM4ZjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldElucHV0Tm90ZXNGcm9tSWRzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldElucHV0Tm90ZXNGcm9tTnVsbGlmaWVyc19iMTI1MTkyNTIxY2IyNzA3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRJbnB1dE5vdGVzRnJvbU51bGxpZmllcnModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0SW5wdXROb3Rlc185ZTdkYWFiM2UxMWFhZGE5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0SW5wdXROb3Rlcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXROb3RlU2NyaXB0XzhkYjRhODdmMWRhYTU3MzIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0Tm90ZVNjcmlwdChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldE5vdGVUYWdzXzQ0NTY3MmZiZGE3NjE3Y2EgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0Tm90ZVRhZ3MoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldE91dHB1dE5vdGVzRnJvbUlkc19hOWY5NWVlZTVhZWExMTFhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPdXRwdXROb3Rlc0Zyb21JZHModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0T3V0cHV0Tm90ZXNGcm9tTnVsbGlmaWVyc18xNTcwODQxOTIwOWYwMDE3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPdXRwdXROb3Rlc0Zyb21OdWxsaWZpZXJzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldE91dHB1dE5vdGVzXzdlOTAzNGI3ODQ1ZDg1NDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPdXRwdXROb3Rlcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzQWxsX2Y3Yjk5ZGE0ZWNjMmNmNjcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlc0FsbCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlc180YjU5ZjNjZjNkNjc4ODVhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFBhcnRpYWxCbG9ja2NoYWluUGVha3NCeUJsb2NrTnVtX2MzNjgzOTU0Y2Y4NzI2MDEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0UGFydGlhbEJsb2NrY2hhaW5QZWFrc0J5QmxvY2tOdW0oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRSYW5kb21WYWx1ZXNfMWM2MWZhYzExNDA1ZmZkYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRSZWFkZXJfNDhlMDA3NDlmZTNmNjA4OSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRTZXR0aW5nXzMwZDQ4N2UyNmVkM2VjZmYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0U2V0dGluZyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFN5bmNIZWlnaHRfZjdjNGZmMDMyZDZlODcxOSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRTeW5jSGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRUaW1lXzE0Nzc2YmZiNDhhMWJmZjkgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRUcmFja2VkQmxvY2tIZWFkZXJzXzBlOTIyYWYwNTQxMDk4MWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0VHJhY2tlZEJsb2NrSGVhZGVycygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0VHJhbnNhY3Rpb25zXzc1MTE4MjJlZDdkZjRhMDQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0VHJhbnNhY3Rpb25zKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0VW5zcGVudElucHV0Tm90ZU51bGxpZmllcnNfYTUzZWUxODg3YjMwNTEyMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRVbnNwZW50SW5wdXROb3RlTnVsbGlmaWVycygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0XzdiZWQwMTZmMTg1YWRkODEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKVthcmcxID4+PiAwXTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF9kb25lX2EwNDYzYWY0M2ExZmM3NjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kb25lO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMHhGRkZGRkYgOiByZXQgPyAxIDogMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF9lZmNiNDQ5ZjU4ZWMyN2MyID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LmdldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF92YWx1ZV81Y2U5NmM5ZjgxY2U3Mzk4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmFsdWU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfd2l0aF9yZWZfa2V5XzFkYzM2MWJkMTAwNTNiZmUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKVtnZXRPYmplY3QoYXJnMSldO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0cHJvY2VkdXJlc3Jlc3VsdGl0ZW1fbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19oYXNfNzg3ZmFmYzk4MGMzY2NkYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5oYXMoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19oZWFkZXJzX2I4N2Q3ZWFiYTYxYzMyNzggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5oZWFkZXJzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5wdXRub3RlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSW5wdXROb3RlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lucHV0bm90ZXJlY29yZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IElucHV0Tm90ZVJlY29yZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnNlcnRBY2NvdW50QWRkcmVzc184MTlhN2FiYjU3ZDVjNTBlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGluc2VydEFjY291bnRBZGRyZXNzKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc2VydEFjY291bnRBdXRoXzg4ZmRmMWFlOWNmZTAxNTUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gYXJnMjtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gYXJnMztcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGluc2VydEFjY291bnRBdXRoKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzIsIGFyZzMpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zZXJ0QmxvY2tIZWFkZXJfNWU0YzM5YTY0YWJhOTQ1ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICB2YXIgdjIgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzQsIGFyZzUpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc0LCBhcmc1ICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBpbnNlcnRCbG9ja0hlYWRlcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxLCB2MiwgYXJnNiAhPT0gMCk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zZXJ0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlc181MTM5Y2M5NzAyZmYwYTk5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBpbnNlcnRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKHYwLCB2MSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnNlcnRTZXR0aW5nXzFlMmZhMGRlNTI0ZjI3ODIgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gaW5zZXJ0U2V0dGluZyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnNlcnRUcmFuc2FjdGlvblNjcmlwdF84ZTViNmQyYmNjNzBjODI2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAoYXJnMiAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gaW5zZXJ0VHJhbnNhY3Rpb25TY3JpcHQodjAsIHYxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfNzBiZWIxMTg5Y2E2M2IzOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX1Byb21pc2VfMDAxZmRkNDJhZmExYjdlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfVWludDhBcnJheV8yMGM4ZTczMDAyZjdhZjk4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXNBcnJheV85NmUwYWY5ODkxZDA5NDVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBcnJheS5pc0FycmF5KGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pc1NhZmVJbnRlZ2VyX2QyMTZlZGE3OTExZGRlMzYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE51bWJlci5pc1NhZmVJbnRlZ2VyKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pdGVyYXRvcl9lNTgyMjY5NTMyN2EzYzM5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzYWNjb3VudHVwZGF0ZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzQWNjb3VudFVwZGF0ZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc2FjY291bnR1cGRhdGVfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc0FjY291bnRVcGRhdGUuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc3N0b3JhZ2VtYXBlbnRyeV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzU3RvcmFnZU1hcEVudHJ5Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzc3RvcmFnZW1hcGVudHJ5X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNTdG9yYWdlTWFwRW50cnkuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc3N0b3JhZ2VzbG90X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNTdG9yYWdlU2xvdC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc3N0b3JhZ2VzbG90X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNTdG9yYWdlU2xvdC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzdmF1bHRhc3NldF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzVmF1bHRBc3NldC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc3ZhdWx0YXNzZXRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc1ZhdWx0QXNzZXQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfNjliY2EzY2I2NGZjODc0OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF9jZGQyMTVlMTBkOWRkNTA3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGlzdFNldHRpbmdLZXlzXzY5NDBiZTAxYzI3YThlMDggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbGlzdFNldHRpbmdLZXlzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sb2NrQWNjb3VudF8xN2U2MzA3MzM1MzQzZWFhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGxvY2tBY2NvdW50KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzBfZjk3NDA2ODZkNzM5MDI1YyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzFhY2MwYjZlZWE4OWQwNDAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzI1MzE3NzNkYWMzOGViYjMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfM2MzZDg0OTA0NjY4OGE2NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdGF0ZTAgPSB7YTogYXJnMCwgYjogYXJnMX07XG4gICAgICAgICAgICB2YXIgY2IwID0gKGFyZzAsIGFyZzEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gc3RhdGUwLmE7XG4gICAgICAgICAgICAgICAgc3RhdGUwLmEgPSAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fMzY3NyhhLCBzdGF0ZTAuYiwgYXJnMCwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUwLmEgPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZShjYjApO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN0YXRlMC5hID0gc3RhdGUwLmIgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfNWE3OWJlM2FiNTNiOGFhNSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld185ZWRmOTgzOGEyZGVmMzljID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld19hNzQ0MmI0YjE5YzFhMzU2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld19lMTdkOWY0MzEwNWIwOGJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2Zyb21fc2xpY2VfOTJmNGQ3OGNhMjgyYTJkMiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfbm9fYXJnc19lZTk4ZWVlNTI3NTAwMGE0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRnVuY3Rpb24oZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGhfNDZlM2U2YTVlOWY5ZTg5YiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApLCBhcmcxID4+PiAwLCBhcmcyID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld193aXRoX3N0cl9hbmRfaW5pdF8wYWU3NzI4YjZlYzM2N2IxID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgUmVxdWVzdChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25leHRfMDIwODEwZTBhZThlYmNiMCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV4dF8yYzgyNmZlNWRmZWM2YjZhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubmV4dDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVhbmRhcmdzX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUFuZEFyZ3MuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlY29uc3VtYWJpbGl0eV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVDb25zdW1hYmlsaXR5Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVjb25zdW1hYmlsaXR5X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUNvbnN1bWFiaWxpdHkuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlZGV0YWlsc2FuZHRhZ19uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVEZXRhaWxzQW5kVGFnLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVkZXRhaWxzYW5kdGFnX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZURldGFpbHNBbmRUYWcuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlZmlsZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVGaWxlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVpZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVJZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlaWRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlSWQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlaWRhbmRhcmdzX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUlkQW5kQXJncy5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVyZWNpcGllbnRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlUmVjaXBpZW50Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZXNjcmlwdF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVTY3JpcHQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3BlbkRhdGFiYXNlX2YyNDJjZDc4MmQzMDA5MTYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gb3BlbkRhdGFiYXNlKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vdXRwdXRub3RlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT3V0cHV0Tm90ZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vdXRwdXRub3RlX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT3V0cHV0Tm90ZS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX291dHB1dG5vdGVzX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gT3V0cHV0Tm90ZXMuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wcm90b3R5cGVzZXRjYWxsXzJhNjYyMGI2OTIyNjk0YjIgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wcm92ZW50cmFuc2FjdGlvbl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFByb3ZlblRyYW5zYWN0aW9uLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3BydW5lSXJyZWxldmFudEJsb2Nrc19jZTUxNzRiODVjYmQ4M2ZhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHBydW5lSXJyZWxldmFudEJsb2NrcygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcXVldWVNaWNyb3Rhc2tfMzRkNjkyYzI1YzQ3ZDA1YiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnF1ZXVlTWljcm90YXNrO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcXVldWVNaWNyb3Rhc2tfOWQ3NmNhY2IyMGM4NGQ1OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soZ2V0T2JqZWN0KGFyZzApKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlYWRfNDhmMTU5M2RmNTQyZjk2OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlbGVhc2VMb2NrXzVkMGI1YTY4ODg3Yjg5MWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yZWxlYXNlTG9jaygpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVtb3ZlQWNjb3VudEFkZHJlc3NfOTRiNDUxZmQ1NDc2YjY3MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHJlbW92ZUFjY291bnRBZGRyZXNzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlbW92ZU5vdGVUYWdfNTUwYjAzODUxNjdmMmRjZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKGFyZzIgIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHYyO1xuICAgICAgICBpZiAoYXJnNCAhPT0gMCkge1xuICAgICAgICAgICAgdjIgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNCwgYXJnNSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzQsIGFyZzUgKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZW1vdmVOb3RlVGFnKHYwLCB2MSwgdjIpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVtb3ZlU2V0dGluZ185ZjU5Y2JmYmU5NWY0ODQzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHJlbW92ZVNldHRpbmcoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXNvbHZlX2NhZjk3YzMwYjgzZjcwNTMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFByb21pc2UucmVzb2x2ZShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzcG9uZF8wZjRkYmY1Mzg2ZjVjNzNlID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmVzcG9uZChhcmcxID4+PiAwKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTZXJpYWxpemVkSW5wdXROb3RlRGF0YS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXJpYWxpemVkaW5wdXRub3RlZGF0YV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0VGltZW91dF85MjljOTdhN2MwZjIzZDM2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBzZXRUaW1lb3V0KGdldE9iamVjdChhcmcwKSwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfOGIzNDJkOGNkOWQyYTAyYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIGdldFN0cmluZ0Zyb21XYXNtMChhcmczLCBhcmc0KSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF85ZTY1MTZkZjdiN2QwZjE5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldEFycmF5VThGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2JvZHlfM2MzNjU5ODk3NTNkNjFmNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmJvZHkgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYzIxM2M4NzE4NTlkNjUwMCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdID0gdGFrZU9iamVjdChhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9jMmFiYmViZThiOWViZWUxID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LnNldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2NhY2hlXzJmOWRlYjE5YjkyYjgxZTMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jYWNoZSA9IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0Q2FjaGVbYXJnMV07XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfY3JlZGVudGlhbHNfZjYyMWNkMmQ4NWMwYzIyOCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNyZWRlbnRpYWxzID0gX193YmluZGdlbl9lbnVtX1JlcXVlc3RDcmVkZW50aWFsc1thcmcxXTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9oZWFkZXJzXzY5MjZkYTIzOGNkMzJlZTQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5oZWFkZXJzID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2ludGVncml0eV82MmE0NmZjNzkyODMyZjQxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuaW50ZWdyaXR5ID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X21ldGhvZF9jMDJkOGNiYmUyMDRhYzJkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkubWV0aG9kID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X21vZGVfNTJlZjczY2ZhNzk2MzljYiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm1vZGUgPSBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdE1vZGVbYXJnMV07XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfcmVkaXJlY3RfZGYwMjg1NDk2ZWM0NWZmOCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJlZGlyZWN0ID0gX193YmluZGdlbl9lbnVtX1JlcXVlc3RSZWRpcmVjdFthcmcxXTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9yZWZlcnJlcl9lYzljZjhhOGEzMTVkNTBjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmVmZXJyZXIgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfcmVmZXJyZXJfcG9saWN5Xzk5YzFmMjk5YjRlMzc0NDYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yZWZlcnJlclBvbGljeSA9IF9fd2JpbmRnZW5fZW51bV9SZWZlcnJlclBvbGljeVthcmcxXTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9zaWduYWxfZGRhMmNmN2NjYjZiZWUwZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNpZ25hbCA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NpZ25hbF80ZGI1YWEwNTViZjllYjlhID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc2lnbmFsO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2xvdGFuZGtleXNfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTbG90QW5kS2V5cy5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfODllMWQ5YWM2YTFiMjUwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBnbG9iYWw7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF9USElTXzhiNTMwZjMyNmE5ZTQ4YWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGdsb2JhbFRoaXM7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX1NFTEZfNmZkZjRiNjQ3MTBjYzkxYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogc2VsZjtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XX2I0NWJmYzVhMzdmNmNmYTIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXR1c19kZTdlZWQ1YTdhNWJmZDVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc3RhdHVzO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RvcmFnZXNsb3RfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTdG9yYWdlU2xvdC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N5bmNzdW1tYXJ5X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3luY1N1bW1hcnkuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl80ZjQ2ZjY1NDRlNmI0YTI4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl83MGQwNWNmNzgwYTE4ZDc3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190b1N0cmluZ183ZGE3YzhkYmVjNzhmY2I4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9uaWRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2FjdGlvbklkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9uaWRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2FjdGlvbklkLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdHJhbnNhY3Rpb25yZWNvcmRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2FjdGlvblJlY29yZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbnJlc3VsdF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uUmVzdWx0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbnN0b3JldXBkYXRlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191bmRvQWNjb3VudFN0YXRlc19mZTlkYTM4MjkzNzAzNmJkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSB1bmRvQWNjb3VudFN0YXRlcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRBY2NvdW50Q29kZV9jOTNlOTExMWIyYzczMjc0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydEFjY291bnRDb2RlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydEFjY291bnRSZWNvcmRfODg4NDNlZTZhNzFjYzhiMyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcsIGFyZzgsIGFyZzksIGFyZzEwLCBhcmcxMSwgYXJnMTIsIGFyZzEzLCBhcmcxNCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkNF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQ0XzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDVfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkNV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSBhcmcyO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSBhcmczO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBhcmc0O1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBhcmc1O1xuICAgICAgICAgICAgZGVmZXJyZWQzXzAgPSBhcmc2O1xuICAgICAgICAgICAgZGVmZXJyZWQzXzEgPSBhcmc3O1xuICAgICAgICAgICAgZGVmZXJyZWQ0XzAgPSBhcmc4O1xuICAgICAgICAgICAgZGVmZXJyZWQ0XzEgPSBhcmc5O1xuICAgICAgICAgICAgZGVmZXJyZWQ1XzAgPSBhcmcxMTtcbiAgICAgICAgICAgIGRlZmVycmVkNV8xID0gYXJnMTI7XG4gICAgICAgICAgICBsZXQgdjY7XG4gICAgICAgICAgICBpZiAoYXJnMTMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2NiA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMTMsIGFyZzE0KS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzEzLCBhcmcxNCAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0QWNjb3VudFJlY29yZChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIGdldFN0cmluZ0Zyb21XYXNtMChhcmcyLCBhcmczKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzQsIGFyZzUpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNiwgYXJnNyksIGdldFN0cmluZ0Zyb21XYXNtMChhcmc4LCBhcmc5KSwgYXJnMTAgIT09IDAsIGdldFN0cmluZ0Zyb21XYXNtMChhcmcxMSwgYXJnMTIpLCB2Nik7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQzXzAsIGRlZmVycmVkM18xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkNF8wLCBkZWZlcnJlZDRfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDVfMCwgZGVmZXJyZWQ1XzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRBY2NvdW50U3RvcmFnZV83MWFlYTk4M2Q4ZTQ1MjUzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRBY2NvdW50U3RvcmFnZSh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRGb3JlaWduQWNjb3VudENvZGVfYTJmZmRkMGRlYjg3YzA2MyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBhcmc0O1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBhcmc1O1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0Rm9yZWlnbkFjY291bnRDb2RlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEsIGdldFN0cmluZ0Zyb21XYXNtMChhcmc0LCBhcmc1KSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydElucHV0Tm90ZV83NzMzNzAyYzQ4ZTJhZTE3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNywgYXJnOCwgYXJnOSwgYXJnMTAsIGFyZzExLCBhcmcxMiwgYXJnMTMsIGFyZzE0LCBhcmcxNSwgYXJnMTYsIGFyZzE3LCBhcmcxOCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkNF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQ0XzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDZfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkNl8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQ3XzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDdfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIHZhciB2MiA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnNCwgYXJnNSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzQsIGFyZzUgKiAxLCAxKTtcbiAgICAgICAgICAgIHZhciB2MyA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnNiwgYXJnNykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzYsIGFyZzcgKiAxLCAxKTtcbiAgICAgICAgICAgIGRlZmVycmVkNF8wID0gYXJnODtcbiAgICAgICAgICAgIGRlZmVycmVkNF8xID0gYXJnOTtcbiAgICAgICAgICAgIHZhciB2NSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMTAsIGFyZzExKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMTAsIGFyZzExICogMSwgMSk7XG4gICAgICAgICAgICBkZWZlcnJlZDZfMCA9IGFyZzEyO1xuICAgICAgICAgICAgZGVmZXJyZWQ2XzEgPSBhcmcxMztcbiAgICAgICAgICAgIGRlZmVycmVkN18wID0gYXJnMTQ7XG4gICAgICAgICAgICBkZWZlcnJlZDdfMSA9IGFyZzE1O1xuICAgICAgICAgICAgdmFyIHY4ID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxNywgYXJnMTgpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcxNywgYXJnMTggKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydElucHV0Tm90ZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxLCB2MiwgdjMsIGdldFN0cmluZ0Zyb21XYXNtMChhcmc4LCBhcmc5KSwgdjUsIGdldFN0cmluZ0Zyb21XYXNtMChhcmcxMiwgYXJnMTMpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMTQsIGFyZzE1KSwgYXJnMTYsIHY4KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQ0XzAsIGRlZmVycmVkNF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkNl8wLCBkZWZlcnJlZDZfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDdfMCwgZGVmZXJyZWQ3XzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnROb3RlU2NyaXB0XzNjNTY5YTY3M2VmZjIxYzkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0Tm90ZVNjcmlwdChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRPdXRwdXROb3RlXzFhOWM2YjgwYmMzYjI5NzkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3LCBhcmc4LCBhcmc5LCBhcmcxMCwgYXJnMTEsIGFyZzEyLCBhcmcxMykge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IGFyZzQ7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGFyZzU7XG4gICAgICAgICAgICB2YXIgdjMgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzYsIGFyZzcpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc2LCBhcmc3ICogMSwgMSk7XG4gICAgICAgICAgICBsZXQgdjQ7XG4gICAgICAgICAgICBpZiAoYXJnOCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHY0ID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzgsIGFyZzkpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnOCwgYXJnOSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHY1ID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxMiwgYXJnMTMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcxMiwgYXJnMTMgKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydE91dHB1dE5vdGUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzQsIGFyZzUpLCB2MywgdjQsIGFyZzEwID4+PiAwLCBhcmcxMSwgdjUpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRTdG9yYWdlTWFwRW50cmllc181N2RhNzM0Y2JlZTQ0OGJmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRTdG9yYWdlTWFwRW50cmllcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRUcmFuc2FjdGlvblJlY29yZF9lNGE4YjA1ZjFiMzcxNGVhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNywgYXJnOCwgYXJnOSwgYXJnMTApIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBhcmc0O1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBhcmc1O1xuICAgICAgICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmc3LCBhcmc4KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNywgYXJnOCAqIDEsIDEpO1xuICAgICAgICAgICAgbGV0IHY0O1xuICAgICAgICAgICAgaWYgKGFyZzkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2NCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnOSwgYXJnMTApLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnOSwgYXJnMTAgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydFRyYW5zYWN0aW9uUmVjb3JkKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEsIGdldFN0cmluZ0Zyb21XYXNtMChhcmc0LCBhcmc1KSwgYXJnNiwgdjMsIHY0KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0VmF1bHRBc3NldHNfY2U1NDllZGU0NDU3ZGY2ZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0VmF1bHRBc3NldHModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdmFsdWVfNjkyNjI3MzA5ODE0YmI4YyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnZhbHVlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfdmlld19mNmMxNWFjOWZlZDYzYmJkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmlldztcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193b3JkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gV29yZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193b3JkX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gV29yZC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF8xZmYzMGM4OWY4YzEzZDRiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihOYW1lZEV4dGVybnJlZihcIlRyYW5zYWN0aW9uUmVjb3JkXCIpKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF8yMjQxYjZhZjRjNGIyOTQxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFJlZihTdHJpbmcpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF8yNWEwYTg0NDQzN2QwZTkyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihOYW1lZEV4dGVybnJlZihcInN0cmluZ1wiKSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfMjk4ZGZkOTk5OThmMWJiZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoTmFtZWRFeHRlcm5yZWYoXCJDb25zdW1hYmxlTm90ZVJlY29yZFwiKSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfMzE4NjE0NGYzMDE0YTZlOSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoTmFtZWRFeHRlcm5yZWYoXCJGZXRjaGVkTm90ZVwiKSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfMzU2YTY0OWM3NmVhM2Q0YSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBDbG9zdXJlKENsb3N1cmUgeyBkdG9yX2lkeDogNTE2LCBmdW5jdGlvbjogRnVuY3Rpb24geyBhcmd1bWVudHM6IFtdLCBzaGltX2lkeDogNTE3LCByZXQ6IFVuaXQsIGlubmVyX3JldDogU29tZShVbml0KSB9LCBtdXRhYmxlOiB0cnVlIH0pIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIHdhc20uX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzMDgsIF9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85MzA5KTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF80NjI1YzU3N2FiMmVjOWVlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFU2NCAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSBCaWdJbnQuYXNVaW50Tig2NCwgYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfNjExODBjZjJkYTU1ODBkYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoTmFtZWRFeHRlcm5yZWYoXCJBY2NvdW50SGVhZGVyXCIpKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF83N2JjM2U5Mjc0NWU5YTM1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoVTgpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0X2EwYzljOTc5OTM4NTE2NzIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKE5hbWVkRXh0ZXJucmVmKFwiSW5wdXROb3RlUmVjb3JkXCIpKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF9jODg3Mzg3MTY2MzgyOWRkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYENsb3N1cmUoQ2xvc3VyZSB7IGR0b3JfaWR4OiA1MTYsIGZ1bmN0aW9uOiBGdW5jdGlvbiB7IGFyZ3VtZW50czogW0V4dGVybnJlZl0sIHNoaW1faWR4OiA1MjEsIHJldDogVW5pdCwgaW5uZXJfcmV0OiBTb21lKFVuaXQpIH0sIG11dGFibGU6IHRydWUgfSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgd2FzbS5fX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTMwOCwgX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzNzUpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0X2Q2Y2QxOWI4MTU2MGZkNmUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgRjY0IC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9jbG9uZV9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB0YWtlT2JqZWN0KGFyZzApO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1wb3J0cztcbn1cblxuZnVuY3Rpb24gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgd2FzbSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgX193YmdfaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICAgIGNhY2hlZEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCA9IG51bGw7XG4gICAgY2FjaGVkRGF0YVZpZXdNZW1vcnkwID0gbnVsbDtcbiAgICBjYWNoZWRVaW50MzJBcnJheU1lbW9yeTAgPSBudWxsO1xuICAgIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID0gbnVsbDtcblxuXG5cbiAgICByZXR1cm4gd2FzbTtcbn1cblxuZnVuY3Rpb24gaW5pdFN5bmMobW9kdWxlKSB7XG4gICAgaWYgKHdhc20gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHdhc207XG5cblxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICh7bW9kdWxlfSA9IG1vZHVsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgYGluaXRTeW5jKClgOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRzID0gX193YmdfZ2V0X2ltcG9ydHMoKTtcblxuICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkpIHtcbiAgICAgICAgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShtb2R1bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX193YmdfaW5pdChtb2R1bGVfb3JfcGF0aCkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZV9vcl9wYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9vcl9wYXRoKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgKHttb2R1bGVfb3JfcGF0aH0gPSBtb2R1bGVfb3JfcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgdGhlIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGVfb3JfcGF0aCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZV9vcl9wYXRoIGluc3RhbmNlb2YgUmVxdWVzdCkgfHwgKHR5cGVvZiBVUkwgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlX29yX3BhdGggaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIG1vZHVsZV9vcl9wYXRoID0gZmV0Y2gobW9kdWxlX29yX3BhdGgpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgX193YmdfbG9hZChhd2FpdCBtb2R1bGVfb3JfcGF0aCwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuY29uc3QgbW9kdWxlID0gbmV3IFVSTChcImFzc2V0cy9taWRlbl9jbGllbnRfd2ViLndhc21cIiwgaW1wb3J0Lm1ldGEudXJsKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgX193YmdfaW5pdCh7IG1vZHVsZV9vcl9wYXRoOiBtb2R1bGUgfSk7XG5cbmV4cG9ydCB7IEFjY291bnQsIEFjY291bnRBcnJheSwgQWNjb3VudEJ1aWxkZXIsIEFjY291bnRCdWlsZGVyUmVzdWx0LCBBY2NvdW50Q29kZSwgQWNjb3VudENvbXBvbmVudCwgQWNjb3VudERlbHRhLCBBY2NvdW50RmlsZSwgQWNjb3VudEhlYWRlciwgQWNjb3VudElkLCBBY2NvdW50SWRBcnJheSwgQWNjb3VudEludGVyZmFjZSwgQWNjb3VudFN0b3JhZ2UsIEFjY291bnRTdG9yYWdlRGVsdGEsIEFjY291bnRTdG9yYWdlTW9kZSwgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMsIEFjY291bnRUeXBlLCBBY2NvdW50VmF1bHREZWx0YSwgQWRkcmVzcywgQWR2aWNlSW5wdXRzLCBBZHZpY2VNYXAsIEFzc2V0VmF1bHQsIEF1dGhTZWNyZXRLZXksIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQsIEJsb2NrSGVhZGVyLCBDb25zdW1hYmxlTm90ZVJlY29yZCwgRW5kcG9pbnQsIEV4ZWN1dGVkVHJhbnNhY3Rpb24sIEZlbHQsIEZlbHRBcnJheSwgRmV0Y2hlZE5vdGUsIEZsYXR0ZW5lZFU4VmVjLCBGb3JlaWduQWNjb3VudCwgRm9yZWlnbkFjY291bnRBcnJheSwgRnVuZ2libGVBc3NldCwgRnVuZ2libGVBc3NldERlbHRhLCBGdW5naWJsZUFzc2V0RGVsdGFJdGVtLCBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbSwgSW5wdXROb3RlLCBJbnB1dE5vdGVSZWNvcmQsIElucHV0Tm90ZVN0YXRlLCBJbnB1dE5vdGVzLCBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2UsIEludG9VbmRlcmx5aW5nU2luaywgSW50b1VuZGVybHlpbmdTb3VyY2UsIEpzQWNjb3VudFVwZGF0ZSwgSnNTdGF0ZVN5bmNVcGRhdGUsIEpzU3RvcmFnZU1hcEVudHJ5LCBKc1N0b3JhZ2VTbG90LCBKc1ZhdWx0QXNzZXQsIExpYnJhcnksIE1lcmtsZVBhdGgsIE5ldHdvcmtJZCwgTm90ZSwgTm90ZUFuZEFyZ3MsIE5vdGVBbmRBcmdzQXJyYXksIE5vdGVBc3NldHMsIE5vdGVDb25zdW1hYmlsaXR5LCBOb3RlRGV0YWlscywgTm90ZURldGFpbHNBbmRUYWcsIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXksIE5vdGVFeGVjdXRpb25IaW50LCBOb3RlRXhlY3V0aW9uTW9kZSwgTm90ZUZpbGUsIE5vdGVGaWx0ZXIsIE5vdGVGaWx0ZXJUeXBlcywgTm90ZUhlYWRlciwgTm90ZUlkLCBOb3RlSWRBbmRBcmdzLCBOb3RlSWRBbmRBcmdzQXJyYXksIE5vdGVJbmNsdXNpb25Qcm9vZiwgTm90ZUlucHV0cywgTm90ZUxvY2F0aW9uLCBOb3RlTWV0YWRhdGEsIE5vdGVSZWNpcGllbnQsIE5vdGVSZWNpcGllbnRBcnJheSwgTm90ZVNjcmlwdCwgTm90ZVRhZywgTm90ZVR5cGUsIE91dHB1dE5vdGUsIE91dHB1dE5vdGVBcnJheSwgT3V0cHV0Tm90ZXMsIE91dHB1dE5vdGVzQXJyYXksIFBhY2thZ2UsIFBhcnRpYWxOb3RlLCBQcm92ZW5UcmFuc2FjdGlvbiwgUHVibGljS2V5LCBScGNDbGllbnQsIFJwbzI1NiwgU2NyaXB0QnVpbGRlciwgU2VjcmV0S2V5LCBTZXJpYWxpemVkSW5wdXROb3RlRGF0YSwgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLCBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLCBTaWduYXR1cmUsIFNpZ25pbmdJbnB1dHMsIFNpZ25pbmdJbnB1dHNUeXBlLCBTbG90QW5kS2V5cywgU3RvcmFnZU1hcCwgU3RvcmFnZVNsb3QsIFN0b3JhZ2VTbG90QXJyYXksIFN5bmNTdW1tYXJ5LCBUZXN0VXRpbHMsIFRva2VuU3ltYm9sLCBUcmFuc2FjdGlvbkFyZ3MsIFRyYW5zYWN0aW9uRmlsdGVyLCBUcmFuc2FjdGlvbklkLCBUcmFuc2FjdGlvblByb3ZlciwgVHJhbnNhY3Rpb25SZWNvcmQsIFRyYW5zYWN0aW9uUmVxdWVzdCwgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlciwgVHJhbnNhY3Rpb25SZXN1bHQsIFRyYW5zYWN0aW9uU2NyaXB0LCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpciwgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheSwgVHJhbnNhY3Rpb25TdGF0dXMsIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUsIFRyYW5zYWN0aW9uU3VtbWFyeSwgV2ViQ2xpZW50LCBXb3JkLCBpbml0U3luYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FyZ28tYWNiZDhhYzUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@demox-labs/miden-sdk/dist/Cargo-acbd8ac5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/assets/miden_client_web.wasm":
/*!******************************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/assets/miden_client_web.wasm ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/miden_client_web.1c58f26d.wasm";

/***/ }),

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/index.js ***!
  \**********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Account),\n/* harmony export */   AccountArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountArray),\n/* harmony export */   AccountBuilder: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountBuilder),\n/* harmony export */   AccountBuilderResult: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountBuilderResult),\n/* harmony export */   AccountCode: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountCode),\n/* harmony export */   AccountComponent: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountComponent),\n/* harmony export */   AccountDelta: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountDelta),\n/* harmony export */   AccountFile: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountFile),\n/* harmony export */   AccountHeader: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountHeader),\n/* harmony export */   AccountId: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountId),\n/* harmony export */   AccountIdArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountIdArray),\n/* harmony export */   AccountInterface: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountInterface),\n/* harmony export */   AccountStorage: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountStorage),\n/* harmony export */   AccountStorageDelta: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountStorageDelta),\n/* harmony export */   AccountStorageMode: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountStorageMode),\n/* harmony export */   AccountStorageRequirements: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountStorageRequirements),\n/* harmony export */   AccountType: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountType),\n/* harmony export */   AccountVaultDelta: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AccountVaultDelta),\n/* harmony export */   Address: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Address),\n/* harmony export */   AdviceInputs: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AdviceInputs),\n/* harmony export */   AdviceMap: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AdviceMap),\n/* harmony export */   AssetVault: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AssetVault),\n/* harmony export */   AuthSecretKey: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.AuthSecretKey),\n/* harmony export */   BasicFungibleFaucetComponent: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.BasicFungibleFaucetComponent),\n/* harmony export */   BlockHeader: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.BlockHeader),\n/* harmony export */   ConsumableNoteRecord: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.ConsumableNoteRecord),\n/* harmony export */   Endpoint: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Endpoint),\n/* harmony export */   ExecutedTransaction: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.ExecutedTransaction),\n/* harmony export */   Felt: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Felt),\n/* harmony export */   FeltArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.FeltArray),\n/* harmony export */   FetchedNote: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.FetchedNote),\n/* harmony export */   FlattenedU8Vec: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.FlattenedU8Vec),\n/* harmony export */   ForeignAccount: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.ForeignAccount),\n/* harmony export */   ForeignAccountArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.ForeignAccountArray),\n/* harmony export */   FungibleAsset: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.FungibleAsset),\n/* harmony export */   FungibleAssetDelta: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.FungibleAssetDelta),\n/* harmony export */   FungibleAssetDeltaItem: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.FungibleAssetDeltaItem),\n/* harmony export */   GetProceduresResultItem: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.GetProceduresResultItem),\n/* harmony export */   InputNote: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.InputNote),\n/* harmony export */   InputNoteRecord: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.InputNoteRecord),\n/* harmony export */   InputNoteState: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.InputNoteState),\n/* harmony export */   InputNotes: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.InputNotes),\n/* harmony export */   IntoUnderlyingByteSource: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.IntoUnderlyingByteSource),\n/* harmony export */   IntoUnderlyingSink: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.IntoUnderlyingSink),\n/* harmony export */   IntoUnderlyingSource: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.IntoUnderlyingSource),\n/* harmony export */   JsAccountUpdate: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.JsAccountUpdate),\n/* harmony export */   JsStateSyncUpdate: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.JsStateSyncUpdate),\n/* harmony export */   JsStorageMapEntry: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.JsStorageMapEntry),\n/* harmony export */   JsStorageSlot: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.JsStorageSlot),\n/* harmony export */   JsVaultAsset: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.JsVaultAsset),\n/* harmony export */   Library: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Library),\n/* harmony export */   MerklePath: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.MerklePath),\n/* harmony export */   MidenArrays: () => (/* binding */ MidenArrays),\n/* harmony export */   MockWebClient: () => (/* binding */ MockWebClient),\n/* harmony export */   NetworkId: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NetworkId),\n/* harmony export */   Note: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Note),\n/* harmony export */   NoteAndArgs: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteAndArgs),\n/* harmony export */   NoteAndArgsArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteAndArgsArray),\n/* harmony export */   NoteAssets: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteAssets),\n/* harmony export */   NoteConsumability: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteConsumability),\n/* harmony export */   NoteDetails: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteDetails),\n/* harmony export */   NoteDetailsAndTag: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteDetailsAndTag),\n/* harmony export */   NoteDetailsAndTagArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteDetailsAndTagArray),\n/* harmony export */   NoteExecutionHint: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteExecutionHint),\n/* harmony export */   NoteExecutionMode: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteExecutionMode),\n/* harmony export */   NoteFile: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteFile),\n/* harmony export */   NoteFilter: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteFilter),\n/* harmony export */   NoteFilterTypes: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteFilterTypes),\n/* harmony export */   NoteHeader: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteHeader),\n/* harmony export */   NoteId: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteId),\n/* harmony export */   NoteIdAndArgs: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteIdAndArgs),\n/* harmony export */   NoteIdAndArgsArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteIdAndArgsArray),\n/* harmony export */   NoteInclusionProof: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteInclusionProof),\n/* harmony export */   NoteInputs: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteInputs),\n/* harmony export */   NoteLocation: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteLocation),\n/* harmony export */   NoteMetadata: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteMetadata),\n/* harmony export */   NoteRecipient: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteRecipient),\n/* harmony export */   NoteRecipientArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteRecipientArray),\n/* harmony export */   NoteScript: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteScript),\n/* harmony export */   NoteTag: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteTag),\n/* harmony export */   NoteType: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.NoteType),\n/* harmony export */   OutputNote: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.OutputNote),\n/* harmony export */   OutputNoteArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.OutputNoteArray),\n/* harmony export */   OutputNotes: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.OutputNotes),\n/* harmony export */   OutputNotesArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.OutputNotesArray),\n/* harmony export */   Package: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Package),\n/* harmony export */   PartialNote: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.PartialNote),\n/* harmony export */   ProvenTransaction: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.ProvenTransaction),\n/* harmony export */   PublicKey: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey),\n/* harmony export */   RpcClient: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.RpcClient),\n/* harmony export */   Rpo256: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Rpo256),\n/* harmony export */   ScriptBuilder: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.ScriptBuilder),\n/* harmony export */   SecretKey: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SecretKey),\n/* harmony export */   SerializedInputNoteData: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SerializedInputNoteData),\n/* harmony export */   SerializedOutputNoteData: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SerializedOutputNoteData),\n/* harmony export */   SerializedTransactionData: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SerializedTransactionData),\n/* harmony export */   Signature: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Signature),\n/* harmony export */   SigningInputs: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SigningInputs),\n/* harmony export */   SigningInputsType: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SigningInputsType),\n/* harmony export */   SlotAndKeys: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SlotAndKeys),\n/* harmony export */   StorageMap: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.StorageMap),\n/* harmony export */   StorageSlot: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.StorageSlot),\n/* harmony export */   StorageSlotArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.StorageSlotArray),\n/* harmony export */   SyncSummary: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.SyncSummary),\n/* harmony export */   TestUtils: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TestUtils),\n/* harmony export */   TokenSymbol: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TokenSymbol),\n/* harmony export */   TransactionArgs: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionArgs),\n/* harmony export */   TransactionFilter: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionFilter),\n/* harmony export */   TransactionId: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionId),\n/* harmony export */   TransactionProver: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionProver),\n/* harmony export */   TransactionRecord: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionRecord),\n/* harmony export */   TransactionRequest: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionRequest),\n/* harmony export */   TransactionRequestBuilder: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionRequestBuilder),\n/* harmony export */   TransactionResult: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionResult),\n/* harmony export */   TransactionScript: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionScript),\n/* harmony export */   TransactionScriptInputPair: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionScriptInputPair),\n/* harmony export */   TransactionScriptInputPairArray: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionScriptInputPairArray),\n/* harmony export */   TransactionStatus: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionStatus),\n/* harmony export */   TransactionStoreUpdate: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionStoreUpdate),\n/* harmony export */   TransactionSummary: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSummary),\n/* harmony export */   WebClient: () => (/* binding */ WebClient),\n/* harmony export */   Word: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.Word),\n/* harmony export */   initSync: () => (/* reexport safe */ _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__.initSync)\n/* harmony export */ });\n/* harmony import */ var _wasm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm.js */ \"(ssr)/./node_modules/@demox-labs/miden-sdk/dist/wasm.js\");\n/* harmony import */ var _Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cargo-acbd8ac5.js */ \"(ssr)/./node_modules/@demox-labs/miden-sdk/dist/Cargo-acbd8ac5.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__]);\n_Cargo_acbd8ac5_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst WorkerAction = Object.freeze({\n  INIT: \"init\",\n  CALL_METHOD: \"callMethod\",\n});\n\nconst MethodName = Object.freeze({\n  CREATE_CLIENT: \"createClient\",\n  NEW_WALLET: \"newWallet\",\n  NEW_FAUCET: \"newFaucet\",\n  EXECUTE_TRANSACTION: \"executeTransaction\",\n  PROVE_TRANSACTION: \"proveTransaction\",\n  SUBMIT_NEW_TRANSACTION: \"submitNewTransaction\",\n  SUBMIT_NEW_TRANSACTION_MOCK: \"submitNewTransactionMock\",\n  SYNC_STATE: \"syncState\",\n  SYNC_STATE_MOCK: \"syncStateMock\",\n});\n\nconst wasm = await (0,_wasm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\nconst buildTypedArraysExport = (exportObject) => {\n  return Object.entries(exportObject).reduce(\n    (exports, [exportName, _export]) => {\n      if (exportName.endsWith(\"Array\")) {\n        exports[exportName] = _export;\n      }\n      return exports;\n    },\n    {}\n  );\n};\n\nconst MidenArrays = buildTypedArraysExport(wasm);\nconst { WebClient: WasmWebClient } = wasm;\n/**\n * WebClient is a wrapper around the underlying WASM WebClient object.\n *\n * This wrapper serves several purposes:\n *\n * 1. It creates a dedicated web worker to offload computationally heavy tasks\n *    (such as creating accounts, executing transactions, submitting transactions, etc.)\n *    from the main thread, helping to prevent UI freezes in the browser.\n *\n * 2. It defines methods that mirror the API of the underlying WASM WebClient,\n *    with the intention of executing these functions via the web worker. This allows us\n *    to maintain the same API and parameters while benefiting from asynchronous, worker-based computation.\n *\n * 3. It employs a Proxy to forward any calls not designated for web worker computation\n *    directly to the underlying WASM WebClient instance.\n *\n * Additionally, the wrapper provides a static createClient function. This static method\n * instantiates the WebClient object and ensures that the necessary createClient calls are\n * performed both in the main thread and within the worker thread. This dual initialization\n * correctly passes user parameters (RPC URL and seed) to both the main-thread\n * WASM WebClient and the worker-side instance.\n *\n * Because of this implementation, the only breaking change for end users is in the way the\n * web client is instantiated. Users should now use the WebClient.createClient static call.\n */\nclass WebClient {\n  /**\n   * Create a WebClient wrapper.\n   *\n   * @param {string | undefined} rpcUrl - RPC endpoint URL used by the client.\n   * @param {Uint8Array | undefined} seed - Optional seed for account initialization.\n   * @param {(pubKey: Uint8Array) => Promise<Uint8Array | null | undefined> | Uint8Array | null | undefined} [getKeyCb]\n   *   - Callback to retrieve the secret key bytes for a given public key. The `pubKey`\n   *   parameter is the serialized public key (from `PublicKey.serialize()`). Return the\n   *   corresponding secret key as a `Uint8Array`, or `null`/`undefined` if not found. The\n   *   return value may be provided synchronously or via a `Promise`.\n   * @param {(pubKey: Uint8Array, secretKey: Uint8Array) => Promise<void> | void} [insertKeyCb]\n   *   - Callback to persist a secret key. `pubKey` is the serialized public key, and\n   *   `secretKey` is the serialized secret key (from `SecretKey.serialize()`). May return\n   *   `void` or a `Promise<void>`.\n   * @param {(pubKey: Uint8Array, signingInputs: Uint8Array) => Promise<Array<number | string>> | Array<number | string>} [signCb]\n   *   - Callback to produce signature elements for the provided inputs. `pubKey` is the\n   *   serialized public key, and `signingInputs` is a `Uint8Array` produced by\n   *   `SigningInputs.serialize()`. Must return an array of numeric values (numbers or numeric\n   *   strings) representing the signature elements, either directly or wrapped in a `Promise`.\n   */\n  constructor(rpcUrl, noteTransportUrl, seed, getKeyCb, insertKeyCb, signCb) {\n    this.rpcUrl = rpcUrl;\n    this.noteTransportUrl = noteTransportUrl;\n    this.seed = seed;\n    this.getKeyCb = getKeyCb;\n    this.insertKeyCb = insertKeyCb;\n    this.signCb = signCb;\n\n    // Check if Web Workers are available.\n    if (\n      typeof Worker !== \"undefined\" &&\n      !this.getKeyCb &&\n      !this.insertKeyCb &&\n      !this.signCb\n    ) {\n      console.log(\"WebClient: Web Workers are available.\");\n      // Create the worker.\n      this.worker = new Worker(\n        new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(0), __webpack_require__.b),\n        { type: undefined }\n      );\n\n      // Map to track pending worker requests.\n      this.pendingRequests = new Map();\n\n      // Promises to track when the worker script is loaded and ready.\n      this.loaded = new Promise((resolve) => {\n        this.loadedResolver = resolve;\n      });\n\n      // Create a promise that resolves when the worker signals that it is fully initialized.\n      this.ready = new Promise((resolve) => {\n        this.readyResolver = resolve;\n      });\n\n      // Listen for messages from the worker.\n      this.worker.addEventListener(\"message\", (event) => {\n        const data = event.data;\n\n        // Worker script loaded.\n        if (data.loaded) {\n          this.loadedResolver();\n          return;\n        }\n\n        // Worker ready.\n        if (data.ready) {\n          this.readyResolver();\n          return;\n        }\n\n        // Handle responses for method calls.\n        const { requestId, error, result, methodName } = data;\n        if (requestId && this.pendingRequests.has(requestId)) {\n          const { resolve, reject } = this.pendingRequests.get(requestId);\n          this.pendingRequests.delete(requestId);\n          if (error) {\n            console.error(\n              `WebClient: Error from worker in ${methodName}:`,\n              error\n            );\n            reject(new Error(error));\n          } else {\n            resolve(result);\n          }\n        }\n      });\n\n      // Once the worker script has loaded, initialize the worker.\n      this.loaded.then(() => {\n        this.worker.postMessage({\n          action: WorkerAction.INIT,\n          args: [\n            this.rpcUrl,\n            this.noteTransportUrl,\n            this.seed,\n            this.getKeyCb,\n            this.insertKeyCb,\n            this.signCb,\n          ],\n        });\n      });\n    } else {\n      console.log(\"WebClient: Web Workers are not available.\");\n      // Worker not available; set up fallback values.\n      this.worker = null;\n      this.pendingRequests = null;\n      this.loaded = Promise.resolve();\n      this.ready = Promise.resolve();\n    }\n\n    // Create the underlying WASM WebClient.\n    this.wasmWebClient = new WasmWebClient();\n  }\n\n  /**\n   * Factory method to create and initialize a WebClient instance.\n   * This method is async so you can await the asynchronous call to createClient().\n   *\n   * @param {string} rpcUrl - The RPC URL.\n   * @param {string} noteTransportUrl - The note transport URL (optional).\n   * @param {string} seed - The seed for the account.\n   * @returns {Promise<WebClient>} The fully initialized WebClient.\n   */\n  static async createClient(rpcUrl, noteTransportUrl, seed) {\n    // Construct the instance (synchronously).\n    const instance = new WebClient(rpcUrl, noteTransportUrl, seed);\n\n    // Wait for the underlying wasmWebClient to be initialized.\n    await instance.wasmWebClient.createClient(rpcUrl, noteTransportUrl, seed);\n\n    // Wait for the worker to be ready\n    await instance.ready;\n\n    // Return a proxy that forwards missing properties to wasmWebClient.\n    return new Proxy(instance, {\n      get(target, prop, receiver) {\n        // If the property exists on the wrapper, return it.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, if the wasmWebClient has it, return that.\n        if (target.wasmWebClient && prop in target.wasmWebClient) {\n          const value = target.wasmWebClient[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target.wasmWebClient);\n          }\n          return value;\n        }\n        return undefined;\n      },\n    });\n  }\n\n  /**\n   * Factory method to create and initialize a WebClient instance with a remote keystore.\n   * This method is async so you can await the asynchronous call to createClientWithExternalKeystore().\n   *\n   * @param {string} rpcUrl - The RPC URL.\n   * @param {string | undefined} noteTransportUrl - The note transport URL (optional).\n   * @param {string | undefined} seed - The seed for the account.\n   * @param {Function | undefined} getKeyCb - The get key callback.\n   * @param {Function | undefined} insertKeyCb - The insert key callback.\n   * @param {Function | undefined} signCb - The sign callback.\n   * @returns {Promise<WebClient>} The fully initialized WebClient.\n   */\n  static async createClientWithExternalKeystore(\n    rpcUrl,\n    noteTransportUrl,\n    seed,\n    getKeyCb,\n    insertKeyCb,\n    signCb\n  ) {\n    // Construct the instance (synchronously).\n    const instance = new WebClient(\n      rpcUrl,\n      noteTransportUrl,\n      seed,\n      getKeyCb,\n      insertKeyCb,\n      signCb\n    );\n    await instance.wasmWebClient.createClientWithExternalKeystore(\n      rpcUrl,\n      noteTransportUrl,\n      seed,\n      getKeyCb,\n      insertKeyCb,\n      signCb\n    );\n    await instance.ready;\n    // Return a proxy that forwards missing properties to wasmWebClient.\n    return new Proxy(instance, {\n      get(target, prop, receiver) {\n        // If the property exists on the wrapper, return it.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, if the wasmWebClient has it, return that.\n        if (target.wasmWebClient && prop in target.wasmWebClient) {\n          const value = target.wasmWebClient[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target.wasmWebClient);\n          }\n          return value;\n        }\n        return undefined;\n      },\n    });\n  }\n\n  /**\n   * Call a method via the worker.\n   * @param {string} methodName - Name of the method to call.\n   * @param  {...any} args - Arguments for the method.\n   * @returns {Promise<any>}\n   */\n  async callMethodWithWorker(methodName, ...args) {\n    await this.ready;\n    // Create a unique request ID.\n    const requestId = `${methodName}-${Date.now()}-${Math.random()}`;\n    return new Promise((resolve, reject) => {\n      // Save the resolve and reject callbacks in the pendingRequests map.\n      this.pendingRequests.set(requestId, { resolve, reject });\n      // Send the method call request to the worker.\n      this.worker.postMessage({\n        action: WorkerAction.CALL_METHOD,\n        methodName,\n        args,\n        requestId,\n      });\n    });\n  }\n\n  // ----- Explicitly Wrapped Methods (Worker-Forwarded) -----\n\n  async newWallet(storageMode, mutable, authSchemeId, seed) {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.newWallet(\n          storageMode,\n          mutable,\n          authSchemeId,\n          seed\n        );\n      }\n      const serializedStorageMode = storageMode.asStr();\n      const serializedAccountBytes = await this.callMethodWithWorker(\n        MethodName.NEW_WALLET,\n        serializedStorageMode,\n        mutable,\n        authSchemeId,\n        seed\n      );\n      return wasm.Account.deserialize(new Uint8Array(serializedAccountBytes));\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in newWallet:\", error.toString());\n      throw error;\n    }\n  }\n\n  async newFaucet(\n    storageMode,\n    nonFungible,\n    tokenSymbol,\n    decimals,\n    maxSupply,\n    authSchemeId\n  ) {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.newFaucet(\n          storageMode,\n          nonFungible,\n          tokenSymbol,\n          decimals,\n          maxSupply,\n          authSchemeId\n        );\n      }\n      const serializedStorageMode = storageMode.asStr();\n      const serializedMaxSupply = maxSupply.toString();\n      const serializedAccountBytes = await this.callMethodWithWorker(\n        MethodName.NEW_FAUCET,\n        serializedStorageMode,\n        nonFungible,\n        tokenSymbol,\n        decimals,\n        serializedMaxSupply,\n        authSchemeId\n      );\n\n      return wasm.Account.deserialize(new Uint8Array(serializedAccountBytes));\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in newFaucet:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitNewTransaction(accountId, transactionRequest) {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.submitNewTransaction(\n          accountId,\n          transactionRequest\n        );\n      }\n\n      const serializedTransactionRequest = transactionRequest.serialize();\n      const result = await this.callMethodWithWorker(\n        MethodName.SUBMIT_NEW_TRANSACTION,\n        accountId.toString(),\n        serializedTransactionRequest\n      );\n\n      const transactionResult = wasm.TransactionResult.deserialize(\n        new Uint8Array(result.serializedTransactionResult)\n      );\n\n      return transactionResult.id();\n    } catch (error) {\n      console.error(\n        \"INDEX.JS: Error in submitNewTransaction:\",\n        error.toString()\n      );\n      throw error;\n    }\n  }\n\n  async executeTransaction(accountId, transactionRequest) {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.executeTransaction(\n          accountId,\n          transactionRequest\n        );\n      }\n\n      const serializedTransactionRequest = transactionRequest.serialize();\n      const serializedResultBytes = await this.callMethodWithWorker(\n        MethodName.EXECUTE_TRANSACTION,\n        accountId.toString(),\n        serializedTransactionRequest\n      );\n\n      return wasm.TransactionResult.deserialize(\n        new Uint8Array(serializedResultBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in executeTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitTransaction(transactionResult, prover) {\n    try {\n      if (!this.worker) {\n        const proven = await this.wasmWebClient.proveTransaction(\n          transactionResult,\n          prover\n        );\n        const submissionHeight =\n          await this.wasmWebClient.submitProvenTransaction(\n            proven,\n            transactionResult\n          );\n        return await this.wasmWebClient.applyTransaction(\n          transactionResult,\n          submissionHeight\n        );\n      }\n\n      const serializedTransactionResult = transactionResult.serialize();\n      const proverPayload = prover ? prover.serialize() : null;\n\n      const { submissionHeight, serializedTransactionUpdate } =\n        await this.callMethodWithWorker(\n          MethodName.SUBMIT_TRANSACTION,\n          serializedTransactionResult,\n          proverPayload\n        );\n\n      if (this instanceof MockWebClient) {\n        return wasm.TransactionStoreUpdate.deserialize(\n          new Uint8Array(serializedTransactionUpdate)\n        );\n      }\n\n      return await this.wasmWebClient.applyTransaction(\n        transactionResult,\n        submissionHeight\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in submitTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async proveTransaction(transactionResult, prover) {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.proveTransaction(\n          transactionResult,\n          prover\n        );\n      }\n\n      const serializedTransactionResult = transactionResult.serialize();\n      const proverPayload = prover ? prover.serialize() : null;\n\n      const serializedProvenBytes = await this.callMethodWithWorker(\n        MethodName.PROVE_TRANSACTION,\n        serializedTransactionResult,\n        proverPayload\n      );\n\n      return wasm.ProvenTransaction.deserialize(\n        new Uint8Array(serializedProvenBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in proveTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async syncState() {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.syncState();\n      }\n\n      const serializedSyncSummaryBytes = await this.callMethodWithWorker(\n        MethodName.SYNC_STATE\n      );\n\n      return wasm.SyncSummary.deserialize(\n        new Uint8Array(serializedSyncSummaryBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in syncState:\", error.toString());\n      throw error;\n    }\n  }\n\n  terminate() {\n    this.worker.terminate();\n  }\n}\n\n// This copies static methods from WasmWebClient to WebClient\nObject.getOwnPropertyNames(WasmWebClient).forEach((prop) => {\n  if (\n    typeof WasmWebClient[prop] === \"function\" &&\n    prop !== \"constructor\" &&\n    prop !== \"prototype\"\n  ) {\n    WebClient[prop] = WasmWebClient[prop];\n  }\n});\n\nclass MockWebClient extends WebClient {\n  constructor(seed) {\n    super(null, seed);\n  }\n\n  /**\n   * Factory method to create a WebClient with a mock chain for testing purposes.\n   *\n   * @param serializedMockChain - Serialized mock chain data (optional). Will use an empty chain if not provided.\n   * @param serializedMockNoteTransportNode - Serialized mock note transport node data (optional). Will use a new instance if not provided.\n   * @param seed - The seed for the account (optional).\n   * @returns A promise that resolves to a MockWebClient.\n   */\n  static async createClient(\n    serializedMockChain,\n    serializedMockNoteTransportNode,\n    seed\n  ) {\n    // Construct the instance (synchronously).\n    const instance = new MockWebClient(seed);\n\n    // Wait for the underlying wasmWebClient to be initialized.\n    await instance.wasmWebClient.createMockClient(\n      seed,\n      serializedMockChain,\n      serializedMockNoteTransportNode\n    );\n\n    // Wait for the worker to be ready\n    await instance.ready;\n\n    // Return a proxy that forwards missing properties to wasmWebClient.\n    return new Proxy(instance, {\n      get(target, prop, receiver) {\n        // If the property exists on the wrapper, return it.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, if the wasmWebClient has it, return that.\n        if (target.wasmWebClient && prop in target.wasmWebClient) {\n          const value = target.wasmWebClient[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target.wasmWebClient);\n          }\n          return value;\n        }\n        return undefined;\n      },\n    });\n  }\n\n  async syncState() {\n    try {\n      if (!this.worker) {\n        return await this.wasmWebClient.syncState();\n      }\n\n      let serializedMockChain = this.wasmWebClient.serializeMockChain().buffer;\n      let serializedMockNoteTransportNode =\n        this.wasmWebClient.serializeMockNoteTransportNode().buffer;\n\n      const serializedSyncSummaryBytes = await this.callMethodWithWorker(\n        MethodName.SYNC_STATE_MOCK,\n        serializedMockChain,\n        serializedMockNoteTransportNode\n      );\n\n      return wasm.SyncSummary.deserialize(\n        new Uint8Array(serializedSyncSummaryBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in syncState:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitTransaction(transactionResult, prover) {\n    try {\n      if (!this.worker) {\n        return await super.submitTransaction(transactionResult, prover);\n      }\n\n      const serializedTransactionResult = transactionResult.serialize();\n      const proverPayload = prover ? prover.serialize() : null;\n      const serializedMockChain =\n        this.wasmWebClient.serializeMockChain().buffer;\n      const serializedMockNoteTransportNode =\n        this.wasmWebClient.serializeMockNoteTransportNode().buffer;\n\n      const result = await this.callMethodWithWorker(\n        MethodName.SUBMIT_TRANSACTION_MOCK,\n        serializedTransactionResult,\n        proverPayload,\n        serializedMockChain,\n        serializedMockNoteTransportNode\n      );\n      const newMockChain = new Uint8Array(result.serializedMockChain);\n      const newMockNoteTransportNode = result.serializedMockNoteTransportNode\n        ? new Uint8Array(result.serializedMockNoteTransportNode)\n        : undefined;\n\n      if (!(this instanceof MockWebClient)) {\n        return await this.wasmWebClient.applyTransaction(\n          transactionResult,\n          result.submissionHeight\n        );\n      }\n\n      this.wasmWebClient = new WasmWebClient();\n      await this.wasmWebClient.createMockClient(\n        this.seed,\n        newMockChain,\n        newMockNoteTransportNode\n      );\n\n      return wasm.TransactionStoreUpdate.deserialize(\n        new Uint8Array(result.serializedTransactionUpdate)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in submitTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitNewTransaction(accountId, transactionRequest) {\n    try {\n      if (!this.worker) {\n        return await super.submitNewTransaction(accountId, transactionRequest);\n      }\n\n      const serializedTransactionRequest = transactionRequest.serialize();\n      const serializedMockChain =\n        this.wasmWebClient.serializeMockChain().buffer;\n      const serializedMockNoteTransportNode =\n        this.wasmWebClient.serializeMockNoteTransportNode().buffer;\n\n      const result = await this.callMethodWithWorker(\n        MethodName.SUBMIT_NEW_TRANSACTION_MOCK,\n        accountId.toString(),\n        serializedTransactionRequest,\n        serializedMockChain,\n        serializedMockNoteTransportNode\n      );\n\n      const newMockChain = new Uint8Array(result.serializedMockChain);\n      const newMockNoteTransportNode = result.serializedMockNoteTransportNode\n        ? new Uint8Array(result.serializedMockNoteTransportNode)\n        : undefined;\n\n      const transactionResult = wasm.TransactionResult.deserialize(\n        new Uint8Array(result.serializedTransactionResult)\n      );\n\n      if (!(this instanceof MockWebClient)) {\n        return transactionResult.id();\n      }\n\n      this.wasmWebClient = new WasmWebClient();\n      await this.wasmWebClient.createMockClient(\n        this.seed,\n        newMockChain,\n        newMockNoteTransportNode\n      );\n\n      return transactionResult.id();\n    } catch (error) {\n      console.error(\n        \"INDEX.JS: Error in submitNewTransaction:\",\n        error.toString()\n      );\n      throw error;\n    }\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlbW94LWxhYnMvbWlkZW4tc2RrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDNjREOztBQUU5NkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsbUJBQW1CLG9EQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLGdHQUFnRztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUVBQXFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkdBQTZHO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyRkFBeUQ7QUFDekUsVUFBVSxNQUFNLFNBQVE7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHNCQUFzQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsR0FBRyxXQUFXLEdBQUcsY0FBYztBQUNuRTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQ7QUFDakQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcY3JhYmRhby1hZ2VudFxcbWlkZW4td2ViLXR1dG9yaWFsc1xcbm9kZV9tb2R1bGVzXFxAZGVtb3gtbGFic1xcbWlkZW4tc2RrXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9hZFdhc20gZnJvbSAnLi93YXNtLmpzJztcbmV4cG9ydCB7IEFjY291bnQsIEFjY291bnRBcnJheSwgQWNjb3VudEJ1aWxkZXIsIEFjY291bnRCdWlsZGVyUmVzdWx0LCBBY2NvdW50Q29kZSwgQWNjb3VudENvbXBvbmVudCwgQWNjb3VudERlbHRhLCBBY2NvdW50RmlsZSwgQWNjb3VudEhlYWRlciwgQWNjb3VudElkLCBBY2NvdW50SWRBcnJheSwgQWNjb3VudEludGVyZmFjZSwgQWNjb3VudFN0b3JhZ2UsIEFjY291bnRTdG9yYWdlRGVsdGEsIEFjY291bnRTdG9yYWdlTW9kZSwgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMsIEFjY291bnRUeXBlLCBBY2NvdW50VmF1bHREZWx0YSwgQWRkcmVzcywgQWR2aWNlSW5wdXRzLCBBZHZpY2VNYXAsIEFzc2V0VmF1bHQsIEF1dGhTZWNyZXRLZXksIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQsIEJsb2NrSGVhZGVyLCBDb25zdW1hYmxlTm90ZVJlY29yZCwgRW5kcG9pbnQsIEV4ZWN1dGVkVHJhbnNhY3Rpb24sIEZlbHQsIEZlbHRBcnJheSwgRmV0Y2hlZE5vdGUsIEZsYXR0ZW5lZFU4VmVjLCBGb3JlaWduQWNjb3VudCwgRm9yZWlnbkFjY291bnRBcnJheSwgRnVuZ2libGVBc3NldCwgRnVuZ2libGVBc3NldERlbHRhLCBGdW5naWJsZUFzc2V0RGVsdGFJdGVtLCBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbSwgSW5wdXROb3RlLCBJbnB1dE5vdGVSZWNvcmQsIElucHV0Tm90ZVN0YXRlLCBJbnB1dE5vdGVzLCBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2UsIEludG9VbmRlcmx5aW5nU2luaywgSW50b1VuZGVybHlpbmdTb3VyY2UsIEpzQWNjb3VudFVwZGF0ZSwgSnNTdGF0ZVN5bmNVcGRhdGUsIEpzU3RvcmFnZU1hcEVudHJ5LCBKc1N0b3JhZ2VTbG90LCBKc1ZhdWx0QXNzZXQsIExpYnJhcnksIE1lcmtsZVBhdGgsIE5ldHdvcmtJZCwgTm90ZSwgTm90ZUFuZEFyZ3MsIE5vdGVBbmRBcmdzQXJyYXksIE5vdGVBc3NldHMsIE5vdGVDb25zdW1hYmlsaXR5LCBOb3RlRGV0YWlscywgTm90ZURldGFpbHNBbmRUYWcsIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXksIE5vdGVFeGVjdXRpb25IaW50LCBOb3RlRXhlY3V0aW9uTW9kZSwgTm90ZUZpbGUsIE5vdGVGaWx0ZXIsIE5vdGVGaWx0ZXJUeXBlcywgTm90ZUhlYWRlciwgTm90ZUlkLCBOb3RlSWRBbmRBcmdzLCBOb3RlSWRBbmRBcmdzQXJyYXksIE5vdGVJbmNsdXNpb25Qcm9vZiwgTm90ZUlucHV0cywgTm90ZUxvY2F0aW9uLCBOb3RlTWV0YWRhdGEsIE5vdGVSZWNpcGllbnQsIE5vdGVSZWNpcGllbnRBcnJheSwgTm90ZVNjcmlwdCwgTm90ZVRhZywgTm90ZVR5cGUsIE91dHB1dE5vdGUsIE91dHB1dE5vdGVBcnJheSwgT3V0cHV0Tm90ZXMsIE91dHB1dE5vdGVzQXJyYXksIFBhY2thZ2UsIFBhcnRpYWxOb3RlLCBQcm92ZW5UcmFuc2FjdGlvbiwgUHVibGljS2V5LCBScGNDbGllbnQsIFJwbzI1NiwgU2NyaXB0QnVpbGRlciwgU2VjcmV0S2V5LCBTZXJpYWxpemVkSW5wdXROb3RlRGF0YSwgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLCBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhLCBTaWduYXR1cmUsIFNpZ25pbmdJbnB1dHMsIFNpZ25pbmdJbnB1dHNUeXBlLCBTbG90QW5kS2V5cywgU3RvcmFnZU1hcCwgU3RvcmFnZVNsb3QsIFN0b3JhZ2VTbG90QXJyYXksIFN5bmNTdW1tYXJ5LCBUZXN0VXRpbHMsIFRva2VuU3ltYm9sLCBUcmFuc2FjdGlvbkFyZ3MsIFRyYW5zYWN0aW9uRmlsdGVyLCBUcmFuc2FjdGlvbklkLCBUcmFuc2FjdGlvblByb3ZlciwgVHJhbnNhY3Rpb25SZWNvcmQsIFRyYW5zYWN0aW9uUmVxdWVzdCwgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlciwgVHJhbnNhY3Rpb25SZXN1bHQsIFRyYW5zYWN0aW9uU2NyaXB0LCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpciwgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheSwgVHJhbnNhY3Rpb25TdGF0dXMsIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUsIFRyYW5zYWN0aW9uU3VtbWFyeSwgV29yZCwgaW5pdFN5bmMgfSBmcm9tICcuL0NhcmdvLWFjYmQ4YWM1LmpzJztcblxuY29uc3QgV29ya2VyQWN0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIElOSVQ6IFwiaW5pdFwiLFxuICBDQUxMX01FVEhPRDogXCJjYWxsTWV0aG9kXCIsXG59KTtcblxuY29uc3QgTWV0aG9kTmFtZSA9IE9iamVjdC5mcmVlemUoe1xuICBDUkVBVEVfQ0xJRU5UOiBcImNyZWF0ZUNsaWVudFwiLFxuICBORVdfV0FMTEVUOiBcIm5ld1dhbGxldFwiLFxuICBORVdfRkFVQ0VUOiBcIm5ld0ZhdWNldFwiLFxuICBFWEVDVVRFX1RSQU5TQUNUSU9OOiBcImV4ZWN1dGVUcmFuc2FjdGlvblwiLFxuICBQUk9WRV9UUkFOU0FDVElPTjogXCJwcm92ZVRyYW5zYWN0aW9uXCIsXG4gIFNVQk1JVF9ORVdfVFJBTlNBQ1RJT046IFwic3VibWl0TmV3VHJhbnNhY3Rpb25cIixcbiAgU1VCTUlUX05FV19UUkFOU0FDVElPTl9NT0NLOiBcInN1Ym1pdE5ld1RyYW5zYWN0aW9uTW9ja1wiLFxuICBTWU5DX1NUQVRFOiBcInN5bmNTdGF0ZVwiLFxuICBTWU5DX1NUQVRFX01PQ0s6IFwic3luY1N0YXRlTW9ja1wiLFxufSk7XG5cbmNvbnN0IHdhc20gPSBhd2FpdCBsb2FkV2FzbSgpO1xuY29uc3QgYnVpbGRUeXBlZEFycmF5c0V4cG9ydCA9IChleHBvcnRPYmplY3QpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGV4cG9ydE9iamVjdCkucmVkdWNlKFxuICAgIChleHBvcnRzLCBbZXhwb3J0TmFtZSwgX2V4cG9ydF0pID0+IHtcbiAgICAgIGlmIChleHBvcnROYW1lLmVuZHNXaXRoKFwiQXJyYXlcIikpIHtcbiAgICAgICAgZXhwb3J0c1tleHBvcnROYW1lXSA9IF9leHBvcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9LFxuICAgIHt9XG4gICk7XG59O1xuXG5jb25zdCBNaWRlbkFycmF5cyA9IGJ1aWxkVHlwZWRBcnJheXNFeHBvcnQod2FzbSk7XG5jb25zdCB7IFdlYkNsaWVudDogV2FzbVdlYkNsaWVudCB9ID0gd2FzbTtcbi8qKlxuICogV2ViQ2xpZW50IGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIHVuZGVybHlpbmcgV0FTTSBXZWJDbGllbnQgb2JqZWN0LlxuICpcbiAqIFRoaXMgd3JhcHBlciBzZXJ2ZXMgc2V2ZXJhbCBwdXJwb3NlczpcbiAqXG4gKiAxLiBJdCBjcmVhdGVzIGEgZGVkaWNhdGVkIHdlYiB3b3JrZXIgdG8gb2ZmbG9hZCBjb21wdXRhdGlvbmFsbHkgaGVhdnkgdGFza3NcbiAqICAgIChzdWNoIGFzIGNyZWF0aW5nIGFjY291bnRzLCBleGVjdXRpbmcgdHJhbnNhY3Rpb25zLCBzdWJtaXR0aW5nIHRyYW5zYWN0aW9ucywgZXRjLilcbiAqICAgIGZyb20gdGhlIG1haW4gdGhyZWFkLCBoZWxwaW5nIHRvIHByZXZlbnQgVUkgZnJlZXplcyBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiAyLiBJdCBkZWZpbmVzIG1ldGhvZHMgdGhhdCBtaXJyb3IgdGhlIEFQSSBvZiB0aGUgdW5kZXJseWluZyBXQVNNIFdlYkNsaWVudCxcbiAqICAgIHdpdGggdGhlIGludGVudGlvbiBvZiBleGVjdXRpbmcgdGhlc2UgZnVuY3Rpb25zIHZpYSB0aGUgd2ViIHdvcmtlci4gVGhpcyBhbGxvd3MgdXNcbiAqICAgIHRvIG1haW50YWluIHRoZSBzYW1lIEFQSSBhbmQgcGFyYW1ldGVycyB3aGlsZSBiZW5lZml0aW5nIGZyb20gYXN5bmNocm9ub3VzLCB3b3JrZXItYmFzZWQgY29tcHV0YXRpb24uXG4gKlxuICogMy4gSXQgZW1wbG95cyBhIFByb3h5IHRvIGZvcndhcmQgYW55IGNhbGxzIG5vdCBkZXNpZ25hdGVkIGZvciB3ZWIgd29ya2VyIGNvbXB1dGF0aW9uXG4gKiAgICBkaXJlY3RseSB0byB0aGUgdW5kZXJseWluZyBXQVNNIFdlYkNsaWVudCBpbnN0YW5jZS5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHRoZSB3cmFwcGVyIHByb3ZpZGVzIGEgc3RhdGljIGNyZWF0ZUNsaWVudCBmdW5jdGlvbi4gVGhpcyBzdGF0aWMgbWV0aG9kXG4gKiBpbnN0YW50aWF0ZXMgdGhlIFdlYkNsaWVudCBvYmplY3QgYW5kIGVuc3VyZXMgdGhhdCB0aGUgbmVjZXNzYXJ5IGNyZWF0ZUNsaWVudCBjYWxscyBhcmVcbiAqIHBlcmZvcm1lZCBib3RoIGluIHRoZSBtYWluIHRocmVhZCBhbmQgd2l0aGluIHRoZSB3b3JrZXIgdGhyZWFkLiBUaGlzIGR1YWwgaW5pdGlhbGl6YXRpb25cbiAqIGNvcnJlY3RseSBwYXNzZXMgdXNlciBwYXJhbWV0ZXJzIChSUEMgVVJMIGFuZCBzZWVkKSB0byBib3RoIHRoZSBtYWluLXRocmVhZFxuICogV0FTTSBXZWJDbGllbnQgYW5kIHRoZSB3b3JrZXItc2lkZSBpbnN0YW5jZS5cbiAqXG4gKiBCZWNhdXNlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24sIHRoZSBvbmx5IGJyZWFraW5nIGNoYW5nZSBmb3IgZW5kIHVzZXJzIGlzIGluIHRoZSB3YXkgdGhlXG4gKiB3ZWIgY2xpZW50IGlzIGluc3RhbnRpYXRlZC4gVXNlcnMgc2hvdWxkIG5vdyB1c2UgdGhlIFdlYkNsaWVudC5jcmVhdGVDbGllbnQgc3RhdGljIGNhbGwuXG4gKi9cbmNsYXNzIFdlYkNsaWVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBXZWJDbGllbnQgd3JhcHBlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHJwY1VybCAtIFJQQyBlbmRwb2ludCBVUkwgdXNlZCBieSB0aGUgY2xpZW50LlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9IHNlZWQgLSBPcHRpb25hbCBzZWVkIGZvciBhY2NvdW50IGluaXRpYWxpemF0aW9uLlxuICAgKiBAcGFyYW0geyhwdWJLZXk6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheSB8IG51bGwgfCB1bmRlZmluZWQ+IHwgVWludDhBcnJheSB8IG51bGwgfCB1bmRlZmluZWR9IFtnZXRLZXlDYl1cbiAgICogICAtIENhbGxiYWNrIHRvIHJldHJpZXZlIHRoZSBzZWNyZXQga2V5IGJ5dGVzIGZvciBhIGdpdmVuIHB1YmxpYyBrZXkuIFRoZSBgcHViS2V5YFxuICAgKiAgIHBhcmFtZXRlciBpcyB0aGUgc2VyaWFsaXplZCBwdWJsaWMga2V5IChmcm9tIGBQdWJsaWNLZXkuc2VyaWFsaXplKClgKS4gUmV0dXJuIHRoZVxuICAgKiAgIGNvcnJlc3BvbmRpbmcgc2VjcmV0IGtleSBhcyBhIGBVaW50OEFycmF5YCwgb3IgYG51bGxgL2B1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gVGhlXG4gICAqICAgcmV0dXJuIHZhbHVlIG1heSBiZSBwcm92aWRlZCBzeW5jaHJvbm91c2x5IG9yIHZpYSBhIGBQcm9taXNlYC5cbiAgICogQHBhcmFtIHsocHViS2V5OiBVaW50OEFycmF5LCBzZWNyZXRLZXk6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkfSBbaW5zZXJ0S2V5Q2JdXG4gICAqICAgLSBDYWxsYmFjayB0byBwZXJzaXN0IGEgc2VjcmV0IGtleS4gYHB1YktleWAgaXMgdGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleSwgYW5kXG4gICAqICAgYHNlY3JldEtleWAgaXMgdGhlIHNlcmlhbGl6ZWQgc2VjcmV0IGtleSAoZnJvbSBgU2VjcmV0S2V5LnNlcmlhbGl6ZSgpYCkuIE1heSByZXR1cm5cbiAgICogICBgdm9pZGAgb3IgYSBgUHJvbWlzZTx2b2lkPmAuXG4gICAqIEBwYXJhbSB7KHB1YktleTogVWludDhBcnJheSwgc2lnbmluZ0lucHV0czogVWludDhBcnJheSkgPT4gUHJvbWlzZTxBcnJheTxudW1iZXIgfCBzdHJpbmc+PiB8IEFycmF5PG51bWJlciB8IHN0cmluZz59IFtzaWduQ2JdXG4gICAqICAgLSBDYWxsYmFjayB0byBwcm9kdWNlIHNpZ25hdHVyZSBlbGVtZW50cyBmb3IgdGhlIHByb3ZpZGVkIGlucHV0cy4gYHB1YktleWAgaXMgdGhlXG4gICAqICAgc2VyaWFsaXplZCBwdWJsaWMga2V5LCBhbmQgYHNpZ25pbmdJbnB1dHNgIGlzIGEgYFVpbnQ4QXJyYXlgIHByb2R1Y2VkIGJ5XG4gICAqICAgYFNpZ25pbmdJbnB1dHMuc2VyaWFsaXplKClgLiBNdXN0IHJldHVybiBhbiBhcnJheSBvZiBudW1lcmljIHZhbHVlcyAobnVtYmVycyBvciBudW1lcmljXG4gICAqICAgc3RyaW5ncykgcmVwcmVzZW50aW5nIHRoZSBzaWduYXR1cmUgZWxlbWVudHMsIGVpdGhlciBkaXJlY3RseSBvciB3cmFwcGVkIGluIGEgYFByb21pc2VgLlxuICAgKi9cbiAgY29uc3RydWN0b3IocnBjVXJsLCBub3RlVHJhbnNwb3J0VXJsLCBzZWVkLCBnZXRLZXlDYiwgaW5zZXJ0S2V5Q2IsIHNpZ25DYikge1xuICAgIHRoaXMucnBjVXJsID0gcnBjVXJsO1xuICAgIHRoaXMubm90ZVRyYW5zcG9ydFVybCA9IG5vdGVUcmFuc3BvcnRVcmw7XG4gICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB0aGlzLmdldEtleUNiID0gZ2V0S2V5Q2I7XG4gICAgdGhpcy5pbnNlcnRLZXlDYiA9IGluc2VydEtleUNiO1xuICAgIHRoaXMuc2lnbkNiID0gc2lnbkNiO1xuXG4gICAgLy8gQ2hlY2sgaWYgV2ViIFdvcmtlcnMgYXJlIGF2YWlsYWJsZS5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAhdGhpcy5nZXRLZXlDYiAmJlxuICAgICAgIXRoaXMuaW5zZXJ0S2V5Q2IgJiZcbiAgICAgICF0aGlzLnNpZ25DYlxuICAgICkge1xuICAgICAgY29uc29sZS5sb2coXCJXZWJDbGllbnQ6IFdlYiBXb3JrZXJzIGFyZSBhdmFpbGFibGUuXCIpO1xuICAgICAgLy8gQ3JlYXRlIHRoZSB3b3JrZXIuXG4gICAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoXG4gICAgICAgIG5ldyBVUkwoXCIuL3dvcmtlcnMvd2ViLWNsaWVudC1tZXRob2RzLXdvcmtlci5qc1wiLCBpbXBvcnQubWV0YS51cmwpLFxuICAgICAgICB7IHR5cGU6IFwibW9kdWxlXCIgfVxuICAgICAgKTtcblxuICAgICAgLy8gTWFwIHRvIHRyYWNrIHBlbmRpbmcgd29ya2VyIHJlcXVlc3RzLlxuICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIC8vIFByb21pc2VzIHRvIHRyYWNrIHdoZW4gdGhlIHdvcmtlciBzY3JpcHQgaXMgbG9hZGVkIGFuZCByZWFkeS5cbiAgICAgIHRoaXMubG9hZGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5sb2FkZWRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHdvcmtlciBzaWduYWxzIHRoYXQgaXQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQuXG4gICAgICB0aGlzLnJlYWR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5yZWFkeVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gdGhlIHdvcmtlci5cbiAgICAgIHRoaXMud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICAvLyBXb3JrZXIgc2NyaXB0IGxvYWRlZC5cbiAgICAgICAgaWYgKGRhdGEubG9hZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZWRSZXNvbHZlcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdvcmtlciByZWFkeS5cbiAgICAgICAgaWYgKGRhdGEucmVhZHkpIHtcbiAgICAgICAgICB0aGlzLnJlYWR5UmVzb2x2ZXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgcmVzcG9uc2VzIGZvciBtZXRob2QgY2FsbHMuXG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdElkLCBlcnJvciwgcmVzdWx0LCBtZXRob2ROYW1lIH0gPSBkYXRhO1xuICAgICAgICBpZiAocmVxdWVzdElkICYmIHRoaXMucGVuZGluZ1JlcXVlc3RzLmhhcyhyZXF1ZXN0SWQpKSB7XG4gICAgICAgICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYFdlYkNsaWVudDogRXJyb3IgZnJvbSB3b3JrZXIgaW4gJHttZXRob2ROYW1lfTpgLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9uY2UgdGhlIHdvcmtlciBzY3JpcHQgaGFzIGxvYWRlZCwgaW5pdGlhbGl6ZSB0aGUgd29ya2VyLlxuICAgICAgdGhpcy5sb2FkZWQudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBhY3Rpb246IFdvcmtlckFjdGlvbi5JTklULFxuICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgIHRoaXMucnBjVXJsLFxuICAgICAgICAgICAgdGhpcy5ub3RlVHJhbnNwb3J0VXJsLFxuICAgICAgICAgICAgdGhpcy5zZWVkLFxuICAgICAgICAgICAgdGhpcy5nZXRLZXlDYixcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0S2V5Q2IsXG4gICAgICAgICAgICB0aGlzLnNpZ25DYixcbiAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldlYkNsaWVudDogV2ViIFdvcmtlcnMgYXJlIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgLy8gV29ya2VyIG5vdCBhdmFpbGFibGU7IHNldCB1cCBmYWxsYmFjayB2YWx1ZXMuXG4gICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IG51bGw7XG4gICAgICB0aGlzLmxvYWRlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5yZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgdW5kZXJseWluZyBXQVNNIFdlYkNsaWVudC5cbiAgICB0aGlzLndhc21XZWJDbGllbnQgPSBuZXcgV2FzbVdlYkNsaWVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIFdlYkNsaWVudCBpbnN0YW5jZS5cbiAgICogVGhpcyBtZXRob2QgaXMgYXN5bmMgc28geW91IGNhbiBhd2FpdCB0aGUgYXN5bmNocm9ub3VzIGNhbGwgdG8gY3JlYXRlQ2xpZW50KCkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBUaGUgUlBDIFVSTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5vdGVUcmFuc3BvcnRVcmwgLSBUaGUgbm90ZSB0cmFuc3BvcnQgVVJMIChvcHRpb25hbCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkIC0gVGhlIHNlZWQgZm9yIHRoZSBhY2NvdW50LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJDbGllbnQ+fSBUaGUgZnVsbHkgaW5pdGlhbGl6ZWQgV2ViQ2xpZW50LlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUNsaWVudChycGNVcmwsIG5vdGVUcmFuc3BvcnRVcmwsIHNlZWQpIHtcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGluc3RhbmNlIChzeW5jaHJvbm91c2x5KS5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJDbGllbnQocnBjVXJsLCBub3RlVHJhbnNwb3J0VXJsLCBzZWVkKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSB1bmRlcmx5aW5nIHdhc21XZWJDbGllbnQgdG8gYmUgaW5pdGlhbGl6ZWQuXG4gICAgYXdhaXQgaW5zdGFuY2Uud2FzbVdlYkNsaWVudC5jcmVhdGVDbGllbnQocnBjVXJsLCBub3RlVHJhbnNwb3J0VXJsLCBzZWVkKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gYmUgcmVhZHlcbiAgICBhd2FpdCBpbnN0YW5jZS5yZWFkeTtcblxuICAgIC8vIFJldHVybiBhIHByb3h5IHRoYXQgZm9yd2FyZHMgbWlzc2luZyBwcm9wZXJ0aWVzIHRvIHdhc21XZWJDbGllbnQuXG4gICAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZSwge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgd3JhcHBlciwgcmV0dXJuIGl0LlxuICAgICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgd2FzbVdlYkNsaWVudCBoYXMgaXQsIHJldHVybiB0aGF0LlxuICAgICAgICBpZiAodGFyZ2V0Lndhc21XZWJDbGllbnQgJiYgcHJvcCBpbiB0YXJnZXQud2FzbVdlYkNsaWVudCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0Lndhc21XZWJDbGllbnRbcHJvcF07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQud2FzbVdlYkNsaWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgYSBXZWJDbGllbnQgaW5zdGFuY2Ugd2l0aCBhIHJlbW90ZSBrZXlzdG9yZS5cbiAgICogVGhpcyBtZXRob2QgaXMgYXN5bmMgc28geW91IGNhbiBhd2FpdCB0aGUgYXN5bmNocm9ub3VzIGNhbGwgdG8gY3JlYXRlQ2xpZW50V2l0aEV4dGVybmFsS2V5c3RvcmUoKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJwY1VybCAtIFRoZSBSUEMgVVJMLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbm90ZVRyYW5zcG9ydFVybCAtIFRoZSBub3RlIHRyYW5zcG9ydCBVUkwgKG9wdGlvbmFsKS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHNlZWQgLSBUaGUgc2VlZCBmb3IgdGhlIGFjY291bnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb24gfCB1bmRlZmluZWR9IGdldEtleUNiIC0gVGhlIGdldCBrZXkgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb24gfCB1bmRlZmluZWR9IGluc2VydEtleUNiIC0gVGhlIGluc2VydCBrZXkgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb24gfCB1bmRlZmluZWR9IHNpZ25DYiAtIFRoZSBzaWduIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJDbGllbnQ+fSBUaGUgZnVsbHkgaW5pdGlhbGl6ZWQgV2ViQ2xpZW50LlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUNsaWVudFdpdGhFeHRlcm5hbEtleXN0b3JlKFxuICAgIHJwY1VybCxcbiAgICBub3RlVHJhbnNwb3J0VXJsLFxuICAgIHNlZWQsXG4gICAgZ2V0S2V5Q2IsXG4gICAgaW5zZXJ0S2V5Q2IsXG4gICAgc2lnbkNiXG4gICkge1xuICAgIC8vIENvbnN0cnVjdCB0aGUgaW5zdGFuY2UgKHN5bmNocm9ub3VzbHkpLlxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkNsaWVudChcbiAgICAgIHJwY1VybCxcbiAgICAgIG5vdGVUcmFuc3BvcnRVcmwsXG4gICAgICBzZWVkLFxuICAgICAgZ2V0S2V5Q2IsXG4gICAgICBpbnNlcnRLZXlDYixcbiAgICAgIHNpZ25DYlxuICAgICk7XG4gICAgYXdhaXQgaW5zdGFuY2Uud2FzbVdlYkNsaWVudC5jcmVhdGVDbGllbnRXaXRoRXh0ZXJuYWxLZXlzdG9yZShcbiAgICAgIHJwY1VybCxcbiAgICAgIG5vdGVUcmFuc3BvcnRVcmwsXG4gICAgICBzZWVkLFxuICAgICAgZ2V0S2V5Q2IsXG4gICAgICBpbnNlcnRLZXlDYixcbiAgICAgIHNpZ25DYlxuICAgICk7XG4gICAgYXdhaXQgaW5zdGFuY2UucmVhZHk7XG4gICAgLy8gUmV0dXJuIGEgcHJveHkgdGhhdCBmb3J3YXJkcyBtaXNzaW5nIHByb3BlcnRpZXMgdG8gd2FzbVdlYkNsaWVudC5cbiAgICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLCB7XG4gICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSB3cmFwcGVyLCByZXR1cm4gaXQuXG4gICAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSB3YXNtV2ViQ2xpZW50IGhhcyBpdCwgcmV0dXJuIHRoYXQuXG4gICAgICAgIGlmICh0YXJnZXQud2FzbVdlYkNsaWVudCAmJiBwcm9wIGluIHRhcmdldC53YXNtV2ViQ2xpZW50KSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXQud2FzbVdlYkNsaWVudFtwcm9wXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKHRhcmdldC53YXNtV2ViQ2xpZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYSBtZXRob2QgdmlhIHRoZSB3b3JrZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gTmFtZSBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyAtIEFyZ3VtZW50cyBmb3IgdGhlIG1ldGhvZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICovXG4gIGFzeW5jIGNhbGxNZXRob2RXaXRoV29ya2VyKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICBhd2FpdCB0aGlzLnJlYWR5O1xuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSByZXF1ZXN0IElELlxuICAgIGNvbnN0IHJlcXVlc3RJZCA9IGAke21ldGhvZE5hbWV9LSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpfWA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFNhdmUgdGhlIHJlc29sdmUgYW5kIHJlamVjdCBjYWxsYmFja3MgaW4gdGhlIHBlbmRpbmdSZXF1ZXN0cyBtYXAuXG4gICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIC8vIFNlbmQgdGhlIG1ldGhvZCBjYWxsIHJlcXVlc3QgdG8gdGhlIHdvcmtlci5cbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiBXb3JrZXJBY3Rpb24uQ0FMTF9NRVRIT0QsXG4gICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gLS0tLS0gRXhwbGljaXRseSBXcmFwcGVkIE1ldGhvZHMgKFdvcmtlci1Gb3J3YXJkZWQpIC0tLS0tXG5cbiAgYXN5bmMgbmV3V2FsbGV0KHN0b3JhZ2VNb2RlLCBtdXRhYmxlLCBhdXRoU2NoZW1lSWQsIHNlZWQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50Lm5ld1dhbGxldChcbiAgICAgICAgICBzdG9yYWdlTW9kZSxcbiAgICAgICAgICBtdXRhYmxlLFxuICAgICAgICAgIGF1dGhTY2hlbWVJZCxcbiAgICAgICAgICBzZWVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXJpYWxpemVkU3RvcmFnZU1vZGUgPSBzdG9yYWdlTW9kZS5hc1N0cigpO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZEFjY291bnRCeXRlcyA9IGF3YWl0IHRoaXMuY2FsbE1ldGhvZFdpdGhXb3JrZXIoXG4gICAgICAgIE1ldGhvZE5hbWUuTkVXX1dBTExFVCxcbiAgICAgICAgc2VyaWFsaXplZFN0b3JhZ2VNb2RlLFxuICAgICAgICBtdXRhYmxlLFxuICAgICAgICBhdXRoU2NoZW1lSWQsXG4gICAgICAgIHNlZWRcbiAgICAgICk7XG4gICAgICByZXR1cm4gd2FzbS5BY2NvdW50LmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRBY2NvdW50Qnl0ZXMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIklOREVYLkpTOiBFcnJvciBpbiBuZXdXYWxsZXQ6XCIsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbmV3RmF1Y2V0KFxuICAgIHN0b3JhZ2VNb2RlLFxuICAgIG5vbkZ1bmdpYmxlLFxuICAgIHRva2VuU3ltYm9sLFxuICAgIGRlY2ltYWxzLFxuICAgIG1heFN1cHBseSxcbiAgICBhdXRoU2NoZW1lSWRcbiAgKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud2FzbVdlYkNsaWVudC5uZXdGYXVjZXQoXG4gICAgICAgICAgc3RvcmFnZU1vZGUsXG4gICAgICAgICAgbm9uRnVuZ2libGUsXG4gICAgICAgICAgdG9rZW5TeW1ib2wsXG4gICAgICAgICAgZGVjaW1hbHMsXG4gICAgICAgICAgbWF4U3VwcGx5LFxuICAgICAgICAgIGF1dGhTY2hlbWVJZFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VyaWFsaXplZFN0b3JhZ2VNb2RlID0gc3RvcmFnZU1vZGUuYXNTdHIoKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNYXhTdXBwbHkgPSBtYXhTdXBwbHkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBY2NvdW50Qnl0ZXMgPSBhd2FpdCB0aGlzLmNhbGxNZXRob2RXaXRoV29ya2VyKFxuICAgICAgICBNZXRob2ROYW1lLk5FV19GQVVDRVQsXG4gICAgICAgIHNlcmlhbGl6ZWRTdG9yYWdlTW9kZSxcbiAgICAgICAgbm9uRnVuZ2libGUsXG4gICAgICAgIHRva2VuU3ltYm9sLFxuICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgc2VyaWFsaXplZE1heFN1cHBseSxcbiAgICAgICAgYXV0aFNjaGVtZUlkXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gd2FzbS5BY2NvdW50LmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRBY2NvdW50Qnl0ZXMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIklOREVYLkpTOiBFcnJvciBpbiBuZXdGYXVjZXQ6XCIsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3VibWl0TmV3VHJhbnNhY3Rpb24oYWNjb3VudElkLCB0cmFuc2FjdGlvblJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50LnN1Ym1pdE5ld1RyYW5zYWN0aW9uKFxuICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICB0cmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVxdWVzdCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbE1ldGhvZFdpdGhXb3JrZXIoXG4gICAgICAgIE1ldGhvZE5hbWUuU1VCTUlUX05FV19UUkFOU0FDVElPTixcbiAgICAgICAgYWNjb3VudElkLnRvU3RyaW5nKCksXG4gICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVzdWx0ID0gd2FzbS5UcmFuc2FjdGlvblJlc3VsdC5kZXNlcmlhbGl6ZShcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0LnNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlc3VsdClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblJlc3VsdC5pZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIklOREVYLkpTOiBFcnJvciBpbiBzdWJtaXROZXdUcmFuc2FjdGlvbjpcIixcbiAgICAgICAgZXJyb3IudG9TdHJpbmcoKVxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVUcmFuc2FjdGlvbihhY2NvdW50SWQsIHRyYW5zYWN0aW9uUmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndhc21XZWJDbGllbnQuZXhlY3V0ZVRyYW5zYWN0aW9uKFxuICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICB0cmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVxdWVzdCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXN1bHRCeXRlcyA9IGF3YWl0IHRoaXMuY2FsbE1ldGhvZFdpdGhXb3JrZXIoXG4gICAgICAgIE1ldGhvZE5hbWUuRVhFQ1VURV9UUkFOU0FDVElPTixcbiAgICAgICAgYWNjb3VudElkLnRvU3RyaW5nKCksXG4gICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB3YXNtLlRyYW5zYWN0aW9uUmVzdWx0LmRlc2VyaWFsaXplKFxuICAgICAgICBuZXcgVWludDhBcnJheShzZXJpYWxpemVkUmVzdWx0Qnl0ZXMpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSU5ERVguSlM6IEVycm9yIGluIGV4ZWN1dGVUcmFuc2FjdGlvbjpcIiwgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvblJlc3VsdCwgcHJvdmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgY29uc3QgcHJvdmVuID0gYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50LnByb3ZlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgdHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgICAgICAgcHJvdmVyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHN1Ym1pc3Npb25IZWlnaHQgPVxuICAgICAgICAgIGF3YWl0IHRoaXMud2FzbVdlYkNsaWVudC5zdWJtaXRQcm92ZW5UcmFuc2FjdGlvbihcbiAgICAgICAgICAgIHByb3ZlbixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uUmVzdWx0XG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud2FzbVdlYkNsaWVudC5hcHBseVRyYW5zYWN0aW9uKFxuICAgICAgICAgIHRyYW5zYWN0aW9uUmVzdWx0LFxuICAgICAgICAgIHN1Ym1pc3Npb25IZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHJhbnNhY3Rpb25SZXN1bHQuc2VyaWFsaXplKCk7XG4gICAgICBjb25zdCBwcm92ZXJQYXlsb2FkID0gcHJvdmVyID8gcHJvdmVyLnNlcmlhbGl6ZSgpIDogbnVsbDtcblxuICAgICAgY29uc3QgeyBzdWJtaXNzaW9uSGVpZ2h0LCBzZXJpYWxpemVkVHJhbnNhY3Rpb25VcGRhdGUgfSA9XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbE1ldGhvZFdpdGhXb3JrZXIoXG4gICAgICAgICAgTWV0aG9kTmFtZS5TVUJNSVRfVFJBTlNBQ1RJT04sXG4gICAgICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgICAgICAgIHByb3ZlclBheWxvYWRcbiAgICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNb2NrV2ViQ2xpZW50KSB7XG4gICAgICAgIHJldHVybiB3YXNtLlRyYW5zYWN0aW9uU3RvcmVVcGRhdGUuZGVzZXJpYWxpemUoXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2VyaWFsaXplZFRyYW5zYWN0aW9uVXBkYXRlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50LmFwcGx5VHJhbnNhY3Rpb24oXG4gICAgICAgIHRyYW5zYWN0aW9uUmVzdWx0LFxuICAgICAgICBzdWJtaXNzaW9uSGVpZ2h0XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSU5ERVguSlM6IEVycm9yIGluIHN1Ym1pdFRyYW5zYWN0aW9uOlwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHByb3ZlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25SZXN1bHQsIHByb3Zlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndhc21XZWJDbGllbnQucHJvdmVUcmFuc2FjdGlvbihcbiAgICAgICAgICB0cmFuc2FjdGlvblJlc3VsdCxcbiAgICAgICAgICBwcm92ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHJhbnNhY3Rpb25SZXN1bHQuc2VyaWFsaXplKCk7XG4gICAgICBjb25zdCBwcm92ZXJQYXlsb2FkID0gcHJvdmVyID8gcHJvdmVyLnNlcmlhbGl6ZSgpIDogbnVsbDtcblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFByb3ZlbkJ5dGVzID0gYXdhaXQgdGhpcy5jYWxsTWV0aG9kV2l0aFdvcmtlcihcbiAgICAgICAgTWV0aG9kTmFtZS5QUk9WRV9UUkFOU0FDVElPTixcbiAgICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgICAgICBwcm92ZXJQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gd2FzbS5Qcm92ZW5UcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZShcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2VyaWFsaXplZFByb3ZlbkJ5dGVzKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIklOREVYLkpTOiBFcnJvciBpbiBwcm92ZVRyYW5zYWN0aW9uOlwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN5bmNTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50LnN5bmNTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXJpYWxpemVkU3luY1N1bW1hcnlCeXRlcyA9IGF3YWl0IHRoaXMuY2FsbE1ldGhvZFdpdGhXb3JrZXIoXG4gICAgICAgIE1ldGhvZE5hbWUuU1lOQ19TVEFURVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHdhc20uU3luY1N1bW1hcnkuZGVzZXJpYWxpemUoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRTeW5jU3VtbWFyeUJ5dGVzKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIklOREVYLkpTOiBFcnJvciBpbiBzeW5jU3RhdGU6XCIsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgdGVybWluYXRlKCkge1xuICAgIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICB9XG59XG5cbi8vIFRoaXMgY29waWVzIHN0YXRpYyBtZXRob2RzIGZyb20gV2FzbVdlYkNsaWVudCB0byBXZWJDbGllbnRcbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFdhc21XZWJDbGllbnQpLmZvckVhY2goKHByb3ApID0+IHtcbiAgaWYgKFxuICAgIHR5cGVvZiBXYXNtV2ViQ2xpZW50W3Byb3BdID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICBwcm9wICE9PSBcImNvbnN0cnVjdG9yXCIgJiZcbiAgICBwcm9wICE9PSBcInByb3RvdHlwZVwiXG4gICkge1xuICAgIFdlYkNsaWVudFtwcm9wXSA9IFdhc21XZWJDbGllbnRbcHJvcF07XG4gIH1cbn0pO1xuXG5jbGFzcyBNb2NrV2ViQ2xpZW50IGV4dGVuZHMgV2ViQ2xpZW50IHtcbiAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgIHN1cGVyKG51bGwsIHNlZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIFdlYkNsaWVudCB3aXRoIGEgbW9jayBjaGFpbiBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHNlcmlhbGl6ZWRNb2NrQ2hhaW4gLSBTZXJpYWxpemVkIG1vY2sgY2hhaW4gZGF0YSAob3B0aW9uYWwpLiBXaWxsIHVzZSBhbiBlbXB0eSBjaGFpbiBpZiBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSBzZXJpYWxpemVkTW9ja05vdGVUcmFuc3BvcnROb2RlIC0gU2VyaWFsaXplZCBtb2NrIG5vdGUgdHJhbnNwb3J0IG5vZGUgZGF0YSAob3B0aW9uYWwpLiBXaWxsIHVzZSBhIG5ldyBpbnN0YW5jZSBpZiBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSBzZWVkIC0gVGhlIHNlZWQgZm9yIHRoZSBhY2NvdW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgTW9ja1dlYkNsaWVudC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVDbGllbnQoXG4gICAgc2VyaWFsaXplZE1vY2tDaGFpbixcbiAgICBzZXJpYWxpemVkTW9ja05vdGVUcmFuc3BvcnROb2RlLFxuICAgIHNlZWRcbiAgKSB7XG4gICAgLy8gQ29uc3RydWN0IHRoZSBpbnN0YW5jZSAoc3luY2hyb25vdXNseSkuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgTW9ja1dlYkNsaWVudChzZWVkKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSB1bmRlcmx5aW5nIHdhc21XZWJDbGllbnQgdG8gYmUgaW5pdGlhbGl6ZWQuXG4gICAgYXdhaXQgaW5zdGFuY2Uud2FzbVdlYkNsaWVudC5jcmVhdGVNb2NrQ2xpZW50KFxuICAgICAgc2VlZCxcbiAgICAgIHNlcmlhbGl6ZWRNb2NrQ2hhaW4sXG4gICAgICBzZXJpYWxpemVkTW9ja05vdGVUcmFuc3BvcnROb2RlXG4gICAgKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSB3b3JrZXIgdG8gYmUgcmVhZHlcbiAgICBhd2FpdCBpbnN0YW5jZS5yZWFkeTtcblxuICAgIC8vIFJldHVybiBhIHByb3h5IHRoYXQgZm9yd2FyZHMgbWlzc2luZyBwcm9wZXJ0aWVzIHRvIHdhc21XZWJDbGllbnQuXG4gICAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZSwge1xuICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgd3JhcHBlciwgcmV0dXJuIGl0LlxuICAgICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgd2FzbVdlYkNsaWVudCBoYXMgaXQsIHJldHVybiB0aGF0LlxuICAgICAgICBpZiAodGFyZ2V0Lndhc21XZWJDbGllbnQgJiYgcHJvcCBpbiB0YXJnZXQud2FzbVdlYkNsaWVudCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0Lndhc21XZWJDbGllbnRbcHJvcF07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQud2FzbVdlYkNsaWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHN5bmNTdGF0ZSgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50LnN5bmNTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2VyaWFsaXplZE1vY2tDaGFpbiA9IHRoaXMud2FzbVdlYkNsaWVudC5zZXJpYWxpemVNb2NrQ2hhaW4oKS5idWZmZXI7XG4gICAgICBsZXQgc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZSA9XG4gICAgICAgIHRoaXMud2FzbVdlYkNsaWVudC5zZXJpYWxpemVNb2NrTm90ZVRyYW5zcG9ydE5vZGUoKS5idWZmZXI7XG5cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRTeW5jU3VtbWFyeUJ5dGVzID0gYXdhaXQgdGhpcy5jYWxsTWV0aG9kV2l0aFdvcmtlcihcbiAgICAgICAgTWV0aG9kTmFtZS5TWU5DX1NUQVRFX01PQ0ssXG4gICAgICAgIHNlcmlhbGl6ZWRNb2NrQ2hhaW4sXG4gICAgICAgIHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGVcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB3YXNtLlN5bmNTdW1tYXJ5LmRlc2VyaWFsaXplKFxuICAgICAgICBuZXcgVWludDhBcnJheShzZXJpYWxpemVkU3luY1N1bW1hcnlCeXRlcylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJJTkRFWC5KUzogRXJyb3IgaW4gc3luY1N0YXRlOlwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uUmVzdWx0LCBwcm92ZXIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc3VibWl0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25SZXN1bHQsIHByb3Zlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlc3VsdCA9IHRyYW5zYWN0aW9uUmVzdWx0LnNlcmlhbGl6ZSgpO1xuICAgICAgY29uc3QgcHJvdmVyUGF5bG9hZCA9IHByb3ZlciA/IHByb3Zlci5zZXJpYWxpemUoKSA6IG51bGw7XG4gICAgICBjb25zdCBzZXJpYWxpemVkTW9ja0NoYWluID1cbiAgICAgICAgdGhpcy53YXNtV2ViQ2xpZW50LnNlcmlhbGl6ZU1vY2tDaGFpbigpLmJ1ZmZlcjtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGUgPVxuICAgICAgICB0aGlzLndhc21XZWJDbGllbnQuc2VyaWFsaXplTW9ja05vdGVUcmFuc3BvcnROb2RlKCkuYnVmZmVyO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGxNZXRob2RXaXRoV29ya2VyKFxuICAgICAgICBNZXRob2ROYW1lLlNVQk1JVF9UUkFOU0FDVElPTl9NT0NLLFxuICAgICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgICAgIHByb3ZlclBheWxvYWQsXG4gICAgICAgIHNlcmlhbGl6ZWRNb2NrQ2hhaW4sXG4gICAgICAgIHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGVcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXdNb2NrQ2hhaW4gPSBuZXcgVWludDhBcnJheShyZXN1bHQuc2VyaWFsaXplZE1vY2tDaGFpbik7XG4gICAgICBjb25zdCBuZXdNb2NrTm90ZVRyYW5zcG9ydE5vZGUgPSByZXN1bHQuc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZVxuICAgICAgICA/IG5ldyBVaW50OEFycmF5KHJlc3VsdC5zZXJpYWxpemVkTW9ja05vdGVUcmFuc3BvcnROb2RlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vY2tXZWJDbGllbnQpKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndhc21XZWJDbGllbnQuYXBwbHlUcmFuc2FjdGlvbihcbiAgICAgICAgICB0cmFuc2FjdGlvblJlc3VsdCxcbiAgICAgICAgICByZXN1bHQuc3VibWlzc2lvbkhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndhc21XZWJDbGllbnQgPSBuZXcgV2FzbVdlYkNsaWVudCgpO1xuICAgICAgYXdhaXQgdGhpcy53YXNtV2ViQ2xpZW50LmNyZWF0ZU1vY2tDbGllbnQoXG4gICAgICAgIHRoaXMuc2VlZCxcbiAgICAgICAgbmV3TW9ja0NoYWluLFxuICAgICAgICBuZXdNb2NrTm90ZVRyYW5zcG9ydE5vZGVcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB3YXNtLlRyYW5zYWN0aW9uU3RvcmVVcGRhdGUuZGVzZXJpYWxpemUoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdC5zZXJpYWxpemVkVHJhbnNhY3Rpb25VcGRhdGUpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSU5ERVguSlM6IEVycm9yIGluIHN1Ym1pdFRyYW5zYWN0aW9uOlwiLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN1Ym1pdE5ld1RyYW5zYWN0aW9uKGFjY291bnRJZCwgdHJhbnNhY3Rpb25SZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnN1Ym1pdE5ld1RyYW5zYWN0aW9uKGFjY291bnRJZCwgdHJhbnNhY3Rpb25SZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVxdWVzdCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNb2NrQ2hhaW4gPVxuICAgICAgICB0aGlzLndhc21XZWJDbGllbnQuc2VyaWFsaXplTW9ja0NoYWluKCkuYnVmZmVyO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZSA9XG4gICAgICAgIHRoaXMud2FzbVdlYkNsaWVudC5zZXJpYWxpemVNb2NrTm90ZVRyYW5zcG9ydE5vZGUoKS5idWZmZXI7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbE1ldGhvZFdpdGhXb3JrZXIoXG4gICAgICAgIE1ldGhvZE5hbWUuU1VCTUlUX05FV19UUkFOU0FDVElPTl9NT0NLLFxuICAgICAgICBhY2NvdW50SWQudG9TdHJpbmcoKSxcbiAgICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVxdWVzdCxcbiAgICAgICAgc2VyaWFsaXplZE1vY2tDaGFpbixcbiAgICAgICAgc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3TW9ja0NoYWluID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0LnNlcmlhbGl6ZWRNb2NrQ2hhaW4pO1xuICAgICAgY29uc3QgbmV3TW9ja05vdGVUcmFuc3BvcnROb2RlID0gcmVzdWx0LnNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGVcbiAgICAgICAgPyBuZXcgVWludDhBcnJheShyZXN1bHQuc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVzdWx0ID0gd2FzbS5UcmFuc2FjdGlvblJlc3VsdC5kZXNlcmlhbGl6ZShcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0LnNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlc3VsdClcbiAgICAgICk7XG5cbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2NrV2ViQ2xpZW50KSkge1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25SZXN1bHQuaWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53YXNtV2ViQ2xpZW50ID0gbmV3IFdhc21XZWJDbGllbnQoKTtcbiAgICAgIGF3YWl0IHRoaXMud2FzbVdlYkNsaWVudC5jcmVhdGVNb2NrQ2xpZW50KFxuICAgICAgICB0aGlzLnNlZWQsXG4gICAgICAgIG5ld01vY2tDaGFpbixcbiAgICAgICAgbmV3TW9ja05vdGVUcmFuc3BvcnROb2RlXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb25SZXN1bHQuaWQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJJTkRFWC5KUzogRXJyb3IgaW4gc3VibWl0TmV3VHJhbnNhY3Rpb246XCIsXG4gICAgICAgIGVycm9yLnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgTWlkZW5BcnJheXMsIE1vY2tXZWJDbGllbnQsIFdlYkNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@demox-labs/miden-sdk/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/wasm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/wasm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadWasm)\n/* harmony export */ });\n// This is a documented workaround that should avoid issues with Vite projects\n// https://github.com/wasm-tool/rollup-plugin-rust?tab=readme-ov-file#usage-with-vite\n// Also, this effectively disables SSR.\nasync function loadWasm() {\n  let wasmModule;\n  if (true) {\n    wasmModule = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./Cargo-acbd8ac5.js */ \"(ssr)/./node_modules/@demox-labs/miden-sdk/dist/Cargo-acbd8ac5.js\"));\n  }\n  return wasmModule;\n}\n\n\n//# sourceMappingURL=wasm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlbW94LWxhYnMvbWlkZW4tc2RrL2Rpc3Qvd2FzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBNkQ7QUFDbkUsdUJBQXVCLG9MQUE2QjtBQUNwRDtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXERFTExcXERlc2t0b3BcXGNyYWJkYW8tYWdlbnRcXG1pZGVuLXdlYi10dXRvcmlhbHNcXG5vZGVfbW9kdWxlc1xcQGRlbW94LWxhYnNcXG1pZGVuLXNka1xcZGlzdFxcd2FzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGlzIGEgZG9jdW1lbnRlZCB3b3JrYXJvdW5kIHRoYXQgc2hvdWxkIGF2b2lkIGlzc3VlcyB3aXRoIFZpdGUgcHJvamVjdHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93YXNtLXRvb2wvcm9sbHVwLXBsdWdpbi1ydXN0P3RhYj1yZWFkbWUtb3YtZmlsZSN1c2FnZS13aXRoLXZpdGVcbi8vIEFsc28sIHRoaXMgZWZmZWN0aXZlbHkgZGlzYWJsZXMgU1NSLlxuYXN5bmMgZnVuY3Rpb24gbG9hZFdhc20oKSB7XG4gIGxldCB3YXNtTW9kdWxlO1xuICBpZiAoIWltcG9ydC5tZXRhLmVudiB8fCAoaW1wb3J0Lm1ldGEuZW52ICYmICFpbXBvcnQubWV0YS5lbnYuU1NSKSkge1xuICAgIHdhc21Nb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4vQ2FyZ28tYWNiZDhhYzUuanMnKTtcbiAgfVxuICByZXR1cm4gd2FzbU1vZHVsZTtcbn1cblxuZXhwb3J0IHsgbG9hZFdhc20gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@demox-labs/miden-sdk/dist/wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js ***!
  \************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountArray: () => (/* binding */ AccountArray),\n/* harmony export */   AccountBuilder: () => (/* binding */ AccountBuilder),\n/* harmony export */   AccountBuilderResult: () => (/* binding */ AccountBuilderResult),\n/* harmony export */   AccountCode: () => (/* binding */ AccountCode),\n/* harmony export */   AccountComponent: () => (/* binding */ AccountComponent),\n/* harmony export */   AccountDelta: () => (/* binding */ AccountDelta),\n/* harmony export */   AccountFile: () => (/* binding */ AccountFile),\n/* harmony export */   AccountHeader: () => (/* binding */ AccountHeader),\n/* harmony export */   AccountId: () => (/* binding */ AccountId),\n/* harmony export */   AccountIdArray: () => (/* binding */ AccountIdArray),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   AccountStorage: () => (/* binding */ AccountStorage),\n/* harmony export */   AccountStorageDelta: () => (/* binding */ AccountStorageDelta),\n/* harmony export */   AccountStorageMode: () => (/* binding */ AccountStorageMode),\n/* harmony export */   AccountStorageRequirements: () => (/* binding */ AccountStorageRequirements),\n/* harmony export */   AccountType: () => (/* binding */ AccountType),\n/* harmony export */   AccountVaultDelta: () => (/* binding */ AccountVaultDelta),\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   AdviceInputs: () => (/* binding */ AdviceInputs),\n/* harmony export */   AdviceMap: () => (/* binding */ AdviceMap),\n/* harmony export */   AssetVault: () => (/* binding */ AssetVault),\n/* harmony export */   AuthSecretKey: () => (/* binding */ AuthSecretKey),\n/* harmony export */   BasicFungibleFaucetComponent: () => (/* binding */ BasicFungibleFaucetComponent),\n/* harmony export */   BlockHeader: () => (/* binding */ BlockHeader),\n/* harmony export */   ConsumableNoteRecord: () => (/* binding */ ConsumableNoteRecord),\n/* harmony export */   Endpoint: () => (/* binding */ Endpoint),\n/* harmony export */   ExecutedTransaction: () => (/* binding */ ExecutedTransaction),\n/* harmony export */   Felt: () => (/* binding */ Felt),\n/* harmony export */   FeltArray: () => (/* binding */ FeltArray),\n/* harmony export */   FetchedNote: () => (/* binding */ FetchedNote),\n/* harmony export */   FlattenedU8Vec: () => (/* binding */ FlattenedU8Vec),\n/* harmony export */   ForeignAccount: () => (/* binding */ ForeignAccount),\n/* harmony export */   ForeignAccountArray: () => (/* binding */ ForeignAccountArray),\n/* harmony export */   FungibleAsset: () => (/* binding */ FungibleAsset),\n/* harmony export */   FungibleAssetDelta: () => (/* binding */ FungibleAssetDelta),\n/* harmony export */   FungibleAssetDeltaItem: () => (/* binding */ FungibleAssetDeltaItem),\n/* harmony export */   GetProceduresResultItem: () => (/* binding */ GetProceduresResultItem),\n/* harmony export */   InputNote: () => (/* binding */ InputNote),\n/* harmony export */   InputNoteRecord: () => (/* binding */ InputNoteRecord),\n/* harmony export */   InputNoteState: () => (/* binding */ InputNoteState),\n/* harmony export */   InputNotes: () => (/* binding */ InputNotes),\n/* harmony export */   IntoUnderlyingByteSource: () => (/* binding */ IntoUnderlyingByteSource),\n/* harmony export */   IntoUnderlyingSink: () => (/* binding */ IntoUnderlyingSink),\n/* harmony export */   IntoUnderlyingSource: () => (/* binding */ IntoUnderlyingSource),\n/* harmony export */   JsAccountUpdate: () => (/* binding */ JsAccountUpdate),\n/* harmony export */   JsStateSyncUpdate: () => (/* binding */ JsStateSyncUpdate),\n/* harmony export */   JsStorageMapEntry: () => (/* binding */ JsStorageMapEntry),\n/* harmony export */   JsStorageSlot: () => (/* binding */ JsStorageSlot),\n/* harmony export */   JsVaultAsset: () => (/* binding */ JsVaultAsset),\n/* harmony export */   Library: () => (/* binding */ Library),\n/* harmony export */   MerklePath: () => (/* binding */ MerklePath),\n/* harmony export */   NetworkId: () => (/* binding */ NetworkId),\n/* harmony export */   Note: () => (/* binding */ Note),\n/* harmony export */   NoteAndArgs: () => (/* binding */ NoteAndArgs),\n/* harmony export */   NoteAndArgsArray: () => (/* binding */ NoteAndArgsArray),\n/* harmony export */   NoteAssets: () => (/* binding */ NoteAssets),\n/* harmony export */   NoteConsumability: () => (/* binding */ NoteConsumability),\n/* harmony export */   NoteDetails: () => (/* binding */ NoteDetails),\n/* harmony export */   NoteDetailsAndTag: () => (/* binding */ NoteDetailsAndTag),\n/* harmony export */   NoteDetailsAndTagArray: () => (/* binding */ NoteDetailsAndTagArray),\n/* harmony export */   NoteExecutionHint: () => (/* binding */ NoteExecutionHint),\n/* harmony export */   NoteExecutionMode: () => (/* binding */ NoteExecutionMode),\n/* harmony export */   NoteFile: () => (/* binding */ NoteFile),\n/* harmony export */   NoteFilter: () => (/* binding */ NoteFilter),\n/* harmony export */   NoteFilterTypes: () => (/* binding */ NoteFilterTypes),\n/* harmony export */   NoteHeader: () => (/* binding */ NoteHeader),\n/* harmony export */   NoteId: () => (/* binding */ NoteId),\n/* harmony export */   NoteIdAndArgs: () => (/* binding */ NoteIdAndArgs),\n/* harmony export */   NoteIdAndArgsArray: () => (/* binding */ NoteIdAndArgsArray),\n/* harmony export */   NoteInclusionProof: () => (/* binding */ NoteInclusionProof),\n/* harmony export */   NoteInputs: () => (/* binding */ NoteInputs),\n/* harmony export */   NoteLocation: () => (/* binding */ NoteLocation),\n/* harmony export */   NoteMetadata: () => (/* binding */ NoteMetadata),\n/* harmony export */   NoteRecipient: () => (/* binding */ NoteRecipient),\n/* harmony export */   NoteRecipientArray: () => (/* binding */ NoteRecipientArray),\n/* harmony export */   NoteScript: () => (/* binding */ NoteScript),\n/* harmony export */   NoteTag: () => (/* binding */ NoteTag),\n/* harmony export */   NoteType: () => (/* binding */ NoteType),\n/* harmony export */   OutputNote: () => (/* binding */ OutputNote),\n/* harmony export */   OutputNoteArray: () => (/* binding */ OutputNoteArray),\n/* harmony export */   OutputNotes: () => (/* binding */ OutputNotes),\n/* harmony export */   OutputNotesArray: () => (/* binding */ OutputNotesArray),\n/* harmony export */   Package: () => (/* binding */ Package),\n/* harmony export */   PartialNote: () => (/* binding */ PartialNote),\n/* harmony export */   ProvenTransaction: () => (/* binding */ ProvenTransaction),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   RpcClient: () => (/* binding */ RpcClient),\n/* harmony export */   Rpo256: () => (/* binding */ Rpo256),\n/* harmony export */   ScriptBuilder: () => (/* binding */ ScriptBuilder),\n/* harmony export */   SecretKey: () => (/* binding */ SecretKey),\n/* harmony export */   SerializedInputNoteData: () => (/* binding */ SerializedInputNoteData),\n/* harmony export */   SerializedOutputNoteData: () => (/* binding */ SerializedOutputNoteData),\n/* harmony export */   SerializedTransactionData: () => (/* binding */ SerializedTransactionData),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   SigningInputs: () => (/* binding */ SigningInputs),\n/* harmony export */   SigningInputsType: () => (/* binding */ SigningInputsType),\n/* harmony export */   SlotAndKeys: () => (/* binding */ SlotAndKeys),\n/* harmony export */   StorageMap: () => (/* binding */ StorageMap),\n/* harmony export */   StorageSlot: () => (/* binding */ StorageSlot),\n/* harmony export */   StorageSlotArray: () => (/* binding */ StorageSlotArray),\n/* harmony export */   SyncSummary: () => (/* binding */ SyncSummary),\n/* harmony export */   TestUtils: () => (/* binding */ TestUtils),\n/* harmony export */   TokenSymbol: () => (/* binding */ TokenSymbol),\n/* harmony export */   TransactionArgs: () => (/* binding */ TransactionArgs),\n/* harmony export */   TransactionFilter: () => (/* binding */ TransactionFilter),\n/* harmony export */   TransactionId: () => (/* binding */ TransactionId),\n/* harmony export */   TransactionProver: () => (/* binding */ TransactionProver),\n/* harmony export */   TransactionRecord: () => (/* binding */ TransactionRecord),\n/* harmony export */   TransactionRequest: () => (/* binding */ TransactionRequest),\n/* harmony export */   TransactionRequestBuilder: () => (/* binding */ TransactionRequestBuilder),\n/* harmony export */   TransactionResult: () => (/* binding */ TransactionResult),\n/* harmony export */   TransactionScript: () => (/* binding */ TransactionScript),\n/* harmony export */   TransactionScriptInputPair: () => (/* binding */ TransactionScriptInputPair),\n/* harmony export */   TransactionScriptInputPairArray: () => (/* binding */ TransactionScriptInputPairArray),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionStoreUpdate: () => (/* binding */ TransactionStoreUpdate),\n/* harmony export */   TransactionSummary: () => (/* binding */ TransactionSummary),\n/* harmony export */   WebClient: () => (/* binding */ WebClient),\n/* harmony export */   Word: () => (/* binding */ Word),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar dexie = {exports: {}};\n\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.0.8, Wed Jul 10 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n\n(function (module, exports) {\n\t(function (global, factory) {\n\t    module.exports = factory() ;\n\t})(commonjsGlobal, (function () {\n\t    /*! *****************************************************************************\n\t    Copyright (c) Microsoft Corporation.\n\t    Permission to use, copy, modify, and/or distribute this software for any\n\t    purpose with or without fee is hereby granted.\n\t    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n\t    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n\t    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n\t    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n\t    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n\t    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n\t    PERFORMANCE OF THIS SOFTWARE.\n\t    ***************************************************************************** */\n\t    var extendStatics = function(d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    function __extends(d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    }\n\t    var __assign = function() {\n\t        __assign = Object.assign || function __assign(t) {\n\t            for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t                s = arguments[i];\n\t                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n\t            }\n\t            return t;\n\t        };\n\t        return __assign.apply(this, arguments);\n\t    };\n\t    function __spreadArray(to, from, pack) {\n\t        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n\t            if (ar || !(i in from)) {\n\t                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n\t                ar[i] = from[i];\n\t            }\n\t        }\n\t        return to.concat(ar || Array.prototype.slice.call(from));\n\t    }\n\n\t    var _global = typeof globalThis !== 'undefined' ? globalThis :\n\t        typeof self !== 'undefined' ? self :\n\t            typeof window !== 'undefined' ? window :\n\t                commonjsGlobal;\n\n\t    var keys = Object.keys;\n\t    var isArray = Array.isArray;\n\t    if (typeof Promise !== 'undefined' && !_global.Promise) {\n\t        _global.Promise = Promise;\n\t    }\n\t    function extend(obj, extension) {\n\t        if (typeof extension !== 'object')\n\t            return obj;\n\t        keys(extension).forEach(function (key) {\n\t            obj[key] = extension[key];\n\t        });\n\t        return obj;\n\t    }\n\t    var getProto = Object.getPrototypeOf;\n\t    var _hasOwn = {}.hasOwnProperty;\n\t    function hasOwn(obj, prop) {\n\t        return _hasOwn.call(obj, prop);\n\t    }\n\t    function props(proto, extension) {\n\t        if (typeof extension === 'function')\n\t            extension = extension(getProto(proto));\n\t        (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n\t            setProp(proto, key, extension[key]);\n\t        });\n\t    }\n\t    var defineProperty = Object.defineProperty;\n\t    function setProp(obj, prop, functionOrGetSet, options) {\n\t        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n\t            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n\t            { value: functionOrGetSet, configurable: true, writable: true }, options));\n\t    }\n\t    function derive(Child) {\n\t        return {\n\t            from: function (Parent) {\n\t                Child.prototype = Object.create(Parent.prototype);\n\t                setProp(Child.prototype, \"constructor\", Child);\n\t                return {\n\t                    extend: props.bind(null, Child.prototype)\n\t                };\n\t            }\n\t        };\n\t    }\n\t    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\t    function getPropertyDescriptor(obj, prop) {\n\t        var pd = getOwnPropertyDescriptor(obj, prop);\n\t        var proto;\n\t        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n\t    }\n\t    var _slice = [].slice;\n\t    function slice(args, start, end) {\n\t        return _slice.call(args, start, end);\n\t    }\n\t    function override(origFunc, overridedFactory) {\n\t        return overridedFactory(origFunc);\n\t    }\n\t    function assert(b) {\n\t        if (!b)\n\t            throw new Error(\"Assertion Failed\");\n\t    }\n\t    function asap$1(fn) {\n\t        if (_global.setImmediate)\n\t            setImmediate(fn);\n\t        else\n\t            setTimeout(fn, 0);\n\t    }\n\t    function arrayToObject(array, extractor) {\n\t        return array.reduce(function (result, item, i) {\n\t            var nameAndValue = extractor(item, i);\n\t            if (nameAndValue)\n\t                result[nameAndValue[0]] = nameAndValue[1];\n\t            return result;\n\t        }, {});\n\t    }\n\t    function getByKeyPath(obj, keyPath) {\n\t        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n\t            return obj[keyPath];\n\t        if (!keyPath)\n\t            return obj;\n\t        if (typeof keyPath !== 'string') {\n\t            var rv = [];\n\t            for (var i = 0, l = keyPath.length; i < l; ++i) {\n\t                var val = getByKeyPath(obj, keyPath[i]);\n\t                rv.push(val);\n\t            }\n\t            return rv;\n\t        }\n\t        var period = keyPath.indexOf('.');\n\t        if (period !== -1) {\n\t            var innerObj = obj[keyPath.substr(0, period)];\n\t            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n\t        }\n\t        return undefined;\n\t    }\n\t    function setByKeyPath(obj, keyPath, value) {\n\t        if (!obj || keyPath === undefined)\n\t            return;\n\t        if ('isFrozen' in Object && Object.isFrozen(obj))\n\t            return;\n\t        if (typeof keyPath !== 'string' && 'length' in keyPath) {\n\t            assert(typeof value !== 'string' && 'length' in value);\n\t            for (var i = 0, l = keyPath.length; i < l; ++i) {\n\t                setByKeyPath(obj, keyPath[i], value[i]);\n\t            }\n\t        }\n\t        else {\n\t            var period = keyPath.indexOf('.');\n\t            if (period !== -1) {\n\t                var currentKeyPath = keyPath.substr(0, period);\n\t                var remainingKeyPath = keyPath.substr(period + 1);\n\t                if (remainingKeyPath === \"\")\n\t                    if (value === undefined) {\n\t                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n\t                            obj.splice(currentKeyPath, 1);\n\t                        else\n\t                            delete obj[currentKeyPath];\n\t                    }\n\t                    else\n\t                        obj[currentKeyPath] = value;\n\t                else {\n\t                    var innerObj = obj[currentKeyPath];\n\t                    if (!innerObj || !hasOwn(obj, currentKeyPath))\n\t                        innerObj = (obj[currentKeyPath] = {});\n\t                    setByKeyPath(innerObj, remainingKeyPath, value);\n\t                }\n\t            }\n\t            else {\n\t                if (value === undefined) {\n\t                    if (isArray(obj) && !isNaN(parseInt(keyPath)))\n\t                        obj.splice(keyPath, 1);\n\t                    else\n\t                        delete obj[keyPath];\n\t                }\n\t                else\n\t                    obj[keyPath] = value;\n\t            }\n\t        }\n\t    }\n\t    function delByKeyPath(obj, keyPath) {\n\t        if (typeof keyPath === 'string')\n\t            setByKeyPath(obj, keyPath, undefined);\n\t        else if ('length' in keyPath)\n\t            [].map.call(keyPath, function (kp) {\n\t                setByKeyPath(obj, kp, undefined);\n\t            });\n\t    }\n\t    function shallowClone(obj) {\n\t        var rv = {};\n\t        for (var m in obj) {\n\t            if (hasOwn(obj, m))\n\t                rv[m] = obj[m];\n\t        }\n\t        return rv;\n\t    }\n\t    var concat = [].concat;\n\t    function flatten(a) {\n\t        return concat.apply([], a);\n\t    }\n\t    var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n\t        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n\t    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n\t    function cloneSimpleObjectTree(o) {\n\t        var rv = {};\n\t        for (var k in o)\n\t            if (hasOwn(o, k)) {\n\t                var v = o[k];\n\t                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n\t            }\n\t        return rv;\n\t    }\n\t    function objectIsEmpty(o) {\n\t        for (var k in o)\n\t            if (hasOwn(o, k))\n\t                return false;\n\t        return true;\n\t    }\n\t    var circularRefs = null;\n\t    function deepClone(any) {\n\t        circularRefs = new WeakMap();\n\t        var rv = innerDeepClone(any);\n\t        circularRefs = null;\n\t        return rv;\n\t    }\n\t    function innerDeepClone(x) {\n\t        if (!x || typeof x !== 'object')\n\t            return x;\n\t        var rv = circularRefs.get(x);\n\t        if (rv)\n\t            return rv;\n\t        if (isArray(x)) {\n\t            rv = [];\n\t            circularRefs.set(x, rv);\n\t            for (var i = 0, l = x.length; i < l; ++i) {\n\t                rv.push(innerDeepClone(x[i]));\n\t            }\n\t        }\n\t        else if (intrinsicTypes.has(x.constructor)) {\n\t            rv = x;\n\t        }\n\t        else {\n\t            var proto = getProto(x);\n\t            rv = proto === Object.prototype ? {} : Object.create(proto);\n\t            circularRefs.set(x, rv);\n\t            for (var prop in x) {\n\t                if (hasOwn(x, prop)) {\n\t                    rv[prop] = innerDeepClone(x[prop]);\n\t                }\n\t            }\n\t        }\n\t        return rv;\n\t    }\n\t    var toString = {}.toString;\n\t    function toStringTag(o) {\n\t        return toString.call(o).slice(8, -1);\n\t    }\n\t    var iteratorSymbol = typeof Symbol !== 'undefined' ?\n\t        Symbol.iterator :\n\t        '@@iterator';\n\t    var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n\t        var i;\n\t        return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n\t    } : function () { return null; };\n\t    function delArrayItem(a, x) {\n\t        var i = a.indexOf(x);\n\t        if (i >= 0)\n\t            a.splice(i, 1);\n\t        return i >= 0;\n\t    }\n\t    var NO_CHAR_ARRAY = {};\n\t    function getArrayOf(arrayLike) {\n\t        var i, a, x, it;\n\t        if (arguments.length === 1) {\n\t            if (isArray(arrayLike))\n\t                return arrayLike.slice();\n\t            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n\t                return [arrayLike];\n\t            if ((it = getIteratorOf(arrayLike))) {\n\t                a = [];\n\t                while ((x = it.next()), !x.done)\n\t                    a.push(x.value);\n\t                return a;\n\t            }\n\t            if (arrayLike == null)\n\t                return [arrayLike];\n\t            i = arrayLike.length;\n\t            if (typeof i === 'number') {\n\t                a = new Array(i);\n\t                while (i--)\n\t                    a[i] = arrayLike[i];\n\t                return a;\n\t            }\n\t            return [arrayLike];\n\t        }\n\t        i = arguments.length;\n\t        a = new Array(i);\n\t        while (i--)\n\t            a[i] = arguments[i];\n\t        return a;\n\t    }\n\t    var isAsyncFunction = typeof Symbol !== 'undefined'\n\t        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n\t        : function () { return false; };\n\n\t    var dexieErrorNames = [\n\t        'Modify',\n\t        'Bulk',\n\t        'OpenFailed',\n\t        'VersionChange',\n\t        'Schema',\n\t        'Upgrade',\n\t        'InvalidTable',\n\t        'MissingAPI',\n\t        'NoSuchDatabase',\n\t        'InvalidArgument',\n\t        'SubTransaction',\n\t        'Unsupported',\n\t        'Internal',\n\t        'DatabaseClosed',\n\t        'PrematureCommit',\n\t        'ForeignAwait'\n\t    ];\n\t    var idbDomErrorNames = [\n\t        'Unknown',\n\t        'Constraint',\n\t        'Data',\n\t        'TransactionInactive',\n\t        'ReadOnly',\n\t        'Version',\n\t        'NotFound',\n\t        'InvalidState',\n\t        'InvalidAccess',\n\t        'Abort',\n\t        'Timeout',\n\t        'QuotaExceeded',\n\t        'Syntax',\n\t        'DataClone'\n\t    ];\n\t    var errorList = dexieErrorNames.concat(idbDomErrorNames);\n\t    var defaultTexts = {\n\t        VersionChanged: \"Database version changed by other database connection\",\n\t        DatabaseClosed: \"Database has been closed\",\n\t        Abort: \"Transaction aborted\",\n\t        TransactionInactive: \"Transaction has already completed or failed\",\n\t        MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n\t    };\n\t    function DexieError(name, msg) {\n\t        this.name = name;\n\t        this.message = msg;\n\t    }\n\t    derive(DexieError).from(Error).extend({\n\t        toString: function () { return this.name + \": \" + this.message; }\n\t    });\n\t    function getMultiErrorMessage(msg, failures) {\n\t        return msg + \". Errors: \" + Object.keys(failures)\n\t            .map(function (key) { return failures[key].toString(); })\n\t            .filter(function (v, i, s) { return s.indexOf(v) === i; })\n\t            .join('\\n');\n\t    }\n\t    function ModifyError(msg, failures, successCount, failedKeys) {\n\t        this.failures = failures;\n\t        this.failedKeys = failedKeys;\n\t        this.successCount = successCount;\n\t        this.message = getMultiErrorMessage(msg, failures);\n\t    }\n\t    derive(ModifyError).from(DexieError);\n\t    function BulkError(msg, failures) {\n\t        this.name = \"BulkError\";\n\t        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n\t        this.failuresByPos = failures;\n\t        this.message = getMultiErrorMessage(msg, this.failures);\n\t    }\n\t    derive(BulkError).from(DexieError);\n\t    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n\t    var BaseException = DexieError;\n\t    var exceptions = errorList.reduce(function (obj, name) {\n\t        var fullName = name + \"Error\";\n\t        function DexieError(msgOrInner, inner) {\n\t            this.name = fullName;\n\t            if (!msgOrInner) {\n\t                this.message = defaultTexts[name] || fullName;\n\t                this.inner = null;\n\t            }\n\t            else if (typeof msgOrInner === 'string') {\n\t                this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n\t                this.inner = inner || null;\n\t            }\n\t            else if (typeof msgOrInner === 'object') {\n\t                this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n\t                this.inner = msgOrInner;\n\t            }\n\t        }\n\t        derive(DexieError).from(BaseException);\n\t        obj[name] = DexieError;\n\t        return obj;\n\t    }, {});\n\t    exceptions.Syntax = SyntaxError;\n\t    exceptions.Type = TypeError;\n\t    exceptions.Range = RangeError;\n\t    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n\t        obj[name + \"Error\"] = exceptions[name];\n\t        return obj;\n\t    }, {});\n\t    function mapError(domError, message) {\n\t        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n\t            return domError;\n\t        var rv = new exceptionMap[domError.name](message || domError.message, domError);\n\t        if (\"stack\" in domError) {\n\t            setProp(rv, \"stack\", { get: function () {\n\t                    return this.inner.stack;\n\t                } });\n\t        }\n\t        return rv;\n\t    }\n\t    var fullNameExceptions = errorList.reduce(function (obj, name) {\n\t        if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n\t            obj[name + \"Error\"] = exceptions[name];\n\t        return obj;\n\t    }, {});\n\t    fullNameExceptions.ModifyError = ModifyError;\n\t    fullNameExceptions.DexieError = DexieError;\n\t    fullNameExceptions.BulkError = BulkError;\n\n\t    function nop() { }\n\t    function mirror(val) { return val; }\n\t    function pureFunctionChain(f1, f2) {\n\t        if (f1 == null || f1 === mirror)\n\t            return f2;\n\t        return function (val) {\n\t            return f2(f1(val));\n\t        };\n\t    }\n\t    function callBoth(on1, on2) {\n\t        return function () {\n\t            on1.apply(this, arguments);\n\t            on2.apply(this, arguments);\n\t        };\n\t    }\n\t    function hookCreatingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            var res = f1.apply(this, arguments);\n\t            if (res !== undefined)\n\t                arguments[0] = res;\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = null;\n\t            this.onerror = null;\n\t            var res2 = f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t            return res2 !== undefined ? res2 : res;\n\t        };\n\t    }\n\t    function hookDeletingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            f1.apply(this, arguments);\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = this.onerror = null;\n\t            f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t        };\n\t    }\n\t    function hookUpdatingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function (modifications) {\n\t            var res = f1.apply(this, arguments);\n\t            extend(modifications, res);\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = null;\n\t            this.onerror = null;\n\t            var res2 = f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t            return res === undefined ?\n\t                (res2 === undefined ? undefined : res2) :\n\t                (extend(res, res2));\n\t        };\n\t    }\n\t    function reverseStoppableEventChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            if (f2.apply(this, arguments) === false)\n\t                return false;\n\t            return f1.apply(this, arguments);\n\t        };\n\t    }\n\t    function promisableChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            var res = f1.apply(this, arguments);\n\t            if (res && typeof res.then === 'function') {\n\t                var thiz = this, i = arguments.length, args = new Array(i);\n\t                while (i--)\n\t                    args[i] = arguments[i];\n\t                return res.then(function () {\n\t                    return f2.apply(thiz, args);\n\t                });\n\t            }\n\t            return f2.apply(this, arguments);\n\t        };\n\t    }\n\n\t    var debug = typeof location !== 'undefined' &&\n\t        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\t    function setDebug(value, filter) {\n\t        debug = value;\n\t    }\n\n\t    var INTERNAL = {};\n\t    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n\t        [] :\n\t        (function () {\n\t            var globalP = Promise.resolve();\n\t            if (typeof crypto === 'undefined' || !crypto.subtle)\n\t                return [globalP, getProto(globalP), globalP];\n\t            var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n\t            return [\n\t                nativeP,\n\t                getProto(nativeP),\n\t                globalP\n\t            ];\n\t        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n\t    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n\t    var patchGlobalPromise = !!resolvedGlobalPromise;\n\t    function schedulePhysicalTick() {\n\t        queueMicrotask(physicalTick);\n\t    }\n\t    var asap = function (callback, args) {\n\t        microtickQueue.push([callback, args]);\n\t        if (needsNewPhysicalTick) {\n\t            schedulePhysicalTick();\n\t            needsNewPhysicalTick = false;\n\t        }\n\t    };\n\t    var isOutsideMicroTick = true,\n\t    needsNewPhysicalTick = true,\n\t    unhandledErrors = [],\n\t    rejectingErrors = [],\n\t    rejectionMapper = mirror;\n\t    var globalPSD = {\n\t        id: 'global',\n\t        global: true,\n\t        ref: 0,\n\t        unhandleds: [],\n\t        onunhandled: nop,\n\t        pgp: false,\n\t        env: {},\n\t        finalize: nop\n\t    };\n\t    var PSD = globalPSD;\n\t    var microtickQueue = [];\n\t    var numScheduledCalls = 0;\n\t    var tickFinalizers = [];\n\t    function DexiePromise(fn) {\n\t        if (typeof this !== 'object')\n\t            throw new TypeError('Promises must be constructed via new');\n\t        this._listeners = [];\n\t        this._lib = false;\n\t        var psd = (this._PSD = PSD);\n\t        if (typeof fn !== 'function') {\n\t            if (fn !== INTERNAL)\n\t                throw new TypeError('Not a function');\n\t            this._state = arguments[1];\n\t            this._value = arguments[2];\n\t            if (this._state === false)\n\t                handleRejection(this, this._value);\n\t            return;\n\t        }\n\t        this._state = null;\n\t        this._value = null;\n\t        ++psd.ref;\n\t        executePromiseTask(this, fn);\n\t    }\n\t    var thenProp = {\n\t        get: function () {\n\t            var psd = PSD, microTaskId = totalEchoes;\n\t            function then(onFulfilled, onRejected) {\n\t                var _this = this;\n\t                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n\t                var cleanup = possibleAwait && !decrementExpectedAwaits();\n\t                var rv = new DexiePromise(function (resolve, reject) {\n\t                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n\t                });\n\t                if (this._consoleTask)\n\t                    rv._consoleTask = this._consoleTask;\n\t                return rv;\n\t            }\n\t            then.prototype = INTERNAL;\n\t            return then;\n\t        },\n\t        set: function (value) {\n\t            setProp(this, 'then', value && value.prototype === INTERNAL ?\n\t                thenProp :\n\t                {\n\t                    get: function () {\n\t                        return value;\n\t                    },\n\t                    set: thenProp.set\n\t                });\n\t        }\n\t    };\n\t    props(DexiePromise.prototype, {\n\t        then: thenProp,\n\t        _then: function (onFulfilled, onRejected) {\n\t            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n\t        },\n\t        catch: function (onRejected) {\n\t            if (arguments.length === 1)\n\t                return this.then(null, onRejected);\n\t            var type = arguments[0], handler = arguments[1];\n\t            return typeof type === 'function' ? this.then(null, function (err) {\n\t                return err instanceof type ? handler(err) : PromiseReject(err);\n\t            })\n\t                : this.then(null, function (err) {\n\t                    return err && err.name === type ? handler(err) : PromiseReject(err);\n\t                });\n\t        },\n\t        finally: function (onFinally) {\n\t            return this.then(function (value) {\n\t                return DexiePromise.resolve(onFinally()).then(function () { return value; });\n\t            }, function (err) {\n\t                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n\t            });\n\t        },\n\t        timeout: function (ms, msg) {\n\t            var _this = this;\n\t            return ms < Infinity ?\n\t                new DexiePromise(function (resolve, reject) {\n\t                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n\t                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n\t                }) : this;\n\t        }\n\t    });\n\t    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n\t        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n\t    globalPSD.env = snapShot();\n\t    function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n\t        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t        this.resolve = resolve;\n\t        this.reject = reject;\n\t        this.psd = zone;\n\t    }\n\t    props(DexiePromise, {\n\t        all: function () {\n\t            var values = getArrayOf.apply(null, arguments)\n\t                .map(onPossibleParallellAsync);\n\t            return new DexiePromise(function (resolve, reject) {\n\t                if (values.length === 0)\n\t                    resolve([]);\n\t                var remaining = values.length;\n\t                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n\t                    values[i] = x;\n\t                    if (!--remaining)\n\t                        resolve(values);\n\t                }, reject); });\n\t            });\n\t        },\n\t        resolve: function (value) {\n\t            if (value instanceof DexiePromise)\n\t                return value;\n\t            if (value && typeof value.then === 'function')\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    value.then(resolve, reject);\n\t                });\n\t            var rv = new DexiePromise(INTERNAL, true, value);\n\t            return rv;\n\t        },\n\t        reject: PromiseReject,\n\t        race: function () {\n\t            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t            return new DexiePromise(function (resolve, reject) {\n\t                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n\t            });\n\t        },\n\t        PSD: {\n\t            get: function () { return PSD; },\n\t            set: function (value) { return PSD = value; }\n\t        },\n\t        totalEchoes: { get: function () { return totalEchoes; } },\n\t        newPSD: newScope,\n\t        usePSD: usePSD,\n\t        scheduler: {\n\t            get: function () { return asap; },\n\t            set: function (value) { asap = value; }\n\t        },\n\t        rejectionMapper: {\n\t            get: function () { return rejectionMapper; },\n\t            set: function (value) { rejectionMapper = value; }\n\t        },\n\t        follow: function (fn, zoneProps) {\n\t            return new DexiePromise(function (resolve, reject) {\n\t                return newScope(function (resolve, reject) {\n\t                    var psd = PSD;\n\t                    psd.unhandleds = [];\n\t                    psd.onunhandled = reject;\n\t                    psd.finalize = callBoth(function () {\n\t                        var _this = this;\n\t                        run_at_end_of_this_or_next_physical_tick(function () {\n\t                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n\t                        });\n\t                    }, psd.finalize);\n\t                    fn();\n\t                }, zoneProps, resolve, reject);\n\t            });\n\t        }\n\t    });\n\t    if (NativePromise) {\n\t        if (NativePromise.allSettled)\n\t            setProp(DexiePromise, \"allSettled\", function () {\n\t                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t                return new DexiePromise(function (resolve) {\n\t                    if (possiblePromises.length === 0)\n\t                        resolve([]);\n\t                    var remaining = possiblePromises.length;\n\t                    var results = new Array(remaining);\n\t                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n\t                        .then(function () { return --remaining || resolve(results); }); });\n\t                });\n\t            });\n\t        if (NativePromise.any && typeof AggregateError !== 'undefined')\n\t            setProp(DexiePromise, \"any\", function () {\n\t                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    if (possiblePromises.length === 0)\n\t                        reject(new AggregateError([]));\n\t                    var remaining = possiblePromises.length;\n\t                    var failures = new Array(remaining);\n\t                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n\t                        failures[i] = failure;\n\t                        if (!--remaining)\n\t                            reject(new AggregateError(failures));\n\t                    }); });\n\t                });\n\t            });\n\t    }\n\t    function executePromiseTask(promise, fn) {\n\t        try {\n\t            fn(function (value) {\n\t                if (promise._state !== null)\n\t                    return;\n\t                if (value === promise)\n\t                    throw new TypeError('A promise cannot be resolved with itself.');\n\t                var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\t                if (value && typeof value.then === 'function') {\n\t                    executePromiseTask(promise, function (resolve, reject) {\n\t                        value instanceof DexiePromise ?\n\t                            value._then(resolve, reject) :\n\t                            value.then(resolve, reject);\n\t                    });\n\t                }\n\t                else {\n\t                    promise._state = true;\n\t                    promise._value = value;\n\t                    propagateAllListeners(promise);\n\t                }\n\t                if (shouldExecuteTick)\n\t                    endMicroTickScope();\n\t            }, handleRejection.bind(null, promise));\n\t        }\n\t        catch (ex) {\n\t            handleRejection(promise, ex);\n\t        }\n\t    }\n\t    function handleRejection(promise, reason) {\n\t        rejectingErrors.push(reason);\n\t        if (promise._state !== null)\n\t            return;\n\t        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\t        reason = rejectionMapper(reason);\n\t        promise._state = false;\n\t        promise._value = reason;\n\t        addPossiblyUnhandledError(promise);\n\t        propagateAllListeners(promise);\n\t        if (shouldExecuteTick)\n\t            endMicroTickScope();\n\t    }\n\t    function propagateAllListeners(promise) {\n\t        var listeners = promise._listeners;\n\t        promise._listeners = [];\n\t        for (var i = 0, len = listeners.length; i < len; ++i) {\n\t            propagateToListener(promise, listeners[i]);\n\t        }\n\t        var psd = promise._PSD;\n\t        --psd.ref || psd.finalize();\n\t        if (numScheduledCalls === 0) {\n\t            ++numScheduledCalls;\n\t            asap(function () {\n\t                if (--numScheduledCalls === 0)\n\t                    finalizePhysicalTick();\n\t            }, []);\n\t        }\n\t    }\n\t    function propagateToListener(promise, listener) {\n\t        if (promise._state === null) {\n\t            promise._listeners.push(listener);\n\t            return;\n\t        }\n\t        var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n\t        if (cb === null) {\n\t            return (promise._state ? listener.resolve : listener.reject)(promise._value);\n\t        }\n\t        ++listener.psd.ref;\n\t        ++numScheduledCalls;\n\t        asap(callListener, [cb, promise, listener]);\n\t    }\n\t    function callListener(cb, promise, listener) {\n\t        try {\n\t            var ret, value = promise._value;\n\t            if (!promise._state && rejectingErrors.length)\n\t                rejectingErrors = [];\n\t            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n\t            if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n\t                markErrorAsHandled(promise);\n\t            }\n\t            listener.resolve(ret);\n\t        }\n\t        catch (e) {\n\t            listener.reject(e);\n\t        }\n\t        finally {\n\t            if (--numScheduledCalls === 0)\n\t                finalizePhysicalTick();\n\t            --listener.psd.ref || listener.psd.finalize();\n\t        }\n\t    }\n\t    function physicalTick() {\n\t        usePSD(globalPSD, function () {\n\t            beginMicroTickScope() && endMicroTickScope();\n\t        });\n\t    }\n\t    function beginMicroTickScope() {\n\t        var wasRootExec = isOutsideMicroTick;\n\t        isOutsideMicroTick = false;\n\t        needsNewPhysicalTick = false;\n\t        return wasRootExec;\n\t    }\n\t    function endMicroTickScope() {\n\t        var callbacks, i, l;\n\t        do {\n\t            while (microtickQueue.length > 0) {\n\t                callbacks = microtickQueue;\n\t                microtickQueue = [];\n\t                l = callbacks.length;\n\t                for (i = 0; i < l; ++i) {\n\t                    var item = callbacks[i];\n\t                    item[0].apply(null, item[1]);\n\t                }\n\t            }\n\t        } while (microtickQueue.length > 0);\n\t        isOutsideMicroTick = true;\n\t        needsNewPhysicalTick = true;\n\t    }\n\t    function finalizePhysicalTick() {\n\t        var unhandledErrs = unhandledErrors;\n\t        unhandledErrors = [];\n\t        unhandledErrs.forEach(function (p) {\n\t            p._PSD.onunhandled.call(null, p._value, p);\n\t        });\n\t        var finalizers = tickFinalizers.slice(0);\n\t        var i = finalizers.length;\n\t        while (i)\n\t            finalizers[--i]();\n\t    }\n\t    function run_at_end_of_this_or_next_physical_tick(fn) {\n\t        function finalizer() {\n\t            fn();\n\t            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n\t        }\n\t        tickFinalizers.push(finalizer);\n\t        ++numScheduledCalls;\n\t        asap(function () {\n\t            if (--numScheduledCalls === 0)\n\t                finalizePhysicalTick();\n\t        }, []);\n\t    }\n\t    function addPossiblyUnhandledError(promise) {\n\t        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n\t            unhandledErrors.push(promise);\n\t    }\n\t    function markErrorAsHandled(promise) {\n\t        var i = unhandledErrors.length;\n\t        while (i)\n\t            if (unhandledErrors[--i]._value === promise._value) {\n\t                unhandledErrors.splice(i, 1);\n\t                return;\n\t            }\n\t    }\n\t    function PromiseReject(reason) {\n\t        return new DexiePromise(INTERNAL, false, reason);\n\t    }\n\t    function wrap(fn, errorCatcher) {\n\t        var psd = PSD;\n\t        return function () {\n\t            var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n\t            try {\n\t                switchToZone(psd, true);\n\t                return fn.apply(this, arguments);\n\t            }\n\t            catch (e) {\n\t                errorCatcher && errorCatcher(e);\n\t            }\n\t            finally {\n\t                switchToZone(outerScope, false);\n\t                if (wasRootExec)\n\t                    endMicroTickScope();\n\t            }\n\t        };\n\t    }\n\t    var task = { awaits: 0, echoes: 0, id: 0 };\n\t    var taskCounter = 0;\n\t    var zoneStack = [];\n\t    var zoneEchoes = 0;\n\t    var totalEchoes = 0;\n\t    var zone_id_counter = 0;\n\t    function newScope(fn, props, a1, a2) {\n\t        var parent = PSD, psd = Object.create(parent);\n\t        psd.parent = parent;\n\t        psd.ref = 0;\n\t        psd.global = false;\n\t        psd.id = ++zone_id_counter;\n\t        globalPSD.env;\n\t        psd.env = patchGlobalPromise ? {\n\t            Promise: DexiePromise,\n\t            PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n\t            all: DexiePromise.all,\n\t            race: DexiePromise.race,\n\t            allSettled: DexiePromise.allSettled,\n\t            any: DexiePromise.any,\n\t            resolve: DexiePromise.resolve,\n\t            reject: DexiePromise.reject,\n\t        } : {};\n\t        if (props)\n\t            extend(psd, props);\n\t        ++parent.ref;\n\t        psd.finalize = function () {\n\t            --this.parent.ref || this.parent.finalize();\n\t        };\n\t        var rv = usePSD(psd, fn, a1, a2);\n\t        if (psd.ref === 0)\n\t            psd.finalize();\n\t        return rv;\n\t    }\n\t    function incrementExpectedAwaits() {\n\t        if (!task.id)\n\t            task.id = ++taskCounter;\n\t        ++task.awaits;\n\t        task.echoes += ZONE_ECHO_LIMIT;\n\t        return task.id;\n\t    }\n\t    function decrementExpectedAwaits() {\n\t        if (!task.awaits)\n\t            return false;\n\t        if (--task.awaits === 0)\n\t            task.id = 0;\n\t        task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n\t        return true;\n\t    }\n\t    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n\t        incrementExpectedAwaits = decrementExpectedAwaits = nop;\n\t    }\n\t    function onPossibleParallellAsync(possiblePromise) {\n\t        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n\t            incrementExpectedAwaits();\n\t            return possiblePromise.then(function (x) {\n\t                decrementExpectedAwaits();\n\t                return x;\n\t            }, function (e) {\n\t                decrementExpectedAwaits();\n\t                return rejection(e);\n\t            });\n\t        }\n\t        return possiblePromise;\n\t    }\n\t    function zoneEnterEcho(targetZone) {\n\t        ++totalEchoes;\n\t        if (!task.echoes || --task.echoes === 0) {\n\t            task.echoes = task.awaits = task.id = 0;\n\t        }\n\t        zoneStack.push(PSD);\n\t        switchToZone(targetZone, true);\n\t    }\n\t    function zoneLeaveEcho() {\n\t        var zone = zoneStack[zoneStack.length - 1];\n\t        zoneStack.pop();\n\t        switchToZone(zone, false);\n\t    }\n\t    function switchToZone(targetZone, bEnteringZone) {\n\t        var currentZone = PSD;\n\t        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n\t            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n\t        }\n\t        if (targetZone === PSD)\n\t            return;\n\t        PSD = targetZone;\n\t        if (currentZone === globalPSD)\n\t            globalPSD.env = snapShot();\n\t        if (patchGlobalPromise) {\n\t            var GlobalPromise = globalPSD.env.Promise;\n\t            var targetEnv = targetZone.env;\n\t            if (currentZone.global || targetZone.global) {\n\t                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n\t                GlobalPromise.all = targetEnv.all;\n\t                GlobalPromise.race = targetEnv.race;\n\t                GlobalPromise.resolve = targetEnv.resolve;\n\t                GlobalPromise.reject = targetEnv.reject;\n\t                if (targetEnv.allSettled)\n\t                    GlobalPromise.allSettled = targetEnv.allSettled;\n\t                if (targetEnv.any)\n\t                    GlobalPromise.any = targetEnv.any;\n\t            }\n\t        }\n\t    }\n\t    function snapShot() {\n\t        var GlobalPromise = _global.Promise;\n\t        return patchGlobalPromise ? {\n\t            Promise: GlobalPromise,\n\t            PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n\t            all: GlobalPromise.all,\n\t            race: GlobalPromise.race,\n\t            allSettled: GlobalPromise.allSettled,\n\t            any: GlobalPromise.any,\n\t            resolve: GlobalPromise.resolve,\n\t            reject: GlobalPromise.reject,\n\t        } : {};\n\t    }\n\t    function usePSD(psd, fn, a1, a2, a3) {\n\t        var outerScope = PSD;\n\t        try {\n\t            switchToZone(psd, true);\n\t            return fn(a1, a2, a3);\n\t        }\n\t        finally {\n\t            switchToZone(outerScope, false);\n\t        }\n\t    }\n\t    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n\t        return typeof fn !== 'function' ? fn : function () {\n\t            var outerZone = PSD;\n\t            if (possibleAwait)\n\t                incrementExpectedAwaits();\n\t            switchToZone(zone, true);\n\t            try {\n\t                return fn.apply(this, arguments);\n\t            }\n\t            finally {\n\t                switchToZone(outerZone, false);\n\t                if (cleanup)\n\t                    queueMicrotask(decrementExpectedAwaits);\n\t            }\n\t        };\n\t    }\n\t    function execInGlobalContext(cb) {\n\t        if (Promise === NativePromise && task.echoes === 0) {\n\t            if (zoneEchoes === 0) {\n\t                cb();\n\t            }\n\t            else {\n\t                enqueueNativeMicroTask(cb);\n\t            }\n\t        }\n\t        else {\n\t            setTimeout(cb, 0);\n\t        }\n\t    }\n\t    var rejection = DexiePromise.reject;\n\n\t    function tempTransaction(db, mode, storeNames, fn) {\n\t        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n\t            if (db._state.openComplete) {\n\t                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n\t            }\n\t            if (!db._state.isBeingOpened) {\n\t                if (!db._state.autoOpen)\n\t                    return rejection(new exceptions.DatabaseClosed());\n\t                db.open().catch(nop);\n\t            }\n\t            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n\t        }\n\t        else {\n\t            var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n\t            try {\n\t                trans.create();\n\t                db._state.PR1398_maxLoop = 3;\n\t            }\n\t            catch (ex) {\n\t                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n\t                    console.warn('Dexie: Need to reopen db');\n\t                    db.close({ disableAutoOpen: false });\n\t                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n\t                }\n\t                return rejection(ex);\n\t            }\n\t            return trans._promise(mode, function (resolve, reject) {\n\t                return newScope(function () {\n\t                    PSD.trans = trans;\n\t                    return fn(resolve, reject, trans);\n\t                });\n\t            }).then(function (result) {\n\t                if (mode === 'readwrite')\n\t                    try {\n\t                        trans.idbtrans.commit();\n\t                    }\n\t                    catch (_a) { }\n\t                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n\t            });\n\t        }\n\t    }\n\n\t    var DEXIE_VERSION = '4.0.8';\n\t    var maxString = String.fromCharCode(65535);\n\t    var minKey = -Infinity;\n\t    var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n\t    var STRING_EXPECTED = \"String expected.\";\n\t    var connections = [];\n\t    var DBNAMES_DB = '__dbnames';\n\t    var READONLY = 'readonly';\n\t    var READWRITE = 'readwrite';\n\n\t    function combine(filter1, filter2) {\n\t        return filter1 ?\n\t            filter2 ?\n\t                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n\t                filter1 :\n\t            filter2;\n\t    }\n\n\t    var AnyRange = {\n\t        type: 3 ,\n\t        lower: -Infinity,\n\t        lowerOpen: false,\n\t        upper: [[]],\n\t        upperOpen: false\n\t    };\n\n\t    function workaroundForUndefinedPrimKey(keyPath) {\n\t        return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n\t            ? function (obj) {\n\t                if (obj[keyPath] === undefined && (keyPath in obj)) {\n\t                    obj = deepClone(obj);\n\t                    delete obj[keyPath];\n\t                }\n\t                return obj;\n\t            }\n\t            : function (obj) { return obj; };\n\t    }\n\n\t    function Entity() {\n\t        throw exceptions.Type();\n\t    }\n\n\t    function cmp(a, b) {\n\t        try {\n\t            var ta = type(a);\n\t            var tb = type(b);\n\t            if (ta !== tb) {\n\t                if (ta === 'Array')\n\t                    return 1;\n\t                if (tb === 'Array')\n\t                    return -1;\n\t                if (ta === 'binary')\n\t                    return 1;\n\t                if (tb === 'binary')\n\t                    return -1;\n\t                if (ta === 'string')\n\t                    return 1;\n\t                if (tb === 'string')\n\t                    return -1;\n\t                if (ta === 'Date')\n\t                    return 1;\n\t                if (tb !== 'Date')\n\t                    return NaN;\n\t                return -1;\n\t            }\n\t            switch (ta) {\n\t                case 'number':\n\t                case 'Date':\n\t                case 'string':\n\t                    return a > b ? 1 : a < b ? -1 : 0;\n\t                case 'binary': {\n\t                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n\t                }\n\t                case 'Array':\n\t                    return compareArrays(a, b);\n\t            }\n\t        }\n\t        catch (_a) { }\n\t        return NaN;\n\t    }\n\t    function compareArrays(a, b) {\n\t        var al = a.length;\n\t        var bl = b.length;\n\t        var l = al < bl ? al : bl;\n\t        for (var i = 0; i < l; ++i) {\n\t            var res = cmp(a[i], b[i]);\n\t            if (res !== 0)\n\t                return res;\n\t        }\n\t        return al === bl ? 0 : al < bl ? -1 : 1;\n\t    }\n\t    function compareUint8Arrays(a, b) {\n\t        var al = a.length;\n\t        var bl = b.length;\n\t        var l = al < bl ? al : bl;\n\t        for (var i = 0; i < l; ++i) {\n\t            if (a[i] !== b[i])\n\t                return a[i] < b[i] ? -1 : 1;\n\t        }\n\t        return al === bl ? 0 : al < bl ? -1 : 1;\n\t    }\n\t    function type(x) {\n\t        var t = typeof x;\n\t        if (t !== 'object')\n\t            return t;\n\t        if (ArrayBuffer.isView(x))\n\t            return 'binary';\n\t        var tsTag = toStringTag(x);\n\t        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n\t    }\n\t    function getUint8Array(a) {\n\t        if (a instanceof Uint8Array)\n\t            return a;\n\t        if (ArrayBuffer.isView(a))\n\t            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n\t        return new Uint8Array(a);\n\t    }\n\n\t    var Table =  (function () {\n\t        function Table() {\n\t        }\n\t        Table.prototype._trans = function (mode, fn, writeLocked) {\n\t            var trans = this._tx || PSD.trans;\n\t            var tableName = this.name;\n\t            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n\t            function checkTableInTransaction(resolve, reject, trans) {\n\t                if (!trans.schema[tableName])\n\t                    throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n\t                return fn(trans.idbtrans, trans);\n\t            }\n\t            var wasRootExec = beginMicroTickScope();\n\t            try {\n\t                var p = trans && trans.db._novip === this.db._novip ?\n\t                    trans === PSD.trans ?\n\t                        trans._promise(mode, checkTableInTransaction, writeLocked) :\n\t                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n\t                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n\t                if (task) {\n\t                    p._consoleTask = task;\n\t                    p = p.catch(function (err) {\n\t                        console.trace(err);\n\t                        return rejection(err);\n\t                    });\n\t                }\n\t                return p;\n\t            }\n\t            finally {\n\t                if (wasRootExec)\n\t                    endMicroTickScope();\n\t            }\n\t        };\n\t        Table.prototype.get = function (keyOrCrit, cb) {\n\t            var _this = this;\n\t            if (keyOrCrit && keyOrCrit.constructor === Object)\n\t                return this.where(keyOrCrit).first(cb);\n\t            if (keyOrCrit == null)\n\t                return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n\t            return this._trans('readonly', function (trans) {\n\t                return _this.core.get({ trans: trans, key: keyOrCrit })\n\t                    .then(function (res) { return _this.hook.reading.fire(res); });\n\t            }).then(cb);\n\t        };\n\t        Table.prototype.where = function (indexOrCrit) {\n\t            if (typeof indexOrCrit === 'string')\n\t                return new this.db.WhereClause(this, indexOrCrit);\n\t            if (isArray(indexOrCrit))\n\t                return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n\t            var keyPaths = keys(indexOrCrit);\n\t            if (keyPaths.length === 1)\n\t                return this\n\t                    .where(keyPaths[0])\n\t                    .equals(indexOrCrit[keyPaths[0]]);\n\t            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n\t                if (ix.compound &&\n\t                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n\t                    for (var i = 0; i < keyPaths.length; ++i) {\n\t                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n\t                            return false;\n\t                    }\n\t                    return true;\n\t                }\n\t                return false;\n\t            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n\t            if (compoundIndex && this.db._maxKey !== maxString) {\n\t                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n\t                return this\n\t                    .where(keyPathsInValidOrder)\n\t                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n\t            }\n\t            if (!compoundIndex && debug)\n\t                console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n\t                    \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n\t            var idxByName = this.schema.idxByName;\n\t            var idb = this.db._deps.indexedDB;\n\t            function equals(a, b) {\n\t                return idb.cmp(a, b) === 0;\n\t            }\n\t            var _a = keyPaths.reduce(function (_a, keyPath) {\n\t                var prevIndex = _a[0], prevFilterFn = _a[1];\n\t                var index = idxByName[keyPath];\n\t                var value = indexOrCrit[keyPath];\n\t                return [\n\t                    prevIndex || index,\n\t                    prevIndex || !index ?\n\t                        combine(prevFilterFn, index && index.multi ?\n\t                            function (x) {\n\t                                var prop = getByKeyPath(x, keyPath);\n\t                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n\t                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n\t                        : prevFilterFn\n\t                ];\n\t            }, [null, null]), idx = _a[0], filterFunction = _a[1];\n\t            return idx ?\n\t                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n\t                    .filter(filterFunction) :\n\t                compoundIndex ?\n\t                    this.filter(filterFunction) :\n\t                    this.where(keyPaths).equals('');\n\t        };\n\t        Table.prototype.filter = function (filterFunction) {\n\t            return this.toCollection().and(filterFunction);\n\t        };\n\t        Table.prototype.count = function (thenShortcut) {\n\t            return this.toCollection().count(thenShortcut);\n\t        };\n\t        Table.prototype.offset = function (offset) {\n\t            return this.toCollection().offset(offset);\n\t        };\n\t        Table.prototype.limit = function (numRows) {\n\t            return this.toCollection().limit(numRows);\n\t        };\n\t        Table.prototype.each = function (callback) {\n\t            return this.toCollection().each(callback);\n\t        };\n\t        Table.prototype.toArray = function (thenShortcut) {\n\t            return this.toCollection().toArray(thenShortcut);\n\t        };\n\t        Table.prototype.toCollection = function () {\n\t            return new this.db.Collection(new this.db.WhereClause(this));\n\t        };\n\t        Table.prototype.orderBy = function (index) {\n\t            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n\t                \"[\".concat(index.join('+'), \"]\") :\n\t                index));\n\t        };\n\t        Table.prototype.reverse = function () {\n\t            return this.toCollection().reverse();\n\t        };\n\t        Table.prototype.mapToClass = function (constructor) {\n\t            var _a = this, db = _a.db, tableName = _a.name;\n\t            this.schema.mappedClass = constructor;\n\t            if (constructor.prototype instanceof Entity) {\n\t                constructor =  (function (_super) {\n\t                    __extends(class_1, _super);\n\t                    function class_1() {\n\t                        return _super !== null && _super.apply(this, arguments) || this;\n\t                    }\n\t                    Object.defineProperty(class_1.prototype, \"db\", {\n\t                        get: function () { return db; },\n\t                        enumerable: false,\n\t                        configurable: true\n\t                    });\n\t                    class_1.prototype.table = function () { return tableName; };\n\t                    return class_1;\n\t                }(constructor));\n\t            }\n\t            var inheritedProps = new Set();\n\t            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n\t                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n\t            }\n\t            var readHook = function (obj) {\n\t                if (!obj)\n\t                    return obj;\n\t                var res = Object.create(constructor.prototype);\n\t                for (var m in obj)\n\t                    if (!inheritedProps.has(m))\n\t                        try {\n\t                            res[m] = obj[m];\n\t                        }\n\t                        catch (_) { }\n\t                return res;\n\t            };\n\t            if (this.schema.readHook) {\n\t                this.hook.reading.unsubscribe(this.schema.readHook);\n\t            }\n\t            this.schema.readHook = readHook;\n\t            this.hook(\"reading\", readHook);\n\t            return constructor;\n\t        };\n\t        Table.prototype.defineClass = function () {\n\t            function Class(content) {\n\t                extend(this, content);\n\t            }\n\t            return this.mapToClass(Class);\n\t        };\n\t        Table.prototype.add = function (obj, key) {\n\t            var _this = this;\n\t            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t            var objToAdd = obj;\n\t            if (keyPath && auto) {\n\t                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n\t            }\n\t            return this._trans('readwrite', function (trans) {\n\t                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n\t            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n\t                .then(function (lastResult) {\n\t                if (keyPath) {\n\t                    try {\n\t                        setByKeyPath(obj, keyPath, lastResult);\n\t                    }\n\t                    catch (_) { }\n\t                }\n\t                return lastResult;\n\t            });\n\t        };\n\t        Table.prototype.update = function (keyOrObject, modifications) {\n\t            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n\t                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n\t                if (key === undefined)\n\t                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n\t                return this.where(\":id\").equals(key).modify(modifications);\n\t            }\n\t            else {\n\t                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n\t            }\n\t        };\n\t        Table.prototype.put = function (obj, key) {\n\t            var _this = this;\n\t            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t            var objToAdd = obj;\n\t            if (keyPath && auto) {\n\t                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n\t            }\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n\t                .then(function (lastResult) {\n\t                if (keyPath) {\n\t                    try {\n\t                        setByKeyPath(obj, keyPath, lastResult);\n\t                    }\n\t                    catch (_) { }\n\t                }\n\t                return lastResult;\n\t            });\n\t        };\n\t        Table.prototype.delete = function (key) {\n\t            var _this = this;\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n\t        };\n\t        Table.prototype.clear = function () {\n\t            var _this = this;\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n\t        };\n\t        Table.prototype.bulkGet = function (keys) {\n\t            var _this = this;\n\t            return this._trans('readonly', function (trans) {\n\t                return _this.core.getMany({\n\t                    keys: keys,\n\t                    trans: trans\n\t                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n\t            });\n\t        };\n\t        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n\t            var _this = this;\n\t            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n\t            options = options || (keys ? undefined : keysOrOptions);\n\t            var wantResults = options ? options.allKeys : undefined;\n\t            return this._trans('readwrite', function (trans) {\n\t                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t                if (keyPath && keys)\n\t                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n\t                if (keys && keys.length !== objects.length)\n\t                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\t                var numObjects = objects.length;\n\t                var objectsToAdd = keyPath && auto ?\n\t                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n\t                    objects;\n\t                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n\t                    .then(function (_a) {\n\t                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n\t                    var result = wantResults ? results : lastResult;\n\t                    if (numFailures === 0)\n\t                        return result;\n\t                    throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n\t            var _this = this;\n\t            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n\t            options = options || (keys ? undefined : keysOrOptions);\n\t            var wantResults = options ? options.allKeys : undefined;\n\t            return this._trans('readwrite', function (trans) {\n\t                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t                if (keyPath && keys)\n\t                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n\t                if (keys && keys.length !== objects.length)\n\t                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\t                var numObjects = objects.length;\n\t                var objectsToPut = keyPath && auto ?\n\t                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n\t                    objects;\n\t                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n\t                    .then(function (_a) {\n\t                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n\t                    var result = wantResults ? results : lastResult;\n\t                    if (numFailures === 0)\n\t                        return result;\n\t                    throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkUpdate = function (keysAndChanges) {\n\t            var _this = this;\n\t            var coreTable = this.core;\n\t            var keys = keysAndChanges.map(function (entry) { return entry.key; });\n\t            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n\t            var offsetMap = [];\n\t            return this._trans('readwrite', function (trans) {\n\t                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n\t                    var resultKeys = [];\n\t                    var resultObjs = [];\n\t                    keysAndChanges.forEach(function (_a, idx) {\n\t                        var key = _a.key, changes = _a.changes;\n\t                        var obj = objs[idx];\n\t                        if (obj) {\n\t                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n\t                                var keyPath = _b[_i];\n\t                                var value = changes[keyPath];\n\t                                if (keyPath === _this.schema.primKey.keyPath) {\n\t                                    if (cmp(value, key) !== 0) {\n\t                                        throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n\t                                    }\n\t                                }\n\t                                else {\n\t                                    setByKeyPath(obj, keyPath, value);\n\t                                }\n\t                            }\n\t                            offsetMap.push(idx);\n\t                            resultKeys.push(key);\n\t                            resultObjs.push(obj);\n\t                        }\n\t                    });\n\t                    var numEntries = resultKeys.length;\n\t                    return coreTable\n\t                        .mutate({\n\t                        trans: trans,\n\t                        type: 'put',\n\t                        keys: resultKeys,\n\t                        values: resultObjs,\n\t                        updates: {\n\t                            keys: keys,\n\t                            changeSpecs: changeSpecs\n\t                        }\n\t                    })\n\t                        .then(function (_a) {\n\t                        var numFailures = _a.numFailures, failures = _a.failures;\n\t                        if (numFailures === 0)\n\t                            return numEntries;\n\t                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n\t                            var offset = _b[_i];\n\t                            var mappedOffset = offsetMap[Number(offset)];\n\t                            if (mappedOffset != null) {\n\t                                var failure = failures[offset];\n\t                                delete failures[offset];\n\t                                failures[mappedOffset] = failure;\n\t                            }\n\t                        }\n\t                        throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n\t                    });\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkDelete = function (keys) {\n\t            var _this = this;\n\t            var numKeys = keys.length;\n\t            return this._trans('readwrite', function (trans) {\n\t                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });\n\t            }).then(function (_a) {\n\t                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n\t                if (numFailures === 0)\n\t                    return lastResult;\n\t                throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n\t            });\n\t        };\n\t        return Table;\n\t    }());\n\n\t    function Events(ctx) {\n\t        var evs = {};\n\t        var rv = function (eventName, subscriber) {\n\t            if (subscriber) {\n\t                var i = arguments.length, args = new Array(i - 1);\n\t                while (--i)\n\t                    args[i - 1] = arguments[i];\n\t                evs[eventName].subscribe.apply(null, args);\n\t                return ctx;\n\t            }\n\t            else if (typeof (eventName) === 'string') {\n\t                return evs[eventName];\n\t            }\n\t        };\n\t        rv.addEventType = add;\n\t        for (var i = 1, l = arguments.length; i < l; ++i) {\n\t            add(arguments[i]);\n\t        }\n\t        return rv;\n\t        function add(eventName, chainFunction, defaultFunction) {\n\t            if (typeof eventName === 'object')\n\t                return addConfiguredEvents(eventName);\n\t            if (!chainFunction)\n\t                chainFunction = reverseStoppableEventChain;\n\t            if (!defaultFunction)\n\t                defaultFunction = nop;\n\t            var context = {\n\t                subscribers: [],\n\t                fire: defaultFunction,\n\t                subscribe: function (cb) {\n\t                    if (context.subscribers.indexOf(cb) === -1) {\n\t                        context.subscribers.push(cb);\n\t                        context.fire = chainFunction(context.fire, cb);\n\t                    }\n\t                },\n\t                unsubscribe: function (cb) {\n\t                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n\t                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n\t                }\n\t            };\n\t            evs[eventName] = rv[eventName] = context;\n\t            return context;\n\t        }\n\t        function addConfiguredEvents(cfg) {\n\t            keys(cfg).forEach(function (eventName) {\n\t                var args = cfg[eventName];\n\t                if (isArray(args)) {\n\t                    add(eventName, cfg[eventName][0], cfg[eventName][1]);\n\t                }\n\t                else if (args === 'asap') {\n\t                    var context = add(eventName, mirror, function fire() {\n\t                        var i = arguments.length, args = new Array(i);\n\t                        while (i--)\n\t                            args[i] = arguments[i];\n\t                        context.subscribers.forEach(function (fn) {\n\t                            asap$1(function fireEvent() {\n\t                                fn.apply(null, args);\n\t                            });\n\t                        });\n\t                    });\n\t                }\n\t                else\n\t                    throw new exceptions.InvalidArgument(\"Invalid event config\");\n\t            });\n\t        }\n\t    }\n\n\t    function makeClassConstructor(prototype, constructor) {\n\t        derive(constructor).from({ prototype: prototype });\n\t        return constructor;\n\t    }\n\n\t    function createTableConstructor(db) {\n\t        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n\t            this.db = db;\n\t            this._tx = trans;\n\t            this.name = name;\n\t            this.schema = tableSchema;\n\t            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n\t                \"creating\": [hookCreatingChain, nop],\n\t                \"reading\": [pureFunctionChain, mirror],\n\t                \"updating\": [hookUpdatingChain, nop],\n\t                \"deleting\": [hookDeletingChain, nop]\n\t            });\n\t        });\n\t    }\n\n\t    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n\t        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n\t            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n\t    }\n\t    function addFilter(ctx, fn) {\n\t        ctx.filter = combine(ctx.filter, fn);\n\t    }\n\t    function addReplayFilter(ctx, factory, isLimitFilter) {\n\t        var curr = ctx.replayFilter;\n\t        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n\t        ctx.justLimit = isLimitFilter && !curr;\n\t    }\n\t    function addMatchFilter(ctx, fn) {\n\t        ctx.isMatch = combine(ctx.isMatch, fn);\n\t    }\n\t    function getIndexOrStore(ctx, coreSchema) {\n\t        if (ctx.isPrimKey)\n\t            return coreSchema.primaryKey;\n\t        var index = coreSchema.getIndexByKeyPath(ctx.index);\n\t        if (!index)\n\t            throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n\t        return index;\n\t    }\n\t    function openCursor(ctx, coreTable, trans) {\n\t        var index = getIndexOrStore(ctx, coreTable.schema);\n\t        return coreTable.openCursor({\n\t            trans: trans,\n\t            values: !ctx.keysOnly,\n\t            reverse: ctx.dir === 'prev',\n\t            unique: !!ctx.unique,\n\t            query: {\n\t                index: index,\n\t                range: ctx.range\n\t            }\n\t        });\n\t    }\n\t    function iter(ctx, fn, coreTrans, coreTable) {\n\t        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n\t        if (!ctx.or) {\n\t            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n\t        }\n\t        else {\n\t            var set_1 = {};\n\t            var union = function (item, cursor, advance) {\n\t                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n\t                    var primaryKey = cursor.primaryKey;\n\t                    var key = '' + primaryKey;\n\t                    if (key === '[object ArrayBuffer]')\n\t                        key = '' + new Uint8Array(primaryKey);\n\t                    if (!hasOwn(set_1, key)) {\n\t                        set_1[key] = true;\n\t                        fn(item, cursor, advance);\n\t                    }\n\t                }\n\t            };\n\t            return Promise.all([\n\t                ctx.or._iterate(union, coreTrans),\n\t                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n\t            ]);\n\t        }\n\t    }\n\t    function iterate(cursorPromise, filter, fn, valueMapper) {\n\t        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n\t        var wrappedFn = wrap(mappedFn);\n\t        return cursorPromise.then(function (cursor) {\n\t            if (cursor) {\n\t                return cursor.start(function () {\n\t                    var c = function () { return cursor.continue(); };\n\t                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n\t                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n\t                    c();\n\t                });\n\t            }\n\t        });\n\t    }\n\n\t    var PropModSymbol = Symbol();\n\t    var PropModification =  (function () {\n\t        function PropModification(spec) {\n\t            Object.assign(this, spec);\n\t        }\n\t        PropModification.prototype.execute = function (value) {\n\t            var _a;\n\t            if (this.add !== undefined) {\n\t                var term = this.add;\n\t                if (isArray(term)) {\n\t                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n\t                }\n\t                if (typeof term === 'number')\n\t                    return (Number(value) || 0) + term;\n\t                if (typeof term === 'bigint') {\n\t                    try {\n\t                        return BigInt(value) + term;\n\t                    }\n\t                    catch (_b) {\n\t                        return BigInt(0) + term;\n\t                    }\n\t                }\n\t                throw new TypeError(\"Invalid term \".concat(term));\n\t            }\n\t            if (this.remove !== undefined) {\n\t                var subtrahend_1 = this.remove;\n\t                if (isArray(subtrahend_1)) {\n\t                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n\t                }\n\t                if (typeof subtrahend_1 === 'number')\n\t                    return Number(value) - subtrahend_1;\n\t                if (typeof subtrahend_1 === 'bigint') {\n\t                    try {\n\t                        return BigInt(value) - subtrahend_1;\n\t                    }\n\t                    catch (_c) {\n\t                        return BigInt(0) - subtrahend_1;\n\t                    }\n\t                }\n\t                throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n\t            }\n\t            var prefixToReplace = (_a = this.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n\t            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n\t                return this.replacePrefix[1] + value.substring(prefixToReplace.length);\n\t            }\n\t            return value;\n\t        };\n\t        return PropModification;\n\t    }());\n\n\t    var Collection =  (function () {\n\t        function Collection() {\n\t        }\n\t        Collection.prototype._read = function (fn, cb) {\n\t            var ctx = this._ctx;\n\t            return ctx.error ?\n\t                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n\t                ctx.table._trans('readonly', fn).then(cb);\n\t        };\n\t        Collection.prototype._write = function (fn) {\n\t            var ctx = this._ctx;\n\t            return ctx.error ?\n\t                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n\t                ctx.table._trans('readwrite', fn, \"locked\");\n\t        };\n\t        Collection.prototype._addAlgorithm = function (fn) {\n\t            var ctx = this._ctx;\n\t            ctx.algorithm = combine(ctx.algorithm, fn);\n\t        };\n\t        Collection.prototype._iterate = function (fn, coreTrans) {\n\t            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n\t        };\n\t        Collection.prototype.clone = function (props) {\n\t            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n\t            if (props)\n\t                extend(ctx, props);\n\t            rv._ctx = ctx;\n\t            return rv;\n\t        };\n\t        Collection.prototype.raw = function () {\n\t            this._ctx.valueMapper = null;\n\t            return this;\n\t        };\n\t        Collection.prototype.each = function (fn) {\n\t            var ctx = this._ctx;\n\t            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n\t        };\n\t        Collection.prototype.count = function (cb) {\n\t            var _this = this;\n\t            return this._read(function (trans) {\n\t                var ctx = _this._ctx;\n\t                var coreTable = ctx.table.core;\n\t                if (isPlainKeyRange(ctx, true)) {\n\t                    return coreTable.count({\n\t                        trans: trans,\n\t                        query: {\n\t                            index: getIndexOrStore(ctx, coreTable.schema),\n\t                            range: ctx.range\n\t                        }\n\t                    }).then(function (count) { return Math.min(count, ctx.limit); });\n\t                }\n\t                else {\n\t                    var count = 0;\n\t                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n\t                        .then(function () { return count; });\n\t                }\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.sortBy = function (keyPath, cb) {\n\t            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n\t            function getval(obj, i) {\n\t                if (i)\n\t                    return getval(obj[parts[i]], i - 1);\n\t                return obj[lastPart];\n\t            }\n\t            var order = this._ctx.dir === \"next\" ? 1 : -1;\n\t            function sorter(a, b) {\n\t                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n\t                return aVal < bVal ? -order : aVal > bVal ? order : 0;\n\t            }\n\t            return this.toArray(function (a) {\n\t                return a.sort(sorter);\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.toArray = function (cb) {\n\t            var _this = this;\n\t            return this._read(function (trans) {\n\t                var ctx = _this._ctx;\n\t                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n\t                    var valueMapper_1 = ctx.valueMapper;\n\t                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n\t                    return ctx.table.core.query({\n\t                        trans: trans,\n\t                        limit: ctx.limit,\n\t                        values: true,\n\t                        query: {\n\t                            index: index,\n\t                            range: ctx.range\n\t                        }\n\t                    }).then(function (_a) {\n\t                        var result = _a.result;\n\t                        return valueMapper_1 ? result.map(valueMapper_1) : result;\n\t                    });\n\t                }\n\t                else {\n\t                    var a_1 = [];\n\t                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n\t                }\n\t            }, cb);\n\t        };\n\t        Collection.prototype.offset = function (offset) {\n\t            var ctx = this._ctx;\n\t            if (offset <= 0)\n\t                return this;\n\t            ctx.offset += offset;\n\t            if (isPlainKeyRange(ctx)) {\n\t                addReplayFilter(ctx, function () {\n\t                    var offsetLeft = offset;\n\t                    return function (cursor, advance) {\n\t                        if (offsetLeft === 0)\n\t                            return true;\n\t                        if (offsetLeft === 1) {\n\t                            --offsetLeft;\n\t                            return false;\n\t                        }\n\t                        advance(function () {\n\t                            cursor.advance(offsetLeft);\n\t                            offsetLeft = 0;\n\t                        });\n\t                        return false;\n\t                    };\n\t                });\n\t            }\n\t            else {\n\t                addReplayFilter(ctx, function () {\n\t                    var offsetLeft = offset;\n\t                    return function () { return (--offsetLeft < 0); };\n\t                });\n\t            }\n\t            return this;\n\t        };\n\t        Collection.prototype.limit = function (numRows) {\n\t            this._ctx.limit = Math.min(this._ctx.limit, numRows);\n\t            addReplayFilter(this._ctx, function () {\n\t                var rowsLeft = numRows;\n\t                return function (cursor, advance, resolve) {\n\t                    if (--rowsLeft <= 0)\n\t                        advance(resolve);\n\t                    return rowsLeft >= 0;\n\t                };\n\t            }, true);\n\t            return this;\n\t        };\n\t        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n\t            addFilter(this._ctx, function (cursor, advance, resolve) {\n\t                if (filterFunction(cursor.value)) {\n\t                    advance(resolve);\n\t                    return bIncludeStopEntry;\n\t                }\n\t                else {\n\t                    return true;\n\t                }\n\t            });\n\t            return this;\n\t        };\n\t        Collection.prototype.first = function (cb) {\n\t            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n\t        };\n\t        Collection.prototype.last = function (cb) {\n\t            return this.reverse().first(cb);\n\t        };\n\t        Collection.prototype.filter = function (filterFunction) {\n\t            addFilter(this._ctx, function (cursor) {\n\t                return filterFunction(cursor.value);\n\t            });\n\t            addMatchFilter(this._ctx, filterFunction);\n\t            return this;\n\t        };\n\t        Collection.prototype.and = function (filter) {\n\t            return this.filter(filter);\n\t        };\n\t        Collection.prototype.or = function (indexName) {\n\t            return new this.db.WhereClause(this._ctx.table, indexName, this);\n\t        };\n\t        Collection.prototype.reverse = function () {\n\t            this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n\t            if (this._ondirectionchange)\n\t                this._ondirectionchange(this._ctx.dir);\n\t            return this;\n\t        };\n\t        Collection.prototype.desc = function () {\n\t            return this.reverse();\n\t        };\n\t        Collection.prototype.eachKey = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n\t        };\n\t        Collection.prototype.eachUniqueKey = function (cb) {\n\t            this._ctx.unique = \"unique\";\n\t            return this.eachKey(cb);\n\t        };\n\t        Collection.prototype.eachPrimaryKey = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n\t        };\n\t        Collection.prototype.keys = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            var a = [];\n\t            return this.each(function (item, cursor) {\n\t                a.push(cursor.key);\n\t            }).then(function () {\n\t                return a;\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.primaryKeys = function (cb) {\n\t            var ctx = this._ctx;\n\t            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n\t                return this._read(function (trans) {\n\t                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n\t                    return ctx.table.core.query({\n\t                        trans: trans,\n\t                        values: false,\n\t                        limit: ctx.limit,\n\t                        query: {\n\t                            index: index,\n\t                            range: ctx.range\n\t                        }\n\t                    });\n\t                }).then(function (_a) {\n\t                    var result = _a.result;\n\t                    return result;\n\t                }).then(cb);\n\t            }\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            var a = [];\n\t            return this.each(function (item, cursor) {\n\t                a.push(cursor.primaryKey);\n\t            }).then(function () {\n\t                return a;\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.uniqueKeys = function (cb) {\n\t            this._ctx.unique = \"unique\";\n\t            return this.keys(cb);\n\t        };\n\t        Collection.prototype.firstKey = function (cb) {\n\t            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n\t        };\n\t        Collection.prototype.lastKey = function (cb) {\n\t            return this.reverse().firstKey(cb);\n\t        };\n\t        Collection.prototype.distinct = function () {\n\t            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n\t            if (!idx || !idx.multi)\n\t                return this;\n\t            var set = {};\n\t            addFilter(this._ctx, function (cursor) {\n\t                var strKey = cursor.primaryKey.toString();\n\t                var found = hasOwn(set, strKey);\n\t                set[strKey] = true;\n\t                return !found;\n\t            });\n\t            return this;\n\t        };\n\t        Collection.prototype.modify = function (changes) {\n\t            var _this = this;\n\t            var ctx = this._ctx;\n\t            return this._write(function (trans) {\n\t                var modifyer;\n\t                if (typeof changes === 'function') {\n\t                    modifyer = changes;\n\t                }\n\t                else {\n\t                    var keyPaths = keys(changes);\n\t                    var numKeys = keyPaths.length;\n\t                    modifyer = function (item) {\n\t                        var anythingModified = false;\n\t                        for (var i = 0; i < numKeys; ++i) {\n\t                            var keyPath = keyPaths[i];\n\t                            var val = changes[keyPath];\n\t                            var origVal = getByKeyPath(item, keyPath);\n\t                            if (val instanceof PropModification) {\n\t                                setByKeyPath(item, keyPath, val.execute(origVal));\n\t                                anythingModified = true;\n\t                            }\n\t                            else if (origVal !== val) {\n\t                                setByKeyPath(item, keyPath, val);\n\t                                anythingModified = true;\n\t                            }\n\t                        }\n\t                        return anythingModified;\n\t                    };\n\t                }\n\t                var coreTable = ctx.table.core;\n\t                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n\t                var limit = _this.db._options.modifyChunkSize || 200;\n\t                var totalFailures = [];\n\t                var successCount = 0;\n\t                var failedKeys = [];\n\t                var applyMutateResult = function (expectedCount, res) {\n\t                    var failures = res.failures, numFailures = res.numFailures;\n\t                    successCount += expectedCount - numFailures;\n\t                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n\t                        var pos = _a[_i];\n\t                        totalFailures.push(failures[pos]);\n\t                    }\n\t                };\n\t                return _this.clone().primaryKeys().then(function (keys) {\n\t                    var criteria = isPlainKeyRange(ctx) &&\n\t                        ctx.limit === Infinity &&\n\t                        (typeof changes !== 'function' || changes === deleteCallback) && {\n\t                        index: ctx.index,\n\t                        range: ctx.range\n\t                    };\n\t                    var nextChunk = function (offset) {\n\t                        var count = Math.min(limit, keys.length - offset);\n\t                        return coreTable.getMany({\n\t                            trans: trans,\n\t                            keys: keys.slice(offset, offset + count),\n\t                            cache: \"immutable\"\n\t                        }).then(function (values) {\n\t                            var addValues = [];\n\t                            var putValues = [];\n\t                            var putKeys = outbound ? [] : null;\n\t                            var deleteKeys = [];\n\t                            for (var i = 0; i < count; ++i) {\n\t                                var origValue = values[i];\n\t                                var ctx_1 = {\n\t                                    value: deepClone(origValue),\n\t                                    primKey: keys[offset + i]\n\t                                };\n\t                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n\t                                    if (ctx_1.value == null) {\n\t                                        deleteKeys.push(keys[offset + i]);\n\t                                    }\n\t                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n\t                                        deleteKeys.push(keys[offset + i]);\n\t                                        addValues.push(ctx_1.value);\n\t                                    }\n\t                                    else {\n\t                                        putValues.push(ctx_1.value);\n\t                                        if (outbound)\n\t                                            putKeys.push(keys[offset + i]);\n\t                                    }\n\t                                }\n\t                            }\n\t                            return Promise.resolve(addValues.length > 0 &&\n\t                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n\t                                    .then(function (res) {\n\t                                    for (var pos in res.failures) {\n\t                                        deleteKeys.splice(parseInt(pos), 1);\n\t                                    }\n\t                                    applyMutateResult(addValues.length, res);\n\t                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n\t                                coreTable.mutate({\n\t                                    trans: trans,\n\t                                    type: 'put',\n\t                                    keys: putKeys,\n\t                                    values: putValues,\n\t                                    criteria: criteria,\n\t                                    changeSpec: typeof changes !== 'function'\n\t                                        && changes,\n\t                                    isAdditionalChunk: offset > 0\n\t                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n\t                                coreTable.mutate({\n\t                                    trans: trans,\n\t                                    type: 'delete',\n\t                                    keys: deleteKeys,\n\t                                    criteria: criteria,\n\t                                    isAdditionalChunk: offset > 0\n\t                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n\t                                return keys.length > offset + count && nextChunk(offset + limit);\n\t                            });\n\t                        });\n\t                    };\n\t                    return nextChunk(0).then(function () {\n\t                        if (totalFailures.length > 0)\n\t                            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n\t                        return keys.length;\n\t                    });\n\t                });\n\t            });\n\t        };\n\t        Collection.prototype.delete = function () {\n\t            var ctx = this._ctx, range = ctx.range;\n\t            if (isPlainKeyRange(ctx) &&\n\t                (ctx.isPrimKey || range.type === 3 ))\n\t             {\n\t                return this._write(function (trans) {\n\t                    var primaryKey = ctx.table.core.schema.primaryKey;\n\t                    var coreRange = range;\n\t                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n\t                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n\t                            .then(function (_a) {\n\t                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;\n\t                            if (numFailures)\n\t                                throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n\t                            return count - numFailures;\n\t                        });\n\t                    });\n\t                });\n\t            }\n\t            return this.modify(deleteCallback);\n\t        };\n\t        return Collection;\n\t    }());\n\t    var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n\t    function createCollectionConstructor(db) {\n\t        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n\t            this.db = db;\n\t            var keyRange = AnyRange, error = null;\n\t            if (keyRangeGenerator)\n\t                try {\n\t                    keyRange = keyRangeGenerator();\n\t                }\n\t                catch (ex) {\n\t                    error = ex;\n\t                }\n\t            var whereCtx = whereClause._ctx;\n\t            var table = whereCtx.table;\n\t            var readingHook = table.hook.reading.fire;\n\t            this._ctx = {\n\t                table: table,\n\t                index: whereCtx.index,\n\t                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n\t                range: keyRange,\n\t                keysOnly: false,\n\t                dir: \"next\",\n\t                unique: \"\",\n\t                algorithm: null,\n\t                filter: null,\n\t                replayFilter: null,\n\t                justLimit: true,\n\t                isMatch: null,\n\t                offset: 0,\n\t                limit: Infinity,\n\t                error: error,\n\t                or: whereCtx.or,\n\t                valueMapper: readingHook !== mirror ? readingHook : null\n\t            };\n\t        });\n\t    }\n\n\t    function simpleCompare(a, b) {\n\t        return a < b ? -1 : a === b ? 0 : 1;\n\t    }\n\t    function simpleCompareReverse(a, b) {\n\t        return a > b ? -1 : a === b ? 0 : 1;\n\t    }\n\n\t    function fail(collectionOrWhereClause, err, T) {\n\t        var collection = collectionOrWhereClause instanceof WhereClause ?\n\t            new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n\t            collectionOrWhereClause;\n\t        collection._ctx.error = T ? new T(err) : new TypeError(err);\n\t        return collection;\n\t    }\n\t    function emptyCollection(whereClause) {\n\t        return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n\t    }\n\t    function upperFactory(dir) {\n\t        return dir === \"next\" ?\n\t            function (s) { return s.toUpperCase(); } :\n\t            function (s) { return s.toLowerCase(); };\n\t    }\n\t    function lowerFactory(dir) {\n\t        return dir === \"next\" ?\n\t            function (s) { return s.toLowerCase(); } :\n\t            function (s) { return s.toUpperCase(); };\n\t    }\n\t    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n\t        var length = Math.min(key.length, lowerNeedle.length);\n\t        var llp = -1;\n\t        for (var i = 0; i < length; ++i) {\n\t            var lwrKeyChar = lowerKey[i];\n\t            if (lwrKeyChar !== lowerNeedle[i]) {\n\t                if (cmp(key[i], upperNeedle[i]) < 0)\n\t                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n\t                if (cmp(key[i], lowerNeedle[i]) < 0)\n\t                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n\t                if (llp >= 0)\n\t                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n\t                return null;\n\t            }\n\t            if (cmp(key[i], lwrKeyChar) < 0)\n\t                llp = i;\n\t        }\n\t        if (length < lowerNeedle.length && dir === \"next\")\n\t            return key + upperNeedle.substr(key.length);\n\t        if (length < key.length && dir === \"prev\")\n\t            return key.substr(0, upperNeedle.length);\n\t        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n\t    }\n\t    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n\t        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n\t        if (!needles.every(function (s) { return typeof s === 'string'; })) {\n\t            return fail(whereClause, STRING_EXPECTED);\n\t        }\n\t        function initDirection(dir) {\n\t            upper = upperFactory(dir);\n\t            lower = lowerFactory(dir);\n\t            compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n\t            var needleBounds = needles.map(function (needle) {\n\t                return { lower: lower(needle), upper: upper(needle) };\n\t            }).sort(function (a, b) {\n\t                return compare(a.lower, b.lower);\n\t            });\n\t            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n\t            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n\t            direction = dir;\n\t            nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n\t        }\n\t        initDirection(\"next\");\n\t        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n\t        c._ondirectionchange = function (direction) {\n\t            initDirection(direction);\n\t        };\n\t        var firstPossibleNeedle = 0;\n\t        c._addAlgorithm(function (cursor, advance, resolve) {\n\t            var key = cursor.key;\n\t            if (typeof key !== 'string')\n\t                return false;\n\t            var lowerKey = lower(key);\n\t            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n\t                return true;\n\t            }\n\t            else {\n\t                var lowestPossibleCasing = null;\n\t                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n\t                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n\t                    if (casing === null && lowestPossibleCasing === null)\n\t                        firstPossibleNeedle = i + 1;\n\t                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n\t                        lowestPossibleCasing = casing;\n\t                    }\n\t                }\n\t                if (lowestPossibleCasing !== null) {\n\t                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n\t                }\n\t                else {\n\t                    advance(resolve);\n\t                }\n\t                return false;\n\t            }\n\t        });\n\t        return c;\n\t    }\n\t    function createRange(lower, upper, lowerOpen, upperOpen) {\n\t        return {\n\t            type: 2 ,\n\t            lower: lower,\n\t            upper: upper,\n\t            lowerOpen: lowerOpen,\n\t            upperOpen: upperOpen\n\t        };\n\t    }\n\t    function rangeEqual(value) {\n\t        return {\n\t            type: 1 ,\n\t            lower: value,\n\t            upper: value\n\t        };\n\t    }\n\n\t    var WhereClause =  (function () {\n\t        function WhereClause() {\n\t        }\n\t        Object.defineProperty(WhereClause.prototype, \"Collection\", {\n\t            get: function () {\n\t                return this._ctx.table.db.Collection;\n\t            },\n\t            enumerable: false,\n\t            configurable: true\n\t        });\n\t        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n\t            includeLower = includeLower !== false;\n\t            includeUpper = includeUpper === true;\n\t            try {\n\t                if ((this._cmp(lower, upper) > 0) ||\n\t                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n\t                    return emptyCollection(this);\n\t                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t        };\n\t        WhereClause.prototype.equals = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return rangeEqual(value); });\n\t        };\n\t        WhereClause.prototype.above = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(value, undefined, true); });\n\t        };\n\t        WhereClause.prototype.aboveOrEqual = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(value, undefined, false); });\n\t        };\n\t        WhereClause.prototype.below = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n\t        };\n\t        WhereClause.prototype.belowOrEqual = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(undefined, value); });\n\t        };\n\t        WhereClause.prototype.startsWith = function (str) {\n\t            if (typeof str !== 'string')\n\t                return fail(this, STRING_EXPECTED);\n\t            return this.between(str, str + maxString, true, true);\n\t        };\n\t        WhereClause.prototype.startsWithIgnoreCase = function (str) {\n\t            if (str === \"\")\n\t                return this.startsWith(str);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n\t        };\n\t        WhereClause.prototype.equalsIgnoreCase = function (str) {\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n\t        };\n\t        WhereClause.prototype.anyOfIgnoreCase = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n\t        };\n\t        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n\t        };\n\t        WhereClause.prototype.anyOf = function () {\n\t            var _this = this;\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            var compare = this._cmp;\n\t            try {\n\t                set.sort(compare);\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n\t            c._ondirectionchange = function (direction) {\n\t                compare = (direction === \"next\" ?\n\t                    _this._ascending :\n\t                    _this._descending);\n\t                set.sort(compare);\n\t            };\n\t            var i = 0;\n\t            c._addAlgorithm(function (cursor, advance, resolve) {\n\t                var key = cursor.key;\n\t                while (compare(key, set[i]) > 0) {\n\t                    ++i;\n\t                    if (i === set.length) {\n\t                        advance(resolve);\n\t                        return false;\n\t                    }\n\t                }\n\t                if (compare(key, set[i]) === 0) {\n\t                    return true;\n\t                }\n\t                else {\n\t                    advance(function () { cursor.continue(set[i]); });\n\t                    return false;\n\t                }\n\t            });\n\t            return c;\n\t        };\n\t        WhereClause.prototype.notEqual = function (value) {\n\t            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n\t        };\n\t        WhereClause.prototype.noneOf = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return new this.Collection(this);\n\t            try {\n\t                set.sort(this._ascending);\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            var ranges = set.reduce(function (res, val) { return res ?\n\t                res.concat([[res[res.length - 1][1], val]]) :\n\t                [[minKey, val]]; }, null);\n\t            ranges.push([set[set.length - 1], this.db._maxKey]);\n\t            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n\t        };\n\t        WhereClause.prototype.inAnyRange = function (ranges, options) {\n\t            var _this = this;\n\t            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n\t            if (ranges.length === 0)\n\t                return emptyCollection(this);\n\t            if (!ranges.every(function (range) {\n\t                return range[0] !== undefined &&\n\t                    range[1] !== undefined &&\n\t                    ascending(range[0], range[1]) <= 0;\n\t            })) {\n\t                return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n\t            }\n\t            var includeLowers = !options || options.includeLowers !== false;\n\t            var includeUppers = options && options.includeUppers === true;\n\t            function addRange(ranges, newRange) {\n\t                var i = 0, l = ranges.length;\n\t                for (; i < l; ++i) {\n\t                    var range = ranges[i];\n\t                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n\t                        range[0] = min(range[0], newRange[0]);\n\t                        range[1] = max(range[1], newRange[1]);\n\t                        break;\n\t                    }\n\t                }\n\t                if (i === l)\n\t                    ranges.push(newRange);\n\t                return ranges;\n\t            }\n\t            var sortDirection = ascending;\n\t            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n\t            var set;\n\t            try {\n\t                set = ranges.reduce(addRange, []);\n\t                set.sort(rangeSorter);\n\t            }\n\t            catch (ex) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            var rangePos = 0;\n\t            var keyIsBeyondCurrentEntry = includeUppers ?\n\t                function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n\t                function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n\t            var keyIsBeforeCurrentEntry = includeLowers ?\n\t                function (key) { return descending(key, set[rangePos][0]) > 0; } :\n\t                function (key) { return descending(key, set[rangePos][0]) >= 0; };\n\t            function keyWithinCurrentRange(key) {\n\t                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n\t            }\n\t            var checkKey = keyIsBeyondCurrentEntry;\n\t            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n\t            c._ondirectionchange = function (direction) {\n\t                if (direction === \"next\") {\n\t                    checkKey = keyIsBeyondCurrentEntry;\n\t                    sortDirection = ascending;\n\t                }\n\t                else {\n\t                    checkKey = keyIsBeforeCurrentEntry;\n\t                    sortDirection = descending;\n\t                }\n\t                set.sort(rangeSorter);\n\t            };\n\t            c._addAlgorithm(function (cursor, advance, resolve) {\n\t                var key = cursor.key;\n\t                while (checkKey(key)) {\n\t                    ++rangePos;\n\t                    if (rangePos === set.length) {\n\t                        advance(resolve);\n\t                        return false;\n\t                    }\n\t                }\n\t                if (keyWithinCurrentRange(key)) {\n\t                    return true;\n\t                }\n\t                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n\t                    return false;\n\t                }\n\t                else {\n\t                    advance(function () {\n\t                        if (sortDirection === ascending)\n\t                            cursor.continue(set[rangePos][0]);\n\t                        else\n\t                            cursor.continue(set[rangePos][1]);\n\t                    });\n\t                    return false;\n\t                }\n\t            });\n\t            return c;\n\t        };\n\t        WhereClause.prototype.startsWithAnyOf = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (!set.every(function (s) { return typeof s === 'string'; })) {\n\t                return fail(this, \"startsWithAnyOf() only works with strings\");\n\t            }\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n\t        };\n\t        return WhereClause;\n\t    }());\n\n\t    function createWhereClauseConstructor(db) {\n\t        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n\t            this.db = db;\n\t            this._ctx = {\n\t                table: table,\n\t                index: index === \":id\" ? null : index,\n\t                or: orCollection\n\t            };\n\t            this._cmp = this._ascending = cmp;\n\t            this._descending = function (a, b) { return cmp(b, a); };\n\t            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n\t            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n\t            this._IDBKeyRange = db._deps.IDBKeyRange;\n\t            if (!this._IDBKeyRange)\n\t                throw new exceptions.MissingAPI();\n\t        });\n\t    }\n\n\t    function eventRejectHandler(reject) {\n\t        return wrap(function (event) {\n\t            preventDefault(event);\n\t            reject(event.target.error);\n\t            return false;\n\t        });\n\t    }\n\t    function preventDefault(event) {\n\t        if (event.stopPropagation)\n\t            event.stopPropagation();\n\t        if (event.preventDefault)\n\t            event.preventDefault();\n\t    }\n\n\t    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n\t    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n\t    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n\t    var Transaction =  (function () {\n\t        function Transaction() {\n\t        }\n\t        Transaction.prototype._lock = function () {\n\t            assert(!PSD.global);\n\t            ++this._reculock;\n\t            if (this._reculock === 1 && !PSD.global)\n\t                PSD.lockOwnerFor = this;\n\t            return this;\n\t        };\n\t        Transaction.prototype._unlock = function () {\n\t            assert(!PSD.global);\n\t            if (--this._reculock === 0) {\n\t                if (!PSD.global)\n\t                    PSD.lockOwnerFor = null;\n\t                while (this._blockedFuncs.length > 0 && !this._locked()) {\n\t                    var fnAndPSD = this._blockedFuncs.shift();\n\t                    try {\n\t                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n\t                    }\n\t                    catch (e) { }\n\t                }\n\t            }\n\t            return this;\n\t        };\n\t        Transaction.prototype._locked = function () {\n\t            return this._reculock && PSD.lockOwnerFor !== this;\n\t        };\n\t        Transaction.prototype.create = function (idbtrans) {\n\t            var _this = this;\n\t            if (!this.mode)\n\t                return this;\n\t            var idbdb = this.db.idbdb;\n\t            var dbOpenError = this.db._state.dbOpenError;\n\t            assert(!this.idbtrans);\n\t            if (!idbtrans && !idbdb) {\n\t                switch (dbOpenError && dbOpenError.name) {\n\t                    case \"DatabaseClosedError\":\n\t                        throw new exceptions.DatabaseClosed(dbOpenError);\n\t                    case \"MissingAPIError\":\n\t                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n\t                    default:\n\t                        throw new exceptions.OpenFailed(dbOpenError);\n\t                }\n\t            }\n\t            if (!this.active)\n\t                throw new exceptions.TransactionInactive();\n\t            assert(this._completion._state === null);\n\t            idbtrans = this.idbtrans = idbtrans ||\n\t                (this.db.core\n\t                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n\t                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n\t            idbtrans.onerror = wrap(function (ev) {\n\t                preventDefault(ev);\n\t                _this._reject(idbtrans.error);\n\t            });\n\t            idbtrans.onabort = wrap(function (ev) {\n\t                preventDefault(ev);\n\t                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n\t                _this.active = false;\n\t                _this.on(\"abort\").fire(ev);\n\t            });\n\t            idbtrans.oncomplete = wrap(function () {\n\t                _this.active = false;\n\t                _this._resolve();\n\t                if ('mutatedParts' in idbtrans) {\n\t                    globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n\t                }\n\t            });\n\t            return this;\n\t        };\n\t        Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n\t            var _this = this;\n\t            if (mode === 'readwrite' && this.mode !== 'readwrite')\n\t                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n\t            if (!this.active)\n\t                return rejection(new exceptions.TransactionInactive());\n\t            if (this._locked()) {\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    _this._blockedFuncs.push([function () {\n\t                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n\t                        }, PSD]);\n\t                });\n\t            }\n\t            else if (bWriteLock) {\n\t                return newScope(function () {\n\t                    var p = new DexiePromise(function (resolve, reject) {\n\t                        _this._lock();\n\t                        var rv = fn(resolve, reject, _this);\n\t                        if (rv && rv.then)\n\t                            rv.then(resolve, reject);\n\t                    });\n\t                    p.finally(function () { return _this._unlock(); });\n\t                    p._lib = true;\n\t                    return p;\n\t                });\n\t            }\n\t            else {\n\t                var p = new DexiePromise(function (resolve, reject) {\n\t                    var rv = fn(resolve, reject, _this);\n\t                    if (rv && rv.then)\n\t                        rv.then(resolve, reject);\n\t                });\n\t                p._lib = true;\n\t                return p;\n\t            }\n\t        };\n\t        Transaction.prototype._root = function () {\n\t            return this.parent ? this.parent._root() : this;\n\t        };\n\t        Transaction.prototype.waitFor = function (promiseLike) {\n\t            var root = this._root();\n\t            var promise = DexiePromise.resolve(promiseLike);\n\t            if (root._waitingFor) {\n\t                root._waitingFor = root._waitingFor.then(function () { return promise; });\n\t            }\n\t            else {\n\t                root._waitingFor = promise;\n\t                root._waitingQueue = [];\n\t                var store = root.idbtrans.objectStore(root.storeNames[0]);\n\t                (function spin() {\n\t                    ++root._spinCount;\n\t                    while (root._waitingQueue.length)\n\t                        (root._waitingQueue.shift())();\n\t                    if (root._waitingFor)\n\t                        store.get(-Infinity).onsuccess = spin;\n\t                }());\n\t            }\n\t            var currentWaitPromise = root._waitingFor;\n\t            return new DexiePromise(function (resolve, reject) {\n\t                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n\t                    if (root._waitingFor === currentWaitPromise) {\n\t                        root._waitingFor = null;\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        Transaction.prototype.abort = function () {\n\t            if (this.active) {\n\t                this.active = false;\n\t                if (this.idbtrans)\n\t                    this.idbtrans.abort();\n\t                this._reject(new exceptions.Abort());\n\t            }\n\t        };\n\t        Transaction.prototype.table = function (tableName) {\n\t            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n\t            if (hasOwn(memoizedTables, tableName))\n\t                return memoizedTables[tableName];\n\t            var tableSchema = this.schema[tableName];\n\t            if (!tableSchema) {\n\t                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n\t            }\n\t            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n\t            transactionBoundTable.core = this.db.core.table(tableName);\n\t            memoizedTables[tableName] = transactionBoundTable;\n\t            return transactionBoundTable;\n\t        };\n\t        return Transaction;\n\t    }());\n\n\t    function createTransactionConstructor(db) {\n\t        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n\t            var _this = this;\n\t            this.db = db;\n\t            this.mode = mode;\n\t            this.storeNames = storeNames;\n\t            this.schema = dbschema;\n\t            this.chromeTransactionDurability = chromeTransactionDurability;\n\t            this.idbtrans = null;\n\t            this.on = Events(this, \"complete\", \"error\", \"abort\");\n\t            this.parent = parent || null;\n\t            this.active = true;\n\t            this._reculock = 0;\n\t            this._blockedFuncs = [];\n\t            this._resolve = null;\n\t            this._reject = null;\n\t            this._waitingFor = null;\n\t            this._waitingQueue = null;\n\t            this._spinCount = 0;\n\t            this._completion = new DexiePromise(function (resolve, reject) {\n\t                _this._resolve = resolve;\n\t                _this._reject = reject;\n\t            });\n\t            this._completion.then(function () {\n\t                _this.active = false;\n\t                _this.on.complete.fire();\n\t            }, function (e) {\n\t                var wasActive = _this.active;\n\t                _this.active = false;\n\t                _this.on.error.fire(e);\n\t                _this.parent ?\n\t                    _this.parent._reject(e) :\n\t                    wasActive && _this.idbtrans && _this.idbtrans.abort();\n\t                return rejection(e);\n\t            });\n\t        });\n\t    }\n\n\t    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n\t        return {\n\t            name: name,\n\t            keyPath: keyPath,\n\t            unique: unique,\n\t            multi: multi,\n\t            auto: auto,\n\t            compound: compound,\n\t            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n\t        };\n\t    }\n\t    function nameFromKeyPath(keyPath) {\n\t        return typeof keyPath === 'string' ?\n\t            keyPath :\n\t            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n\t    }\n\n\t    function createTableSchema(name, primKey, indexes) {\n\t        return {\n\t            name: name,\n\t            primKey: primKey,\n\t            indexes: indexes,\n\t            mappedClass: null,\n\t            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })\n\t        };\n\t    }\n\n\t    function safariMultiStoreFix(storeNames) {\n\t        return storeNames.length === 1 ? storeNames[0] : storeNames;\n\t    }\n\t    var getMaxKey = function (IdbKeyRange) {\n\t        try {\n\t            IdbKeyRange.only([[]]);\n\t            getMaxKey = function () { return [[]]; };\n\t            return [[]];\n\t        }\n\t        catch (e) {\n\t            getMaxKey = function () { return maxString; };\n\t            return maxString;\n\t        }\n\t    };\n\n\t    function getKeyExtractor(keyPath) {\n\t        if (keyPath == null) {\n\t            return function () { return undefined; };\n\t        }\n\t        else if (typeof keyPath === 'string') {\n\t            return getSinglePathKeyExtractor(keyPath);\n\t        }\n\t        else {\n\t            return function (obj) { return getByKeyPath(obj, keyPath); };\n\t        }\n\t    }\n\t    function getSinglePathKeyExtractor(keyPath) {\n\t        var split = keyPath.split('.');\n\t        if (split.length === 1) {\n\t            return function (obj) { return obj[keyPath]; };\n\t        }\n\t        else {\n\t            return function (obj) { return getByKeyPath(obj, keyPath); };\n\t        }\n\t    }\n\n\t    function arrayify(arrayLike) {\n\t        return [].slice.call(arrayLike);\n\t    }\n\t    var _id_counter = 0;\n\t    function getKeyPathAlias(keyPath) {\n\t        return keyPath == null ?\n\t            \":id\" :\n\t            typeof keyPath === 'string' ?\n\t                keyPath :\n\t                \"[\".concat(keyPath.join('+'), \"]\");\n\t    }\n\t    function createDBCore(db, IdbKeyRange, tmpTrans) {\n\t        function extractSchema(db, trans) {\n\t            var tables = arrayify(db.objectStoreNames);\n\t            return {\n\t                schema: {\n\t                    name: db.name,\n\t                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n\t                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n\t                        var compound = isArray(keyPath);\n\t                        var outbound = keyPath == null;\n\t                        var indexByKeyPath = {};\n\t                        var result = {\n\t                            name: store.name,\n\t                            primaryKey: {\n\t                                name: null,\n\t                                isPrimaryKey: true,\n\t                                outbound: outbound,\n\t                                compound: compound,\n\t                                keyPath: keyPath,\n\t                                autoIncrement: autoIncrement,\n\t                                unique: true,\n\t                                extractKey: getKeyExtractor(keyPath)\n\t                            },\n\t                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n\t                                .map(function (index) {\n\t                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n\t                                var compound = isArray(keyPath);\n\t                                var result = {\n\t                                    name: name,\n\t                                    compound: compound,\n\t                                    keyPath: keyPath,\n\t                                    unique: unique,\n\t                                    multiEntry: multiEntry,\n\t                                    extractKey: getKeyExtractor(keyPath)\n\t                                };\n\t                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n\t                                return result;\n\t                            }),\n\t                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n\t                        };\n\t                        indexByKeyPath[\":id\"] = result.primaryKey;\n\t                        if (keyPath != null) {\n\t                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n\t                        }\n\t                        return result;\n\t                    })\n\t                },\n\t                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n\t                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n\t                        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n\t                        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n\t            };\n\t        }\n\t        function makeIDBKeyRange(range) {\n\t            if (range.type === 3 )\n\t                return null;\n\t            if (range.type === 4 )\n\t                throw new Error(\"Cannot convert never type to IDBKeyRange\");\n\t            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n\t            var idbRange = lower === undefined ?\n\t                upper === undefined ?\n\t                    null :\n\t                    IdbKeyRange.upperBound(upper, !!upperOpen) :\n\t                upper === undefined ?\n\t                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n\t                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n\t            return idbRange;\n\t        }\n\t        function createDbCoreTable(tableSchema) {\n\t            var tableName = tableSchema.name;\n\t            function mutate(_a) {\n\t                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n\t                return new Promise(function (resolve, reject) {\n\t                    resolve = wrap(resolve);\n\t                    var store = trans.objectStore(tableName);\n\t                    var outbound = store.keyPath == null;\n\t                    var isAddOrPut = type === \"put\" || type === \"add\";\n\t                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n\t                        throw new Error(\"Invalid operation type: \" + type);\n\t                    var length = (keys || values || { length: 1 }).length;\n\t                    if (keys && values && keys.length !== values.length) {\n\t                        throw new Error(\"Given keys array must have same length as given values array.\");\n\t                    }\n\t                    if (length === 0)\n\t                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n\t                    var req;\n\t                    var reqs = [];\n\t                    var failures = [];\n\t                    var numFailures = 0;\n\t                    var errorHandler = function (event) {\n\t                        ++numFailures;\n\t                        preventDefault(event);\n\t                    };\n\t                    if (type === 'deleteRange') {\n\t                        if (range.type === 4 )\n\t                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n\t                        if (range.type === 3 )\n\t                            reqs.push(req = store.clear());\n\t                        else\n\t                            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n\t                    }\n\t                    else {\n\t                        var _a = isAddOrPut ?\n\t                            outbound ?\n\t                                [values, keys] :\n\t                                [values, null] :\n\t                            [keys, null], args1 = _a[0], args2 = _a[1];\n\t                        if (isAddOrPut) {\n\t                            for (var i = 0; i < length; ++i) {\n\t                                reqs.push(req = (args2 && args2[i] !== undefined ?\n\t                                    store[type](args1[i], args2[i]) :\n\t                                    store[type](args1[i])));\n\t                                req.onerror = errorHandler;\n\t                            }\n\t                        }\n\t                        else {\n\t                            for (var i = 0; i < length; ++i) {\n\t                                reqs.push(req = store[type](args1[i]));\n\t                                req.onerror = errorHandler;\n\t                            }\n\t                        }\n\t                    }\n\t                    var done = function (event) {\n\t                        var lastResult = event.target.result;\n\t                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n\t                        resolve({\n\t                            numFailures: numFailures,\n\t                            failures: failures,\n\t                            results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n\t                            lastResult: lastResult\n\t                        });\n\t                    };\n\t                    req.onerror = function (event) {\n\t                        errorHandler(event);\n\t                        done(event);\n\t                    };\n\t                    req.onsuccess = done;\n\t                });\n\t            }\n\t            function openCursor(_a) {\n\t                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n\t                return new Promise(function (resolve, reject) {\n\t                    resolve = wrap(resolve);\n\t                    var index = query.index, range = query.range;\n\t                    var store = trans.objectStore(tableName);\n\t                    var source = index.isPrimaryKey ?\n\t                        store :\n\t                        store.index(index.name);\n\t                    var direction = reverse ?\n\t                        unique ?\n\t                            \"prevunique\" :\n\t                            \"prev\" :\n\t                        unique ?\n\t                            \"nextunique\" :\n\t                            \"next\";\n\t                    var req = values || !('openKeyCursor' in source) ?\n\t                        source.openCursor(makeIDBKeyRange(range), direction) :\n\t                        source.openKeyCursor(makeIDBKeyRange(range), direction);\n\t                    req.onerror = eventRejectHandler(reject);\n\t                    req.onsuccess = wrap(function (ev) {\n\t                        var cursor = req.result;\n\t                        if (!cursor) {\n\t                            resolve(null);\n\t                            return;\n\t                        }\n\t                        cursor.___id = ++_id_counter;\n\t                        cursor.done = false;\n\t                        var _cursorContinue = cursor.continue.bind(cursor);\n\t                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n\t                        if (_cursorContinuePrimaryKey)\n\t                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n\t                        var _cursorAdvance = cursor.advance.bind(cursor);\n\t                        var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n\t                        var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n\t                        cursor.trans = trans;\n\t                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n\t                        cursor.fail = wrap(reject);\n\t                        cursor.next = function () {\n\t                            var _this = this;\n\t                            var gotOne = 1;\n\t                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n\t                        };\n\t                        cursor.start = function (callback) {\n\t                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n\t                                resolveIteration = wrap(resolveIteration);\n\t                                req.onerror = eventRejectHandler(rejectIteration);\n\t                                cursor.fail = rejectIteration;\n\t                                cursor.stop = function (value) {\n\t                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n\t                                    resolveIteration(value);\n\t                                };\n\t                            });\n\t                            var guardedCallback = function () {\n\t                                if (req.result) {\n\t                                    try {\n\t                                        callback();\n\t                                    }\n\t                                    catch (err) {\n\t                                        cursor.fail(err);\n\t                                    }\n\t                                }\n\t                                else {\n\t                                    cursor.done = true;\n\t                                    cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n\t                                    cursor.stop();\n\t                                }\n\t                            };\n\t                            req.onsuccess = wrap(function (ev) {\n\t                                req.onsuccess = guardedCallback;\n\t                                guardedCallback();\n\t                            });\n\t                            cursor.continue = _cursorContinue;\n\t                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n\t                            cursor.advance = _cursorAdvance;\n\t                            guardedCallback();\n\t                            return iterationPromise;\n\t                        };\n\t                        resolve(cursor);\n\t                    }, reject);\n\t                });\n\t            }\n\t            function query(hasGetAll) {\n\t                return function (request) {\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n\t                        var nonInfinitLimit = limit === Infinity ? undefined : limit;\n\t                        var index = query.index, range = query.range;\n\t                        var store = trans.objectStore(tableName);\n\t                        var source = index.isPrimaryKey ? store : store.index(index.name);\n\t                        var idbKeyRange = makeIDBKeyRange(range);\n\t                        if (limit === 0)\n\t                            return resolve({ result: [] });\n\t                        if (hasGetAll) {\n\t                            var req = values ?\n\t                                source.getAll(idbKeyRange, nonInfinitLimit) :\n\t                                source.getAllKeys(idbKeyRange, nonInfinitLimit);\n\t                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n\t                            req.onerror = eventRejectHandler(reject);\n\t                        }\n\t                        else {\n\t                            var count_1 = 0;\n\t                            var req_1 = values || !('openKeyCursor' in source) ?\n\t                                source.openCursor(idbKeyRange) :\n\t                                source.openKeyCursor(idbKeyRange);\n\t                            var result_1 = [];\n\t                            req_1.onsuccess = function (event) {\n\t                                var cursor = req_1.result;\n\t                                if (!cursor)\n\t                                    return resolve({ result: result_1 });\n\t                                result_1.push(values ? cursor.value : cursor.primaryKey);\n\t                                if (++count_1 === limit)\n\t                                    return resolve({ result: result_1 });\n\t                                cursor.continue();\n\t                            };\n\t                            req_1.onerror = eventRejectHandler(reject);\n\t                        }\n\t                    });\n\t                };\n\t            }\n\t            return {\n\t                name: tableName,\n\t                schema: tableSchema,\n\t                mutate: mutate,\n\t                getMany: function (_a) {\n\t                    var trans = _a.trans, keys = _a.keys;\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var store = trans.objectStore(tableName);\n\t                        var length = keys.length;\n\t                        var result = new Array(length);\n\t                        var keyCount = 0;\n\t                        var callbackCount = 0;\n\t                        var req;\n\t                        var successHandler = function (event) {\n\t                            var req = event.target;\n\t                            if ((result[req._pos] = req.result) != null)\n\t                                ;\n\t                            if (++callbackCount === keyCount)\n\t                                resolve(result);\n\t                        };\n\t                        var errorHandler = eventRejectHandler(reject);\n\t                        for (var i = 0; i < length; ++i) {\n\t                            var key = keys[i];\n\t                            if (key != null) {\n\t                                req = store.get(keys[i]);\n\t                                req._pos = i;\n\t                                req.onsuccess = successHandler;\n\t                                req.onerror = errorHandler;\n\t                                ++keyCount;\n\t                            }\n\t                        }\n\t                        if (keyCount === 0)\n\t                            resolve(result);\n\t                    });\n\t                },\n\t                get: function (_a) {\n\t                    var trans = _a.trans, key = _a.key;\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var store = trans.objectStore(tableName);\n\t                        var req = store.get(key);\n\t                        req.onsuccess = function (event) { return resolve(event.target.result); };\n\t                        req.onerror = eventRejectHandler(reject);\n\t                    });\n\t                },\n\t                query: query(hasGetAll),\n\t                openCursor: openCursor,\n\t                count: function (_a) {\n\t                    var query = _a.query, trans = _a.trans;\n\t                    var index = query.index, range = query.range;\n\t                    return new Promise(function (resolve, reject) {\n\t                        var store = trans.objectStore(tableName);\n\t                        var source = index.isPrimaryKey ? store : store.index(index.name);\n\t                        var idbKeyRange = makeIDBKeyRange(range);\n\t                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n\t                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n\t                        req.onerror = eventRejectHandler(reject);\n\t                    });\n\t                }\n\t            };\n\t        }\n\t        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n\t        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n\t        var tableMap = {};\n\t        tables.forEach(function (table) { return tableMap[table.name] = table; });\n\t        return {\n\t            stack: \"dbcore\",\n\t            transaction: db.transaction.bind(db),\n\t            table: function (name) {\n\t                var result = tableMap[name];\n\t                if (!result)\n\t                    throw new Error(\"Table '\".concat(name, \"' not found\"));\n\t                return tableMap[name];\n\t            },\n\t            MIN_KEY: -Infinity,\n\t            MAX_KEY: getMaxKey(IdbKeyRange),\n\t            schema: schema\n\t        };\n\t    }\n\n\t    function createMiddlewareStack(stackImpl, middlewares) {\n\t        return middlewares.reduce(function (down, _a) {\n\t            var create = _a.create;\n\t            return (__assign(__assign({}, down), create(down)));\n\t        }, stackImpl);\n\t    }\n\t    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n\t        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n\t        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n\t        return {\n\t            dbcore: dbcore\n\t        };\n\t    }\n\t    function generateMiddlewareStacks(db, tmpTrans) {\n\t        var idbdb = tmpTrans.db;\n\t        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n\t        db.core = stacks.dbcore;\n\t        db.tables.forEach(function (table) {\n\t            var tableName = table.name;\n\t            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n\t                table.core = db.core.table(tableName);\n\t                if (db[tableName] instanceof db.Table) {\n\t                    db[tableName].core = table.core;\n\t                }\n\t            }\n\t        });\n\t    }\n\n\t    function setApiOnPlace(db, objs, tableNames, dbschema) {\n\t        tableNames.forEach(function (tableName) {\n\t            var schema = dbschema[tableName];\n\t            objs.forEach(function (obj) {\n\t                var propDesc = getPropertyDescriptor(obj, tableName);\n\t                if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n\t                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n\t                        setProp(obj, tableName, {\n\t                            get: function () { return this.table(tableName); },\n\t                            set: function (value) {\n\t                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n\t                            }\n\t                        });\n\t                    }\n\t                    else {\n\t                        obj[tableName] = new db.Table(tableName, schema);\n\t                    }\n\t                }\n\t            });\n\t        });\n\t    }\n\t    function removeTablesApi(db, objs) {\n\t        objs.forEach(function (obj) {\n\t            for (var key in obj) {\n\t                if (obj[key] instanceof db.Table)\n\t                    delete obj[key];\n\t            }\n\t        });\n\t    }\n\t    function lowerVersionFirst(a, b) {\n\t        return a._cfg.version - b._cfg.version;\n\t    }\n\t    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n\t        var globalSchema = db._dbSchema;\n\t        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n\t            globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n\t            db._storeNames.push('$meta');\n\t        }\n\t        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n\t        trans.create(idbUpgradeTrans);\n\t        trans._completion.catch(reject);\n\t        var rejectTransaction = trans._reject.bind(trans);\n\t        var transless = PSD.transless || PSD;\n\t        newScope(function () {\n\t            PSD.trans = trans;\n\t            PSD.transless = transless;\n\t            if (oldVersion === 0) {\n\t                keys(globalSchema).forEach(function (tableName) {\n\t                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n\t                });\n\t                generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n\t            }\n\t            else {\n\t                generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                return getExistingVersion(db, trans, oldVersion)\n\t                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n\t                    .catch(rejectTransaction);\n\t            }\n\t        });\n\t    }\n\t    function patchCurrentVersion(db, idbUpgradeTrans) {\n\t        createMissingTables(db._dbSchema, idbUpgradeTrans);\n\t        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n\t            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n\t        }\n\t        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n\t        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n\t        var diff = getSchemaDiff(globalSchema, db._dbSchema);\n\t        var _loop_1 = function (tableChange) {\n\t            if (tableChange.change.length || tableChange.recreate) {\n\t                console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n\t                return { value: void 0 };\n\t            }\n\t            var store = idbUpgradeTrans.objectStore(tableChange.name);\n\t            tableChange.add.forEach(function (idx) {\n\t                if (debug)\n\t                    console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n\t                addIndex(store, idx);\n\t            });\n\t        };\n\t        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n\t            var tableChange = _a[_i];\n\t            var state_1 = _loop_1(tableChange);\n\t            if (typeof state_1 === \"object\")\n\t                return state_1.value;\n\t        }\n\t    }\n\t    function getExistingVersion(db, trans, oldVersion) {\n\t        if (trans.storeNames.includes('$meta')) {\n\t            return trans.table('$meta').get('version').then(function (metaVersion) {\n\t                return metaVersion != null ? metaVersion : oldVersion;\n\t            });\n\t        }\n\t        else {\n\t            return DexiePromise.resolve(oldVersion);\n\t        }\n\t    }\n\t    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n\t        var queue = [];\n\t        var versions = db._versions;\n\t        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n\t        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n\t        if (versToRun.length === 0) {\n\t            return DexiePromise.resolve();\n\t        }\n\t        versToRun.forEach(function (version) {\n\t            queue.push(function () {\n\t                var oldSchema = globalSchema;\n\t                var newSchema = version._cfg.dbschema;\n\t                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n\t                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n\t                globalSchema = db._dbSchema = newSchema;\n\t                var diff = getSchemaDiff(oldSchema, newSchema);\n\t                diff.add.forEach(function (tuple) {\n\t                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n\t                });\n\t                diff.change.forEach(function (change) {\n\t                    if (change.recreate) {\n\t                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n\t                    }\n\t                    else {\n\t                        var store_1 = idbUpgradeTrans.objectStore(change.name);\n\t                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n\t                        change.change.forEach(function (idx) {\n\t                            store_1.deleteIndex(idx.name);\n\t                            addIndex(store_1, idx);\n\t                        });\n\t                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n\t                    }\n\t                });\n\t                var contentUpgrade = version._cfg.contentUpgrade;\n\t                if (contentUpgrade && version._cfg.version > oldVersion) {\n\t                    generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                    trans._memoizedTables = {};\n\t                    var upgradeSchema_1 = shallowClone(newSchema);\n\t                    diff.del.forEach(function (table) {\n\t                        upgradeSchema_1[table] = oldSchema[table];\n\t                    });\n\t                    removeTablesApi(db, [db.Transaction.prototype]);\n\t                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n\t                    trans.schema = upgradeSchema_1;\n\t                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n\t                    if (contentUpgradeIsAsync_1) {\n\t                        incrementExpectedAwaits();\n\t                    }\n\t                    var returnValue_1;\n\t                    var promiseFollowed = DexiePromise.follow(function () {\n\t                        returnValue_1 = contentUpgrade(trans);\n\t                        if (returnValue_1) {\n\t                            if (contentUpgradeIsAsync_1) {\n\t                                var decrementor = decrementExpectedAwaits.bind(null, null);\n\t                                returnValue_1.then(decrementor, decrementor);\n\t                            }\n\t                        }\n\t                    });\n\t                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n\t                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n\t                }\n\t            });\n\t            queue.push(function (idbtrans) {\n\t                var newSchema = version._cfg.dbschema;\n\t                deleteRemovedTables(newSchema, idbtrans);\n\t                removeTablesApi(db, [db.Transaction.prototype]);\n\t                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n\t                trans.schema = db._dbSchema;\n\t            });\n\t            queue.push(function (idbtrans) {\n\t                if (db.idbdb.objectStoreNames.contains('$meta')) {\n\t                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n\t                        db.idbdb.deleteObjectStore('$meta');\n\t                        delete db._dbSchema.$meta;\n\t                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n\t                    }\n\t                    else {\n\t                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n\t                    }\n\t                }\n\t            });\n\t        });\n\t        function runQueue() {\n\t            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n\t                DexiePromise.resolve();\n\t        }\n\t        return runQueue().then(function () {\n\t            createMissingTables(globalSchema, idbUpgradeTrans);\n\t        });\n\t    }\n\t    function getSchemaDiff(oldSchema, newSchema) {\n\t        var diff = {\n\t            del: [],\n\t            add: [],\n\t            change: []\n\t        };\n\t        var table;\n\t        for (table in oldSchema) {\n\t            if (!newSchema[table])\n\t                diff.del.push(table);\n\t        }\n\t        for (table in newSchema) {\n\t            var oldDef = oldSchema[table], newDef = newSchema[table];\n\t            if (!oldDef) {\n\t                diff.add.push([table, newDef]);\n\t            }\n\t            else {\n\t                var change = {\n\t                    name: table,\n\t                    def: newDef,\n\t                    recreate: false,\n\t                    del: [],\n\t                    add: [],\n\t                    change: []\n\t                };\n\t                if ((\n\t                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n\t                    (oldDef.primKey.auto !== newDef.primKey.auto)) {\n\t                    change.recreate = true;\n\t                    diff.change.push(change);\n\t                }\n\t                else {\n\t                    var oldIndexes = oldDef.idxByName;\n\t                    var newIndexes = newDef.idxByName;\n\t                    var idxName = void 0;\n\t                    for (idxName in oldIndexes) {\n\t                        if (!newIndexes[idxName])\n\t                            change.del.push(idxName);\n\t                    }\n\t                    for (idxName in newIndexes) {\n\t                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n\t                        if (!oldIdx)\n\t                            change.add.push(newIdx);\n\t                        else if (oldIdx.src !== newIdx.src)\n\t                            change.change.push(newIdx);\n\t                    }\n\t                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n\t                        diff.change.push(change);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return diff;\n\t    }\n\t    function createTable(idbtrans, tableName, primKey, indexes) {\n\t        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n\t            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n\t            { autoIncrement: primKey.auto });\n\t        indexes.forEach(function (idx) { return addIndex(store, idx); });\n\t        return store;\n\t    }\n\t    function createMissingTables(newSchema, idbtrans) {\n\t        keys(newSchema).forEach(function (tableName) {\n\t            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n\t                if (debug)\n\t                    console.debug('Dexie: Creating missing table', tableName);\n\t                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n\t            }\n\t        });\n\t    }\n\t    function deleteRemovedTables(newSchema, idbtrans) {\n\t        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n\t            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n\t        });\n\t    }\n\t    function addIndex(store, idx) {\n\t        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n\t    }\n\t    function buildGlobalSchema(db, idbdb, tmpTrans) {\n\t        var globalSchema = {};\n\t        var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n\t        dbStoreNames.forEach(function (storeName) {\n\t            var store = tmpTrans.objectStore(storeName);\n\t            var keyPath = store.keyPath;\n\t            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n\t            var indexes = [];\n\t            for (var j = 0; j < store.indexNames.length; ++j) {\n\t                var idbindex = store.index(store.indexNames[j]);\n\t                keyPath = idbindex.keyPath;\n\t                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n\t                indexes.push(index);\n\t            }\n\t            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n\t        });\n\t        return globalSchema;\n\t    }\n\t    function readGlobalSchema(db, idbdb, tmpTrans) {\n\t        db.verno = idbdb.version / 10;\n\t        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n\t        db._storeNames = slice(idbdb.objectStoreNames, 0);\n\t        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n\t    }\n\t    function verifyInstalledSchema(db, tmpTrans) {\n\t        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n\t        var diff = getSchemaDiff(installedSchema, db._dbSchema);\n\t        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n\t    }\n\t    function adjustToExistingIndexNames(db, schema, idbtrans) {\n\t        var storeNames = idbtrans.db.objectStoreNames;\n\t        for (var i = 0; i < storeNames.length; ++i) {\n\t            var storeName = storeNames[i];\n\t            var store = idbtrans.objectStore(storeName);\n\t            db._hasGetAll = 'getAll' in store;\n\t            for (var j = 0; j < store.indexNames.length; ++j) {\n\t                var indexName = store.indexNames[j];\n\t                var keyPath = store.index(indexName).keyPath;\n\t                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n\t                if (schema[storeName]) {\n\t                    var indexSpec = schema[storeName].idxByName[dexieName];\n\t                    if (indexSpec) {\n\t                        indexSpec.name = indexName;\n\t                        delete schema[storeName].idxByName[dexieName];\n\t                        schema[storeName].idxByName[indexName] = indexSpec;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n\t            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n\t            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n\t            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n\t            db._hasGetAll = false;\n\t        }\n\t    }\n\t    function parseIndexSyntax(primKeyAndIndexes) {\n\t        return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n\t            index = index.trim();\n\t            var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n\t            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n\t            return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n\t        });\n\t    }\n\n\t    var Version =  (function () {\n\t        function Version() {\n\t        }\n\t        Version.prototype._parseStoresSpec = function (stores, outSchema) {\n\t            keys(stores).forEach(function (tableName) {\n\t                if (stores[tableName] !== null) {\n\t                    var indexes = parseIndexSyntax(stores[tableName]);\n\t                    var primKey = indexes.shift();\n\t                    primKey.unique = true;\n\t                    if (primKey.multi)\n\t                        throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n\t                    indexes.forEach(function (idx) {\n\t                        if (idx.auto)\n\t                            throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n\t                        if (!idx.keyPath)\n\t                            throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n\t                    });\n\t                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n\t                }\n\t            });\n\t        };\n\t        Version.prototype.stores = function (stores) {\n\t            var db = this.db;\n\t            this._cfg.storesSource = this._cfg.storesSource ?\n\t                extend(this._cfg.storesSource, stores) :\n\t                stores;\n\t            var versions = db._versions;\n\t            var storesSpec = {};\n\t            var dbschema = {};\n\t            versions.forEach(function (version) {\n\t                extend(storesSpec, version._cfg.storesSource);\n\t                dbschema = (version._cfg.dbschema = {});\n\t                version._parseStoresSpec(storesSpec, dbschema);\n\t            });\n\t            db._dbSchema = dbschema;\n\t            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n\t            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n\t            db._storeNames = keys(dbschema);\n\t            return this;\n\t        };\n\t        Version.prototype.upgrade = function (upgradeFunction) {\n\t            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n\t            return this;\n\t        };\n\t        return Version;\n\t    }());\n\n\t    function createVersionConstructor(db) {\n\t        return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n\t            this.db = db;\n\t            this._cfg = {\n\t                version: versionNumber,\n\t                storesSource: null,\n\t                dbschema: {},\n\t                tables: {},\n\t                contentUpgrade: null\n\t            };\n\t        });\n\t    }\n\n\t    function getDbNamesTable(indexedDB, IDBKeyRange) {\n\t        var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n\t        if (!dbNamesDB) {\n\t            dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n\t                addons: [],\n\t                indexedDB: indexedDB,\n\t                IDBKeyRange: IDBKeyRange,\n\t            });\n\t            dbNamesDB.version(1).stores({ dbnames: \"name\" });\n\t        }\n\t        return dbNamesDB.table(\"dbnames\");\n\t    }\n\t    function hasDatabasesNative(indexedDB) {\n\t        return indexedDB && typeof indexedDB.databases === \"function\";\n\t    }\n\t    function getDatabaseNames(_a) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        return hasDatabasesNative(indexedDB)\n\t            ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n\t                return infos\n\t                    .map(function (info) { return info.name; })\n\t                    .filter(function (name) { return name !== DBNAMES_DB; });\n\t            })\n\t            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n\t    }\n\t    function _onDatabaseCreated(_a, name) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        !hasDatabasesNative(indexedDB) &&\n\t            name !== DBNAMES_DB &&\n\t            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n\t    }\n\t    function _onDatabaseDeleted(_a, name) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        !hasDatabasesNative(indexedDB) &&\n\t            name !== DBNAMES_DB &&\n\t            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n\t    }\n\n\t    function vip(fn) {\n\t        return newScope(function () {\n\t            PSD.letThrough = true;\n\t            return fn();\n\t        });\n\t    }\n\n\t    function idbReady() {\n\t        var isSafari = !navigator.userAgentData &&\n\t            /Safari\\//.test(navigator.userAgent) &&\n\t            !/Chrom(e|ium)\\//.test(navigator.userAgent);\n\t        if (!isSafari || !indexedDB.databases)\n\t            return Promise.resolve();\n\t        var intervalId;\n\t        return new Promise(function (resolve) {\n\t            var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n\t            intervalId = setInterval(tryIdb, 100);\n\t            tryIdb();\n\t        }).finally(function () { return clearInterval(intervalId); });\n\t    }\n\n\t    var _a;\n\t    function isEmptyRange(node) {\n\t        return !(\"from\" in node);\n\t    }\n\t    var RangeSet = function (fromOrTree, to) {\n\t        if (this) {\n\t            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n\t        }\n\t        else {\n\t            var rv = new RangeSet();\n\t            if (fromOrTree && (\"d\" in fromOrTree)) {\n\t                extend(rv, fromOrTree);\n\t            }\n\t            return rv;\n\t        }\n\t    };\n\t    props(RangeSet.prototype, (_a = {\n\t            add: function (rangeSet) {\n\t                mergeRanges(this, rangeSet);\n\t                return this;\n\t            },\n\t            addKey: function (key) {\n\t                addRange(this, key, key);\n\t                return this;\n\t            },\n\t            addKeys: function (keys) {\n\t                var _this = this;\n\t                keys.forEach(function (key) { return addRange(_this, key, key); });\n\t                return this;\n\t            },\n\t            hasKey: function (key) {\n\t                var node = getRangeSetIterator(this).next(key).value;\n\t                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n\t            }\n\t        },\n\t        _a[iteratorSymbol] = function () {\n\t            return getRangeSetIterator(this);\n\t        },\n\t        _a));\n\t    function addRange(target, from, to) {\n\t        var diff = cmp(from, to);\n\t        if (isNaN(diff))\n\t            return;\n\t        if (diff > 0)\n\t            throw RangeError();\n\t        if (isEmptyRange(target))\n\t            return extend(target, { from: from, to: to, d: 1 });\n\t        var left = target.l;\n\t        var right = target.r;\n\t        if (cmp(to, target.from) < 0) {\n\t            left\n\t                ? addRange(left, from, to)\n\t                : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n\t            return rebalance(target);\n\t        }\n\t        if (cmp(from, target.to) > 0) {\n\t            right\n\t                ? addRange(right, from, to)\n\t                : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n\t            return rebalance(target);\n\t        }\n\t        if (cmp(from, target.from) < 0) {\n\t            target.from = from;\n\t            target.l = null;\n\t            target.d = right ? right.d + 1 : 1;\n\t        }\n\t        if (cmp(to, target.to) > 0) {\n\t            target.to = to;\n\t            target.r = null;\n\t            target.d = target.l ? target.l.d + 1 : 1;\n\t        }\n\t        var rightWasCutOff = !target.r;\n\t        if (left && !target.l) {\n\t            mergeRanges(target, left);\n\t        }\n\t        if (right && rightWasCutOff) {\n\t            mergeRanges(target, right);\n\t        }\n\t    }\n\t    function mergeRanges(target, newSet) {\n\t        function _addRangeSet(target, _a) {\n\t            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n\t            addRange(target, from, to);\n\t            if (l)\n\t                _addRangeSet(target, l);\n\t            if (r)\n\t                _addRangeSet(target, r);\n\t        }\n\t        if (!isEmptyRange(newSet))\n\t            _addRangeSet(target, newSet);\n\t    }\n\t    function rangesOverlap(rangeSet1, rangeSet2) {\n\t        var i1 = getRangeSetIterator(rangeSet2);\n\t        var nextResult1 = i1.next();\n\t        if (nextResult1.done)\n\t            return false;\n\t        var a = nextResult1.value;\n\t        var i2 = getRangeSetIterator(rangeSet1);\n\t        var nextResult2 = i2.next(a.from);\n\t        var b = nextResult2.value;\n\t        while (!nextResult1.done && !nextResult2.done) {\n\t            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n\t                return true;\n\t            cmp(a.from, b.from) < 0\n\t                ? (a = (nextResult1 = i1.next(b.from)).value)\n\t                : (b = (nextResult2 = i2.next(a.from)).value);\n\t        }\n\t        return false;\n\t    }\n\t    function getRangeSetIterator(node) {\n\t        var state = isEmptyRange(node) ? null : { s: 0, n: node };\n\t        return {\n\t            next: function (key) {\n\t                var keyProvided = arguments.length > 0;\n\t                while (state) {\n\t                    switch (state.s) {\n\t                        case 0:\n\t                            state.s = 1;\n\t                            if (keyProvided) {\n\t                                while (state.n.l && cmp(key, state.n.from) < 0)\n\t                                    state = { up: state, n: state.n.l, s: 1 };\n\t                            }\n\t                            else {\n\t                                while (state.n.l)\n\t                                    state = { up: state, n: state.n.l, s: 1 };\n\t                            }\n\t                        case 1:\n\t                            state.s = 2;\n\t                            if (!keyProvided || cmp(key, state.n.to) <= 0)\n\t                                return { value: state.n, done: false };\n\t                        case 2:\n\t                            if (state.n.r) {\n\t                                state.s = 3;\n\t                                state = { up: state, n: state.n.r, s: 0 };\n\t                                continue;\n\t                            }\n\t                        case 3:\n\t                            state = state.up;\n\t                    }\n\t                }\n\t                return { done: true };\n\t            },\n\t        };\n\t    }\n\t    function rebalance(target) {\n\t        var _a, _b;\n\t        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n\t        var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n\t        if (r) {\n\t            var l = r === \"r\" ? \"l\" : \"r\";\n\t            var rootClone = __assign({}, target);\n\t            var oldRootRight = target[r];\n\t            target.from = oldRootRight.from;\n\t            target.to = oldRootRight.to;\n\t            target[r] = oldRootRight[r];\n\t            rootClone[r] = oldRootRight[l];\n\t            target[l] = rootClone;\n\t            rootClone.d = computeDepth(rootClone);\n\t        }\n\t        target.d = computeDepth(target);\n\t    }\n\t    function computeDepth(_a) {\n\t        var r = _a.r, l = _a.l;\n\t        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n\t    }\n\n\t    function extendObservabilitySet(target, newSet) {\n\t        keys(newSet).forEach(function (part) {\n\t            if (target[part])\n\t                mergeRanges(target[part], newSet[part]);\n\t            else\n\t                target[part] = cloneSimpleObjectTree(newSet[part]);\n\t        });\n\t        return target;\n\t    }\n\n\t    function obsSetsOverlap(os1, os2) {\n\t        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n\t    }\n\n\t    var cache = {};\n\n\t    var unsignaledParts = {};\n\t    var isTaskEnqueued = false;\n\t    function signalSubscribersLazily(part, optimistic) {\n\t        extendObservabilitySet(unsignaledParts, part);\n\t        if (!isTaskEnqueued) {\n\t            isTaskEnqueued = true;\n\t            setTimeout(function () {\n\t                isTaskEnqueued = false;\n\t                var parts = unsignaledParts;\n\t                unsignaledParts = {};\n\t                signalSubscribersNow(parts, false);\n\t            }, 0);\n\t        }\n\t    }\n\t    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n\t        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n\t        var queriesToSignal = new Set();\n\t        if (updatedParts.all) {\n\t            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n\t                var tblCache = _a[_i];\n\t                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in updatedParts) {\n\t                var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n\t                if (parts) {\n\t                    var dbName = parts[1], tableName = parts[2];\n\t                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t                    if (tblCache)\n\t                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n\t                }\n\t            }\n\t        }\n\t        queriesToSignal.forEach(function (requery) { return requery(); });\n\t    }\n\t    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n\t        var updatedEntryLists = [];\n\t        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n\t            var _b = _a[_i], indexName = _b[0], entries = _b[1];\n\t            var filteredEntries = [];\n\t            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n\t                var entry = entries_1[_c];\n\t                if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n\t                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n\t                }\n\t                else if (deleteAffectedCacheEntries) {\n\t                    filteredEntries.push(entry);\n\t                }\n\t            }\n\t            if (deleteAffectedCacheEntries)\n\t                updatedEntryLists.push([indexName, filteredEntries]);\n\t        }\n\t        if (deleteAffectedCacheEntries) {\n\t            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n\t                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n\t                tblCache.queries.query[indexName] = filteredEntries;\n\t            }\n\t        }\n\t    }\n\n\t    function dexieOpen(db) {\n\t        var state = db._state;\n\t        var indexedDB = db._deps.indexedDB;\n\t        if (state.isBeingOpened || db.idbdb)\n\t            return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n\t                rejection(state.dbOpenError) :\n\t                db; });\n\t        state.isBeingOpened = true;\n\t        state.dbOpenError = null;\n\t        state.openComplete = false;\n\t        var openCanceller = state.openCanceller;\n\t        var nativeVerToOpen = Math.round(db.verno * 10);\n\t        var schemaPatchMode = false;\n\t        function throwIfCancelled() {\n\t            if (state.openCanceller !== openCanceller)\n\t                throw new exceptions.DatabaseClosed('db.open() was cancelled');\n\t        }\n\t        var resolveDbReady = state.dbReadyResolve,\n\t        upgradeTransaction = null, wasCreated = false;\n\t        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n\t            throwIfCancelled();\n\t            if (!indexedDB)\n\t                throw new exceptions.MissingAPI();\n\t            var dbName = db.name;\n\t            var req = state.autoSchema || !nativeVerToOpen ?\n\t                indexedDB.open(dbName) :\n\t                indexedDB.open(dbName, nativeVerToOpen);\n\t            if (!req)\n\t                throw new exceptions.MissingAPI();\n\t            req.onerror = eventRejectHandler(reject);\n\t            req.onblocked = wrap(db._fireOnBlocked);\n\t            req.onupgradeneeded = wrap(function (e) {\n\t                upgradeTransaction = req.transaction;\n\t                if (state.autoSchema && !db._options.allowEmptyDB) {\n\t                    req.onerror = preventDefault;\n\t                    upgradeTransaction.abort();\n\t                    req.result.close();\n\t                    var delreq = indexedDB.deleteDatabase(dbName);\n\t                    delreq.onsuccess = delreq.onerror = wrap(function () {\n\t                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n\t                    });\n\t                }\n\t                else {\n\t                    upgradeTransaction.onerror = eventRejectHandler(reject);\n\t                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n\t                    wasCreated = oldVer < 1;\n\t                    db.idbdb = req.result;\n\t                    if (schemaPatchMode) {\n\t                        patchCurrentVersion(db, upgradeTransaction);\n\t                    }\n\t                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n\t                }\n\t            }, reject);\n\t            req.onsuccess = wrap(function () {\n\t                upgradeTransaction = null;\n\t                var idbdb = db.idbdb = req.result;\n\t                var objectStoreNames = slice(idbdb.objectStoreNames);\n\t                if (objectStoreNames.length > 0)\n\t                    try {\n\t                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n\t                        if (state.autoSchema)\n\t                            readGlobalSchema(db, idbdb, tmpTrans);\n\t                        else {\n\t                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n\t                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n\t                                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n\t                                idbdb.close();\n\t                                nativeVerToOpen = idbdb.version + 1;\n\t                                schemaPatchMode = true;\n\t                                return resolve(tryOpenDB());\n\t                            }\n\t                        }\n\t                        generateMiddlewareStacks(db, tmpTrans);\n\t                    }\n\t                    catch (e) {\n\t                    }\n\t                connections.push(db);\n\t                idbdb.onversionchange = wrap(function (ev) {\n\t                    state.vcFired = true;\n\t                    db.on(\"versionchange\").fire(ev);\n\t                });\n\t                idbdb.onclose = wrap(function (ev) {\n\t                    db.on(\"close\").fire(ev);\n\t                });\n\t                if (wasCreated)\n\t                    _onDatabaseCreated(db._deps, dbName);\n\t                resolve();\n\t            }, reject);\n\t        }).catch(function (err) {\n\t            switch (err === null || err === void 0 ? void 0 : err.name) {\n\t                case \"UnknownError\":\n\t                    if (state.PR1398_maxLoop > 0) {\n\t                        state.PR1398_maxLoop--;\n\t                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n\t                        return tryOpenDB();\n\t                    }\n\t                    break;\n\t                case \"VersionError\":\n\t                    if (nativeVerToOpen > 0) {\n\t                        nativeVerToOpen = 0;\n\t                        return tryOpenDB();\n\t                    }\n\t                    break;\n\t            }\n\t            return DexiePromise.reject(err);\n\t        }); };\n\t        return DexiePromise.race([\n\t            openCanceller,\n\t            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n\t        ]).then(function () {\n\t            throwIfCancelled();\n\t            state.onReadyBeingFired = [];\n\t            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n\t                if (state.onReadyBeingFired.length > 0) {\n\t                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n\t                    state.onReadyBeingFired = [];\n\t                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n\t                }\n\t            });\n\t        }).finally(function () {\n\t            if (state.openCanceller === openCanceller) {\n\t                state.onReadyBeingFired = null;\n\t                state.isBeingOpened = false;\n\t            }\n\t        }).catch(function (err) {\n\t            state.dbOpenError = err;\n\t            try {\n\t                upgradeTransaction && upgradeTransaction.abort();\n\t            }\n\t            catch (_a) { }\n\t            if (openCanceller === state.openCanceller) {\n\t                db._close();\n\t            }\n\t            return rejection(err);\n\t        }).finally(function () {\n\t            state.openComplete = true;\n\t            resolveDbReady();\n\t        }).then(function () {\n\t            if (wasCreated) {\n\t                var everything_1 = {};\n\t                db.tables.forEach(function (table) {\n\t                    table.schema.indexes.forEach(function (idx) {\n\t                        if (idx.name)\n\t                            everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n\t                    });\n\t                    everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n\t                });\n\t                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n\t                signalSubscribersNow(everything_1, true);\n\t            }\n\t            return db;\n\t        });\n\t    }\n\n\t    function awaitIterator(iterator) {\n\t        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n\t        function step(getNext) {\n\t            return function (val) {\n\t                var next = getNext(val), value = next.value;\n\t                return next.done ? value :\n\t                    (!value || typeof value.then !== 'function' ?\n\t                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n\t                        value.then(onSuccess, onError));\n\t            };\n\t        }\n\t        return step(callNext)();\n\t    }\n\n\t    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n\t        var i = arguments.length;\n\t        if (i < 2)\n\t            throw new exceptions.InvalidArgument(\"Too few arguments\");\n\t        var args = new Array(i - 1);\n\t        while (--i)\n\t            args[i - 1] = arguments[i];\n\t        scopeFunc = args.pop();\n\t        var tables = flatten(args);\n\t        return [mode, tables, scopeFunc];\n\t    }\n\t    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n\t        return DexiePromise.resolve().then(function () {\n\t            var transless = PSD.transless || PSD;\n\t            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n\t            trans.explicit = true;\n\t            var zoneProps = {\n\t                trans: trans,\n\t                transless: transless\n\t            };\n\t            if (parentTransaction) {\n\t                trans.idbtrans = parentTransaction.idbtrans;\n\t            }\n\t            else {\n\t                try {\n\t                    trans.create();\n\t                    trans.idbtrans._explicit = true;\n\t                    db._state.PR1398_maxLoop = 3;\n\t                }\n\t                catch (ex) {\n\t                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n\t                        console.warn('Dexie: Need to reopen db');\n\t                        db.close({ disableAutoOpen: false });\n\t                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n\t                    }\n\t                    return rejection(ex);\n\t                }\n\t            }\n\t            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n\t            if (scopeFuncIsAsync) {\n\t                incrementExpectedAwaits();\n\t            }\n\t            var returnValue;\n\t            var promiseFollowed = DexiePromise.follow(function () {\n\t                returnValue = scopeFunc.call(trans, trans);\n\t                if (returnValue) {\n\t                    if (scopeFuncIsAsync) {\n\t                        var decrementor = decrementExpectedAwaits.bind(null, null);\n\t                        returnValue.then(decrementor, decrementor);\n\t                    }\n\t                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n\t                        returnValue = awaitIterator(returnValue);\n\t                    }\n\t                }\n\t            }, zoneProps);\n\t            return (returnValue && typeof returnValue.then === 'function' ?\n\t                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n\t                    x\n\t                    : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n\t                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n\t                if (parentTransaction)\n\t                    trans._resolve();\n\t                return trans._completion.then(function () { return x; });\n\t            }).catch(function (e) {\n\t                trans._reject(e);\n\t                return rejection(e);\n\t            });\n\t        });\n\t    }\n\n\t    function pad(a, value, count) {\n\t        var result = isArray(a) ? a.slice() : [a];\n\t        for (var i = 0; i < count; ++i)\n\t            result.push(value);\n\t        return result;\n\t    }\n\t    function createVirtualIndexMiddleware(down) {\n\t        return __assign(__assign({}, down), { table: function (tableName) {\n\t                var table = down.table(tableName);\n\t                var schema = table.schema;\n\t                var indexLookup = {};\n\t                var allVirtualIndexes = [];\n\t                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n\t                    var keyPathAlias = getKeyPathAlias(keyPath);\n\t                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n\t                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n\t                    var isVirtual = keyTail > 0;\n\t                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n\t                            ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n\t                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n\t                    indexList.push(virtualIndex);\n\t                    if (!virtualIndex.isPrimaryKey) {\n\t                        allVirtualIndexes.push(virtualIndex);\n\t                    }\n\t                    if (keyLength > 1) {\n\t                        var virtualKeyPath = keyLength === 2 ?\n\t                            keyPath[0] :\n\t                            keyPath.slice(0, keyLength - 1);\n\t                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n\t                    }\n\t                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n\t                    return virtualIndex;\n\t                }\n\t                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n\t                indexLookup[\":id\"] = [primaryKey];\n\t                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n\t                    var index = _a[_i];\n\t                    addVirtualIndexes(index.keyPath, 0, index);\n\t                }\n\t                function findBestIndex(keyPath) {\n\t                    var result = indexLookup[getKeyPathAlias(keyPath)];\n\t                    return result && result[0];\n\t                }\n\t                function translateRange(range, keyTail) {\n\t                    return {\n\t                        type: range.type === 1  ?\n\t                            2  :\n\t                            range.type,\n\t                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n\t                        lowerOpen: true,\n\t                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n\t                        upperOpen: true\n\t                    };\n\t                }\n\t                function translateRequest(req) {\n\t                    var index = req.query.index;\n\t                    return index.isVirtual ? __assign(__assign({}, req), { query: {\n\t                            index: index.lowLevelIndex,\n\t                            range: translateRange(req.query.range, index.keyTail)\n\t                        } }) : req;\n\t                }\n\t                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n\t                        return table.count(translateRequest(req));\n\t                    }, query: function (req) {\n\t                        return table.query(translateRequest(req));\n\t                    }, openCursor: function (req) {\n\t                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n\t                        if (!isVirtual)\n\t                            return table.openCursor(req);\n\t                        function createVirtualCursor(cursor) {\n\t                            function _continue(key) {\n\t                                key != null ?\n\t                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n\t                                    req.unique ?\n\t                                        cursor.continue(cursor.key.slice(0, keyLength)\n\t                                            .concat(req.reverse\n\t                                            ? down.MIN_KEY\n\t                                            : down.MAX_KEY, keyTail)) :\n\t                                        cursor.continue();\n\t                            }\n\t                            var virtualCursor = Object.create(cursor, {\n\t                                continue: { value: _continue },\n\t                                continuePrimaryKey: {\n\t                                    value: function (key, primaryKey) {\n\t                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n\t                                    }\n\t                                },\n\t                                primaryKey: {\n\t                                    get: function () {\n\t                                        return cursor.primaryKey;\n\t                                    }\n\t                                },\n\t                                key: {\n\t                                    get: function () {\n\t                                        var key = cursor.key;\n\t                                        return keyLength === 1 ?\n\t                                            key[0] :\n\t                                            key.slice(0, keyLength);\n\t                                    }\n\t                                },\n\t                                value: {\n\t                                    get: function () {\n\t                                        return cursor.value;\n\t                                    }\n\t                                }\n\t                            });\n\t                            return virtualCursor;\n\t                        }\n\t                        return table.openCursor(translateRequest(req))\n\t                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n\t                    } });\n\t                return result;\n\t            } });\n\t    }\n\t    var virtualIndexMiddleware = {\n\t        stack: \"dbcore\",\n\t        name: \"VirtualIndexMiddleware\",\n\t        level: 1,\n\t        create: createVirtualIndexMiddleware\n\t    };\n\n\t    function getObjectDiff(a, b, rv, prfx) {\n\t        rv = rv || {};\n\t        prfx = prfx || '';\n\t        keys(a).forEach(function (prop) {\n\t            if (!hasOwn(b, prop)) {\n\t                rv[prfx + prop] = undefined;\n\t            }\n\t            else {\n\t                var ap = a[prop], bp = b[prop];\n\t                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n\t                    var apTypeName = toStringTag(ap);\n\t                    var bpTypeName = toStringTag(bp);\n\t                    if (apTypeName !== bpTypeName) {\n\t                        rv[prfx + prop] = b[prop];\n\t                    }\n\t                    else if (apTypeName === 'Object') {\n\t                        getObjectDiff(ap, bp, rv, prfx + prop + '.');\n\t                    }\n\t                    else if (ap !== bp) {\n\t                        rv[prfx + prop] = b[prop];\n\t                    }\n\t                }\n\t                else if (ap !== bp)\n\t                    rv[prfx + prop] = b[prop];\n\t            }\n\t        });\n\t        keys(b).forEach(function (prop) {\n\t            if (!hasOwn(a, prop)) {\n\t                rv[prfx + prop] = b[prop];\n\t            }\n\t        });\n\t        return rv;\n\t    }\n\n\t    function getEffectiveKeys(primaryKey, req) {\n\t        if (req.type === 'delete')\n\t            return req.keys;\n\t        return req.keys || req.values.map(primaryKey.extractKey);\n\t    }\n\n\t    var hooksMiddleware = {\n\t        stack: \"dbcore\",\n\t        name: \"HooksMiddleware\",\n\t        level: 2,\n\t        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n\t                var downTable = downCore.table(tableName);\n\t                var primaryKey = downTable.schema.primaryKey;\n\t                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n\t                        var dxTrans = PSD.trans;\n\t                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n\t                        switch (req.type) {\n\t                            case 'add':\n\t                                if (creating.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'put':\n\t                                if (creating.fire === nop && updating.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'delete':\n\t                                if (deleting.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'deleteRange':\n\t                                if (deleting.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n\t                        }\n\t                        return downTable.mutate(req);\n\t                        function addPutOrDelete(req) {\n\t                            var dxTrans = PSD.trans;\n\t                            var keys = req.keys || getEffectiveKeys(primaryKey, req);\n\t                            if (!keys)\n\t                                throw new Error(\"Keys missing\");\n\t                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n\t                            if (req.type !== 'delete')\n\t                                req.values = __spreadArray([], req.values, true);\n\t                            if (req.keys)\n\t                                req.keys = __spreadArray([], req.keys, true);\n\t                            return getExistingValues(downTable, req, keys).then(function (existingValues) {\n\t                                var contexts = keys.map(function (key, i) {\n\t                                    var existingValue = existingValues[i];\n\t                                    var ctx = { onerror: null, onsuccess: null };\n\t                                    if (req.type === 'delete') {\n\t                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n\t                                    }\n\t                                    else if (req.type === 'add' || existingValue === undefined) {\n\t                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n\t                                        if (key == null && generatedPrimaryKey != null) {\n\t                                            key = generatedPrimaryKey;\n\t                                            req.keys[i] = key;\n\t                                            if (!primaryKey.outbound) {\n\t                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                    else {\n\t                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);\n\t                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n\t                                        if (additionalChanges_1) {\n\t                                            var requestedValue_1 = req.values[i];\n\t                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {\n\t                                                if (hasOwn(requestedValue_1, keyPath)) {\n\t                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n\t                                                }\n\t                                                else {\n\t                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n\t                                                }\n\t                                            });\n\t                                        }\n\t                                    }\n\t                                    return ctx;\n\t                                });\n\t                                return downTable.mutate(req).then(function (_a) {\n\t                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n\t                                    for (var i = 0; i < keys.length; ++i) {\n\t                                        var primKey = results ? results[i] : keys[i];\n\t                                        var ctx = contexts[i];\n\t                                        if (primKey == null) {\n\t                                            ctx.onerror && ctx.onerror(failures[i]);\n\t                                        }\n\t                                        else {\n\t                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n\t                                                req.values[i] :\n\t                                                primKey\n\t                                            );\n\t                                        }\n\t                                    }\n\t                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n\t                                }).catch(function (error) {\n\t                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n\t                                    return Promise.reject(error);\n\t                                });\n\t                            });\n\t                        }\n\t                        function deleteRange(req) {\n\t                            return deleteNextChunk(req.trans, req.range, 10000);\n\t                        }\n\t                        function deleteNextChunk(trans, range, limit) {\n\t                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n\t                                .then(function (_a) {\n\t                                var result = _a.result;\n\t                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n\t                                    if (res.numFailures > 0)\n\t                                        return Promise.reject(res.failures[0]);\n\t                                    if (result.length < limit) {\n\t                                        return { failures: [], numFailures: 0, lastResult: undefined };\n\t                                    }\n\t                                    else {\n\t                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n\t                                    }\n\t                                });\n\t                            });\n\t                        }\n\t                    } });\n\t                return tableMiddleware;\n\t            } })); }\n\t    };\n\t    function getExistingValues(table, req, effectiveKeys) {\n\t        return req.type === \"add\"\n\t            ? Promise.resolve([])\n\t            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n\t    }\n\n\t    function getFromTransactionCache(keys, cache, clone) {\n\t        try {\n\t            if (!cache)\n\t                return null;\n\t            if (cache.keys.length < keys.length)\n\t                return null;\n\t            var result = [];\n\t            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n\t                if (cmp(cache.keys[i], keys[j]) !== 0)\n\t                    continue;\n\t                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n\t                ++j;\n\t            }\n\t            return result.length === keys.length ? result : null;\n\t        }\n\t        catch (_a) {\n\t            return null;\n\t        }\n\t    }\n\t    var cacheExistingValuesMiddleware = {\n\t        stack: \"dbcore\",\n\t        level: -1,\n\t        create: function (core) {\n\t            return {\n\t                table: function (tableName) {\n\t                    var table = core.table(tableName);\n\t                    return __assign(__assign({}, table), { getMany: function (req) {\n\t                            if (!req.cache) {\n\t                                return table.getMany(req);\n\t                            }\n\t                            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n\t                            if (cachedResult) {\n\t                                return DexiePromise.resolve(cachedResult);\n\t                            }\n\t                            return table.getMany(req).then(function (res) {\n\t                                req.trans[\"_cache\"] = {\n\t                                    keys: req.keys,\n\t                                    values: req.cache === \"clone\" ? deepClone(res) : res,\n\t                                };\n\t                                return res;\n\t                            });\n\t                        }, mutate: function (req) {\n\t                            if (req.type !== \"add\")\n\t                                req.trans[\"_cache\"] = null;\n\t                            return table.mutate(req);\n\t                        } });\n\t                },\n\t            };\n\t        },\n\t    };\n\n\t    function isCachableContext(ctx, table) {\n\t        return (ctx.trans.mode === 'readonly' &&\n\t            !!ctx.subscr &&\n\t            !ctx.trans.explicit &&\n\t            ctx.trans.db._options.cache !== 'disabled' &&\n\t            !table.schema.primaryKey.outbound);\n\t    }\n\n\t    function isCachableRequest(type, req) {\n\t        switch (type) {\n\t            case 'query':\n\t                return req.values && !req.unique;\n\t            case 'get':\n\t                return false;\n\t            case 'getMany':\n\t                return false;\n\t            case 'count':\n\t                return false;\n\t            case 'openCursor':\n\t                return false;\n\t        }\n\t    }\n\n\t    var observabilityMiddleware = {\n\t        stack: \"dbcore\",\n\t        level: 0,\n\t        name: \"Observability\",\n\t        create: function (core) {\n\t            var dbName = core.schema.name;\n\t            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n\t            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n\t                    if (PSD.subscr && mode !== 'readonly') {\n\t                        throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n\t                    }\n\t                    return core.transaction(stores, mode, options);\n\t                }, table: function (tableName) {\n\t                    var table = core.table(tableName);\n\t                    var schema = table.schema;\n\t                    var primaryKey = schema.primaryKey, indexes = schema.indexes;\n\t                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n\t                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n\t                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n\t                            var trans = req.trans;\n\t                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n\t                            var getRangeSet = function (indexName) {\n\t                                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n\t                                return (mutatedParts[part] ||\n\t                                    (mutatedParts[part] = new RangeSet()));\n\t                            };\n\t                            var pkRangeSet = getRangeSet(\"\");\n\t                            var delsRangeSet = getRangeSet(\":dels\");\n\t                            var type = req.type;\n\t                            var _a = req.type === \"deleteRange\"\n\t                                ? [req.range]\n\t                                : req.type === \"delete\"\n\t                                    ? [req.keys]\n\t                                    : req.values.length < 50\n\t                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n\t                                        : [], keys = _a[0], newObjs = _a[1];\n\t                            var oldCache = req.trans[\"_cache\"];\n\t                            if (isArray(keys)) {\n\t                                pkRangeSet.addKeys(keys);\n\t                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n\t                                if (!oldObjs) {\n\t                                    delsRangeSet.addKeys(keys);\n\t                                }\n\t                                if (oldObjs || newObjs) {\n\t                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n\t                                }\n\t                            }\n\t                            else if (keys) {\n\t                                var range = { from: keys.lower, to: keys.upper };\n\t                                delsRangeSet.add(range);\n\t                                pkRangeSet.add(range);\n\t                            }\n\t                            else {\n\t                                pkRangeSet.add(FULL_RANGE);\n\t                                delsRangeSet.add(FULL_RANGE);\n\t                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n\t                            }\n\t                            return table.mutate(req).then(function (res) {\n\t                                if (keys && (req.type === 'add' || req.type === 'put')) {\n\t                                    pkRangeSet.addKeys(res.results);\n\t                                    if (indexesWithAutoIncPK) {\n\t                                        indexesWithAutoIncPK.forEach(function (idx) {\n\t                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n\t                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n\t                                            res.results.forEach(function (pk) { return idxVals[pkPos] = pk; });\n\t                                            getRangeSet(idx.name).addKeys(idxVals);\n\t                                        });\n\t                                    }\n\t                                }\n\t                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n\t                                return res;\n\t                            });\n\t                        } });\n\t                    var getRange = function (_a) {\n\t                        var _b, _c;\n\t                        var _d = _a.query, index = _d.index, range = _d.range;\n\t                        return [\n\t                            index,\n\t                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n\t                        ];\n\t                    };\n\t                    var readSubscribers = {\n\t                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n\t                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n\t                        count: getRange,\n\t                        query: getRange,\n\t                        openCursor: getRange,\n\t                    };\n\t                    keys(readSubscribers).forEach(function (method) {\n\t                        tableClone[method] = function (req) {\n\t                            var subscr = PSD.subscr;\n\t                            var isLiveQuery = !!subscr;\n\t                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n\t                            var obsSet = cachable\n\t                                ? req.obsSet = {}\n\t                                : subscr;\n\t                            if (isLiveQuery) {\n\t                                var getRangeSet = function (indexName) {\n\t                                    var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n\t                                    return (obsSet[part] ||\n\t                                        (obsSet[part] = new RangeSet()));\n\t                                };\n\t                                var pkRangeSet_1 = getRangeSet(\"\");\n\t                                var delsRangeSet_1 = getRangeSet(\":dels\");\n\t                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n\t                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n\t                                    delsRangeSet_1.add(queriedRanges);\n\t                                }\n\t                                else {\n\t                                    getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n\t                                }\n\t                                if (!queriedIndex.isPrimaryKey) {\n\t                                    if (method === \"count\") {\n\t                                        delsRangeSet_1.add(FULL_RANGE);\n\t                                    }\n\t                                    else {\n\t                                        var keysPromise_1 = method === \"query\" &&\n\t                                            outbound &&\n\t                                            req.values &&\n\t                                            table.query(__assign(__assign({}, req), { values: false }));\n\t                                        return table[method].apply(this, arguments).then(function (res) {\n\t                                            if (method === \"query\") {\n\t                                                if (outbound && req.values) {\n\t                                                    return keysPromise_1.then(function (_a) {\n\t                                                        var resultingKeys = _a.result;\n\t                                                        pkRangeSet_1.addKeys(resultingKeys);\n\t                                                        return res;\n\t                                                    });\n\t                                                }\n\t                                                var pKeys = req.values\n\t                                                    ? res.result.map(extractKey)\n\t                                                    : res.result;\n\t                                                if (req.values) {\n\t                                                    pkRangeSet_1.addKeys(pKeys);\n\t                                                }\n\t                                                else {\n\t                                                    delsRangeSet_1.addKeys(pKeys);\n\t                                                }\n\t                                            }\n\t                                            else if (method === \"openCursor\") {\n\t                                                var cursor_1 = res;\n\t                                                var wantValues_1 = req.values;\n\t                                                return (cursor_1 &&\n\t                                                    Object.create(cursor_1, {\n\t                                                        key: {\n\t                                                            get: function () {\n\t                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);\n\t                                                                return cursor_1.key;\n\t                                                            },\n\t                                                        },\n\t                                                        primaryKey: {\n\t                                                            get: function () {\n\t                                                                var pkey = cursor_1.primaryKey;\n\t                                                                delsRangeSet_1.addKey(pkey);\n\t                                                                return pkey;\n\t                                                            },\n\t                                                        },\n\t                                                        value: {\n\t                                                            get: function () {\n\t                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n\t                                                                return cursor_1.value;\n\t                                                            },\n\t                                                        },\n\t                                                    }));\n\t                                            }\n\t                                            return res;\n\t                                        });\n\t                                    }\n\t                                }\n\t                            }\n\t                            return table[method].apply(this, arguments);\n\t                        };\n\t                    });\n\t                    return tableClone;\n\t                } });\n\t        },\n\t    };\n\t    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n\t        function addAffectedIndex(ix) {\n\t            var rangeSet = getRangeSet(ix.name || \"\");\n\t            function extractKey(obj) {\n\t                return obj != null ? ix.extractKey(obj) : null;\n\t            }\n\t            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n\t                ? key.forEach(function (key) { return rangeSet.addKey(key); })\n\t                : rangeSet.addKey(key); };\n\t            (oldObjs || newObjs).forEach(function (_, i) {\n\t                var oldKey = oldObjs && extractKey(oldObjs[i]);\n\t                var newKey = newObjs && extractKey(newObjs[i]);\n\t                if (cmp(oldKey, newKey) !== 0) {\n\t                    if (oldKey != null)\n\t                        addKeyOrKeys(oldKey);\n\t                    if (newKey != null)\n\t                        addKeyOrKeys(newKey);\n\t                }\n\t            });\n\t        }\n\t        schema.indexes.forEach(addAffectedIndex);\n\t    }\n\n\t    function adjustOptimisticFromFailures(tblCache, req, res) {\n\t        if (res.numFailures === 0)\n\t            return req;\n\t        if (req.type === 'deleteRange') {\n\t            return null;\n\t        }\n\t        var numBulkOps = req.keys\n\t            ? req.keys.length\n\t            : 'values' in req && req.values\n\t                ? req.values.length\n\t                : 1;\n\t        if (res.numFailures === numBulkOps) {\n\t            return null;\n\t        }\n\t        var clone = __assign({}, req);\n\t        if (isArray(clone.keys)) {\n\t            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n\t        }\n\t        if ('values' in clone && isArray(clone.values)) {\n\t            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n\t        }\n\t        return clone;\n\t    }\n\n\t    function isAboveLower(key, range) {\n\t        return range.lower === undefined\n\t            ? true\n\t            : range.lowerOpen\n\t                ? cmp(key, range.lower) > 0\n\t                : cmp(key, range.lower) >= 0;\n\t    }\n\t    function isBelowUpper(key, range) {\n\t        return range.upper === undefined\n\t            ? true\n\t            : range.upperOpen\n\t                ? cmp(key, range.upper) < 0\n\t                : cmp(key, range.upper) <= 0;\n\t    }\n\t    function isWithinRange(key, range) {\n\t        return isAboveLower(key, range) && isBelowUpper(key, range);\n\t    }\n\n\t    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n\t        if (!ops || ops.length === 0)\n\t            return result;\n\t        var index = req.query.index;\n\t        var multiEntry = index.multiEntry;\n\t        var queryRange = req.query.range;\n\t        var primaryKey = table.schema.primaryKey;\n\t        var extractPrimKey = primaryKey.extractKey;\n\t        var extractIndex = index.extractKey;\n\t        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n\t        var finalResult = ops.reduce(function (result, op) {\n\t            var modifedResult = result;\n\t            var includedValues = [];\n\t            if (op.type === 'add' || op.type === 'put') {\n\t                var includedPKs = new RangeSet();\n\t                for (var i = op.values.length - 1; i >= 0; --i) {\n\t                    var value = op.values[i];\n\t                    var pk = extractPrimKey(value);\n\t                    if (includedPKs.hasKey(pk))\n\t                        continue;\n\t                    var key = extractIndex(value);\n\t                    if (multiEntry && isArray(key)\n\t                        ? key.some(function (k) { return isWithinRange(k, queryRange); })\n\t                        : isWithinRange(key, queryRange)) {\n\t                        includedPKs.addKey(pk);\n\t                        includedValues.push(value);\n\t                    }\n\t                }\n\t            }\n\t            switch (op.type) {\n\t                case 'add':\n\t                    modifedResult = result.concat(req.values\n\t                        ? includedValues\n\t                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n\t                    break;\n\t                case 'put':\n\t                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n\t                    modifedResult = result\n\t                        .filter(\n\t                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n\t                        .concat(\n\t                    req.values\n\t                        ? includedValues\n\t                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n\t                    break;\n\t                case 'delete':\n\t                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n\t                    modifedResult = result.filter(function (item) { return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item); });\n\t                    break;\n\t                case 'deleteRange':\n\t                    var range_1 = op.range;\n\t                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n\t                    break;\n\t            }\n\t            return modifedResult;\n\t        }, result);\n\t        if (finalResult === result)\n\t            return result;\n\t        finalResult.sort(function (a, b) {\n\t            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n\t                cmp(extractPrimKey(a), extractPrimKey(b));\n\t        });\n\t        if (req.limit && req.limit < Infinity) {\n\t            if (finalResult.length > req.limit) {\n\t                finalResult.length = req.limit;\n\t            }\n\t            else if (result.length === req.limit && finalResult.length < req.limit) {\n\t                cacheEntry.dirty = true;\n\t            }\n\t        }\n\t        return immutable ? Object.freeze(finalResult) : finalResult;\n\t    }\n\n\t    function areRangesEqual(r1, r2) {\n\t        return (cmp(r1.lower, r2.lower) === 0 &&\n\t            cmp(r1.upper, r2.upper) === 0 &&\n\t            !!r1.lowerOpen === !!r2.lowerOpen &&\n\t            !!r1.upperOpen === !!r2.upperOpen);\n\t    }\n\n\t    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n\t        if (lower1 === undefined)\n\t            return lower2 !== undefined ? -1 : 0;\n\t        if (lower2 === undefined)\n\t            return 1;\n\t        var c = cmp(lower1, lower2);\n\t        if (c === 0) {\n\t            if (lowerOpen1 && lowerOpen2)\n\t                return 0;\n\t            if (lowerOpen1)\n\t                return 1;\n\t            if (lowerOpen2)\n\t                return -1;\n\t        }\n\t        return c;\n\t    }\n\t    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n\t        if (upper1 === undefined)\n\t            return upper2 !== undefined ? 1 : 0;\n\t        if (upper2 === undefined)\n\t            return -1;\n\t        var c = cmp(upper1, upper2);\n\t        if (c === 0) {\n\t            if (upperOpen1 && upperOpen2)\n\t                return 0;\n\t            if (upperOpen1)\n\t                return -1;\n\t            if (upperOpen2)\n\t                return 1;\n\t        }\n\t        return c;\n\t    }\n\t    function isSuperRange(r1, r2) {\n\t        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n\t            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n\t    }\n\n\t    function findCompatibleQuery(dbName, tableName, type, req) {\n\t        var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t        if (!tblCache)\n\t            return [];\n\t        var queries = tblCache.queries[type];\n\t        if (!queries)\n\t            return [null, false, tblCache, null];\n\t        var indexName = req.query ? req.query.index.name : null;\n\t        var entries = queries[indexName || ''];\n\t        if (!entries)\n\t            return [null, false, tblCache, null];\n\t        switch (type) {\n\t            case 'query':\n\t                var equalEntry = entries.find(function (entry) {\n\t                    return entry.req.limit === req.limit &&\n\t                        entry.req.values === req.values &&\n\t                        areRangesEqual(entry.req.query.range, req.query.range);\n\t                });\n\t                if (equalEntry)\n\t                    return [\n\t                        equalEntry,\n\t                        true,\n\t                        tblCache,\n\t                        entries,\n\t                    ];\n\t                var superEntry = entries.find(function (entry) {\n\t                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n\t                    return (limit >= req.limit &&\n\t                        (req.values ? entry.req.values : true) &&\n\t                        isSuperRange(entry.req.query.range, req.query.range));\n\t                });\n\t                return [superEntry, false, tblCache, entries];\n\t            case 'count':\n\t                var countQuery = entries.find(function (entry) {\n\t                    return areRangesEqual(entry.req.query.range, req.query.range);\n\t                });\n\t                return [countQuery, !!countQuery, tblCache, entries];\n\t        }\n\t    }\n\n\t    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n\t        cacheEntry.subscribers.add(requery);\n\t        signal.addEventListener(\"abort\", function () {\n\t            cacheEntry.subscribers.delete(requery);\n\t            if (cacheEntry.subscribers.size === 0) {\n\t                enqueForDeletion(cacheEntry, container);\n\t            }\n\t        });\n\t    }\n\t    function enqueForDeletion(cacheEntry, container) {\n\t        setTimeout(function () {\n\t            if (cacheEntry.subscribers.size === 0) {\n\t                delArrayItem(container, cacheEntry);\n\t            }\n\t        }, 3000);\n\t    }\n\n\t    var cacheMiddleware = {\n\t        stack: 'dbcore',\n\t        level: 0,\n\t        name: 'Cache',\n\t        create: function (core) {\n\t            var dbName = core.schema.name;\n\t            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n\t                    var idbtrans = core.transaction(stores, mode, options);\n\t                    if (mode === 'readwrite') {\n\t                        var ac_1 = new AbortController();\n\t                        var signal = ac_1.signal;\n\t                        var endTransaction = function (wasCommitted) { return function () {\n\t                            ac_1.abort();\n\t                            if (mode === 'readwrite') {\n\t                                var affectedSubscribers_1 = new Set();\n\t                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n\t                                    var storeName = stores_1[_i];\n\t                                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n\t                                    if (tblCache) {\n\t                                        var table = core.table(storeName);\n\t                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n\t                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n\t                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n\t                                                var entries = _b[_a];\n\t                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n\t                                                    var entry = _d[_c];\n\t                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n\t                                                        delArrayItem(entries, entry);\n\t                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                    }\n\t                                                }\n\t                                            }\n\t                                        }\n\t                                        else if (ops.length > 0) {\n\t                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n\t                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n\t                                                var entries = _f[_e];\n\t                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n\t                                                    var entry = _h[_g];\n\t                                                    if (entry.res != null &&\n\t                                                        idbtrans.mutatedParts\n\t    ) {\n\t                                                        if (wasCommitted && !entry.dirty) {\n\t                                                            var freezeResults = Object.isFrozen(entry.res);\n\t                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n\t                                                            if (entry.dirty) {\n\t                                                                delArrayItem(entries, entry);\n\t                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                            }\n\t                                                            else if (modRes !== entry.res) {\n\t                                                                entry.res = modRes;\n\t                                                                entry.promise = DexiePromise.resolve({ result: modRes });\n\t                                                            }\n\t                                                        }\n\t                                                        else {\n\t                                                            if (entry.dirty) {\n\t                                                                delArrayItem(entries, entry);\n\t                                                            }\n\t                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                        }\n\t                                                    }\n\t                                                }\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                }\n\t                                affectedSubscribers_1.forEach(function (requery) { return requery(); });\n\t                            }\n\t                        }; };\n\t                        idbtrans.addEventListener('abort', endTransaction(false), {\n\t                            signal: signal,\n\t                        });\n\t                        idbtrans.addEventListener('error', endTransaction(false), {\n\t                            signal: signal,\n\t                        });\n\t                        idbtrans.addEventListener('complete', endTransaction(true), {\n\t                            signal: signal,\n\t                        });\n\t                    }\n\t                    return idbtrans;\n\t                }, table: function (tableName) {\n\t                    var downTable = core.table(tableName);\n\t                    var primKey = downTable.schema.primaryKey;\n\t                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n\t                            var trans = PSD.trans;\n\t                            if (primKey.outbound ||\n\t                                trans.db._options.cache === 'disabled' ||\n\t                                trans.explicit\n\t                            ) {\n\t                                return downTable.mutate(req);\n\t                            }\n\t                            var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t                            if (!tblCache)\n\t                                return downTable.mutate(req);\n\t                            var promise = downTable.mutate(req);\n\t                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n\t                                promise.then(function (res) {\n\t                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n\t                                            var _a;\n\t                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n\t                                                ? deepClone(value)\n\t                                                : __assign({}, value);\n\t                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n\t                                            return valueWithKey;\n\t                                        }) });\n\t                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n\t                                    tblCache.optimisticOps.push(adjustedReq);\n\t                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n\t                                });\n\t                            }\n\t                            else {\n\t                                tblCache.optimisticOps.push(req);\n\t                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                promise.then(function (res) {\n\t                                    if (res.numFailures > 0) {\n\t                                        delArrayItem(tblCache.optimisticOps, req);\n\t                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n\t                                        if (adjustedReq) {\n\t                                            tblCache.optimisticOps.push(adjustedReq);\n\t                                        }\n\t                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                    }\n\t                                });\n\t                                promise.catch(function () {\n\t                                    delArrayItem(tblCache.optimisticOps, req);\n\t                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                });\n\t                            }\n\t                            return promise;\n\t                        }, query: function (req) {\n\t                            var _a;\n\t                            if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n\t                                return downTable.query(req);\n\t                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n\t                            var _b = PSD, requery = _b.requery, signal = _b.signal;\n\t                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n\t                            if (cacheEntry && exactMatch) {\n\t                                cacheEntry.obsSet = req.obsSet;\n\t                            }\n\t                            else {\n\t                                var promise = downTable.query(req).then(function (res) {\n\t                                    var result = res.result;\n\t                                    if (cacheEntry)\n\t                                        cacheEntry.res = result;\n\t                                    if (freezeResults) {\n\t                                        for (var i = 0, l = result.length; i < l; ++i) {\n\t                                            Object.freeze(result[i]);\n\t                                        }\n\t                                        Object.freeze(result);\n\t                                    }\n\t                                    else {\n\t                                        res.result = deepClone(result);\n\t                                    }\n\t                                    return res;\n\t                                }).catch(function (error) {\n\t                                    if (container && cacheEntry)\n\t                                        delArrayItem(container, cacheEntry);\n\t                                    return Promise.reject(error);\n\t                                });\n\t                                cacheEntry = {\n\t                                    obsSet: req.obsSet,\n\t                                    promise: promise,\n\t                                    subscribers: new Set(),\n\t                                    type: 'query',\n\t                                    req: req,\n\t                                    dirty: false,\n\t                                };\n\t                                if (container) {\n\t                                    container.push(cacheEntry);\n\t                                }\n\t                                else {\n\t                                    container = [cacheEntry];\n\t                                    if (!tblCache) {\n\t                                        tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n\t                                            queries: {\n\t                                                query: {},\n\t                                                count: {},\n\t                                            },\n\t                                            objs: new Map(),\n\t                                            optimisticOps: [],\n\t                                            unsignaledParts: {}\n\t                                        };\n\t                                    }\n\t                                    tblCache.queries.query[req.query.index.name || ''] = container;\n\t                                }\n\t                            }\n\t                            subscribeToCacheEntry(cacheEntry, container, requery, signal);\n\t                            return cacheEntry.promise.then(function (res) {\n\t                                return {\n\t                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n\t                                };\n\t                            });\n\t                        } });\n\t                    return tableMW;\n\t                } });\n\t            return coreMW;\n\t        },\n\t    };\n\n\t    function vipify(target, vipDb) {\n\t        return new Proxy(target, {\n\t            get: function (target, prop, receiver) {\n\t                if (prop === 'db')\n\t                    return vipDb;\n\t                return Reflect.get(target, prop, receiver);\n\t            }\n\t        });\n\t    }\n\n\t    var Dexie$1 =  (function () {\n\t        function Dexie(name, options) {\n\t            var _this = this;\n\t            this._middlewares = {};\n\t            this.verno = 0;\n\t            var deps = Dexie.dependencies;\n\t            this._options = options = __assign({\n\t                addons: Dexie.addons, autoOpen: true,\n\t                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n\t            this._deps = {\n\t                indexedDB: options.indexedDB,\n\t                IDBKeyRange: options.IDBKeyRange\n\t            };\n\t            var addons = options.addons;\n\t            this._dbSchema = {};\n\t            this._versions = [];\n\t            this._storeNames = [];\n\t            this._allTables = {};\n\t            this.idbdb = null;\n\t            this._novip = this;\n\t            var state = {\n\t                dbOpenError: null,\n\t                isBeingOpened: false,\n\t                onReadyBeingFired: null,\n\t                openComplete: false,\n\t                dbReadyResolve: nop,\n\t                dbReadyPromise: null,\n\t                cancelOpen: nop,\n\t                openCanceller: null,\n\t                autoSchema: true,\n\t                PR1398_maxLoop: 3,\n\t                autoOpen: options.autoOpen,\n\t            };\n\t            state.dbReadyPromise = new DexiePromise(function (resolve) {\n\t                state.dbReadyResolve = resolve;\n\t            });\n\t            state.openCanceller = new DexiePromise(function (_, reject) {\n\t                state.cancelOpen = reject;\n\t            });\n\t            this._state = state;\n\t            this.name = name;\n\t            this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n\t            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n\t                return function (subscriber, bSticky) {\n\t                    Dexie.vip(function () {\n\t                        var state = _this._state;\n\t                        if (state.openComplete) {\n\t                            if (!state.dbOpenError)\n\t                                DexiePromise.resolve().then(subscriber);\n\t                            if (bSticky)\n\t                                subscribe(subscriber);\n\t                        }\n\t                        else if (state.onReadyBeingFired) {\n\t                            state.onReadyBeingFired.push(subscriber);\n\t                            if (bSticky)\n\t                                subscribe(subscriber);\n\t                        }\n\t                        else {\n\t                            subscribe(subscriber);\n\t                            var db_1 = _this;\n\t                            if (!bSticky)\n\t                                subscribe(function unsubscribe() {\n\t                                    db_1.on.ready.unsubscribe(subscriber);\n\t                                    db_1.on.ready.unsubscribe(unsubscribe);\n\t                                });\n\t                        }\n\t                    });\n\t                };\n\t            });\n\t            this.Collection = createCollectionConstructor(this);\n\t            this.Table = createTableConstructor(this);\n\t            this.Transaction = createTransactionConstructor(this);\n\t            this.Version = createVersionConstructor(this);\n\t            this.WhereClause = createWhereClauseConstructor(this);\n\t            this.on(\"versionchange\", function (ev) {\n\t                if (ev.newVersion > 0)\n\t                    console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n\t                else\n\t                    console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n\t                _this.close({ disableAutoOpen: false });\n\t            });\n\t            this.on(\"blocked\", function (ev) {\n\t                if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n\t                    console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n\t                else\n\t                    console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n\t            });\n\t            this._maxKey = getMaxKey(options.IDBKeyRange);\n\t            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n\t            this._fireOnBlocked = function (ev) {\n\t                _this.on(\"blocked\").fire(ev);\n\t                connections\n\t                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n\t                    .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n\t            };\n\t            this.use(cacheExistingValuesMiddleware);\n\t            this.use(cacheMiddleware);\n\t            this.use(observabilityMiddleware);\n\t            this.use(virtualIndexMiddleware);\n\t            this.use(hooksMiddleware);\n\t            var vipDB = new Proxy(this, {\n\t                get: function (_, prop, receiver) {\n\t                    if (prop === '_vip')\n\t                        return true;\n\t                    if (prop === 'table')\n\t                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n\t                    var rv = Reflect.get(_, prop, receiver);\n\t                    if (rv instanceof Table)\n\t                        return vipify(rv, vipDB);\n\t                    if (prop === 'tables')\n\t                        return rv.map(function (t) { return vipify(t, vipDB); });\n\t                    if (prop === '_createTransaction')\n\t                        return function () {\n\t                            var tx = rv.apply(this, arguments);\n\t                            return vipify(tx, vipDB);\n\t                        };\n\t                    return rv;\n\t                }\n\t            });\n\t            this.vip = vipDB;\n\t            addons.forEach(function (addon) { return addon(_this); });\n\t        }\n\t        Dexie.prototype.version = function (versionNumber) {\n\t            if (isNaN(versionNumber) || versionNumber < 0.1)\n\t                throw new exceptions.Type(\"Given version is not a positive number\");\n\t            versionNumber = Math.round(versionNumber * 10) / 10;\n\t            if (this.idbdb || this._state.isBeingOpened)\n\t                throw new exceptions.Schema(\"Cannot add version when database is open\");\n\t            this.verno = Math.max(this.verno, versionNumber);\n\t            var versions = this._versions;\n\t            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n\t            if (versionInstance)\n\t                return versionInstance;\n\t            versionInstance = new this.Version(versionNumber);\n\t            versions.push(versionInstance);\n\t            versions.sort(lowerVersionFirst);\n\t            versionInstance.stores({});\n\t            this._state.autoSchema = false;\n\t            return versionInstance;\n\t        };\n\t        Dexie.prototype._whenReady = function (fn) {\n\t            var _this = this;\n\t            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n\t                if (_this._state.openComplete) {\n\t                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n\t                }\n\t                if (!_this._state.isBeingOpened) {\n\t                    if (!_this._state.autoOpen) {\n\t                        reject(new exceptions.DatabaseClosed());\n\t                        return;\n\t                    }\n\t                    _this.open().catch(nop);\n\t                }\n\t                _this._state.dbReadyPromise.then(resolve, reject);\n\t            }).then(fn);\n\t        };\n\t        Dexie.prototype.use = function (_a) {\n\t            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n\t            if (name)\n\t                this.unuse({ stack: stack, name: name });\n\t            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n\t            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n\t            middlewares.sort(function (a, b) { return a.level - b.level; });\n\t            return this;\n\t        };\n\t        Dexie.prototype.unuse = function (_a) {\n\t            var stack = _a.stack, name = _a.name, create = _a.create;\n\t            if (stack && this._middlewares[stack]) {\n\t                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n\t                    return create ? mw.create !== create :\n\t                        name ? mw.name !== name :\n\t                            false;\n\t                });\n\t            }\n\t            return this;\n\t        };\n\t        Dexie.prototype.open = function () {\n\t            var _this = this;\n\t            return usePSD(globalPSD,\n\t            function () { return dexieOpen(_this); });\n\t        };\n\t        Dexie.prototype._close = function () {\n\t            var state = this._state;\n\t            var idx = connections.indexOf(this);\n\t            if (idx >= 0)\n\t                connections.splice(idx, 1);\n\t            if (this.idbdb) {\n\t                try {\n\t                    this.idbdb.close();\n\t                }\n\t                catch (e) { }\n\t                this.idbdb = null;\n\t            }\n\t            if (!state.isBeingOpened) {\n\t                state.dbReadyPromise = new DexiePromise(function (resolve) {\n\t                    state.dbReadyResolve = resolve;\n\t                });\n\t                state.openCanceller = new DexiePromise(function (_, reject) {\n\t                    state.cancelOpen = reject;\n\t                });\n\t            }\n\t        };\n\t        Dexie.prototype.close = function (_a) {\n\t            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n\t            var state = this._state;\n\t            if (disableAutoOpen) {\n\t                if (state.isBeingOpened) {\n\t                    state.cancelOpen(new exceptions.DatabaseClosed());\n\t                }\n\t                this._close();\n\t                state.autoOpen = false;\n\t                state.dbOpenError = new exceptions.DatabaseClosed();\n\t            }\n\t            else {\n\t                this._close();\n\t                state.autoOpen = this._options.autoOpen ||\n\t                    state.isBeingOpened;\n\t                state.openComplete = false;\n\t                state.dbOpenError = null;\n\t            }\n\t        };\n\t        Dexie.prototype.delete = function (closeOptions) {\n\t            var _this = this;\n\t            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n\t            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n\t            var state = this._state;\n\t            return new DexiePromise(function (resolve, reject) {\n\t                var doDelete = function () {\n\t                    _this.close(closeOptions);\n\t                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n\t                    req.onsuccess = wrap(function () {\n\t                        _onDatabaseDeleted(_this._deps, _this.name);\n\t                        resolve();\n\t                    });\n\t                    req.onerror = eventRejectHandler(reject);\n\t                    req.onblocked = _this._fireOnBlocked;\n\t                };\n\t                if (hasInvalidArguments)\n\t                    throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n\t                if (state.isBeingOpened) {\n\t                    state.dbReadyPromise.then(doDelete);\n\t                }\n\t                else {\n\t                    doDelete();\n\t                }\n\t            });\n\t        };\n\t        Dexie.prototype.backendDB = function () {\n\t            return this.idbdb;\n\t        };\n\t        Dexie.prototype.isOpen = function () {\n\t            return this.idbdb !== null;\n\t        };\n\t        Dexie.prototype.hasBeenClosed = function () {\n\t            var dbOpenError = this._state.dbOpenError;\n\t            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n\t        };\n\t        Dexie.prototype.hasFailed = function () {\n\t            return this._state.dbOpenError !== null;\n\t        };\n\t        Dexie.prototype.dynamicallyOpened = function () {\n\t            return this._state.autoSchema;\n\t        };\n\t        Object.defineProperty(Dexie.prototype, \"tables\", {\n\t            get: function () {\n\t                var _this = this;\n\t                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n\t            },\n\t            enumerable: false,\n\t            configurable: true\n\t        });\n\t        Dexie.prototype.transaction = function () {\n\t            var args = extractTransactionArgs.apply(this, arguments);\n\t            return this._transaction.apply(this, args);\n\t        };\n\t        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n\t            var _this = this;\n\t            var parentTransaction = PSD.trans;\n\t            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n\t                parentTransaction = null;\n\t            var onlyIfCompatible = mode.indexOf('?') !== -1;\n\t            mode = mode.replace('!', '').replace('?', '');\n\t            var idbMode, storeNames;\n\t            try {\n\t                storeNames = tables.map(function (table) {\n\t                    var storeName = table instanceof _this.Table ? table.name : table;\n\t                    if (typeof storeName !== 'string')\n\t                        throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n\t                    return storeName;\n\t                });\n\t                if (mode == \"r\" || mode === READONLY)\n\t                    idbMode = READONLY;\n\t                else if (mode == \"rw\" || mode == READWRITE)\n\t                    idbMode = READWRITE;\n\t                else\n\t                    throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\t                if (parentTransaction) {\n\t                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n\t                        if (onlyIfCompatible) {\n\t                            parentTransaction = null;\n\t                        }\n\t                        else\n\t                            throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n\t                    }\n\t                    if (parentTransaction) {\n\t                        storeNames.forEach(function (storeName) {\n\t                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n\t                                if (onlyIfCompatible) {\n\t                                    parentTransaction = null;\n\t                                }\n\t                                else\n\t                                    throw new exceptions.SubTransaction(\"Table \" + storeName +\n\t                                        \" not included in parent transaction.\");\n\t                            }\n\t                        });\n\t                    }\n\t                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n\t                        parentTransaction = null;\n\t                    }\n\t                }\n\t            }\n\t            catch (e) {\n\t                return parentTransaction ?\n\t                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n\t                    rejection(e);\n\t            }\n\t            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n\t            return (parentTransaction ?\n\t                parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n\t                PSD.trans ?\n\t                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n\t                    this._whenReady(enterTransaction));\n\t        };\n\t        Dexie.prototype.table = function (tableName) {\n\t            if (!hasOwn(this._allTables, tableName)) {\n\t                throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n\t            }\n\t            return this._allTables[tableName];\n\t        };\n\t        return Dexie;\n\t    }());\n\n\t    var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n\t        ? Symbol.observable\n\t        : \"@@observable\";\n\t    var Observable =  (function () {\n\t        function Observable(subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t        Observable.prototype.subscribe = function (x, error, complete) {\n\t            return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n\t        };\n\t        Observable.prototype[symbolObservable] = function () {\n\t            return this;\n\t        };\n\t        return Observable;\n\t    }());\n\n\t    var domDeps;\n\t    try {\n\t        domDeps = {\n\t            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n\t            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n\t        };\n\t    }\n\t    catch (e) {\n\t        domDeps = { indexedDB: null, IDBKeyRange: null };\n\t    }\n\n\t    function liveQuery(querier) {\n\t        var hasValue = false;\n\t        var currentValue;\n\t        var observable = new Observable(function (observer) {\n\t            var scopeFuncIsAsync = isAsyncFunction(querier);\n\t            function execute(ctx) {\n\t                var wasRootExec = beginMicroTickScope();\n\t                try {\n\t                    if (scopeFuncIsAsync) {\n\t                        incrementExpectedAwaits();\n\t                    }\n\t                    var rv = newScope(querier, ctx);\n\t                    if (scopeFuncIsAsync) {\n\t                        rv = rv.finally(decrementExpectedAwaits);\n\t                    }\n\t                    return rv;\n\t                }\n\t                finally {\n\t                    wasRootExec && endMicroTickScope();\n\t                }\n\t            }\n\t            var closed = false;\n\t            var abortController;\n\t            var accumMuts = {};\n\t            var currentObs = {};\n\t            var subscription = {\n\t                get closed() {\n\t                    return closed;\n\t                },\n\t                unsubscribe: function () {\n\t                    if (closed)\n\t                        return;\n\t                    closed = true;\n\t                    if (abortController)\n\t                        abortController.abort();\n\t                    if (startedListening)\n\t                        globalEvents.storagemutated.unsubscribe(mutationListener);\n\t                },\n\t            };\n\t            observer.start && observer.start(subscription);\n\t            var startedListening = false;\n\t            var doQuery = function () { return execInGlobalContext(_doQuery); };\n\t            function shouldNotify() {\n\t                return obsSetsOverlap(currentObs, accumMuts);\n\t            }\n\t            var mutationListener = function (parts) {\n\t                extendObservabilitySet(accumMuts, parts);\n\t                if (shouldNotify()) {\n\t                    doQuery();\n\t                }\n\t            };\n\t            var _doQuery = function () {\n\t                if (closed ||\n\t                    !domDeps.indexedDB)\n\t                 {\n\t                    return;\n\t                }\n\t                accumMuts = {};\n\t                var subscr = {};\n\t                if (abortController)\n\t                    abortController.abort();\n\t                abortController = new AbortController();\n\t                var ctx = {\n\t                    subscr: subscr,\n\t                    signal: abortController.signal,\n\t                    requery: doQuery,\n\t                    querier: querier,\n\t                    trans: null\n\t                };\n\t                var ret = execute(ctx);\n\t                Promise.resolve(ret).then(function (result) {\n\t                    hasValue = true;\n\t                    currentValue = result;\n\t                    if (closed || ctx.signal.aborted) {\n\t                        return;\n\t                    }\n\t                    accumMuts = {};\n\t                    currentObs = subscr;\n\t                    if (!objectIsEmpty(currentObs) && !startedListening) {\n\t                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n\t                        startedListening = true;\n\t                    }\n\t                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n\t                }, function (err) {\n\t                    hasValue = false;\n\t                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n\t                        if (!closed)\n\t                            execInGlobalContext(function () {\n\t                                if (closed)\n\t                                    return;\n\t                                observer.error && observer.error(err);\n\t                            });\n\t                    }\n\t                });\n\t            };\n\t            setTimeout(doQuery, 0);\n\t            return subscription;\n\t        });\n\t        observable.hasValue = function () { return hasValue; };\n\t        observable.getValue = function () { return currentValue; };\n\t        return observable;\n\t    }\n\n\t    var Dexie = Dexie$1;\n\t    props(Dexie, __assign(__assign({}, fullNameExceptions), {\n\t        delete: function (databaseName) {\n\t            var db = new Dexie(databaseName, { addons: [] });\n\t            return db.delete();\n\t        },\n\t        exists: function (name) {\n\t            return new Dexie(name, { addons: [] }).open().then(function (db) {\n\t                db.close();\n\t                return true;\n\t            }).catch('NoSuchDatabaseError', function () { return false; });\n\t        },\n\t        getDatabaseNames: function (cb) {\n\t            try {\n\t                return getDatabaseNames(Dexie.dependencies).then(cb);\n\t            }\n\t            catch (_a) {\n\t                return rejection(new exceptions.MissingAPI());\n\t            }\n\t        },\n\t        defineClass: function () {\n\t            function Class(content) {\n\t                extend(this, content);\n\t            }\n\t            return Class;\n\t        }, ignoreTransaction: function (scopeFunc) {\n\t            return PSD.trans ?\n\t                usePSD(PSD.transless, scopeFunc) :\n\t                scopeFunc();\n\t        }, vip: vip, async: function (generatorFn) {\n\t            return function () {\n\t                try {\n\t                    var rv = awaitIterator(generatorFn.apply(this, arguments));\n\t                    if (!rv || typeof rv.then !== 'function')\n\t                        return DexiePromise.resolve(rv);\n\t                    return rv;\n\t                }\n\t                catch (e) {\n\t                    return rejection(e);\n\t                }\n\t            };\n\t        }, spawn: function (generatorFn, args, thiz) {\n\t            try {\n\t                var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n\t                if (!rv || typeof rv.then !== 'function')\n\t                    return DexiePromise.resolve(rv);\n\t                return rv;\n\t            }\n\t            catch (e) {\n\t                return rejection(e);\n\t            }\n\t        },\n\t        currentTransaction: {\n\t            get: function () { return PSD.trans || null; }\n\t        }, waitFor: function (promiseOrFunction, optionalTimeout) {\n\t            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n\t                Dexie.ignoreTransaction(promiseOrFunction) :\n\t                promiseOrFunction)\n\t                .timeout(optionalTimeout || 60000);\n\t            return PSD.trans ?\n\t                PSD.trans.waitFor(promise) :\n\t                promise;\n\t        },\n\t        Promise: DexiePromise,\n\t        debug: {\n\t            get: function () { return debug; },\n\t            set: function (value) {\n\t                setDebug(value);\n\t            }\n\t        },\n\t        derive: derive, extend: extend, props: props, override: override,\n\t        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n\t        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n\t        minKey: minKey,\n\t        addons: [],\n\t        connections: connections,\n\t        errnames: errnames,\n\t        dependencies: domDeps, cache: cache,\n\t        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n\t            .map(function (n) { return parseInt(n); })\n\t            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n\t    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n\t    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n\t        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n\t            if (!propagatingLocally) {\n\t                var event_1;\n\t                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n\t                    detail: updatedParts\n\t                });\n\t                propagatingLocally = true;\n\t                dispatchEvent(event_1);\n\t                propagatingLocally = false;\n\t            }\n\t        });\n\t        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n\t            var detail = _a.detail;\n\t            if (!propagatingLocally) {\n\t                propagateLocally(detail);\n\t            }\n\t        });\n\t    }\n\t    function propagateLocally(updateParts) {\n\t        var wasMe = propagatingLocally;\n\t        try {\n\t            propagatingLocally = true;\n\t            globalEvents.storagemutated.fire(updateParts);\n\t            signalSubscribersNow(updateParts, true);\n\t        }\n\t        finally {\n\t            propagatingLocally = wasMe;\n\t        }\n\t    }\n\t    var propagatingLocally = false;\n\n\t    var bc;\n\t    var createBC = function () { };\n\t    if (typeof BroadcastChannel !== 'undefined') {\n\t        createBC = function () {\n\t            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n\t            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n\t        };\n\t        createBC();\n\t        if (typeof bc.unref === 'function') {\n\t            bc.unref();\n\t        }\n\t        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n\t            if (!propagatingLocally) {\n\t                bc.postMessage(changedParts);\n\t            }\n\t        });\n\t    }\n\n\t    if (typeof addEventListener !== 'undefined') {\n\t        addEventListener('pagehide', function (event) {\n\t            if (!Dexie$1.disableBfCache && event.persisted) {\n\t                if (debug)\n\t                    console.debug('Dexie: handling persisted pagehide');\n\t                bc === null || bc === void 0 ? void 0 : bc.close();\n\t                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n\t                    var db = connections_1[_i];\n\t                    db.close({ disableAutoOpen: false });\n\t                }\n\t            }\n\t        });\n\t        addEventListener('pageshow', function (event) {\n\t            if (!Dexie$1.disableBfCache && event.persisted) {\n\t                if (debug)\n\t                    console.debug('Dexie: handling persisted pageshow');\n\t                createBC();\n\t                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n\t            }\n\t        });\n\t    }\n\n\t    function add(value) {\n\t        return new PropModification({ add: value });\n\t    }\n\n\t    function remove(value) {\n\t        return new PropModification({ remove: value });\n\t    }\n\n\t    function replacePrefix(a, b) {\n\t        return new PropModification({ replacePrefix: [a, b] });\n\t    }\n\n\t    DexiePromise.rejectionMapper = mapError;\n\t    setDebug(debug);\n\n\t    var namedExports = /*#__PURE__*/Object.freeze({\n\t        __proto__: null,\n\t        Dexie: Dexie$1,\n\t        liveQuery: liveQuery,\n\t        Entity: Entity,\n\t        cmp: cmp,\n\t        PropModSymbol: PropModSymbol,\n\t        PropModification: PropModification,\n\t        replacePrefix: replacePrefix,\n\t        add: add,\n\t        remove: remove,\n\t        'default': Dexie$1,\n\t        RangeSet: RangeSet,\n\t        mergeRanges: mergeRanges,\n\t        rangesOverlap: rangesOverlap\n\t    });\n\n\t    __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n\t    return Dexie$1;\n\n\t}));\n\t\n} (dexie));\n\nvar dexieExports = dexie.exports;\nvar _Dexie = /*@__PURE__*/getDefaultExportFromCjs(dexieExports);\n\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);\nif (_Dexie.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);\n}\n\n// Helper for undefined values, like map for Option<T> in Rust.\n// A better name for this is welcome.\nconst mapOption = (value, func) => {\n    return value != undefined ? func(value) : undefined;\n};\n// Anything can be thrown as an error in raw JS (also the TS compiler can't type-check exceptions),\n// so we allow it here.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst logWebStoreError = (error, errorContext) => {\n    if (error instanceof Dexie.DexieError) {\n        if (errorContext) {\n            console.error(`${errorContext}: Indexdb error (${error.name}): ${error.message}`);\n        }\n        else {\n            console.error(`Indexdb error: (${error.name}): ${error.message}`);\n        }\n        mapOption(error.stack, (stack) => {\n            console.error(`Stacktrace: \\n ${stack}`);\n        });\n        mapOption(error.inner, (innerException) => logWebStoreError(innerException));\n    }\n    else if (error instanceof Error) {\n        console.error(`Unexpected error while accessing indexdb: ${error.toString()}`);\n        mapOption(error.stack, (stack) => {\n            console.error(`Stacktrace: ${stack}`);\n        });\n    }\n    else {\n        console.error(`Got an exception with a non-error value, as JSON: \\n ${JSON.stringify(error)}. As String \\n ${String(error)} `);\n        console.trace();\n    }\n    throw error;\n};\nconst uint8ArrayToBase64 = (bytes) => {\n    const binary = bytes.reduce((acc, byte) => acc + String.fromCharCode(byte), \"\");\n    return btoa(binary);\n};\n\nconst DATABASE_NAME = \"MidenClientDB\";\nasync function openDatabase() {\n    console.log(\"Opening database...\");\n    try {\n        await db.open();\n        console.log(\"Database opened successfully\");\n        return true;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to open database\");\n        return false;\n    }\n}\nvar Table;\n(function (Table) {\n    Table[\"AccountCode\"] = \"accountCode\";\n    Table[\"AccountStorage\"] = \"accountStorage\";\n    Table[\"AccountAssets\"] = \"accountAssets\";\n    Table[\"StorageMapEntries\"] = \"storageMapEntries\";\n    Table[\"AccountAuth\"] = \"accountAuth\";\n    Table[\"Accounts\"] = \"accounts\";\n    Table[\"Addresses\"] = \"addresses\";\n    Table[\"Transactions\"] = \"transactions\";\n    Table[\"TransactionScripts\"] = \"transactionScripts\";\n    Table[\"InputNotes\"] = \"inputNotes\";\n    Table[\"OutputNotes\"] = \"outputNotes\";\n    Table[\"NotesScripts\"] = \"notesScripts\";\n    Table[\"StateSync\"] = \"stateSync\";\n    Table[\"BlockHeaders\"] = \"blockHeaders\";\n    Table[\"PartialBlockchainNodes\"] = \"partialBlockchainNodes\";\n    Table[\"Tags\"] = \"tags\";\n    Table[\"ForeignAccountCode\"] = \"foreignAccountCode\";\n    Table[\"Settings\"] = \"settings\";\n    Table[\"TrackedAccounts\"] = \"trackedAccounts\";\n})(Table || (Table = {}));\nconst db = new Dexie(DATABASE_NAME);\ndb.version(1).stores({\n    [Table.AccountCode]: indexes(\"root\"),\n    [Table.AccountStorage]: indexes(\"[commitment+slotIndex]\", \"commitment\"),\n    [Table.StorageMapEntries]: indexes(\"[root+key]\", \"root\"),\n    [Table.AccountAssets]: indexes(\"[root+vaultKey]\", \"root\", \"faucetIdPrefix\"),\n    [Table.AccountAuth]: indexes(\"pubKey\"),\n    [Table.Accounts]: indexes(\"&accountCommitment\", \"id\", \"[id+nonce]\", \"codeRoot\", \"storageRoot\", \"vaultRoot\"),\n    [Table.Addresses]: indexes(\"address\", \"id\"),\n    [Table.Transactions]: indexes(\"id\", \"statusVariant\"),\n    [Table.TransactionScripts]: indexes(\"scriptRoot\"),\n    [Table.InputNotes]: indexes(\"noteId\", \"nullifier\", \"stateDiscriminant\"),\n    [Table.OutputNotes]: indexes(\"noteId\", \"recipientDigest\", \"stateDiscriminant\", \"nullifier\"),\n    [Table.NotesScripts]: indexes(\"scriptRoot\"),\n    [Table.StateSync]: indexes(\"id\"),\n    [Table.BlockHeaders]: indexes(\"blockNum\", \"hasClientNotes\"),\n    [Table.PartialBlockchainNodes]: indexes(\"id\"),\n    [Table.Tags]: indexes(\"id++\", \"tag\", \"source_note_id\", \"source_account_id\"),\n    [Table.ForeignAccountCode]: indexes(\"accountId\"),\n    [Table.Settings]: indexes(\"key\"),\n    [Table.TrackedAccounts]: indexes(\"&id\"),\n});\nfunction indexes(...items) {\n    return items.join(\",\");\n}\ndb.on(\"populate\", () => {\n    // Populate the stateSync table with default values\n    stateSync\n        .put({ id: 1, blockNum: \"0\" })\n        .catch((err) => logWebStoreError(err, \"Failed to populate DB\"));\n});\nconst accountCodes = db.table(Table.AccountCode);\nconst accountStorages = db.table(Table.AccountStorage);\nconst storageMapEntries = db.table(Table.StorageMapEntries);\nconst accountAssets = db.table(Table.AccountAssets);\nconst accountAuths = db.table(Table.AccountAuth);\nconst accounts = db.table(Table.Accounts);\nconst addresses = db.table(Table.Addresses);\nconst transactions = db.table(Table.Transactions);\nconst transactionScripts = db.table(Table.TransactionScripts);\nconst inputNotes = db.table(Table.InputNotes);\nconst outputNotes = db.table(Table.OutputNotes);\nconst notesScripts = db.table(Table.NotesScripts);\nconst stateSync = db.table(Table.StateSync);\nconst blockHeaders = db.table(Table.BlockHeaders);\nconst partialBlockchainNodes = db.table(Table.PartialBlockchainNodes);\nconst tags = db.table(Table.Tags);\nconst foreignAccountCode = db.table(Table.ForeignAccountCode);\nconst settings = db.table(Table.Settings);\nconst trackedAccounts = db.table(Table.TrackedAccounts);\n\n// GET FUNCTIONS\nasync function getAccountIds() {\n    try {\n        const tracked = await trackedAccounts.toArray();\n        return tracked.map((entry) => entry.id);\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error while fetching account IDs\");\n    }\n    return [];\n}\nasync function getAllAccountHeaders() {\n    try {\n        // Use a Map to track the latest record for each id based on nonce\n        const latestRecordsMap = new Map();\n        await accounts.each((record) => {\n            const existingRecord = latestRecordsMap.get(record.id);\n            if (!existingRecord ||\n                BigInt(record.nonce) > BigInt(existingRecord.nonce)) {\n                latestRecordsMap.set(record.id, record);\n            }\n        });\n        // Extract the latest records from the Map\n        const latestRecords = Array.from(latestRecordsMap.values());\n        const resultObject = await Promise.all(latestRecords.map((record) => {\n            let accountSeedBase64 = undefined;\n            if (record.accountSeed) {\n                const seedAsBytes = new Uint8Array(record.accountSeed);\n                if (seedAsBytes.length > 0) {\n                    accountSeedBase64 = uint8ArrayToBase64(seedAsBytes);\n                }\n            }\n            return {\n                id: record.id,\n                nonce: record.nonce,\n                vaultRoot: record.vaultRoot, // Fallback if missing\n                storageRoot: record.storageRoot || \"\",\n                codeRoot: record.codeRoot || \"\",\n                accountSeed: accountSeedBase64, // null or base64 string\n                locked: record.locked,\n                committed: record.committed, // Use actual value or default\n                accountCommitment: record.accountCommitment || \"\", // Keep original field name\n            };\n        }));\n        return resultObject;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error while fetching account headers\");\n    }\n}\nasync function getAccountHeader(accountId) {\n    try {\n        // Fetch all records matching the given id\n        const allMatchingRecords = await accounts\n            .where(\"id\")\n            .equals(accountId)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No account header record found for given ID.\");\n            return null;\n        }\n        // Convert nonce to BigInt and sort\n        // Note: This assumes all nonces are valid BigInt strings.\n        const sortedRecords = allMatchingRecords.sort((a, b) => {\n            const bigIntA = BigInt(a.nonce);\n            const bigIntB = BigInt(b.nonce);\n            return bigIntA > bigIntB ? -1 : bigIntA < bigIntB ? 1 : 0;\n        });\n        // The first record is the most recent one due to the sorting\n        const mostRecentRecord = sortedRecords[0];\n        if (mostRecentRecord === undefined) {\n            return null;\n        }\n        let accountSeedBase64 = undefined;\n        if (mostRecentRecord.accountSeed) {\n            // Ensure accountSeed is processed as a Uint8Array and converted to Base64\n            if (mostRecentRecord.accountSeed.length > 0) {\n                accountSeedBase64 = uint8ArrayToBase64(mostRecentRecord.accountSeed);\n            }\n        }\n        const AccountHeader = {\n            id: mostRecentRecord.id,\n            nonce: mostRecentRecord.nonce,\n            vaultRoot: mostRecentRecord.vaultRoot,\n            storageRoot: mostRecentRecord.storageRoot,\n            codeRoot: mostRecentRecord.codeRoot,\n            accountSeed: accountSeedBase64,\n            locked: mostRecentRecord.locked,\n        };\n        return AccountHeader;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching account header for id: ${accountId}`);\n    }\n}\nasync function getAccountHeaderByCommitment(accountCommitment) {\n    try {\n        // Fetch all records matching the given commitment\n        const allMatchingRecords = await accounts\n            .where(\"accountCommitment\")\n            .equals(accountCommitment)\n            .toArray();\n        if (allMatchingRecords.length == 0) {\n            return undefined;\n        }\n        // There should be only one match\n        const matchingRecord = allMatchingRecords[0];\n        if (matchingRecord === undefined) {\n            console.log(\"No account header record found for given commitment.\");\n            return null;\n        }\n        let accountSeedBase64 = undefined;\n        if (matchingRecord.accountSeed) {\n            accountSeedBase64 = uint8ArrayToBase64(matchingRecord.accountSeed);\n        }\n        const AccountHeader = {\n            id: matchingRecord.id,\n            nonce: matchingRecord.nonce,\n            vaultRoot: matchingRecord.vaultRoot,\n            storageRoot: matchingRecord.storageRoot,\n            codeRoot: matchingRecord.codeRoot,\n            accountSeed: accountSeedBase64,\n            locked: matchingRecord.locked,\n        };\n        return AccountHeader;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account header for commitment ${accountCommitment}`);\n    }\n}\nasync function getAccountCode(codeRoot) {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await accountCodes\n            .where(\"root\")\n            .equals(codeRoot)\n            .toArray();\n        // The first record is the only one due to the uniqueness constraint\n        const codeRecord = allMatchingRecords[0];\n        if (codeRecord === undefined) {\n            console.log(\"No records found for given code root.\");\n            return null;\n        }\n        // Convert the code Blob to an ArrayBuffer\n        const codeBase64 = uint8ArrayToBase64(codeRecord.code);\n        return {\n            root: codeRecord.root,\n            code: codeBase64,\n        };\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account code for root ${codeRoot}`);\n    }\n}\nasync function getAccountStorage(storageCommitment) {\n    try {\n        const allMatchingRecords = await accountStorages\n            .where(\"commitment\")\n            .equals(storageCommitment)\n            .toArray();\n        const slots = allMatchingRecords.map((record) => {\n            return {\n                slotIndex: record.slotIndex,\n                slotValue: record.slotValue,\n                slotType: record.slotType,\n            };\n        });\n        return slots;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account storage for commitment ${storageCommitment}`);\n    }\n}\nasync function getAccountStorageMaps(roots) {\n    try {\n        const allMatchingRecords = await storageMapEntries\n            .where(\"root\")\n            .anyOf(roots)\n            .toArray();\n        return allMatchingRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account storage maps for roots ${roots.join(\", \")}`);\n    }\n}\nasync function getAccountVaultAssets(vaultRoot) {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await accountAssets\n            .where(\"root\")\n            .equals(vaultRoot)\n            .toArray();\n        // Map the records to their asset values\n        const assets = allMatchingRecords.map((record) => {\n            return {\n                asset: record.asset,\n            };\n        });\n        return assets;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account vault for root ${vaultRoot}`);\n    }\n}\nasync function getAccountAuthByPubKey(pubKey) {\n    // Try to get the account auth from the store\n    const accountSecretKey = await accountAuths\n        .where(\"pubKey\")\n        .equals(pubKey)\n        .first();\n    // If it's not in the cache, throw an error\n    if (!accountSecretKey) {\n        throw new Error(\"Account auth not found in cache.\");\n    }\n    const data = {\n        secretKey: accountSecretKey.secretKey,\n    };\n    return data;\n}\nasync function getAccountAddresses(accountId) {\n    try {\n        // Fetch all records matching the given accountId\n        const allMatchingRecords = await addresses\n            .where(\"id\")\n            .equals(accountId)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No address records found for given account ID.\");\n            return [];\n        }\n        return allMatchingRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching account addresses for id: ${accountId}`);\n    }\n}\n// INSERT FUNCTIONS\nasync function upsertAccountCode(codeRoot, code) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            root: codeRoot, // Using codeRoot as the key\n            code,\n        };\n        // Perform the insert using Dexie\n        await accountCodes.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting code with root: ${codeRoot}`);\n    }\n}\nasync function upsertAccountStorage(storageSlots) {\n    try {\n        let processedSlots = storageSlots.map((slot) => {\n            return {\n                commitment: slot.commitment,\n                slotIndex: slot.slotIndex,\n                slotValue: slot.slotValue,\n                slotType: slot.slotType,\n            };\n        });\n        await accountStorages.bulkPut(processedSlots);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting storage slots`);\n    }\n}\nasync function upsertStorageMapEntries(entries) {\n    try {\n        let processedEntries = entries.map((entry) => {\n            return {\n                root: entry.root,\n                key: entry.key,\n                value: entry.value,\n            };\n        });\n        await storageMapEntries.bulkPut(processedEntries);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting storage map entries`);\n    }\n}\nasync function upsertVaultAssets(assets) {\n    try {\n        let processedAssets = assets.map((asset) => {\n            return {\n                root: asset.root,\n                vaultKey: asset.vaultKey,\n                faucetIdPrefix: asset.faucetIdPrefix,\n                asset: asset.asset,\n            };\n        });\n        await accountAssets.bulkPut(processedAssets);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting assets`);\n    }\n}\nasync function upsertAccountRecord(accountId, codeRoot, storageRoot, vaultRoot, nonce, committed, commitment, accountSeed) {\n    try {\n        const data = {\n            id: accountId,\n            codeRoot,\n            storageRoot,\n            vaultRoot,\n            nonce,\n            committed,\n            accountSeed,\n            accountCommitment: commitment,\n            locked: false,\n        };\n        await accounts.put(data);\n        await trackedAccounts.put({ id: accountId });\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting account: ${accountId}`);\n    }\n}\nasync function insertAccountAuth(pubKey, secretKey) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            pubKey: pubKey,\n            secretKey: secretKey,\n        };\n        // Perform the insert using Dexie\n        await accountAuths.add(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting account auth for pubKey: ${pubKey}`);\n    }\n}\nasync function insertAccountAddress(address, accountId) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            address,\n            id: accountId,\n        };\n        // Perform the insert using Dexie\n        await addresses.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting address with value: ${String(address)} for the account ID ${accountId}`);\n    }\n}\nasync function removeAccountAddress(address) {\n    try {\n        // Perform the delete using Dexie\n        await addresses.where(\"address\").equals(address).delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error removing address with value: ${String(address)}`);\n    }\n}\nasync function upsertForeignAccountCode(accountId, code, codeRoot) {\n    try {\n        await upsertAccountCode(codeRoot, code);\n        const data = {\n            accountId,\n            codeRoot,\n        };\n        await foreignAccountCode.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error upserting foreign account code for account: ${accountId}`);\n    }\n}\nasync function getForeignAccountCode(accountIds) {\n    try {\n        const foreignAccounts = await foreignAccountCode\n            .where(\"accountId\")\n            .anyOf(accountIds)\n            .toArray();\n        if (foreignAccounts.length === 0) {\n            console.log(\"No records found for the given account IDs.\");\n            return null; // No records found\n        }\n        const codeRoots = foreignAccounts.map((account) => account.codeRoot);\n        const accountCode = await accountCodes\n            .where(\"root\")\n            .anyOf(codeRoots)\n            .toArray();\n        const processedCode = foreignAccounts\n            .map((foreignAccount) => {\n            const matchingCode = accountCode.find((code) => code.root === foreignAccount.codeRoot);\n            if (matchingCode === undefined) {\n                return undefined;\n            }\n            const codeBase64 = uint8ArrayToBase64(matchingCode.code);\n            return {\n                accountId: foreignAccount.accountId,\n                code: codeBase64,\n            };\n        })\n            .filter((matchingCode) => matchingCode !== undefined);\n        return processedCode;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetching foreign account code\");\n    }\n}\nasync function lockAccount(accountId) {\n    try {\n        await accounts.where(\"id\").equals(accountId).modify({ locked: true });\n    }\n    catch (error) {\n        logWebStoreError(error, `Error locking account: ${accountId}`);\n    }\n}\n// Delete functions\nasync function undoAccountStates(accountCommitments) {\n    try {\n        await accounts\n            .where(\"accountCommitment\")\n            .anyOf(accountCommitments)\n            .delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error undoing account states: ${accountCommitments.join(\",\")}`);\n    }\n}\n\n// INSERT FUNCTIONS\nasync function insertBlockHeader(blockNum, header, partialBlockchainPeaks, hasClientNotes) {\n    try {\n        const data = {\n            blockNum: blockNum,\n            header,\n            partialBlockchainPeaks,\n            hasClientNotes: hasClientNotes.toString(),\n        };\n        const existingBlockHeader = await blockHeaders.get(blockNum);\n        if (!existingBlockHeader) {\n            await blockHeaders.add(data);\n        }\n        else {\n            console.log(\"Block header already exists, checking for update.\");\n            // Update the hasClientNotes if the existing value is false\n            if (existingBlockHeader.hasClientNotes === \"false\" && hasClientNotes) {\n                await blockHeaders.update(blockNum, {\n                    hasClientNotes: hasClientNotes.toString(),\n                });\n                console.log(\"Updated hasClientNotes to true.\");\n            }\n            else {\n                console.log(\"No update needed for hasClientNotes.\");\n            }\n        }\n    }\n    catch (err) {\n        logWebStoreError(err);\n    }\n}\nasync function insertPartialBlockchainNodes(ids, nodes) {\n    try {\n        // Check if the arrays are not of the same length\n        if (ids.length !== nodes.length) {\n            throw new Error(\"ids and nodes arrays must be of the same length\");\n        }\n        if (ids.length === 0) {\n            return;\n        }\n        // Create array of objects with id and node\n        const data = nodes.map((node, index) => ({\n            id: ids[index],\n            node: node,\n        }));\n        // Use bulkPut to add/overwrite the entries\n        await partialBlockchainNodes.bulkPut(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert partial blockchain nodes\");\n    }\n}\n// GET FUNCTIONS\nasync function getBlockHeaders(blockNumbers) {\n    try {\n        const results = await blockHeaders.bulkGet(blockNumbers);\n        const processedResults = await Promise.all(results.map((result) => {\n            if (result === undefined) {\n                return null;\n            }\n            else {\n                const headerBase64 = uint8ArrayToBase64(result.header);\n                const partialBlockchainPeaksBase64 = uint8ArrayToBase64(result.partialBlockchainPeaks);\n                return {\n                    blockNum: result.blockNum,\n                    header: headerBase64,\n                    partialBlockchainPeaks: partialBlockchainPeaksBase64,\n                    hasClientNotes: result.hasClientNotes === \"true\",\n                };\n            }\n        }));\n        return processedResults;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get block headers\");\n    }\n}\nasync function getTrackedBlockHeaders() {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await blockHeaders\n            .where(\"hasClientNotes\")\n            .equals(\"true\")\n            .toArray();\n        // Process all records with async operations\n        const processedRecords = await Promise.all(allMatchingRecords.map((record) => {\n            const headerBase64 = uint8ArrayToBase64(record.header);\n            const partialBlockchainPeaksBase64 = uint8ArrayToBase64(record.partialBlockchainPeaks);\n            return {\n                blockNum: record.blockNum,\n                header: headerBase64,\n                partialBlockchainPeaks: partialBlockchainPeaksBase64,\n                hasClientNotes: record.hasClientNotes === \"true\",\n            };\n        }));\n        return processedRecords;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get tracked block headers\");\n    }\n}\nasync function getPartialBlockchainPeaksByBlockNum(blockNum) {\n    try {\n        const blockHeader = await blockHeaders.get(blockNum);\n        if (blockHeader == undefined) {\n            return {\n                peaks: undefined,\n            };\n        }\n        const partialBlockchainPeaksBase64 = uint8ArrayToBase64(blockHeader.partialBlockchainPeaks);\n        return {\n            peaks: partialBlockchainPeaksBase64,\n        };\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain peaks\");\n    }\n}\nasync function getPartialBlockchainNodesAll() {\n    try {\n        const partialBlockchainNodesAll = await partialBlockchainNodes.toArray();\n        return partialBlockchainNodesAll;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain nodes\");\n    }\n}\nasync function getPartialBlockchainNodes(ids) {\n    try {\n        const results = await partialBlockchainNodes.bulkGet(ids);\n        return results;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain nodes\");\n    }\n}\nasync function pruneIrrelevantBlocks() {\n    try {\n        const syncHeight = await stateSync.get(1);\n        if (syncHeight == undefined) {\n            throw Error(\"SyncHeight is undefined -- is the state sync table empty?\");\n        }\n        const allMatchingRecords = await blockHeaders\n            .where(\"hasClientNotes\")\n            .equals(\"false\")\n            .and((record) => record.blockNum !== \"0\" && record.blockNum !== syncHeight.blockNum)\n            .toArray();\n        await blockHeaders.bulkDelete(allMatchingRecords.map((r) => r.blockNum));\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to prune irrelevant blocks\");\n    }\n}\n\n// Disabling `any` checks since this file mostly deals with exporting DB types.\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n/* eslint-disable  @typescript-eslint/no-unsafe-return */\n/* eslint-disable  @typescript-eslint/no-unsafe-assignment */\nasync function recursivelyTransformForExport(obj) {\n    switch (obj.type) {\n        case \"Uint8Array\":\n            return Array.from(obj.value);\n        case \"Blob\":\n            return {\n                __type: \"Blob\",\n                data: uint8ArrayToBase64(new Uint8Array(await obj.value.arrayBuffer())),\n            };\n        case \"Array\":\n            return await Promise.all(obj.value.map((v) => recursivelyTransformForExport({ type: getInputType(v), value: v })));\n        case \"Record\":\n            return Object.fromEntries(await Promise.all(Object.entries(obj.value).map(async ([key, value]) => [\n                key,\n                await recursivelyTransformForExport({\n                    type: getInputType(value),\n                    value,\n                }),\n            ])));\n        case \"Primitive\":\n            return obj.value;\n    }\n}\nfunction getInputType(value) {\n    if (value instanceof Uint8Array)\n        return \"Uint8Array\";\n    if (value instanceof Blob)\n        return \"Blob\";\n    if (Array.isArray(value))\n        return \"Array\";\n    if (value && typeof value === \"object\")\n        return \"Record\";\n    return \"Primitive\";\n}\nasync function transformForExport(obj) {\n    return recursivelyTransformForExport({ type: getInputType(obj), value: obj });\n}\nasync function exportStore() {\n    const dbJson = {};\n    for (const table of db.tables) {\n        const records = await table.toArray();\n        dbJson[table.name] = await Promise.all(records.map(transformForExport));\n    }\n    return JSON.stringify(dbJson);\n}\n\n// Disabling `any` checks since this file mostly deals\n// with importing DB types and we're testing this which\n// should be enough + the TS compiler.\n/* eslint-disable */\nasync function recursivelyTransformForImport(obj) {\n    switch (obj.type) {\n        case \"Blob\":\n            return new Blob([base64ToUint8Array(obj.value.data)]);\n        case \"Array\":\n            return await Promise.all(obj.value.map((v) => recursivelyTransformForImport({ type: getImportType(v), value: v })));\n        case \"Object\":\n            return Object.fromEntries(await Promise.all(Object.entries(obj.value).map(async ([key, value]) => [\n                key,\n                await recursivelyTransformForImport({\n                    type: getImportType(value),\n                    value,\n                }),\n            ])));\n        case \"Primitive\":\n            return obj.value;\n    }\n}\nfunction getImportType(value) {\n    if (value && typeof value === \"object\" && value.__type === \"Blob\") {\n        return \"Blob\";\n    }\n    if (Array.isArray(value))\n        return \"Array\";\n    if (value && typeof value === \"object\")\n        return \"Object\";\n    return \"Primitive\";\n}\nasync function transformForImport(obj) {\n    return recursivelyTransformForImport({\n        type: getImportType(obj),\n        value: obj,\n    });\n}\nasync function forceImportStore(jsonStr) {\n    try {\n        if (!db.isOpen) {\n            await openDatabase();\n        }\n        let dbJson = JSON.parse(jsonStr);\n        if (typeof dbJson === \"string\") {\n            dbJson = JSON.parse(dbJson);\n        }\n        const jsonTableNames = Object.keys(dbJson);\n        const dbTableNames = db.tables.map((t) => t.name);\n        if (jsonTableNames.length === 0) {\n            throw new Error(\"No tables found in the provided JSON.\");\n        }\n        await db.transaction(\"rw\", dbTableNames, async () => {\n            await Promise.all(db.tables.map((t) => t.clear()));\n            for (const tableName of jsonTableNames) {\n                const table = db.table(tableName);\n                if (!dbTableNames.includes(tableName)) {\n                    console.warn(`Table \"${tableName}\" does not exist in the database schema. Skipping.`);\n                    continue;\n                }\n                const records = dbJson[tableName];\n                const transformedRecords = await Promise.all(records.map(transformForImport));\n                await table.bulkPut(transformedRecords);\n            }\n        });\n        console.log(\"Store imported successfully.\");\n    }\n    catch (err) {\n        logWebStoreError(err);\n    }\n}\nfunction base64ToUint8Array(base64) {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n\nasync function getOutputNotes(states) {\n    try {\n        let notes = states.length == 0\n            ? await outputNotes.toArray()\n            : await outputNotes.where(\"stateDiscriminant\").anyOf(states).toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes\");\n    }\n}\nasync function getInputNotes(states) {\n    try {\n        let notes;\n        if (states.length === 0) {\n            notes = await inputNotes.toArray();\n        }\n        else {\n            notes = await inputNotes\n                .where(\"stateDiscriminant\")\n                .anyOf(states)\n                .toArray();\n        }\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes\");\n    }\n}\nasync function getInputNotesFromIds(noteIds) {\n    try {\n        let notes = await inputNotes.where(\"noteId\").anyOf(noteIds).toArray();\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes from IDs\");\n    }\n}\nasync function getInputNotesFromNullifiers(nullifiers) {\n    try {\n        let notes = await inputNotes.where(\"nullifier\").anyOf(nullifiers).toArray();\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes from nullifiers\");\n    }\n}\nasync function getOutputNotesFromNullifiers(nullifiers) {\n    try {\n        let notes = await outputNotes\n            .where(\"nullifier\")\n            .anyOf(nullifiers)\n            .toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes from nullifiers\");\n    }\n}\nasync function getOutputNotesFromIds(noteIds) {\n    try {\n        let notes = await outputNotes.where(\"noteId\").anyOf(noteIds).toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes from IDs\");\n    }\n}\nasync function getUnspentInputNoteNullifiers() {\n    try {\n        const notes = await inputNotes\n            .where(\"stateDiscriminant\")\n            .anyOf([2, 4, 5])\n            .toArray();\n        return notes.map((note) => note.nullifier);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get unspent input note nullifiers\");\n    }\n}\nasync function getNoteScript(scriptRoot) {\n    try {\n        const noteScript = await notesScripts\n            .where(\"scriptRoot\")\n            .equals(scriptRoot)\n            .first();\n        return noteScript;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get note script from root\");\n    }\n}\nasync function upsertInputNote(noteId, assets, serialNumber, inputs, scriptRoot, serializedNoteScript, nullifier, serializedCreatedAt, stateDiscriminant, state) {\n    return db.transaction(\"rw\", inputNotes, notesScripts, async (tx) => {\n        try {\n            const data = {\n                noteId,\n                assets,\n                serialNumber,\n                inputs,\n                scriptRoot,\n                nullifier,\n                state,\n                stateDiscriminant,\n                serializedCreatedAt,\n            };\n            await tx.inputNotes.put(data);\n            const noteScriptData = {\n                scriptRoot,\n                serializedNoteScript,\n            };\n            await tx.notesScripts.put(noteScriptData);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note: ${noteId}`);\n        }\n    });\n}\nasync function upsertOutputNote(noteId, assets, recipientDigest, metadata, nullifier, expectedHeight, stateDiscriminant, state) {\n    return db.transaction(\"rw\", outputNotes, notesScripts, async (tx) => {\n        try {\n            const data = {\n                noteId,\n                assets,\n                recipientDigest,\n                metadata,\n                nullifier: nullifier ? nullifier : undefined,\n                expectedHeight,\n                stateDiscriminant,\n                state,\n            };\n            await tx.outputNotes.put(data);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note: ${noteId}`);\n        }\n    });\n}\nasync function processInputNotes(notes) {\n    return await Promise.all(notes.map(async (note) => {\n        const assetsBase64 = uint8ArrayToBase64(note.assets);\n        const serialNumberBase64 = uint8ArrayToBase64(note.serialNumber);\n        const inputsBase64 = uint8ArrayToBase64(note.inputs);\n        let serializedNoteScriptBase64 = undefined;\n        if (note.scriptRoot) {\n            let record = await notesScripts.get(note.scriptRoot);\n            if (record) {\n                serializedNoteScriptBase64 = uint8ArrayToBase64(record.serializedNoteScript);\n            }\n        }\n        const stateBase64 = uint8ArrayToBase64(note.state);\n        return {\n            assets: assetsBase64,\n            serialNumber: serialNumberBase64,\n            inputs: inputsBase64,\n            createdAt: note.serializedCreatedAt,\n            serializedNoteScript: serializedNoteScriptBase64,\n            state: stateBase64,\n        };\n    }));\n}\nasync function processOutputNotes(notes) {\n    return await Promise.all(notes.map((note) => {\n        const assetsBase64 = uint8ArrayToBase64(note.assets);\n        const metadataBase64 = uint8ArrayToBase64(note.metadata);\n        const stateBase64 = uint8ArrayToBase64(note.state);\n        return {\n            assets: assetsBase64,\n            recipientDigest: note.recipientDigest,\n            metadata: metadataBase64,\n            expectedHeight: note.expectedHeight,\n            state: stateBase64,\n        };\n    }));\n}\nasync function upsertNoteScript(scriptRoot, serializedNoteScript) {\n    return db.transaction(\"rw\", outputNotes, notesScripts, async (tx) => {\n        try {\n            const noteScriptData = {\n                scriptRoot,\n                serializedNoteScript,\n            };\n            await tx.notesScripts.put(noteScriptData);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note script: ${scriptRoot}`);\n        }\n    });\n}\n\nasync function getSetting(key) {\n    try {\n        // Fetch all records matching the given key\n        const allMatchingRecords = await settings\n            .where(\"key\")\n            .equals(key)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No setting record found for given key.\");\n            return null;\n        }\n        // There should be only one match\n        const matchingRecord = allMatchingRecords[0];\n        // Convert the setting value to base64\n        const valueBase64 = uint8ArrayToBase64(matchingRecord.value);\n        return {\n            key: matchingRecord.key,\n            value: valueBase64,\n        };\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching setting key: ${key}`);\n    }\n}\nasync function insertSetting(key, value) {\n    try {\n        const setting = {\n            key,\n            value,\n        };\n        await settings.put(setting);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting setting with key: ${key} and value(base64): ${uint8ArrayToBase64(value)}`);\n    }\n}\nasync function removeSetting(key) {\n    try {\n        await settings.where(\"key\").equals(key).delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error deleting setting with key: ${key}`);\n    }\n}\nasync function listSettingKeys() {\n    try {\n        const keys = await settings\n            .toArray()\n            .then((settings) => settings.map((setting) => setting.key));\n        return keys;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error listing setting keys`);\n    }\n}\n\nconst IDS_FILTER_PREFIX = \"Ids:\";\nconst EXPIRED_BEFORE_FILTER_PREFIX = \"ExpiredPending:\";\nconst STATUS_COMMITTED_VARIANT = 1;\nconst STATUS_DISCARDED_VARIANT = 2;\nasync function getTransactions(filter) {\n    let transactionRecords = [];\n    try {\n        if (filter === \"Uncommitted\") {\n            transactionRecords = await transactions\n                .filter((tx) => tx.statusVariant !== STATUS_COMMITTED_VARIANT)\n                .toArray();\n        }\n        else if (filter.startsWith(IDS_FILTER_PREFIX)) {\n            const idsString = filter.substring(IDS_FILTER_PREFIX.length);\n            const ids = idsString.split(\",\");\n            if (ids.length > 0) {\n                transactionRecords = await transactions\n                    .where(\"id\")\n                    .anyOf(ids)\n                    .toArray();\n            }\n            else {\n                transactionRecords = [];\n            }\n        }\n        else if (filter.startsWith(EXPIRED_BEFORE_FILTER_PREFIX)) {\n            const blockNumString = filter.substring(EXPIRED_BEFORE_FILTER_PREFIX.length);\n            const blockNum = parseInt(blockNumString);\n            transactionRecords = await transactions\n                .filter((tx) => tx.blockNum < blockNum &&\n                tx.statusVariant !== STATUS_COMMITTED_VARIANT &&\n                tx.statusVariant !== STATUS_DISCARDED_VARIANT)\n                .toArray();\n        }\n        else {\n            transactionRecords = await transactions.toArray();\n        }\n        if (transactionRecords.length === 0) {\n            return [];\n        }\n        const scriptRoots = transactionRecords\n            .map((transactionRecord) => {\n            return transactionRecord.scriptRoot;\n        })\n            .filter((scriptRoot) => scriptRoot != undefined);\n        const scripts = await transactionScripts\n            .where(\"scriptRoot\")\n            .anyOf(scriptRoots)\n            .toArray();\n        // Create a map of scriptRoot to script for quick lookup\n        const scriptMap = new Map();\n        scripts.forEach((script) => {\n            if (script.txScript) {\n                scriptMap.set(script.scriptRoot, script.txScript);\n            }\n        });\n        const processedTransactions = await Promise.all(transactionRecords.map((transactionRecord) => {\n            let txScriptBase64 = undefined;\n            if (transactionRecord.scriptRoot) {\n                const txScript = scriptMap.get(transactionRecord.scriptRoot);\n                if (txScript) {\n                    txScriptBase64 = uint8ArrayToBase64(txScript);\n                }\n            }\n            const detailsBase64 = uint8ArrayToBase64(transactionRecord.details);\n            const statusBase64 = uint8ArrayToBase64(transactionRecord.status);\n            const data = {\n                id: transactionRecord.id,\n                details: detailsBase64,\n                scriptRoot: transactionRecord.scriptRoot,\n                txScript: txScriptBase64,\n                blockNum: transactionRecord.blockNum.toString(),\n                statusVariant: transactionRecord.statusVariant,\n                status: statusBase64,\n            };\n            return data;\n        }));\n        return processedTransactions;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get transactions\");\n    }\n}\nasync function insertTransactionScript(scriptRoot, txScript) {\n    try {\n        const scriptRootArray = new Uint8Array(scriptRoot);\n        const scriptRootBase64 = uint8ArrayToBase64(scriptRootArray);\n        const data = {\n            scriptRoot: scriptRootBase64,\n            txScript: mapOption(txScript, (txScript) => new Uint8Array(txScript)),\n        };\n        await transactionScripts.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to insert transaction script\");\n    }\n}\nasync function upsertTransactionRecord(transactionId, details, blockNum, statusVariant, status, scriptRoot) {\n    try {\n        const data = {\n            id: transactionId,\n            details,\n            scriptRoot: mapOption(scriptRoot, (root) => uint8ArrayToBase64(root)),\n            blockNum: parseInt(blockNum, 10),\n            statusVariant,\n            status,\n        };\n        await transactions.put(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert proven transaction data\");\n    }\n}\n\nasync function getNoteTags() {\n    try {\n        let records = await tags.toArray();\n        let processedRecords = records.map((record) => {\n            record.sourceNoteId =\n                record.sourceNoteId == \"\" ? undefined : record.sourceNoteId;\n            record.sourceAccountId =\n                record.sourceAccountId == \"\" ? undefined : record.sourceAccountId;\n            return record;\n        });\n        return processedRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetch tag record\");\n    }\n}\nasync function getSyncHeight() {\n    try {\n        const record = await stateSync.get(1); // Since id is the primary key and always 1\n        if (record) {\n            let data = {\n                blockNum: record.blockNum,\n            };\n            return data;\n        }\n        else {\n            return null;\n        }\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetching sync height\");\n    }\n}\nasync function addNoteTag(tag, sourceNoteId, sourceAccountId) {\n    try {\n        let tagArray = new Uint8Array(tag);\n        let tagBase64 = uint8ArrayToBase64(tagArray);\n        await tags.add({\n            tag: tagBase64,\n            sourceNoteId: sourceNoteId ? sourceNoteId : \"\",\n            sourceAccountId: sourceAccountId ? sourceAccountId : \"\",\n        });\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to add note tag\");\n    }\n}\nasync function removeNoteTag(tag, sourceNoteId, sourceAccountId) {\n    try {\n        let tagArray = new Uint8Array(tag);\n        let tagBase64 = uint8ArrayToBase64(tagArray);\n        return await tags\n            .where({\n            tag: tagBase64,\n            sourceNoteId: sourceNoteId ? sourceNoteId : \"\",\n            sourceAccountId: sourceAccountId ? sourceAccountId : \"\",\n        })\n            .delete();\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to remove note tag\");\n    }\n}\n/*\n * Takes a `JsStateSyncUpdate` object and writes the state update into the store.\n * @param {JsStateSyncUpdate}\n */\nasync function applyStateSync(stateUpdate) {\n    const { blockNum, // Target block number for this sync\n    flattenedNewBlockHeaders, // Serialized block headers to be reconstructed\n    flattenedPartialBlockChainPeaks, // Serialized blockchain peaks for verification\n    newBlockNums, // Block numbers corresponding to new headers\n    blockHasRelevantNotes, // Flags indicating which blocks have relevant notes\n    serializedNodeIds, // IDs for new authentication nodes\n    serializedNodes, // Authentication node data for merkle proofs\n    committedNoteIds, // Note tags to be cleaned up/removed\n    serializedInputNotes, // Input notes consumed in transactions\n    serializedOutputNotes, // Output notes created in transactions\n    accountUpdates, // Account state changes\n    transactionUpdates, // Transaction records and scripts\n     } = stateUpdate;\n    // Block headers and Blockchain peaks are flattened before calling\n    // this function, here we rebuild them.\n    const newBlockHeaders = reconstructFlattenedVec(flattenedNewBlockHeaders);\n    const partialBlockchainPeaks = reconstructFlattenedVec(flattenedPartialBlockChainPeaks);\n    // Create promises to insert each input note. Each note will have its own transaction,\n    // and therefore, nested inside the final transaction inside this function.\n    let inputNotesWriteOp = Promise.all(serializedInputNotes.map((note) => {\n        return upsertInputNote(note.noteId, note.noteAssets, note.serialNumber, note.inputs, note.noteScriptRoot, note.noteScript, note.nullifier, note.createdAt, note.stateDiscriminant, note.state);\n    }));\n    // See comment above, the same thing applies here, but for Output Notes.\n    let outputNotesWriteOp = Promise.all(serializedOutputNotes.map((note) => {\n        return upsertOutputNote(note.noteId, note.noteAssets, note.recipientDigest, note.metadata, note.nullifier, note.expectedHeight, note.stateDiscriminant, note.state);\n    }));\n    // Promises to insert each transaction update.\n    let transactionWriteOp = Promise.all(transactionUpdates.map((transactionRecord) => {\n        let promises = [\n            upsertTransactionRecord(transactionRecord.id, transactionRecord.details, transactionRecord.blockNum, transactionRecord.statusVariant, transactionRecord.status, transactionRecord.scriptRoot),\n        ];\n        if (transactionRecord.scriptRoot && transactionRecord.txScript) {\n            promises.push(insertTransactionScript(transactionRecord.scriptRoot, transactionRecord.txScript));\n        }\n        return Promise.all(promises);\n    }));\n    // Promises to insert each account update.\n    let accountUpdatesWriteOp = Promise.all(accountUpdates.flatMap((accountUpdate) => {\n        return [\n            upsertAccountStorage(accountUpdate.storageSlots),\n            upsertStorageMapEntries(accountUpdate.storageMapEntries),\n            upsertVaultAssets(accountUpdate.assets),\n            upsertAccountRecord(accountUpdate.accountId, accountUpdate.codeRoot, accountUpdate.storageRoot, accountUpdate.assetVaultRoot, accountUpdate.nonce, accountUpdate.committed, accountUpdate.accountCommitment, accountUpdate.accountSeed),\n        ];\n    }));\n    const tablesToAccess = [\n        stateSync,\n        inputNotes,\n        outputNotes,\n        transactions,\n        blockHeaders,\n        partialBlockchainNodes,\n        tags,\n    ];\n    // Write everything in a single transaction, this transaction will atomically do the operations\n    // below, since every operation here (or at least, most of them), is done in a nested transaction.\n    // For more information on this, check: https://dexie.org/docs/Dexie/Dexie.transaction()\n    return await db.transaction(\"rw\", tablesToAccess, async (tx) => {\n        // Everything is under a single promise since otherwise the tx expires.\n        await Promise.all([\n            inputNotesWriteOp,\n            outputNotesWriteOp,\n            transactionWriteOp,\n            accountUpdatesWriteOp,\n            updateSyncHeight(tx, blockNum),\n            updatePartialBlockchainNodes(tx, serializedNodeIds, serializedNodes),\n            updateCommittedNoteTags(tx, committedNoteIds),\n            Promise.all(newBlockHeaders.map((newBlockHeader, i) => {\n                return updateBlockHeader(tx, newBlockNums[i], newBlockHeader, partialBlockchainPeaks[i], blockHasRelevantNotes[i] == 1);\n            })),\n        ]);\n    });\n}\nasync function updateSyncHeight(tx, blockNum) {\n    try {\n        await tx.stateSync.update(1, { blockNum: blockNum });\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to update sync height\");\n    }\n}\nasync function updateBlockHeader(tx, blockNum, blockHeader, partialBlockchainPeaks, hasClientNotes) {\n    try {\n        const data = {\n            blockNum: blockNum,\n            header: blockHeader,\n            partialBlockchainPeaks,\n            hasClientNotes: hasClientNotes.toString(),\n        };\n        const existingBlockHeader = await tx.blockHeaders.get(blockNum);\n        if (!existingBlockHeader) {\n            await tx.blockHeaders.add(data);\n        }\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert block header\");\n    }\n}\nasync function updatePartialBlockchainNodes(tx, nodeIndexes, nodes) {\n    try {\n        // Check if the arrays are not of the same length\n        if (nodeIndexes.length !== nodes.length) {\n            throw new Error(\"nodeIndexes and nodes arrays must be of the same length\");\n        }\n        if (nodeIndexes.length === 0) {\n            return;\n        }\n        // Create array of objects with id and node\n        const data = nodes.map((node, index) => ({\n            id: nodeIndexes[index],\n            node: node,\n        }));\n        // Use bulkPut to add/overwrite the entries\n        await tx.partialBlockchainNodes.bulkPut(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to update partial blockchain nodes\");\n    }\n}\nasync function updateCommittedNoteTags(tx, inputNoteIds) {\n    try {\n        for (let i = 0; i < inputNoteIds.length; i++) {\n            const noteId = inputNoteIds[i];\n            // Remove note tags\n            await tx.tags.where(\"source_note_id\").equals(noteId).delete();\n        }\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to pudate committed note tags\");\n    }\n}\n// Helper function to reconstruct arrays from flattened data\nfunction reconstructFlattenedVec(flattenedVec) {\n    const data = flattenedVec.data();\n    const lengths = flattenedVec.lengths();\n    let index = 0;\n    const result = [];\n    lengths.forEach((length) => {\n        result.push(data.slice(index, index + length));\n        index += length;\n    });\n    return result;\n}\n\nlet wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export4(addHeapObject(e));\n    }\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getDataViewMemory0();\n    const result = [];\n    for (let i = ptr; i < ptr + 4 * len; i += 4) {\n        result.push(takeObject(mem.getUint32(i, true)));\n    }\n    return result;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => state.dtor(state.a, state.b));\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            state.a = a;\n            real._wbg_cb_unref();\n        }\n    };\n    real._wbg_cb_unref = () => {\n        if (--state.cnt === 0) {\n            state.dtor(state.a, state.b);\n            state.a = 0;\n            CLOSURE_DTORS.unregister(state);\n        }\n    };\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    const mem = getDataViewMemory0();\n    for (let i = 0; i < array.length; i++) {\n        mem.setUint32(ptr + 4 * i, addHeapObject(array[i]), true);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nlet cachedBigUint64ArrayMemory0 = null;\n\nfunction getBigUint64ArrayMemory0() {\n    if (cachedBigUint64ArrayMemory0 === null || cachedBigUint64ArrayMemory0.byteLength === 0) {\n        cachedBigUint64ArrayMemory0 = new BigUint64Array(wasm.memory.buffer);\n    }\n    return cachedBigUint64ArrayMemory0;\n}\n\nfunction passArray64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8, 8) >>> 0;\n    getBigUint64ArrayMemory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU64FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getBigUint64ArrayMemory0().subarray(ptr / 8, ptr / 8 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\nfunction __wasm_bindgen_func_elem_9375(arg0, arg1, arg2) {\n    wasm.__wasm_bindgen_func_elem_9375(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wasm_bindgen_func_elem_9309(arg0, arg1) {\n    wasm.__wasm_bindgen_func_elem_9309(arg0, arg1);\n}\n\nfunction __wasm_bindgen_func_elem_3677(arg0, arg1, arg2, arg3) {\n    wasm.__wasm_bindgen_func_elem_3677(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n * @enum {0}\n */\nconst AccountInterface = Object.freeze({\n    BasicWallet: 0, \"0\": \"BasicWallet\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nconst AccountType = Object.freeze({\n    FungibleFaucet: 0, \"0\": \"FungibleFaucet\",\n    NonFungibleFaucet: 1, \"1\": \"NonFungibleFaucet\",\n    RegularAccountImmutableCode: 2, \"2\": \"RegularAccountImmutableCode\",\n    RegularAccountUpdatableCode: 3, \"3\": \"RegularAccountUpdatableCode\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8}\n */\nconst InputNoteState = Object.freeze({\n    Expected: 0, \"0\": \"Expected\",\n    Unverified: 1, \"1\": \"Unverified\",\n    Committed: 2, \"2\": \"Committed\",\n    Invalid: 3, \"3\": \"Invalid\",\n    ProcessingAuthenticated: 4, \"4\": \"ProcessingAuthenticated\",\n    ProcessingUnauthenticated: 5, \"5\": \"ProcessingUnauthenticated\",\n    ConsumedAuthenticatedLocal: 6, \"6\": \"ConsumedAuthenticatedLocal\",\n    ConsumedUnauthenticatedLocal: 7, \"7\": \"ConsumedUnauthenticatedLocal\",\n    ConsumedExternal: 8, \"8\": \"ConsumedExternal\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst NetworkId = Object.freeze({\n    Mainnet: 0, \"0\": \"Mainnet\",\n    Testnet: 1, \"1\": \"Testnet\",\n    Devnet: 2, \"2\": \"Devnet\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8}\n */\nconst NoteFilterTypes = Object.freeze({\n    All: 0, \"0\": \"All\",\n    Consumed: 1, \"1\": \"Consumed\",\n    Committed: 2, \"2\": \"Committed\",\n    Expected: 3, \"3\": \"Expected\",\n    Processing: 4, \"4\": \"Processing\",\n    List: 5, \"5\": \"List\",\n    Unique: 6, \"6\": \"Unique\",\n    Nullifiers: 7, \"7\": \"Nullifiers\",\n    Unverified: 8, \"8\": \"Unverified\",\n});\n/**\n * @enum {2 | 3 | 1}\n */\nconst NoteType = Object.freeze({\n    /**\n     * Notes with this type have only their hash published to the network.\n     */\n    Private: 2, \"2\": \"Private\",\n    /**\n     * Notes with this type are shared with the network encrypted.\n     */\n    Encrypted: 3, \"3\": \"Encrypted\",\n    /**\n     * Notes with this type are fully shared with the network.\n     */\n    Public: 1, \"1\": \"Public\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst SigningInputsType = Object.freeze({\n    TransactionSummary: 0, \"0\": \"TransactionSummary\",\n    Arbitrary: 1, \"1\": \"Arbitrary\",\n    Blind: 2, \"2\": \"Blind\",\n});\n\nconst __wbindgen_enum_AddressInterface = [\"BasicWallet\"];\n\nconst __wbindgen_enum_ReadableStreamType = [\"bytes\"];\n\nconst __wbindgen_enum_ReferrerPolicy = [\"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"origin\", \"origin-when-cross-origin\", \"unsafe-url\", \"same-origin\", \"strict-origin\", \"strict-origin-when-cross-origin\"];\n\nconst __wbindgen_enum_RequestCache = [\"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\"];\n\nconst __wbindgen_enum_RequestCredentials = [\"omit\", \"same-origin\", \"include\"];\n\nconst __wbindgen_enum_RequestMode = [\"same-origin\", \"no-cors\", \"cors\", \"navigate\"];\n\nconst __wbindgen_enum_RequestRedirect = [\"follow\", \"error\", \"manual\"];\n\nconst AccountFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_account_free(ptr >>> 0, 1));\n\nclass Account {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Account.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Account)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_account_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.account_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.account_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonce() {\n        const ret = wasm.account_nonce(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {AssetVault}\n     */\n    vault() {\n        const ret = wasm.account_vault(this.__wbg_ptr);\n        return AssetVault.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorage}\n     */\n    storage() {\n        const ret = wasm.account_storage(this.__wbg_ptr);\n        return AccountStorage.__wrap(ret);\n    }\n    /**\n     * @returns {AccountCode}\n     */\n    code() {\n        const ret = wasm.account_code(this.__wbg_ptr);\n        return AccountCode.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFaucet() {\n        const ret = wasm.account_isFaucet(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isRegularAccount() {\n        const ret = wasm.account_isRegularAccount(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isUpdatable() {\n        const ret = wasm.account_isUpdatable(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPublic() {\n        const ret = wasm.account_isPublic(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPrivate() {\n        const ret = wasm.account_isPrivate(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNetwork() {\n        const ret = wasm.account_isNetwork(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNew() {\n        const ret = wasm.account_isNew(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.account_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Account}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.account_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Account.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {Word[]}\n     */\n    getPublicKeys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.account_getPublicKeys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Account.prototype[Symbol.dispose] = Account.prototype.free;\n\nconst AccountArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountarray_free(ptr >>> 0, 1));\n\nclass AccountArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountarray_free(ptr, 0);\n    }\n    /**\n     * @param {Account[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        AccountArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {Account}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Account.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {Account} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Account);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.accountarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Account} element\n     */\n    push(element) {\n        _assertClass(element, Account);\n        wasm.accountarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.accountarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) AccountArray.prototype[Symbol.dispose] = AccountArray.prototype.free;\n\nconst AccountBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountbuilder_free(ptr >>> 0, 1));\n\nclass AccountBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountbuilder_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array} init_seed\n     */\n    constructor(init_seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountbuilder_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            AccountBuilderFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountType} account_type\n     * @returns {AccountBuilder}\n     */\n    accountType(account_type) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountbuilder_accountType(ptr, account_type);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @returns {AccountBuilder}\n     */\n    storageMode(storage_mode) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(storage_mode, AccountStorageMode);\n        const ret = wasm.accountbuilder_storageMode(ptr, storage_mode.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountComponent} account_component\n     * @returns {AccountBuilder}\n     */\n    withComponent(account_component) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(account_component, AccountComponent);\n        const ret = wasm.accountbuilder_withComponent(ptr, account_component.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountComponent} account_component\n     * @returns {AccountBuilder}\n     */\n    withAuthComponent(account_component) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(account_component, AccountComponent);\n        const ret = wasm.accountbuilder_withAuthComponent(ptr, account_component.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {AccountBuilder}\n     */\n    withNoAuthComponent() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountbuilder_withNoAuthComponent(ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {AccountBuilderResult}\n     */\n    build() {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountbuilder_build(retptr, ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountBuilderResult.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountBuilder.prototype[Symbol.dispose] = AccountBuilder.prototype.free;\n\nconst AccountBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountbuilderresult_free(ptr >>> 0, 1));\n\nclass AccountBuilderResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountBuilderResult.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountBuilderResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountbuilderresult_free(ptr, 0);\n    }\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        const ret = wasm.accountbuilderresult_account(this.__wbg_ptr);\n        return Account.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    get seed() {\n        const ret = wasm.accountbuilderresult_seed(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountBuilderResult.prototype[Symbol.dispose] = AccountBuilderResult.prototype.free;\n\nconst AccountCodeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountcode_free(ptr >>> 0, 1));\n\nclass AccountCode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountCode.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountCodeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountCodeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountcode_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {Word} mast_root\n     * @returns {boolean}\n     */\n    hasProcedure(mast_root) {\n        _assertClass(mast_root, Word);\n        var ptr0 = mast_root.__destroy_into_raw();\n        const ret = wasm.accountcode_hasProcedure(this.__wbg_ptr, ptr0);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) AccountCode.prototype[Symbol.dispose] = AccountCode.prototype.free;\n\nconst AccountComponentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountcomponent_free(ptr >>> 0, 1));\n\nclass AccountComponent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountComponent.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountComponentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountComponentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountcomponent_free(ptr, 0);\n    }\n    /**\n     * @param {string} account_code\n     * @param {ScriptBuilder} builder\n     * @param {StorageSlot[]} storage_slots\n     * @returns {AccountComponent}\n     */\n    static compile(account_code, builder, storage_slots) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(account_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            _assertClass(builder, ScriptBuilder);\n            const ptr1 = passArrayJsValueToWasm0(storage_slots, wasm.__wbindgen_export);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.accountcomponent_compile(retptr, ptr0, len0, builder.__wbg_ptr, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountComponent}\n     */\n    withSupportsAllTypes() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountcomponent_withSupportsAllTypes(ptr);\n        return AccountComponent.__wrap(ret);\n    }\n    /**\n     * @param {string} procedure_name\n     * @returns {string}\n     */\n    getProcedureHash(procedure_name) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(procedure_name, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountcomponent_getProcedureHash(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @returns {GetProceduresResultItem[]}\n     */\n    getProcedures() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountcomponent_getProcedures(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {SecretKey} secret_key\n     * @returns {AccountComponent}\n     */\n    static createAuthComponent(secret_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(secret_key, SecretKey);\n            wasm.accountcomponent_createAuthComponent(retptr, secret_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Package} _package\n     * @param {StorageSlotArray} storage_slots\n     * @returns {AccountComponent}\n     */\n    static fromPackage(_package, storage_slots) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_package, Package);\n            _assertClass(storage_slots, StorageSlotArray);\n            wasm.accountcomponent_fromPackage(retptr, _package.__wbg_ptr, storage_slots.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountComponent.prototype[Symbol.dispose] = AccountComponent.prototype.free;\n\nconst AccountDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountdelta_free(ptr >>> 0, 1));\n\nclass AccountDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountdelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {AccountStorageDelta}\n     */\n    storage() {\n        const ret = wasm.accountdelta_storage(this.__wbg_ptr);\n        return AccountStorageDelta.__wrap(ret);\n    }\n    /**\n     * @returns {AccountVaultDelta}\n     */\n    vault() {\n        const ret = wasm.accountdelta_vault(this.__wbg_ptr);\n        return AccountVaultDelta.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonceDelta() {\n        const ret = wasm.accountdelta_nonceDelta(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountDelta.prototype[Symbol.dispose] = AccountDelta.prototype.free;\n\nconst AccountFileFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountfile_free(ptr >>> 0, 1));\n\nclass AccountFile {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountFile.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountFileFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountFileFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountfile_free(ptr, 0);\n    }\n    /**\n     * Serializes the `AccountFile` into a byte array\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountfile_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a byte array into an `AccountFile`\n     * @param {Uint8Array} bytes\n     * @returns {AccountFile}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountfile_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountFile.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) AccountFile.prototype[Symbol.dispose] = AccountFile.prototype.free;\n\nconst AccountHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountheader_free(ptr >>> 0, 1));\n\nclass AccountHeader {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountHeader.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountHeaderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountheader_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.accountheader_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonce() {\n        const ret = wasm.accountheader_nonce(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    vaultCommitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    storageCommitment() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    codeCommitment() {\n        const ret = wasm.accountheader_codeCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountHeader.prototype[Symbol.dispose] = AccountHeader.prototype.free;\n\nconst AccountIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountid_free(ptr >>> 0, 1));\n\nclass AccountId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountId.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof AccountId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountid_free(ptr, 0);\n    }\n    /**\n     * @param {string} hex\n     * @returns {AccountId}\n     */\n    static fromHex(hex) {\n        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountid_fromHex(ptr0, len0);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFaucet() {\n        const ret = wasm.accountid_isFaucet(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isRegularAccount() {\n        const ret = wasm.accountid_isRegularAccount(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPublic() {\n        const ret = wasm.accountid_isPublic(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPrivate() {\n        const ret = wasm.accountid_isPrivate(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNetwork() {\n        const ret = wasm.accountid_isNetwork(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountid_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Will turn the Account ID into its bech32 string representation. To avoid a potential\n     * wrongful encoding, this function will expect only IDs for either mainnet (\"mm\"),\n     * testnet (\"mtst\") or devnet (\"mdev\"). To use a custom bech32 prefix, see\n     * `Self::to_bech_32_custom`.\n     * @param {NetworkId} network_id\n     * @param {AccountInterface} account_interface\n     * @returns {string}\n     */\n    toBech32(network_id, account_interface) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountid_toBech32(retptr, this.__wbg_ptr, network_id, account_interface);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Turn this Account ID into its bech32 string representation. This method accepts a custom\n     * network ID.\n     * @param {string} custom_network_id\n     * @param {AccountInterface} account_interface\n     * @returns {string}\n     */\n    toBech32Custom(custom_network_id, account_interface) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(custom_network_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountid_toBech32Custom(retptr, this.__wbg_ptr, ptr0, len0, account_interface);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @returns {Felt}\n     */\n    prefix() {\n        const ret = wasm.accountid_prefix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    suffix() {\n        const ret = wasm.accountid_suffix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountId.prototype[Symbol.dispose] = AccountId.prototype.free;\n\nconst AccountIdArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountidarray_free(ptr >>> 0, 1));\n\nclass AccountIdArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountIdArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountidarray_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountidarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        AccountIdArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {AccountId}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountidarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {AccountId} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, AccountId);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.accountidarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} element\n     */\n    push(element) {\n        _assertClass(element, AccountId);\n        wasm.accountidarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.accountidarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) AccountIdArray.prototype[Symbol.dispose] = AccountIdArray.prototype.free;\n\nconst AccountStorageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstorage_free(ptr >>> 0, 1));\n\nclass AccountStorage {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorage.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstorage_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountstorage_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @returns {Word | undefined}\n     */\n    getItem(index) {\n        const ret = wasm.accountstorage_getItem(this.__wbg_ptr, index);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @param {Word} key\n     * @returns {Word | undefined}\n     */\n    getMapItem(index, key) {\n        _assertClass(key, Word);\n        const ret = wasm.accountstorage_getMapItem(this.__wbg_ptr, index, key.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * Get all key-value pairs from the map slot at `index`.\n     * Returns `undefined` if the slot isn't a map or `index` is out of bounds (0-255).\n     * Returns `[]` if the map exists but is empty.\n     * @param {number} index\n     * @returns {JsStorageMapEntry[] | undefined}\n     */\n    getMapEntries(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstorage_getMapEntries(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorage.prototype[Symbol.dispose] = AccountStorage.prototype.free;\n\nconst AccountStorageDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragedelta_free(ptr >>> 0, 1));\n\nclass AccountStorageDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragedelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountstoragedelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountStorageDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragedelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountstoragedelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    values() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragedelta_values(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageDelta.prototype[Symbol.dispose] = AccountStorageDelta.prototype.free;\n\nconst AccountStorageModeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragemode_free(ptr >>> 0, 1));\n\nclass AccountStorageMode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageMode.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageModeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageModeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragemode_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static private() {\n        const ret = wasm.accountstoragemode_private();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static public() {\n        const ret = wasm.accountstoragemode_public();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static network() {\n        const ret = wasm.accountstoragemode_network();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @param {string} s\n     * @returns {AccountStorageMode}\n     */\n    static tryFromStr(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountstoragemode_tryFromStr(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageMode.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    asStr() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragemode_asStr(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageMode.prototype[Symbol.dispose] = AccountStorageMode.prototype.free;\n\nconst AccountStorageRequirementsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragerequirements_free(ptr >>> 0, 1));\n\nclass AccountStorageRequirements {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageRequirements.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageRequirementsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageRequirementsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragerequirements_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.accountstoragerequirements_new();\n        this.__wbg_ptr = ret >>> 0;\n        AccountStorageRequirementsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {SlotAndKeys[]} slots_and_keys\n     * @returns {AccountStorageRequirements}\n     */\n    static fromSlotAndKeysArray(slots_and_keys) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(slots_and_keys, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountstoragerequirements_fromSlotAndKeysArray(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageRequirements.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageRequirements.prototype[Symbol.dispose] = AccountStorageRequirements.prototype.free;\n\nconst AccountVaultDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountvaultdelta_free(ptr >>> 0, 1));\n\nclass AccountVaultDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountVaultDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountVaultDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountVaultDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountvaultdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountvaultdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountVaultDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountVaultDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountstoragedelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {FungibleAssetDelta}\n     */\n    fungible() {\n        const ret = wasm.accountvaultdelta_fungible(this.__wbg_ptr);\n        return FungibleAssetDelta.__wrap(ret);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    addedFungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_addedFungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    removedFungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_removedFungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountVaultDelta.prototype[Symbol.dispose] = AccountVaultDelta.prototype.free;\n\nconst AddressFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr >>> 0, 1));\n\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n        AddressFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AddressFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {string | null} [_interface]\n     * @returns {Address}\n     */\n    static fromAccountId(account_id, _interface) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account_id, AccountId);\n            var ptr0 = isLikeNone(_interface) ? 0 : passStringToWasm0(_interface, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_fromAccountId(retptr, account_id.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} bech32\n     * @returns {Address}\n     */\n    static fromBech32(bech32) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_fromBech32(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AddressInterface}\n     */\n    interface() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_interface(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return __wbindgen_enum_AddressInterface[r0];\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_accountId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    toNoteTag() {\n        const ret = wasm.address_toNoteTag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {NetworkId} network_id\n     * @returns {string}\n     */\n    toBech32(network_id) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_toBech32(retptr, this.__wbg_ptr, network_id);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Address.prototype[Symbol.dispose] = Address.prototype.free;\n\nconst AdviceInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_adviceinputs_free(ptr >>> 0, 1));\n\nclass AdviceInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AdviceInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        AdviceInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AdviceInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_adviceinputs_free(ptr, 0);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    stack() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.adviceinputs_stack(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Word} key\n     * @returns {Felt[] | undefined}\n     */\n    mappedValues(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, Word);\n            wasm.adviceinputs_mappedValues(retptr, this.__wbg_ptr, key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AdviceInputs.prototype[Symbol.dispose] = AdviceInputs.prototype.free;\n\nconst AdviceMapFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_advicemap_free(ptr >>> 0, 1));\n\nclass AdviceMap {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AdviceMapFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_advicemap_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.accountstoragerequirements_new();\n        this.__wbg_ptr = ret >>> 0;\n        AdviceMapFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {Word} key\n     * @param {FeltArray} value\n     * @returns {Felt[] | undefined}\n     */\n    insert(key, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, Word);\n            _assertClass(value, FeltArray);\n            wasm.advicemap_insert(retptr, this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AdviceMap.prototype[Symbol.dispose] = AdviceMap.prototype.free;\n\nconst AssetVaultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_assetvault_free(ptr >>> 0, 1));\n\nclass AssetVault {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AssetVault.prototype);\n        obj.__wbg_ptr = ptr;\n        AssetVaultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AssetVaultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetvault_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @returns {bigint}\n     */\n    getBalance(faucet_id) {\n        _assertClass(faucet_id, AccountId);\n        const ret = wasm.assetvault_getBalance(this.__wbg_ptr, faucet_id.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    fungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetvault_fungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AssetVault.prototype[Symbol.dispose] = AssetVault.prototype.free;\n\nconst AuthSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_authsecretkey_free(ptr >>> 0, 1));\n\nclass AuthSecretKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AuthSecretKey.prototype);\n        obj.__wbg_ptr = ptr;\n        AuthSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AuthSecretKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_authsecretkey_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    getRpoFalcon512PublicKeyAsWord() {\n        const ret = wasm.authsecretkey_getRpoFalcon512PublicKeyAsWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    getRpoFalcon512SecretKeyAsFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.authsecretkey_getRpoFalcon512SecretKeyAsFelts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    getEcdsaK256KeccakPublicKeyAsWord() {\n        const ret = wasm.authsecretkey_getEcdsaK256KeccakPublicKeyAsWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    getEcdsaK256KeccakSecretKeyAsFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.authsecretkey_getEcdsaK256KeccakSecretKeyAsFelts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AuthSecretKey.prototype[Symbol.dispose] = AuthSecretKey.prototype.free;\n\nconst BasicFungibleFaucetComponentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_basicfungiblefaucetcomponent_free(ptr >>> 0, 1));\n\nclass BasicFungibleFaucetComponent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BasicFungibleFaucetComponent.prototype);\n        obj.__wbg_ptr = ptr;\n        BasicFungibleFaucetComponentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BasicFungibleFaucetComponentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_basicfungiblefaucetcomponent_free(ptr, 0);\n    }\n    /**\n     * @param {Account} account\n     * @returns {BasicFungibleFaucetComponent}\n     */\n    static fromAccount(account) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account, Account);\n            var ptr0 = account.__destroy_into_raw();\n            wasm.basicfungiblefaucetcomponent_fromAccount(retptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BasicFungibleFaucetComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {TokenSymbol}\n     */\n    symbol() {\n        const ret = wasm.accountid_prefix(this.__wbg_ptr);\n        return TokenSymbol.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    decimals() {\n        const ret = wasm.basicfungiblefaucetcomponent_decimals(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Felt}\n     */\n    maxSupply() {\n        const ret = wasm.accountid_suffix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) BasicFungibleFaucetComponent.prototype[Symbol.dispose] = BasicFungibleFaucetComponent.prototype.free;\n\nconst BlockHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_blockheader_free(ptr >>> 0, 1));\n\nclass BlockHeader {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BlockHeader.prototype);\n        obj.__wbg_ptr = ptr;\n        BlockHeaderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BlockHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    version() {\n        const ret = wasm.blockheader_version(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.blockheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    subCommitment() {\n        const ret = wasm.blockheader_subCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    prevBlockCommitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.blockheader_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    chainCommitment() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    accountRoot() {\n        const ret = wasm.accountheader_codeCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    nullifierRoot() {\n        const ret = wasm.blockheader_nullifierRoot(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    noteRoot() {\n        const ret = wasm.blockheader_noteRoot(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    txCommitment() {\n        const ret = wasm.blockheader_txCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    txKernelCommitment() {\n        const ret = wasm.accountbuilderresult_seed(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    proofCommitment() {\n        const ret = wasm.blockheader_proofCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    timestamp() {\n        const ret = wasm.blockheader_timestamp(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) BlockHeader.prototype[Symbol.dispose] = BlockHeader.prototype.free;\n\nconst ConsumableNoteRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_consumablenoterecord_free(ptr >>> 0, 1));\n\nclass ConsumableNoteRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ConsumableNoteRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        ConsumableNoteRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ConsumableNoteRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_consumablenoterecord_free(ptr, 0);\n    }\n    /**\n     * @param {InputNoteRecord} input_note_record\n     * @param {NoteConsumability[]} note_consumability\n     */\n    constructor(input_note_record, note_consumability) {\n        _assertClass(input_note_record, InputNoteRecord);\n        var ptr0 = input_note_record.__destroy_into_raw();\n        const ptr1 = passArrayJsValueToWasm0(note_consumability, wasm.__wbindgen_export);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.consumablenoterecord_new(ptr0, ptr1, len1);\n        this.__wbg_ptr = ret >>> 0;\n        ConsumableNoteRecordFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {InputNoteRecord}\n     */\n    inputNoteRecord() {\n        const ret = wasm.consumablenoterecord_inputNoteRecord(this.__wbg_ptr);\n        return InputNoteRecord.__wrap(ret);\n    }\n    /**\n     * @returns {NoteConsumability[]}\n     */\n    noteConsumability() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.consumablenoterecord_noteConsumability(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ConsumableNoteRecord.prototype[Symbol.dispose] = ConsumableNoteRecord.prototype.free;\n\nconst EndpointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_endpoint_free(ptr >>> 0, 1));\n/**\n * Represents a network endpoint for connecting to Miden nodes.\n *\n * An endpoint consists of a protocol (http/https), host, and optional port.\n * Provides convenient constructors for common network configurations.\n */\nclass Endpoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Endpoint.prototype);\n        obj.__wbg_ptr = ptr;\n        EndpointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EndpointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_endpoint_free(ptr, 0);\n    }\n    /**\n     * Creates an endpoint from a URL string.\n     *\n     * @param url - The URL string (e.g., <https://localhost:57291>)\n     * @throws throws an error if the URL is invalid\n     * @param {string} url\n     */\n    constructor(url) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.endpoint_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            EndpointFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the endpoint for the Miden testnet.\n     * @returns {Endpoint}\n     */\n    static testnet() {\n        const ret = wasm.endpoint_testnet();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the endpoint for the Miden devnet.\n     * @returns {Endpoint}\n     */\n    static devnet() {\n        const ret = wasm.endpoint_devnet();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the endpoint for a local Miden node.\n     *\n     * Uses <http://localhost:57291>\n     * @returns {Endpoint}\n     */\n    static localhost() {\n        const ret = wasm.endpoint_localhost();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the protocol of the endpoint.\n     * @returns {string}\n     */\n    get protocol() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_protocol(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the host of the endpoint.\n     * @returns {string}\n     */\n    get host() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_host(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the port of the endpoint.\n     * @returns {number | undefined}\n     */\n    get port() {\n        const ret = wasm.endpoint_port(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n     * Returns the string representation of the endpoint.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Endpoint.prototype[Symbol.dispose] = Endpoint.prototype.free;\n\nconst ExecutedTransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_executedtransaction_free(ptr >>> 0, 1));\n\nclass ExecutedTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutedTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutedTransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutedTransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executedtransaction_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.executedtransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.executedtransaction_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountHeader}\n     */\n    initialAccountHeader() {\n        const ret = wasm.executedtransaction_initialAccountHeader(this.__wbg_ptr);\n        return AccountHeader.__wrap(ret);\n    }\n    /**\n     * @returns {AccountHeader}\n     */\n    finalAccountHeader() {\n        const ret = wasm.executedtransaction_finalAccountHeader(this.__wbg_ptr);\n        return AccountHeader.__wrap(ret);\n    }\n    /**\n     * @returns {InputNotes}\n     */\n    inputNotes() {\n        const ret = wasm.executedtransaction_inputNotes(this.__wbg_ptr);\n        return InputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.executedtransaction_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionArgs}\n     */\n    txArgs() {\n        const ret = wasm.executedtransaction_txArgs(this.__wbg_ptr);\n        return TransactionArgs.__wrap(ret);\n    }\n    /**\n     * @returns {BlockHeader}\n     */\n    blockHeader() {\n        const ret = wasm.executedtransaction_blockHeader(this.__wbg_ptr);\n        return BlockHeader.__wrap(ret);\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        const ret = wasm.executedtransaction_accountDelta(this.__wbg_ptr);\n        return AccountDelta.__wrap(ret);\n    }\n}\nif (Symbol.dispose) ExecutedTransaction.prototype[Symbol.dispose] = ExecutedTransaction.prototype.free;\n\nconst FeltFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_felt_free(ptr >>> 0, 1));\n\nclass Felt {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Felt.prototype);\n        obj.__wbg_ptr = ptr;\n        FeltFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Felt)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FeltFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_felt_free(ptr, 0);\n    }\n    /**\n     * @param {bigint} value\n     */\n    constructor(value) {\n        const ret = wasm.felt_new(value);\n        this.__wbg_ptr = ret >>> 0;\n        FeltFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {bigint}\n     */\n    asInt() {\n        const ret = wasm.felt_asInt(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.felt_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Felt.prototype[Symbol.dispose] = Felt.prototype.free;\n\nconst FeltArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_feltarray_free(ptr >>> 0, 1));\n\nclass FeltArray {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FeltArray.prototype);\n        obj.__wbg_ptr = ptr;\n        FeltArrayFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FeltArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_feltarray_free(ptr, 0);\n    }\n    /**\n     * @param {Felt[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.feltarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        FeltArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {Felt}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.feltarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Felt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {Felt} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Felt);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.feltarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Felt} element\n     */\n    push(element) {\n        _assertClass(element, Felt);\n        wasm.feltarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.feltarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) FeltArray.prototype[Symbol.dispose] = FeltArray.prototype.free;\n\nconst FetchedNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fetchednote_free(ptr >>> 0, 1));\n/**\n * Represents a note fetched from a Miden node via RPC.\n */\nclass FetchedNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FetchedNote.prototype);\n        obj.__wbg_ptr = ptr;\n        FetchedNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FetchedNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fetchednote_free(ptr, 0);\n    }\n    /**\n     * Create a note with an optional `InputNote`.\n     * @param {NoteId} note_id\n     * @param {NoteMetadata} metadata\n     * @param {InputNote | null} [input_note]\n     */\n    constructor(note_id, metadata, input_note) {\n        _assertClass(note_id, NoteId);\n        var ptr0 = note_id.__destroy_into_raw();\n        _assertClass(metadata, NoteMetadata);\n        var ptr1 = metadata.__destroy_into_raw();\n        let ptr2 = 0;\n        if (!isLikeNone(input_note)) {\n            _assertClass(input_note, InputNote);\n            ptr2 = input_note.__destroy_into_raw();\n        }\n        const ret = wasm.fetchednote_new(ptr0, ptr1, ptr2);\n        this.__wbg_ptr = ret >>> 0;\n        FetchedNoteFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The unique identifier of the note.\n     * @returns {NoteId}\n     */\n    get noteId() {\n        const ret = wasm.fetchednote_noteId(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * The note's metadata, including sender, tag, and other properties.\n     * Available for both private and public notes.\n     * @returns {NoteMetadata}\n     */\n    get metadata() {\n        const ret = wasm.fetchednote_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * The full [`InputNote`] with inclusion proof.\n     *\n     * For public notes, it contains the complete note data and inclusion proof.\n     * For private notes, it will be ``None`.\n     * @returns {InputNote | undefined}\n     */\n    get inputNote() {\n        const ret = wasm.fetchednote_inputNote(this.__wbg_ptr);\n        return ret === 0 ? undefined : InputNote.__wrap(ret);\n    }\n    /**\n     * @returns {NoteType}\n     */\n    get noteType() {\n        const ret = wasm.fetchednote_noteType(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) FetchedNote.prototype[Symbol.dispose] = FetchedNote.prototype.free;\n\nconst FlattenedU8VecFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_flattenedu8vec_free(ptr >>> 0, 1));\n\nclass FlattenedU8Vec {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FlattenedU8Vec.prototype);\n        obj.__wbg_ptr = ptr;\n        FlattenedU8VecFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FlattenedU8VecFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_flattenedu8vec_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    data() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.flattenedu8vec_data(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint32Array}\n     */\n    lengths() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.flattenedu8vec_lengths(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    num_inner_vecs() {\n        const ret = wasm.flattenedu8vec_num_inner_vecs(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) FlattenedU8Vec.prototype[Symbol.dispose] = FlattenedU8Vec.prototype.free;\n\nconst ForeignAccountFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_foreignaccount_free(ptr >>> 0, 1));\n\nclass ForeignAccount {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ForeignAccount.prototype);\n        obj.__wbg_ptr = ptr;\n        ForeignAccountFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof ForeignAccount)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ForeignAccountFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_foreignaccount_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {AccountStorageRequirements} storage_requirements\n     * @returns {ForeignAccount}\n     */\n    static public(account_id, storage_requirements) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account_id, AccountId);\n            var ptr0 = account_id.__destroy_into_raw();\n            _assertClass(storage_requirements, AccountStorageRequirements);\n            var ptr1 = storage_requirements.__destroy_into_raw();\n            wasm.foreignaccount_public(retptr, ptr0, ptr1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ForeignAccount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountStorageRequirements}\n     */\n    storage_slot_requirements() {\n        const ret = wasm.foreignaccount_storage_slot_requirements(this.__wbg_ptr);\n        return AccountStorageRequirements.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    account_id() {\n        const ret = wasm.foreignaccount_account_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n}\nif (Symbol.dispose) ForeignAccount.prototype[Symbol.dispose] = ForeignAccount.prototype.free;\n\nconst ForeignAccountArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_foreignaccountarray_free(ptr >>> 0, 1));\n\nclass ForeignAccountArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ForeignAccountArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_foreignaccountarray_free(ptr, 0);\n    }\n    /**\n     * @param {ForeignAccount[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.foreignaccountarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        ForeignAccountArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {ForeignAccount}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.foreignaccountarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ForeignAccount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {ForeignAccount} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, ForeignAccount);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.foreignaccountarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {ForeignAccount} element\n     */\n    push(element) {\n        _assertClass(element, ForeignAccount);\n        wasm.foreignaccountarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.foreignaccountarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) ForeignAccountArray.prototype[Symbol.dispose] = ForeignAccountArray.prototype.free;\n\nconst FungibleAssetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleasset_free(ptr >>> 0, 1));\n\nclass FungibleAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAsset.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof FungibleAsset)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleasset_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @param {bigint} amount\n     */\n    constructor(faucet_id, amount) {\n        _assertClass(faucet_id, AccountId);\n        const ret = wasm.fungibleasset_new(faucet_id.__wbg_ptr, amount);\n        this.__wbg_ptr = ret >>> 0;\n        FungibleAssetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {AccountId}\n     */\n    faucetId() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    amount() {\n        const ret = wasm.fungibleasset_amount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    intoWord() {\n        const ret = wasm.fungibleasset_intoWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) FungibleAsset.prototype[Symbol.dispose] = FungibleAsset.prototype.free;\n\nconst FungibleAssetDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleassetdelta_free(ptr >>> 0, 1));\n\nclass FungibleAssetDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAssetDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleassetdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.fungibleassetdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {FungibleAssetDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fungibleassetdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FungibleAssetDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.fungibleassetdelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @returns {bigint | undefined}\n     */\n    amount(faucet_id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(faucet_id, AccountId);\n            wasm.fungibleassetdelta_amount(retptr, this.__wbg_ptr, faucet_id.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    numAssets() {\n        const ret = wasm.fungibleassetdelta_numAssets(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {FungibleAssetDeltaItem[]}\n     */\n    assets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fungibleassetdelta_assets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) FungibleAssetDelta.prototype[Symbol.dispose] = FungibleAssetDelta.prototype.free;\n\nconst FungibleAssetDeltaItemFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleassetdeltaitem_free(ptr >>> 0, 1));\n\nclass FungibleAssetDeltaItem {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAssetDeltaItem.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetDeltaItemFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetDeltaItemFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleassetdeltaitem_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    get faucetId() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    get amount() {\n        const ret = wasm.fungibleasset_amount(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) FungibleAssetDeltaItem.prototype[Symbol.dispose] = FungibleAssetDeltaItem.prototype.free;\n\nconst GetProceduresResultItemFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_getproceduresresultitem_free(ptr >>> 0, 1));\n\nclass GetProceduresResultItem {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GetProceduresResultItem.prototype);\n        obj.__wbg_ptr = ptr;\n        GetProceduresResultItemFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GetProceduresResultItemFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_getproceduresresultitem_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    get digest() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    get isAuth() {\n        const ret = wasm.getproceduresresultitem_isAuth(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) GetProceduresResultItem.prototype[Symbol.dispose] = GetProceduresResultItem.prototype.free;\n\nconst InputNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnote_free(ptr >>> 0, 1));\n\nclass InputNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNote.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnote_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.inputnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Note}\n     */\n    note() {\n        const ret = wasm.inputnote_note(this.__wbg_ptr);\n        return Note.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.inputnote_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInclusionProof | undefined}\n     */\n    proof() {\n        const ret = wasm.inputnote_proof(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteInclusionProof.__wrap(ret);\n    }\n    /**\n     * @returns {NoteLocation | undefined}\n     */\n    location() {\n        const ret = wasm.inputnote_location(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteLocation.__wrap(ret);\n    }\n}\nif (Symbol.dispose) InputNote.prototype[Symbol.dispose] = InputNote.prototype.free;\n\nconst InputNoteRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnoterecord_free(ptr >>> 0, 1));\n\nclass InputNoteRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNoteRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNoteRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNoteRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnoterecord_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.inputnoterecord_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {InputNoteState}\n     */\n    state() {\n        const ret = wasm.inputnoterecord_state(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {NoteDetails}\n     */\n    details() {\n        const ret = wasm.inputnoterecord_details(this.__wbg_ptr);\n        return NoteDetails.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata | undefined}\n     */\n    metadata() {\n        const ret = wasm.inputnoterecord_metadata(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    commitment() {\n        const ret = wasm.inputnoterecord_commitment(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInclusionProof | undefined}\n     */\n    inclusionProof() {\n        const ret = wasm.inputnoterecord_inclusionProof(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteInclusionProof.__wrap(ret);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    consumerTransactionId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_consumerTransactionId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    nullifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_nullifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isAuthenticated() {\n        const ret = wasm.inputnoterecord_isAuthenticated(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isConsumed() {\n        const ret = wasm.inputnoterecord_isConsumed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isProcessing() {\n        const ret = wasm.inputnoterecord_isProcessing(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {InputNote}\n     */\n    toInputNote() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_toInputNote(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return InputNote.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) InputNoteRecord.prototype[Symbol.dispose] = InputNoteRecord.prototype.free;\n\nconst InputNotesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnotes_free(ptr >>> 0, 1));\n\nclass InputNotes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNotes.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNotesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNotesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnotes_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    numNotes() {\n        const ret = wasm.inputnotes_numNotes(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.inputnotes_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {InputNote}\n     */\n    getNote(index) {\n        const ret = wasm.inputnotes_getNote(this.__wbg_ptr, index);\n        return InputNote.__wrap(ret);\n    }\n    /**\n     * @returns {InputNote[]}\n     */\n    notes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnotes_notes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) InputNotes.prototype[Symbol.dispose] = InputNotes.prototype.free;\n\nconst IntoUnderlyingByteSourceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingByteSource {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingByteSourceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingbytesource_free(ptr, 0);\n    }\n    /**\n     * @returns {ReadableStreamType}\n     */\n    get type() {\n        const ret = wasm.intounderlyingbytesource_type(this.__wbg_ptr);\n        return __wbindgen_enum_ReadableStreamType[ret];\n    }\n    /**\n     * @returns {number}\n     */\n    get autoAllocateChunkSize() {\n        const ret = wasm.intounderlyingbytesource_autoAllocateChunkSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {ReadableByteStreamController} controller\n     */\n    start(controller) {\n        wasm.intounderlyingbytesource_start(this.__wbg_ptr, addHeapObject(controller));\n    }\n    /**\n     * @param {ReadableByteStreamController} controller\n     * @returns {Promise<any>}\n     */\n    pull(controller) {\n        const ret = wasm.intounderlyingbytesource_pull(this.__wbg_ptr, addHeapObject(controller));\n        return takeObject(ret);\n    }\n    cancel() {\n        const ptr = this.__destroy_into_raw();\n        wasm.intounderlyingbytesource_cancel(ptr);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingByteSource.prototype[Symbol.dispose] = IntoUnderlyingByteSource.prototype.free;\n\nconst IntoUnderlyingSinkFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsink_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingSink {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingSinkFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingsink_free(ptr, 0);\n    }\n    /**\n     * @param {any} chunk\n     * @returns {Promise<any>}\n     */\n    write(chunk) {\n        const ret = wasm.intounderlyingsink_write(this.__wbg_ptr, addHeapObject(chunk));\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<any>}\n     */\n    close() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.intounderlyingsink_close(ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {any} reason\n     * @returns {Promise<any>}\n     */\n    abort(reason) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.intounderlyingsink_abort(ptr, addHeapObject(reason));\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingSink.prototype[Symbol.dispose] = IntoUnderlyingSink.prototype.free;\n\nconst IntoUnderlyingSourceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsource_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingSource {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingSourceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingsource_free(ptr, 0);\n    }\n    /**\n     * @param {ReadableStreamDefaultController} controller\n     * @returns {Promise<any>}\n     */\n    pull(controller) {\n        const ret = wasm.intounderlyingsource_pull(this.__wbg_ptr, addHeapObject(controller));\n        return takeObject(ret);\n    }\n    cancel() {\n        const ptr = this.__destroy_into_raw();\n        wasm.intounderlyingsource_cancel(ptr);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingSource.prototype[Symbol.dispose] = IntoUnderlyingSource.prototype.free;\n\nconst JsAccountUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsaccountupdate_free(ptr >>> 0, 1));\n/**\n * Represents an update to a single account's state.\n */\nclass JsAccountUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsAccountUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        JsAccountUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsAccountUpdate)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            storageRoot: this.storageRoot,\n            storageSlots: this.storageSlots,\n            storageMapEntries: this.storageMapEntries,\n            assetVaultRoot: this.assetVaultRoot,\n            assets: this.assets,\n            accountId: this.accountId,\n            codeRoot: this.codeRoot,\n            committed: this.committed,\n            nonce: this.nonce,\n            accountCommitment: this.accountCommitment,\n            accountSeed: this.accountSeed,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsAccountUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsaccountupdate_free(ptr, 0);\n    }\n    /**\n     * The merkle root of the account's storage trie.\n     * @returns {string}\n     */\n    get storageRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's storage trie.\n     * @param {string} arg0\n     */\n    set storageRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized storage slot data for this account.\n     * @returns {JsStorageSlot[]}\n     */\n    get storageSlots() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageSlots(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized storage slot data for this account.\n     * @param {JsStorageSlot[]} arg0\n     */\n    set storageSlots(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageSlots(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized storage map entries for this account.\n     * @returns {JsStorageMapEntry[]}\n     */\n    get storageMapEntries() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageMapEntries(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized storage map entries for this account.\n     * @param {JsStorageMapEntry[]} arg0\n     */\n    set storageMapEntries(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageMapEntries(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The merkle root of the account's asset vault.\n     * @returns {string}\n     */\n    get assetVaultRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assetVaultRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's asset vault.\n     * @param {string} arg0\n     */\n    set assetVaultRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assetVaultRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The account's asset vault.\n     * @returns {JsVaultAsset[]}\n     */\n    get assets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The account's asset vault.\n     * @param {JsVaultAsset[]} arg0\n     */\n    set assets(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * ID for this account.\n     * @returns {string}\n     */\n    get accountId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * ID for this account.\n     * @param {string} arg0\n     */\n    set accountId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountId(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The merkle root of the account's executable code.\n     * @returns {string}\n     */\n    get codeRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_codeRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's executable code.\n     * @param {string} arg0\n     */\n    set codeRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_codeRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Whether this account update has been committed.\n     * @returns {boolean}\n     */\n    get committed() {\n        const ret = wasm.__wbg_get_jsaccountupdate_committed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Whether this account update has been committed.\n     * @param {boolean} arg0\n     */\n    set committed(arg0) {\n        wasm.__wbg_set_jsaccountupdate_committed(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The account's transaction nonce as a string.\n     * @returns {string}\n     */\n    get nonce() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_nonce(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The account's transaction nonce as a string.\n     * @param {string} arg0\n     */\n    set nonce(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_nonce(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The cryptographic commitment representing this account's current state.\n     * @returns {string}\n     */\n    get accountCommitment() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountCommitment(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The cryptographic commitment representing this account's current state.\n     * @param {string} arg0\n     */\n    set accountCommitment(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountCommitment(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Optional seed data for the account.\n     * @returns {Uint8Array | undefined}\n     */\n    get accountSeed() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountSeed(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Optional seed data for the account.\n     * @param {Uint8Array | null} [arg0]\n     */\n    set accountSeed(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountSeed(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsAccountUpdate.prototype[Symbol.dispose] = JsAccountUpdate.prototype.free;\n\nconst JsStateSyncUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstatesyncupdate_free(ptr >>> 0, 1));\n/**\n * An object that contains data for a sync update,\n * which will be received by the applyStateSync JS function.\n * under sync.js\n */\nclass JsStateSyncUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStateSyncUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStateSyncUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStateSyncUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstatesyncupdate_free(ptr, 0);\n    }\n    /**\n     * The block number for this update, stored as a string since it will be\n     * persisted in `IndexedDB`.\n     * @returns {string}\n     */\n    get blockNum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The block number for this update, stored as a string since it will be\n     * persisted in `IndexedDB`.\n     * @param {string} arg0\n     */\n    set blockNum(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The new block headers for this state update, serialized into a flattened byte array.\n     * @returns {FlattenedU8Vec}\n     */\n    get flattenedNewBlockHeaders() {\n        const ret = wasm.__wbg_get_jsstatesyncupdate_flattenedNewBlockHeaders(this.__wbg_ptr);\n        return FlattenedU8Vec.__wrap(ret);\n    }\n    /**\n     * The new block headers for this state update, serialized into a flattened byte array.\n     * @param {FlattenedU8Vec} arg0\n     */\n    set flattenedNewBlockHeaders(arg0) {\n        _assertClass(arg0, FlattenedU8Vec);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_jsstatesyncupdate_flattenedNewBlockHeaders(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The block numbers corresponding to each header in `flattened_new_block_headers`.\n     * This vec should have the same length as the number of headers, with each index\n     * representing the block number for the header at that same index.\n     * @returns {string[]}\n     */\n    get newBlockNums() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_newBlockNums(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The block numbers corresponding to each header in `flattened_new_block_headers`.\n     * This vec should have the same length as the number of headers, with each index\n     * representing the block number for the header at that same index.\n     * @param {string[]} arg0\n     */\n    set newBlockNums(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_newBlockNums(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Flattened byte array containing partial blockchain peaks used for merkle tree\n     * verification.\n     * @returns {FlattenedU8Vec}\n     */\n    get flattenedPartialBlockChainPeaks() {\n        const ret = wasm.__wbg_get_jsstatesyncupdate_flattenedPartialBlockChainPeaks(this.__wbg_ptr);\n        return FlattenedU8Vec.__wrap(ret);\n    }\n    /**\n     * Flattened byte array containing partial blockchain peaks used for merkle tree\n     * verification.\n     * @param {FlattenedU8Vec} arg0\n     */\n    set flattenedPartialBlockChainPeaks(arg0) {\n        _assertClass(arg0, FlattenedU8Vec);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_jsstatesyncupdate_flattenedPartialBlockChainPeaks(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * For each block in this update, stores a boolean (as u8) indicating whether\n     * that block contains notes relevant to this client. Index i corresponds to\n     * the ith block, with 1 meaning relevant and 0 meaning not relevant.\n     * @returns {Uint8Array}\n     */\n    get blockHasRelevantNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_blockHasRelevantNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * For each block in this update, stores a boolean (as u8) indicating whether\n     * that block contains notes relevant to this client. Index i corresponds to\n     * the ith block, with 1 meaning relevant and 0 meaning not relevant.\n     * @param {Uint8Array} arg0\n     */\n    set blockHasRelevantNotes(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_blockHasRelevantNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized IDs for new authentication nodes required to verify block headers.\n     * @returns {string[]}\n     */\n    get serializedNodeIds() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedNodeIds(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized IDs for new authentication nodes required to verify block headers.\n     * @param {string[]} arg0\n     */\n    set serializedNodeIds(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedNodeIds(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The actual authentication node data corresponding to the IDs above.\n     * @returns {string[]}\n     */\n    get serializedNodes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedNodes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The actual authentication node data corresponding to the IDs above.\n     * @param {string[]} arg0\n     */\n    set serializedNodes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedNodes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * IDs of note tags that should be removed from the client's local state.\n     * @returns {string[]}\n     */\n    get committedNoteIds() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_committedNoteIds(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * IDs of note tags that should be removed from the client's local state.\n     * @param {string[]} arg0\n     */\n    set committedNoteIds(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_committedNoteIds(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Input notes for this state update in serialized form.\n     * @returns {SerializedInputNoteData[]}\n     */\n    get serializedInputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedInputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Input notes for this state update in serialized form.\n     * @param {SerializedInputNoteData[]} arg0\n     */\n    set serializedInputNotes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedInputNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Output notes created in this state update in serialized form.\n     * @returns {SerializedOutputNoteData[]}\n     */\n    get serializedOutputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedOutputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Output notes created in this state update in serialized form.\n     * @param {SerializedOutputNoteData[]} arg0\n     */\n    set serializedOutputNotes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedOutputNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Account state updates included in this sync.\n     * @returns {JsAccountUpdate[]}\n     */\n    get accountUpdates() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_accountUpdates(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Account state updates included in this sync.\n     * @param {JsAccountUpdate[]} arg0\n     */\n    set accountUpdates(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_accountUpdates(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Transaction data for transactions included in this update.\n     * @returns {SerializedTransactionData[]}\n     */\n    get transactionUpdates() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_transactionUpdates(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Transaction data for transactions included in this update.\n     * @param {SerializedTransactionData[]} arg0\n     */\n    set transactionUpdates(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_transactionUpdates(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsStateSyncUpdate.prototype[Symbol.dispose] = JsStateSyncUpdate.prototype.free;\n\nconst JsStorageMapEntryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstoragemapentry_free(ptr >>> 0, 1));\n/**\n * A JavaScript representation of a storage map entry in an account.\n */\nclass JsStorageMapEntry {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStorageMapEntry.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStorageMapEntryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsStorageMapEntry)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            root: this.root,\n            key: this.key,\n            value: this.value,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStorageMapEntryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstoragemapentry_free(ptr, 0);\n    }\n    /**\n     * The root of the storage map entry.\n     * @returns {string}\n     */\n    get root() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The root of the storage map entry.\n     * @param {string} arg0\n     */\n    set root(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The key of the storage map entry.\n     * @returns {string}\n     */\n    get key() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The key of the storage map entry.\n     * @param {string} arg0\n     */\n    set key(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The value of the storage map entry.\n     * @returns {string}\n     */\n    get value() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The value of the storage map entry.\n     * @param {string} arg0\n     */\n    set value(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsStorageMapEntry.prototype[Symbol.dispose] = JsStorageMapEntry.prototype.free;\n\nconst JsStorageSlotFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstorageslot_free(ptr >>> 0, 1));\n/**\n * A JavaScript representation of a storage slot in an account.\n */\nclass JsStorageSlot {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStorageSlot.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStorageSlotFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsStorageSlot)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            commitment: this.commitment,\n            slotIndex: this.slotIndex,\n            slotValue: this.slotValue,\n            slotType: this.slotType,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStorageSlotFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstorageslot_free(ptr, 0);\n    }\n    /**\n     * Commitment of the whole account storage\n     * @returns {string}\n     */\n    get commitment() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Commitment of the whole account storage\n     * @param {string} arg0\n     */\n    set commitment(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The index of the storage slot.\n     * @returns {number}\n     */\n    get slotIndex() {\n        const ret = wasm.__wbg_get_jsstorageslot_slotIndex(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The index of the storage slot.\n     * @param {number} arg0\n     */\n    set slotIndex(arg0) {\n        wasm.__wbg_set_jsstorageslot_slotIndex(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The value stored in the storage slot.\n     * @returns {string}\n     */\n    get slotValue() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The value stored in the storage slot.\n     * @param {string} arg0\n     */\n    set slotValue(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The type of the storage slot.\n     * @returns {number}\n     */\n    get slotType() {\n        const ret = wasm.__wbg_get_jsstorageslot_slotType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The type of the storage slot.\n     * @param {number} arg0\n     */\n    set slotType(arg0) {\n        wasm.__wbg_set_jsstorageslot_slotType(this.__wbg_ptr, arg0);\n    }\n}\nif (Symbol.dispose) JsStorageSlot.prototype[Symbol.dispose] = JsStorageSlot.prototype.free;\n\nconst JsVaultAssetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsvaultasset_free(ptr >>> 0, 1));\n/**\n * An object that contains a serialized vault asset\n */\nclass JsVaultAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsVaultAsset.prototype);\n        obj.__wbg_ptr = ptr;\n        JsVaultAssetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsVaultAsset)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            root: this.root,\n            vaultKey: this.vaultKey,\n            faucetIdPrefix: this.faucetIdPrefix,\n            asset: this.asset,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsVaultAssetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsvaultasset_free(ptr, 0);\n    }\n    /**\n     * The merkle root of the vault's assets.\n     * @returns {string}\n     */\n    get root() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the vault's assets.\n     * @param {string} arg0\n     */\n    set root(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The vault key associated with the asset.\n     * @returns {string}\n     */\n    get vaultKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The vault key associated with the asset.\n     * @param {string} arg0\n     */\n    set vaultKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Asset's faucet ID prefix.\n     * @returns {string}\n     */\n    get faucetIdPrefix() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Asset's faucet ID prefix.\n     * @param {string} arg0\n     */\n    set faucetIdPrefix(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Word representing the asset.\n     * @returns {string}\n     */\n    get asset() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assetVaultRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Word representing the asset.\n     * @param {string} arg0\n     */\n    set asset(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assetVaultRoot(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsVaultAsset.prototype[Symbol.dispose] = JsVaultAsset.prototype.free;\n\nconst LibraryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_library_free(ptr >>> 0, 1));\n\nclass Library {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Library.prototype);\n        obj.__wbg_ptr = ptr;\n        LibraryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        LibraryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_library_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Library.prototype[Symbol.dispose] = Library.prototype.free;\n\nconst MerklePathFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_merklepath_free(ptr >>> 0, 1));\n\nclass MerklePath {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MerklePath.prototype);\n        obj.__wbg_ptr = ptr;\n        MerklePathFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MerklePathFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merklepath_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    depth() {\n        const ret = wasm.merklepath_depth(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    nodes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.merklepath_nodes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {bigint} index\n     * @param {Word} node\n     * @returns {Word}\n     */\n    computeRoot(index, node) {\n        _assertClass(node, Word);\n        const ret = wasm.merklepath_computeRoot(this.__wbg_ptr, index, node.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {bigint} index\n     * @param {Word} node\n     * @param {Word} root\n     * @returns {boolean}\n     */\n    verify(index, node, root) {\n        _assertClass(node, Word);\n        _assertClass(root, Word);\n        const ret = wasm.merklepath_verify(this.__wbg_ptr, index, node.__wbg_ptr, root.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) MerklePath.prototype[Symbol.dispose] = MerklePath.prototype.free;\n\nconst NoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_note_free(ptr >>> 0, 1));\n\nclass Note {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Note.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_note_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAssets} note_assets\n     * @param {NoteMetadata} note_metadata\n     * @param {NoteRecipient} note_recipient\n     */\n    constructor(note_assets, note_metadata, note_recipient) {\n        _assertClass(note_assets, NoteAssets);\n        _assertClass(note_metadata, NoteMetadata);\n        _assertClass(note_recipient, NoteRecipient);\n        const ret = wasm.note_new(note_assets.__wbg_ptr, note_metadata.__wbg_ptr, note_recipient.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.note_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Note}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.note_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.note_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.note_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.note_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {NoteRecipient}\n     */\n    recipient() {\n        const ret = wasm.note_recipient(this.__wbg_ptr);\n        return NoteRecipient.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.note_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    script() {\n        const ret = wasm.note_script(this.__wbg_ptr);\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {AccountId} target\n     * @param {NoteAssets} assets\n     * @param {NoteType} note_type\n     * @param {Felt} aux\n     * @returns {Note}\n     */\n    static createP2IDNote(sender, target, assets, note_type, aux) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender, AccountId);\n            _assertClass(target, AccountId);\n            _assertClass(assets, NoteAssets);\n            _assertClass(aux, Felt);\n            wasm.note_createP2IDNote(retptr, sender.__wbg_ptr, target.__wbg_ptr, assets.__wbg_ptr, note_type, aux.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {AccountId} target\n     * @param {NoteAssets} assets\n     * @param {number | null | undefined} reclaim_height\n     * @param {number | null | undefined} timelock_height\n     * @param {NoteType} note_type\n     * @param {Felt} aux\n     * @returns {Note}\n     */\n    static createP2IDENote(sender, target, assets, reclaim_height, timelock_height, note_type, aux) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender, AccountId);\n            _assertClass(target, AccountId);\n            _assertClass(assets, NoteAssets);\n            _assertClass(aux, Felt);\n            wasm.note_createP2IDENote(retptr, sender.__wbg_ptr, target.__wbg_ptr, assets.__wbg_ptr, isLikeNone(reclaim_height) ? 0x100000001 : (reclaim_height) >>> 0, isLikeNone(timelock_height) ? 0x100000001 : (timelock_height) >>> 0, note_type, aux.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Note.prototype[Symbol.dispose] = Note.prototype.free;\n\nconst NoteAndArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteandargs_free(ptr >>> 0, 1));\n\nclass NoteAndArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteAndArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteAndArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteAndArgs)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAndArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteandargs_free(ptr, 0);\n    }\n    /**\n     * @param {Note} note\n     * @param {Word | null} [args]\n     */\n    constructor(note, args) {\n        _assertClass(note, Note);\n        var ptr0 = note.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(args)) {\n            _assertClass(args, Word);\n            ptr1 = args.__destroy_into_raw();\n        }\n        const ret = wasm.noteandargs_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAndArgsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteAndArgs.prototype[Symbol.dispose] = NoteAndArgs.prototype.free;\n\nconst NoteAndArgsArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteandargsarray_free(ptr >>> 0, 1));\n\nclass NoteAndArgsArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAndArgsArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteandargsarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAndArgs[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteandargsarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAndArgsArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteAndArgs}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteandargsarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteAndArgs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteAndArgs} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteAndArgs);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noteandargsarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteAndArgs} element\n     */\n    push(element) {\n        _assertClass(element, NoteAndArgs);\n        wasm.noteandargsarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noteandargsarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteAndArgsArray.prototype[Symbol.dispose] = NoteAndArgsArray.prototype.free;\n\nconst NoteAssetsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteassets_free(ptr >>> 0, 1));\n\nclass NoteAssets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteAssets.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteAssetsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAssetsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteassets_free(ptr, 0);\n    }\n    /**\n     * @param {FungibleAsset[] | null} [assets_array]\n     */\n    constructor(assets_array) {\n        var ptr0 = isLikeNone(assets_array) ? 0 : passArrayJsValueToWasm0(assets_array, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteassets_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAssetsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {FungibleAsset} asset\n     */\n    push(asset) {\n        _assertClass(asset, FungibleAsset);\n        wasm.noteassets_push(this.__wbg_ptr, asset.__wbg_ptr);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    fungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteassets_fungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) NoteAssets.prototype[Symbol.dispose] = NoteAssets.prototype.free;\n\nconst NoteConsumabilityFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteconsumability_free(ptr >>> 0, 1));\n\nclass NoteConsumability {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteConsumability.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteConsumabilityFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteConsumability)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteConsumabilityFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteconsumability_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.noteconsumability_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    consumableAfterBlock() {\n        const ret = wasm.noteconsumability_consumableAfterBlock(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\nif (Symbol.dispose) NoteConsumability.prototype[Symbol.dispose] = NoteConsumability.prototype.free;\n\nconst NoteDetailsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetails_free(ptr >>> 0, 1));\n\nclass NoteDetails {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteDetails.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteDetailsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetails_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAssets} note_assets\n     * @param {NoteRecipient} note_recipient\n     */\n    constructor(note_assets, note_recipient) {\n        _assertClass(note_assets, NoteAssets);\n        _assertClass(note_recipient, NoteRecipient);\n        const ret = wasm.notedetails_new(note_assets.__wbg_ptr, note_recipient.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.notedetails_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.notedetails_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteRecipient}\n     */\n    recipient() {\n        const ret = wasm.notedetails_recipient(this.__wbg_ptr);\n        return NoteRecipient.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteDetails.prototype[Symbol.dispose] = NoteDetails.prototype.free;\n\nconst NoteDetailsAndTagFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetailsandtag_free(ptr >>> 0, 1));\n\nclass NoteDetailsAndTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteDetailsAndTag.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteDetailsAndTagFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteDetailsAndTag)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsAndTagFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetailsandtag_free(ptr, 0);\n    }\n    /**\n     * @param {NoteDetails} note_details\n     * @param {NoteTag} tag\n     */\n    constructor(note_details, tag) {\n        _assertClass(note_details, NoteDetails);\n        var ptr0 = note_details.__destroy_into_raw();\n        _assertClass(tag, NoteTag);\n        var ptr1 = tag.__destroy_into_raw();\n        const ret = wasm.notedetailsandtag_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsAndTagFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {NoteDetails}\n     */\n    get noteDetails() {\n        const ret = wasm.notedetailsandtag_noteDetails(this.__wbg_ptr);\n        return NoteDetails.__wrap(ret);\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    get tag() {\n        const ret = wasm.notedetailsandtag_tag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteDetailsAndTag.prototype[Symbol.dispose] = NoteDetailsAndTag.prototype.free;\n\nconst NoteDetailsAndTagArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetailsandtagarray_free(ptr >>> 0, 1));\n\nclass NoteDetailsAndTagArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsAndTagArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetailsandtagarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteDetailsAndTag[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.notedetailsandtagarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsAndTagArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteDetailsAndTag}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notedetailsandtagarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteDetailsAndTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteDetailsAndTag} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteDetailsAndTag);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.notedetailsandtagarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteDetailsAndTag} element\n     */\n    push(element) {\n        _assertClass(element, NoteDetailsAndTag);\n        wasm.notedetailsandtagarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.notedetailsandtagarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteDetailsAndTagArray.prototype[Symbol.dispose] = NoteDetailsAndTagArray.prototype.free;\n\nconst NoteExecutionHintFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteexecutionhint_free(ptr >>> 0, 1));\n\nclass NoteExecutionHint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteExecutionHint.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteExecutionHintFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteExecutionHintFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteexecutionhint_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteExecutionHint}\n     */\n    static none() {\n        const ret = wasm.noteexecutionhint_none();\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @returns {NoteExecutionHint}\n     */\n    static always() {\n        const ret = wasm.noteexecutionhint_always();\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {NoteExecutionHint}\n     */\n    static afterBlock(block_num) {\n        const ret = wasm.noteexecutionhint_afterBlock(block_num);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} epoch_len\n     * @param {number} slot_len\n     * @param {number} slot_offset\n     * @returns {NoteExecutionHint}\n     */\n    static onBlockSlot(epoch_len, slot_len, slot_offset) {\n        const ret = wasm.noteexecutionhint_onBlockSlot(epoch_len, slot_len, slot_offset);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} payload\n     * @returns {NoteExecutionHint}\n     */\n    static fromParts(tag, payload) {\n        const ret = wasm.noteexecutionhint_fromParts(tag, payload);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {boolean}\n     */\n    canBeConsumed(block_num) {\n        const ret = wasm.noteexecutionhint_canBeConsumed(this.__wbg_ptr, block_num);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) NoteExecutionHint.prototype[Symbol.dispose] = NoteExecutionHint.prototype.free;\n\nconst NoteExecutionModeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteexecutionmode_free(ptr >>> 0, 1));\n\nclass NoteExecutionMode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteExecutionMode.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteExecutionModeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteExecutionModeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteexecutionmode_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    static newLocal() {\n        const ret = wasm.accountstoragemode_network();\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    static newNetwork() {\n        const ret = wasm.accountstoragemode_public();\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteexecutionmode_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) NoteExecutionMode.prototype[Symbol.dispose] = NoteExecutionMode.prototype.free;\n\nconst NoteFileFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notefile_free(ptr >>> 0, 1));\n/**\n * A serialized representation of a note.\n */\nclass NoteFile {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteFile.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteFileFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFileFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notefile_free(ptr, 0);\n    }\n    /**\n     * Returns this `NoteFile`'s types.\n     * @returns {string}\n     */\n    noteType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notefile_noteType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Turn a notefile into its byte representation.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notefile_serialize(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a valid byte representation of a `NoteFile`,\n     * return it as a struct.\n     * @param {Uint8Array} bytes\n     * @returns {NoteFile}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.notefile_deserialize(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteFile.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {InputNote} note\n     * @returns {NoteFile}\n     */\n    static fromInputNote(note) {\n        _assertClass(note, InputNote);\n        const ret = wasm.notefile_fromInputNote(note.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {OutputNote} note\n     * @returns {NoteFile}\n     */\n    static fromOutputNote(note) {\n        _assertClass(note, OutputNote);\n        const ret = wasm.notefile_fromOutputNote(note.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {NoteDetails} note_details\n     * @returns {NoteFile}\n     */\n    static fromNoteDetails(note_details) {\n        _assertClass(note_details, NoteDetails);\n        const ret = wasm.notefile_fromNoteDetails(note_details.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {NoteId} note_details\n     * @returns {NoteFile}\n     */\n    static fromNoteId(note_details) {\n        _assertClass(note_details, NoteId);\n        const ret = wasm.notefile_fromNoteId(note_details.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteFile.prototype[Symbol.dispose] = NoteFile.prototype.free;\n\nconst NoteFilterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notefilter_free(ptr >>> 0, 1));\n\nclass NoteFilter {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFilterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notefilter_free(ptr, 0);\n    }\n    /**\n     * @param {NoteFilterTypes} note_type\n     * @param {NoteId[] | null} [note_ids]\n     */\n    constructor(note_type, note_ids) {\n        var ptr0 = isLikeNone(note_ids) ? 0 : passArrayJsValueToWasm0(note_ids, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.notefilter_new(note_type, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteFilterFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteFilter.prototype[Symbol.dispose] = NoteFilter.prototype.free;\n\nconst NoteHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteheader_free(ptr >>> 0, 1));\n\nclass NoteHeader {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteheader_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.noteheader_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.noteheader_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.noteheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteHeader.prototype[Symbol.dispose] = NoteHeader.prototype.free;\n\nconst NoteIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteid_free(ptr >>> 0, 1));\n\nclass NoteId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteId.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteid_free(ptr, 0);\n    }\n    /**\n     * @param {Word} recipient_digest\n     * @param {Word} asset_commitment_digest\n     */\n    constructor(recipient_digest, asset_commitment_digest) {\n        _assertClass(recipient_digest, Word);\n        _assertClass(asset_commitment_digest, Word);\n        const ret = wasm.noteid_new(recipient_digest.__wbg_ptr, asset_commitment_digest.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {string} hex\n     * @returns {NoteId}\n     */\n    static fromHex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.noteid_fromHex(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteid_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) NoteId.prototype[Symbol.dispose] = NoteId.prototype.free;\n\nconst NoteIdAndArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteidandargs_free(ptr >>> 0, 1));\n\nclass NoteIdAndArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteIdAndArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteIdAndArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteIdAndArgs)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdAndArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteidandargs_free(ptr, 0);\n    }\n    /**\n     * @param {NoteId} note_id\n     * @param {Word | null} [args]\n     */\n    constructor(note_id, args) {\n        _assertClass(note_id, NoteId);\n        var ptr0 = note_id.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(args)) {\n            _assertClass(args, Word);\n            ptr1 = args.__destroy_into_raw();\n        }\n        const ret = wasm.noteidandargs_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdAndArgsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteIdAndArgs.prototype[Symbol.dispose] = NoteIdAndArgs.prototype.free;\n\nconst NoteIdAndArgsArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteidandargsarray_free(ptr >>> 0, 1));\n\nclass NoteIdAndArgsArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdAndArgsArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteidandargsarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteIdAndArgs[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteidandargsarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdAndArgsArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteIdAndArgs}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteidandargsarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteIdAndArgs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteIdAndArgs} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteIdAndArgs);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noteidandargsarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteIdAndArgs} element\n     */\n    push(element) {\n        _assertClass(element, NoteIdAndArgs);\n        wasm.noteidandargsarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noteidandargsarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteIdAndArgsArray.prototype[Symbol.dispose] = NoteIdAndArgsArray.prototype.free;\n\nconst NoteInclusionProofFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteinclusionproof_free(ptr >>> 0, 1));\n\nclass NoteInclusionProof {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteInclusionProof.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteInclusionProofFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteInclusionProofFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteinclusionproof_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteLocation}\n     */\n    location() {\n        const ret = wasm.noteinclusionproof_location(this.__wbg_ptr);\n        return NoteLocation.__wrap(ret);\n    }\n    /**\n     * @returns {MerklePath}\n     */\n    notePath() {\n        const ret = wasm.noteinclusionproof_notePath(this.__wbg_ptr);\n        return MerklePath.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteInclusionProof.prototype[Symbol.dispose] = NoteInclusionProof.prototype.free;\n\nconst NoteInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteinputs_free(ptr >>> 0, 1));\n\nclass NoteInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteinputs_free(ptr, 0);\n    }\n    /**\n     * @param {FeltArray} felt_array\n     */\n    constructor(felt_array) {\n        _assertClass(felt_array, FeltArray);\n        const ret = wasm.noteinputs_new(felt_array.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteInputsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    values() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteinputs_values(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) NoteInputs.prototype[Symbol.dispose] = NoteInputs.prototype.free;\n\nconst NoteLocationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notelocation_free(ptr >>> 0, 1));\n\nclass NoteLocation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteLocation.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteLocationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteLocationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notelocation_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.notelocation_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    nodeIndexInBlock() {\n        const ret = wasm.notelocation_nodeIndexInBlock(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) NoteLocation.prototype[Symbol.dispose] = NoteLocation.prototype.free;\n\nconst NoteMetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notemetadata_free(ptr >>> 0, 1));\n\nclass NoteMetadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteMetadata.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteMetadataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteMetadataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notemetadata_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {NoteType} note_type\n     * @param {NoteTag} note_tag\n     * @param {NoteExecutionHint} note_execution_hint\n     * @param {Felt | null} [aux]\n     */\n    constructor(sender, note_type, note_tag, note_execution_hint, aux) {\n        _assertClass(sender, AccountId);\n        _assertClass(note_tag, NoteTag);\n        _assertClass(note_execution_hint, NoteExecutionHint);\n        let ptr0 = 0;\n        if (!isLikeNone(aux)) {\n            _assertClass(aux, Felt);\n            ptr0 = aux.__destroy_into_raw();\n        }\n        const ret = wasm.notemetadata_new(sender.__wbg_ptr, note_type, note_tag.__wbg_ptr, note_execution_hint.__wbg_ptr, ptr0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteMetadataFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {AccountId}\n     */\n    sender() {\n        const ret = wasm.notemetadata_sender(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    tag() {\n        const ret = wasm.notedetailsandtag_tag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @returns {NoteType}\n     */\n    noteType() {\n        const ret = wasm.notemetadata_noteType(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) NoteMetadata.prototype[Symbol.dispose] = NoteMetadata.prototype.free;\n\nconst NoteRecipientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noterecipient_free(ptr >>> 0, 1));\n\nclass NoteRecipient {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteRecipient.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteRecipientFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteRecipient)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteRecipientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noterecipient_free(ptr, 0);\n    }\n    /**\n     * @param {Word} serial_num\n     * @param {NoteScript} note_script\n     * @param {NoteInputs} inputs\n     */\n    constructor(serial_num, note_script, inputs) {\n        _assertClass(serial_num, Word);\n        _assertClass(note_script, NoteScript);\n        _assertClass(inputs, NoteInputs);\n        const ret = wasm.noterecipient_new(serial_num.__wbg_ptr, note_script.__wbg_ptr, inputs.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteRecipientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Word}\n     */\n    digest() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    serialNum() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    script() {\n        const ret = wasm.noterecipient_script(this.__wbg_ptr);\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInputs}\n     */\n    inputs() {\n        const ret = wasm.noterecipient_inputs(this.__wbg_ptr);\n        return NoteInputs.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteRecipient.prototype[Symbol.dispose] = NoteRecipient.prototype.free;\n\nconst NoteRecipientArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noterecipientarray_free(ptr >>> 0, 1));\n\nclass NoteRecipientArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteRecipientArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noterecipientarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteRecipient[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noterecipientarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteRecipientArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteRecipient}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noterecipientarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteRecipient.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteRecipient} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteRecipient);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noterecipientarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteRecipient} element\n     */\n    push(element) {\n        _assertClass(element, NoteRecipient);\n        wasm.noterecipientarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noterecipientarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteRecipientArray.prototype[Symbol.dispose] = NoteRecipientArray.prototype.free;\n\nconst NoteScriptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notescript_free(ptr >>> 0, 1));\n\nclass NoteScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteScript.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteScriptFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteScriptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notescript_free(ptr, 0);\n    }\n    /**\n     * Print the MAST source for this script.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notescript_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.notescript_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {NoteScript}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notescript_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static p2id() {\n        const ret = wasm.notescript_p2id();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static p2ide() {\n        const ret = wasm.notescript_p2ide();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static swap() {\n        const ret = wasm.notescript_swap();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.notescript_root(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteScript.prototype[Symbol.dispose] = NoteScript.prototype.free;\n\nconst NoteTagFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notetag_free(ptr >>> 0, 1));\n\nclass NoteTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteTag.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteTagFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteTagFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notetag_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {NoteTag}\n     */\n    static fromAccountId(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.notetag_fromAccountId(account_id.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {number} use_case_id\n     * @param {number} payload\n     * @param {NoteExecutionMode} execution\n     * @returns {NoteTag}\n     */\n    static forPublicUseCase(use_case_id, payload, execution) {\n        _assertClass(execution, NoteExecutionMode);\n        const ret = wasm.notetag_forPublicUseCase(use_case_id, payload, execution.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {number} use_case_id\n     * @param {number} payload\n     * @returns {NoteTag}\n     */\n    static forLocalUseCase(use_case_id, payload) {\n        const ret = wasm.notetag_forLocalUseCase(use_case_id, payload);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isSingleTarget() {\n        const ret = wasm.notetag_isSingleTarget(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    executionMode() {\n        const ret = wasm.notetag_executionMode(this.__wbg_ptr);\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    asU32() {\n        const ret = wasm.notetag_asU32(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteTag.prototype[Symbol.dispose] = NoteTag.prototype.free;\n\nconst OutputNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnote_free(ptr >>> 0, 1));\n\nclass OutputNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputNote.prototype);\n        obj.__wbg_ptr = ptr;\n        OutputNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof OutputNote)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnote_free(ptr, 0);\n    }\n    /**\n     * @param {Note} note\n     * @returns {OutputNote}\n     */\n    static full(note) {\n        _assertClass(note, Note);\n        const ret = wasm.outputnote_full(note.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @param {PartialNote} partial_note\n     * @returns {OutputNote}\n     */\n    static partial(partial_note) {\n        _assertClass(partial_note, PartialNote);\n        const ret = wasm.outputnote_partial(partial_note.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @param {NoteHeader} note_header\n     * @returns {OutputNote}\n     */\n    static header(note_header) {\n        _assertClass(note_header, NoteHeader);\n        const ret = wasm.outputnote_header(note_header.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets | undefined}\n     */\n    assets() {\n        const ret = wasm.outputnote_assets(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.outputnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    recipientDigest() {\n        const ret = wasm.outputnote_recipientDigest(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.outputnote_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNote}\n     */\n    shrink() {\n        const ret = wasm.outputnote_shrink(this.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {Note | undefined}\n     */\n    intoFull() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.outputnote_intoFull(ptr);\n        return ret === 0 ? undefined : Note.__wrap(ret);\n    }\n}\nif (Symbol.dispose) OutputNote.prototype[Symbol.dispose] = OutputNote.prototype.free;\n\nconst OutputNoteArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotearray_free(ptr >>> 0, 1));\n\nclass OutputNoteArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNoteArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotearray_free(ptr, 0);\n    }\n    /**\n     * @param {OutputNote[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.outputnotearray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        OutputNoteArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {OutputNote}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotearray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNote.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {OutputNote} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, OutputNote);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.outputnotearray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {OutputNote} element\n     */\n    push(element) {\n        _assertClass(element, OutputNote);\n        wasm.outputnotearray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotearray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) OutputNoteArray.prototype[Symbol.dispose] = OutputNoteArray.prototype.free;\n\nconst OutputNotesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotes_free(ptr >>> 0, 1));\n\nclass OutputNotes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputNotes.prototype);\n        obj.__wbg_ptr = ptr;\n        OutputNotesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof OutputNotes)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNotesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotes_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    numNotes() {\n        const ret = wasm.outputnotes_numNotes(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.outputnotes_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {OutputNote}\n     */\n    getNote(index) {\n        const ret = wasm.outputnotes_getNote(this.__wbg_ptr, index);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNote[]}\n     */\n    notes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotes_notes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) OutputNotes.prototype[Symbol.dispose] = OutputNotes.prototype.free;\n\nconst OutputNotesArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotesarray_free(ptr >>> 0, 1));\n\nclass OutputNotesArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNotesArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotesarray_free(ptr, 0);\n    }\n    /**\n     * @param {OutputNotes[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.outputnotesarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        OutputNotesArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {OutputNotes}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotesarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {OutputNotes} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, OutputNotes);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.outputnotesarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {OutputNotes} element\n     */\n    push(element) {\n        _assertClass(element, OutputNotes);\n        wasm.outputnotesarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotesarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) OutputNotesArray.prototype[Symbol.dispose] = OutputNotesArray.prototype.free;\n\nconst PackageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_package_free(ptr >>> 0, 1));\n\nclass Package {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Package.prototype);\n        obj.__wbg_ptr = ptr;\n        PackageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PackageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_package_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.package_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Package}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.package_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Package.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) Package.prototype[Symbol.dispose] = Package.prototype.free;\n\nconst PartialNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_partialnote_free(ptr >>> 0, 1));\n\nclass PartialNote {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PartialNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_partialnote_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.partialnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.note_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    recipientDigest() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.partialnote_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n}\nif (Symbol.dispose) PartialNote.prototype[Symbol.dispose] = PartialNote.prototype.free;\n\nconst ProvenTransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_proventransaction_free(ptr >>> 0, 1));\n/**\n * WASM wrapper around the native [`ProvenTransaction`].\n */\nclass ProvenTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvenTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n        ProvenTransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProvenTransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proventransaction_free(ptr, 0);\n    }\n    /**\n     * Serializes the proven transaction into bytes.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.proventransaction_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a proven transaction from bytes.\n     * @param {Uint8Array} bytes\n     * @returns {ProvenTransaction}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proventransaction_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvenTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Returns the transaction ID.\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.proventransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * Returns the account ID the transaction was executed against.\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.proventransaction_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * Returns the reference block number used during execution.\n     * @returns {number}\n     */\n    refBlockNumber() {\n        const ret = wasm.proventransaction_refBlockNumber(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Returns the block number at which the transaction expires.\n     * @returns {number}\n     */\n    expirationBlockNumber() {\n        const ret = wasm.proventransaction_expirationBlockNumber(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Returns notes created by this transaction.\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.proventransaction_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * Returns the commitment of the reference block.\n     * @returns {Word}\n     */\n    refBlockCommitment() {\n        const ret = wasm.proventransaction_refBlockCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * Returns the nullifiers of the consumed input notes.\n     * @returns {Word[]}\n     */\n    nullifiers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proventransaction_nullifiers(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ProvenTransaction.prototype[Symbol.dispose] = ProvenTransaction.prototype.free;\n\nconst PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0, 1));\n\nclass PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PublicKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.publickey_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PublicKey}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Word} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        _assertClass(message, Word);\n        _assertClass(signature, Signature);\n        const ret = wasm.publickey_verify(this.__wbg_ptr, message.__wbg_ptr, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    toCommitment() {\n        const ret = wasm.publickey_toCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {Word} message\n     * @param {Signature} signature\n     * @returns {PublicKey}\n     */\n    static recoverFrom(message, signature) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(message, Word);\n            _assertClass(signature, Signature);\n            wasm.publickey_recoverFrom(retptr, message.__wbg_ptr, signature.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {SigningInputs} signing_inputs\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verifyData(signing_inputs, signature) {\n        _assertClass(signing_inputs, SigningInputs);\n        _assertClass(signature, Signature);\n        const ret = wasm.publickey_verifyData(this.__wbg_ptr, signing_inputs.__wbg_ptr, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) PublicKey.prototype[Symbol.dispose] = PublicKey.prototype.free;\n\nconst RpcClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rpcclient_free(ptr >>> 0, 1));\n/**\n * RPC Client for interacting with Miden nodes directly.\n */\nclass RpcClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RpcClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rpcclient_free(ptr, 0);\n    }\n    /**\n     * Creates a new RPC client instance.\n     *\n     * @param endpoint - Endpoint to connect to.\n     * @param {Endpoint} endpoint\n     */\n    constructor(endpoint) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(endpoint, Endpoint);\n            var ptr0 = endpoint.__destroy_into_raw();\n            wasm.rpcclient_new(retptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            RpcClientFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Fetches notes by their IDs from the connected Miden node.\n     *\n     * @param note_ids - Array of [`NoteId`] objects to fetch\n     * @returns Promise that resolves to  different data depending on the note type:\n     * - Private notes: Returns only `note_id` and `metadata`. The `input_note` field will be\n     *   `null`.\n     * - Public notes: Returns the full `input_note` with inclusion proof, alongside metadata and\n     *   ID.\n     * @param {NoteId[]} note_ids\n     * @returns {Promise<FetchedNote[]>}\n     */\n    getNotesById(note_ids) {\n        const ptr0 = passArrayJsValueToWasm0(note_ids, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rpcclient_getNotesById(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Fetches a note script by its root hash from the connected Miden node.\n     *\n     * @param `script_root` The root hash of the note script to fetch\n     * @returns Promise that resolves to the `NoteScript`\n     * @param {Word} script_root\n     * @returns {Promise<NoteScript>}\n     */\n    getNoteScriptByRoot(script_root) {\n        _assertClass(script_root, Word);\n        var ptr0 = script_root.__destroy_into_raw();\n        const ret = wasm.rpcclient_getNoteScriptByRoot(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) RpcClient.prototype[Symbol.dispose] = RpcClient.prototype.free;\n\nconst Rpo256Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rpo256_free(ptr >>> 0, 1));\n\nclass Rpo256 {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Rpo256Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rpo256_free(ptr, 0);\n    }\n    /**\n     * @param {FeltArray} felt_array\n     * @returns {Word}\n     */\n    static hashElements(felt_array) {\n        _assertClass(felt_array, FeltArray);\n        const ret = wasm.rpo256_hashElements(felt_array.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) Rpo256.prototype[Symbol.dispose] = Rpo256.prototype.free;\n\nconst ScriptBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_scriptbuilder_free(ptr >>> 0, 1));\n\nclass ScriptBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        ScriptBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ScriptBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptbuilder_free(ptr, 0);\n    }\n    /**\n     * Given a module path (something like `my_lib::module`) and source code, this will\n     * statically link it for use with scripts to be built with this builder.\n     * @param {string} module_path\n     * @param {string} module_code\n     */\n    linkModule(module_path, module_code) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(module_path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(module_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_linkModule(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Statically links the given library.\n     *\n     * Static linking means the library code is copied into the script code.\n     * Use this for most libraries that are not available on-chain.\n     *\n     * Receives as argument the library to link.\n     * @param {Library} library\n     */\n    linkStaticLibrary(library) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(library, Library);\n            wasm.scriptbuilder_linkStaticLibrary(retptr, this.__wbg_ptr, library.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * This is useful to dynamically link the [`Library`] of a foreign account\n     * that is invoked using foreign procedure invocation (FPI). Its code is available\n     * on-chain and so it does not have to be copied into the script code.\n     *\n     * For all other use cases not involving FPI, link the library statically.\n     * Receives as argument the library to be linked.\n     * @param {Library} library\n     */\n    linkDynamicLibrary(library) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(library, Library);\n            wasm.scriptbuilder_linkDynamicLibrary(retptr, this.__wbg_ptr, library.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Transaction Script's source code, compiles it with the available\n     * modules under this builder. Returns the compiled script.\n     * @param {string} tx_script\n     * @returns {TransactionScript}\n     */\n    compileTxScript(tx_script) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(tx_script, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_compileTxScript(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Note Script's source code, compiles it with the available\n     * modules under this builder. Returns the compiled script.\n     * @param {string} program\n     * @returns {NoteScript}\n     */\n    compileNoteScript(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_compileNoteScript(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Library Path, and a source code, turn it into a Library.\n     * E.g. A path library can be `miden::my_contract`. When turned into a library,\n     * this can be used from another script with an import statement, following the\n     * previous example: `use.miden::my_contract'.\n     * @param {string} library_path\n     * @param {string} source_code\n     * @returns {Library}\n     */\n    buildLibrary(library_path, source_code) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(library_path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(source_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_buildLibrary(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Library.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ScriptBuilder.prototype[Symbol.dispose] = ScriptBuilder.prototype.free;\n\nconst SecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_secretkey_free(ptr >>> 0, 1));\n\nclass SecretKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SecretKey.prototype);\n        obj.__wbg_ptr = ptr;\n        SecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SecretKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array | null} [seed]\n     * @returns {SecretKey}\n     */\n    static rpoFalconWithRNG(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_rpoFalconWithRNG(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [seed]\n     * @returns {SecretKey}\n     */\n    static ecdsaWithRNG(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_ecdsaWithRNG(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {PublicKey}\n     */\n    publicKey() {\n        const ret = wasm.secretkey_publicKey(this.__wbg_ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n     * @param {Word} message\n     * @returns {Signature}\n     */\n    sign(message) {\n        _assertClass(message, Word);\n        const ret = wasm.secretkey_sign(this.__wbg_ptr, message.__wbg_ptr);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * @param {SigningInputs} signing_inputs\n     * @returns {Signature}\n     */\n    signData(signing_inputs) {\n        _assertClass(signing_inputs, SigningInputs);\n        const ret = wasm.secretkey_signData(this.__wbg_ptr, signing_inputs.__wbg_ptr);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.secretkey_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SecretKey}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SecretKey.prototype[Symbol.dispose] = SecretKey.prototype.free;\n\nconst SerializedInputNoteDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedinputnotedata_free(ptr >>> 0, 1));\n\nclass SerializedInputNoteData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedInputNoteData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedInputNoteDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedInputNoteData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedInputNoteDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedinputnotedata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteAssets(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get serialNumber() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_serialNumber(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set serialNumber(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_serialNumber(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get inputs() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set inputs(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteScriptRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteScriptRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteScriptRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteScriptRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteScript() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteScript(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteScript(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteScript(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get nullifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_codeRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set nullifier(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_codeRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get stateDiscriminant() {\n        const ret = wasm.__wbg_get_serializedinputnotedata_stateDiscriminant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set stateDiscriminant(arg0) {\n        wasm.__wbg_set_serializedinputnotedata_stateDiscriminant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set state(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_state(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get createdAt() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountCommitment(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set createdAt(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountCommitment(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedInputNoteData.prototype[Symbol.dispose] = SerializedInputNoteData.prototype.free;\n\nconst SerializedOutputNoteDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedoutputnotedata_free(ptr >>> 0, 1));\n\nclass SerializedOutputNoteData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedOutputNoteData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedOutputNoteDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedOutputNoteData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedOutputNoteDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedoutputnotedata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteAssets(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get recipientDigest() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set recipientDigest(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get metadata() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set metadata(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    get nullifier() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedoutputnotedata_nullifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string | null} [arg0]\n     */\n    set nullifier(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedoutputnotedata_nullifier(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get expectedHeight() {\n        const ret = wasm.__wbg_get_serializedoutputnotedata_expectedHeight(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set expectedHeight(arg0) {\n        wasm.__wbg_set_serializedoutputnotedata_expectedHeight(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get stateDiscriminant() {\n        const ret = wasm.__wbg_get_serializedoutputnotedata_stateDiscriminant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set stateDiscriminant(arg0) {\n        wasm.__wbg_set_serializedoutputnotedata_stateDiscriminant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedoutputnotedata_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set state(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedoutputnotedata_state(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedOutputNoteData.prototype[Symbol.dispose] = SerializedOutputNoteData.prototype.free;\n\nconst SerializedTransactionDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedtransactiondata_free(ptr >>> 0, 1));\n\nclass SerializedTransactionData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedTransactionData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedTransactionDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedTransactionData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedTransactionDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedtransactiondata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set id(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get details() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set details(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    get scriptRoot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedtransactiondata_scriptRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [arg0]\n     */\n    set scriptRoot(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedtransactiondata_scriptRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    get txScript() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedtransactiondata_txScript(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [arg0]\n     */\n    set txScript(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedtransactiondata_txScript(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get blockNum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set blockNum(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get statusVariant() {\n        const ret = wasm.__wbg_get_serializedtransactiondata_statusVariant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set statusVariant(arg0) {\n        wasm.__wbg_set_serializedtransactiondata_statusVariant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get status() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set status(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedTransactionData.prototype[Symbol.dispose] = SerializedTransactionData.prototype.free;\n\nconst SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr >>> 0, 1));\n\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.signature_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Signature}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Word} message\n     * @returns {Felt[]}\n     */\n    toPreparedSignature(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(message, Word);\n            var ptr0 = message.__destroy_into_raw();\n            wasm.signature_toPreparedSignature(retptr, this.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v2 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Signature.prototype[Symbol.dispose] = Signature.prototype.free;\n\nconst SigningInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signinginputs_free(ptr >>> 0, 1));\n\nclass SigningInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SigningInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        SigningInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SigningInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signinginputs_free(ptr, 0);\n    }\n    /**\n     * @param {TransactionSummary} summary\n     * @returns {SigningInputs}\n     */\n    static newTransactionSummary(summary) {\n        _assertClass(summary, TransactionSummary);\n        var ptr0 = summary.__destroy_into_raw();\n        const ret = wasm.signinginputs_newTransactionSummary(ptr0);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @param {Felt[]} felts\n     * @returns {SigningInputs}\n     */\n    static newArbitrary(felts) {\n        const ptr0 = passArrayJsValueToWasm0(felts, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signinginputs_newArbitrary(ptr0, len0);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @param {Word} word\n     * @returns {SigningInputs}\n     */\n    static newBlind(word) {\n        _assertClass(word, Word);\n        const ret = wasm.signinginputs_newBlind(word.__wbg_ptr);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionSummary}\n     */\n    transactionSummaryPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_transactionSummaryPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    arbitraryPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_arbitraryPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FeltArray.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    blindPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_blindPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {SigningInputsType}\n     */\n    get variantType() {\n        const ret = wasm.signinginputs_variantType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word}\n     */\n    toCommitment() {\n        const ret = wasm.signinginputs_toCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    toElements() {\n        const ret = wasm.signinginputs_toElements(this.__wbg_ptr);\n        return FeltArray.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.signinginputs_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SigningInputs}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SigningInputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SigningInputs.prototype[Symbol.dispose] = SigningInputs.prototype.free;\n\nconst SlotAndKeysFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_slotandkeys_free(ptr >>> 0, 1));\n\nclass SlotAndKeys {\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SlotAndKeys)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SlotAndKeysFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_slotandkeys_free(ptr, 0);\n    }\n    /**\n     * @param {number} storage_slot_index\n     * @param {Word[]} storage_map_keys\n     */\n    constructor(storage_slot_index, storage_map_keys) {\n        const ptr0 = passArrayJsValueToWasm0(storage_map_keys, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.slotandkeys_new(storage_slot_index, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        SlotAndKeysFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    storage_slot_index() {\n        const ret = wasm.slotandkeys_storage_slot_index(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    storage_map_keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.slotandkeys_storage_map_keys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) SlotAndKeys.prototype[Symbol.dispose] = SlotAndKeys.prototype.free;\n\nconst StorageMapFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storagemap_free(ptr >>> 0, 1));\n\nclass StorageMap {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageMapFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storagemap_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.storagemap_new();\n        this.__wbg_ptr = ret >>> 0;\n        StorageMapFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {Word} key\n     * @param {Word} value\n     * @returns {Word}\n     */\n    insert(key, value) {\n        _assertClass(key, Word);\n        _assertClass(value, Word);\n        const ret = wasm.storagemap_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) StorageMap.prototype[Symbol.dispose] = StorageMap.prototype.free;\n\nconst StorageSlotFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storageslot_free(ptr >>> 0, 1));\n\nclass StorageSlot {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StorageSlot.prototype);\n        obj.__wbg_ptr = ptr;\n        StorageSlotFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof StorageSlot)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageSlotFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storageslot_free(ptr, 0);\n    }\n    /**\n     * @param {Word} value\n     * @returns {StorageSlot}\n     */\n    static fromValue(value) {\n        _assertClass(value, Word);\n        const ret = wasm.storageslot_fromValue(value.__wbg_ptr);\n        return StorageSlot.__wrap(ret);\n    }\n    /**\n     * @returns {StorageSlot}\n     */\n    static emptyValue() {\n        const ret = wasm.storageslot_emptyValue();\n        return StorageSlot.__wrap(ret);\n    }\n    /**\n     * @param {StorageMap} storage_map\n     * @returns {StorageSlot}\n     */\n    static map(storage_map) {\n        _assertClass(storage_map, StorageMap);\n        const ret = wasm.storageslot_map(storage_map.__wbg_ptr);\n        return StorageSlot.__wrap(ret);\n    }\n}\nif (Symbol.dispose) StorageSlot.prototype[Symbol.dispose] = StorageSlot.prototype.free;\n\nconst StorageSlotArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storageslotarray_free(ptr >>> 0, 1));\n\nclass StorageSlotArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageSlotArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storageslotarray_free(ptr, 0);\n    }\n    /**\n     * @param {StorageSlot[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.storageslotarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        StorageSlotArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {StorageSlot}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.storageslotarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StorageSlot.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {StorageSlot} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, StorageSlot);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.storageslotarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {StorageSlot} element\n     */\n    push(element) {\n        _assertClass(element, StorageSlot);\n        wasm.storageslotarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.storageslotarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) StorageSlotArray.prototype[Symbol.dispose] = StorageSlotArray.prototype.free;\n\nconst SyncSummaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_syncsummary_free(ptr >>> 0, 1));\n\nclass SyncSummary {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SyncSummary.prototype);\n        obj.__wbg_ptr = ptr;\n        SyncSummaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SyncSummaryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncsummary_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.syncsummary_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {NoteId[]}\n     */\n    committedNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_committedNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteId[]}\n     */\n    consumedNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_consumedNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountId[]}\n     */\n    updatedAccounts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_updatedAccounts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {TransactionId[]}\n     */\n    committedTransactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_committedTransactions(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.syncsummary_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SyncSummary}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SyncSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SyncSummary.prototype[Symbol.dispose] = SyncSummary.prototype.free;\n\nconst TestUtilsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_testutils_free(ptr >>> 0, 1));\n\nclass TestUtils {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TestUtilsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_testutils_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    static createMockAccountId() {\n        const ret = wasm.testutils_createMockAccountId();\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    static createMockSerializedPackage() {\n        const ret = wasm.testutils_createMockSerializedPackage();\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) TestUtils.prototype[Symbol.dispose] = TestUtils.prototype.free;\n\nconst TokenSymbolFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokensymbol_free(ptr >>> 0, 1));\n\nclass TokenSymbol {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TokenSymbol.prototype);\n        obj.__wbg_ptr = ptr;\n        TokenSymbolFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenSymbolFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokensymbol_free(ptr, 0);\n    }\n    /**\n     * @param {string} symbol\n     */\n    constructor(symbol) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(symbol, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.tokensymbol_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            TokenSymbolFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokensymbol_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) TokenSymbol.prototype[Symbol.dispose] = TokenSymbol.prototype.free;\n\nconst TransactionArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionargs_free(ptr >>> 0, 1));\n\nclass TransactionArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionargs_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionScript | undefined}\n     */\n    txScript() {\n        const ret = wasm.transactionargs_txScript(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionScript.__wrap(ret);\n    }\n    /**\n     * @param {NoteId} note_id\n     * @returns {Word | undefined}\n     */\n    getNoteArgs(note_id) {\n        _assertClass(note_id, NoteId);\n        const ret = wasm.transactionargs_getNoteArgs(this.__wbg_ptr, note_id.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {AdviceInputs}\n     */\n    adviceInputs() {\n        const ret = wasm.transactionargs_adviceInputs(this.__wbg_ptr);\n        return AdviceInputs.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionArgs.prototype[Symbol.dispose] = TransactionArgs.prototype.free;\n\nconst TransactionFilterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionfilter_free(ptr >>> 0, 1));\n\nclass TransactionFilter {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionFilter.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionFilterFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionFilterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionfilter_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionFilter}\n     */\n    static all() {\n        const ret = wasm.transactionfilter_all();\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @param {TransactionId[]} ids\n     * @returns {TransactionFilter}\n     */\n    static ids(ids) {\n        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionfilter_ids(ptr0, len0);\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionFilter}\n     */\n    static uncommitted() {\n        const ret = wasm.transactionfilter_uncommitted();\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {TransactionFilter}\n     */\n    static expiredBefore(block_num) {\n        const ret = wasm.transactionfilter_expiredBefore(block_num);\n        return TransactionFilter.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionFilter.prototype[Symbol.dispose] = TransactionFilter.prototype.free;\n\nconst TransactionIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionid_free(ptr >>> 0, 1));\n\nclass TransactionId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionId.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof TransactionId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionid_free(ptr, 0);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    asElements() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asElements(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    asBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toHex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_toHex(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    inner() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionId.prototype[Symbol.dispose] = TransactionId.prototype.free;\n\nconst TransactionProverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionprover_free(ptr >>> 0, 1));\n\nclass TransactionProver {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionProver.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionProverFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionProverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionprover_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionProver}\n     */\n    static newLocalProver() {\n        const ret = wasm.transactionprover_newLocalProver();\n        return TransactionProver.__wrap(ret);\n    }\n    /**\n     * @param {string} endpoint\n     * @returns {TransactionProver}\n     */\n    static newRemoteProver(endpoint) {\n        const ptr0 = passStringToWasm0(endpoint, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionprover_newRemoteProver(ptr0, len0);\n        return TransactionProver.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    serialize() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionprover_serialize(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} prover_type\n     * @param {string | null} [endpoint]\n     * @returns {TransactionProver}\n     */\n    static deserialize(prover_type, endpoint) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prover_type, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(endpoint) ? 0 : passStringToWasm0(endpoint, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transactionprover_deserialize(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionProver.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    endpoint() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionprover_endpoint(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionProver.prototype[Symbol.dispose] = TransactionProver.prototype.free;\n\nconst TransactionRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrecord_free(ptr >>> 0, 1));\n\nclass TransactionRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrecord_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.transactionrecord_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    initAccountState() {\n        const ret = wasm.transactionrecord_initAccountState(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    finalAccountState() {\n        const ret = wasm.transactionrecord_finalAccountState(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word[]}\n     */\n    inputNoteNullifiers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrecord_inputNoteNullifiers(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.transactionrecord_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.transactionrecord_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {TransactionStatus}\n     */\n    transactionStatus() {\n        const ret = wasm.transactionrecord_transactionStatus(this.__wbg_ptr);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    creationTimestamp() {\n        const ret = wasm.transactionrecord_creationTimestamp(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n}\nif (Symbol.dispose) TransactionRecord.prototype[Symbol.dispose] = TransactionRecord.prototype.free;\n\nconst TransactionRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrequest_free(ptr >>> 0, 1));\n\nclass TransactionRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrequest_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionrequest_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionRequest}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {Note[]}\n     */\n    expectedOutputOwnNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_expectedOutputOwnNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteDetailsAndTag[]}\n     */\n    expectedFutureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_expectedFutureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    scriptArg() {\n        const ret = wasm.transactionrequest_scriptArg(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    authArg() {\n        const ret = wasm.transactionrequest_authArg(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionRequest.prototype[Symbol.dispose] = TransactionRequest.prototype.free;\n\nconst TransactionRequestBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrequestbuilder_free(ptr >>> 0, 1));\n\nclass TransactionRequestBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRequestBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRequestBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRequestBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrequestbuilder_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.transactionrequestbuilder_new();\n        this.__wbg_ptr = ret >>> 0;\n        TransactionRequestBuilderFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {NoteAndArgsArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withUnauthenticatedInputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, NoteAndArgsArray);\n        const ret = wasm.transactionrequestbuilder_withUnauthenticatedInputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteIdAndArgsArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withAuthenticatedInputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, NoteIdAndArgsArray);\n        const ret = wasm.transactionrequestbuilder_withAuthenticatedInputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {OutputNoteArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withOwnOutputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, OutputNoteArray);\n        const ret = wasm.transactionrequestbuilder_withOwnOutputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {TransactionScript} script\n     * @returns {TransactionRequestBuilder}\n     */\n    withCustomScript(script) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(script, TransactionScript);\n        const ret = wasm.transactionrequestbuilder_withCustomScript(ptr, script.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteRecipientArray} recipients\n     * @returns {TransactionRequestBuilder}\n     */\n    withExpectedOutputRecipients(recipients) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(recipients, NoteRecipientArray);\n        const ret = wasm.transactionrequestbuilder_withExpectedOutputRecipients(ptr, recipients.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteDetailsAndTagArray} note_details_and_tag\n     * @returns {TransactionRequestBuilder}\n     */\n    withExpectedFutureNotes(note_details_and_tag) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(note_details_and_tag, NoteDetailsAndTagArray);\n        const ret = wasm.transactionrequestbuilder_withExpectedFutureNotes(ptr, note_details_and_tag.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AdviceMap} advice_map\n     * @returns {TransactionRequestBuilder}\n     */\n    extendAdviceMap(advice_map) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(advice_map, AdviceMap);\n        const ret = wasm.transactionrequestbuilder_extendAdviceMap(ptr, advice_map.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {ForeignAccountArray} foreign_accounts\n     * @returns {TransactionRequestBuilder}\n     */\n    withForeignAccounts(foreign_accounts) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(foreign_accounts, ForeignAccountArray);\n        const ret = wasm.transactionrequestbuilder_withForeignAccounts(ptr, foreign_accounts.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {Word} script_arg\n     * @returns {TransactionRequestBuilder}\n     */\n    withScriptArg(script_arg) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(script_arg, Word);\n        const ret = wasm.transactionrequestbuilder_withScriptArg(ptr, script_arg.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {Word} auth_arg\n     * @returns {TransactionRequestBuilder}\n     */\n    withAuthArg(auth_arg) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(auth_arg, Word);\n        const ret = wasm.transactionrequestbuilder_withAuthArg(ptr, auth_arg.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionRequest}\n     */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.transactionrequestbuilder_build(ptr);\n        return TransactionRequest.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionRequestBuilder.prototype[Symbol.dispose] = TransactionRequestBuilder.prototype.free;\n\nconst TransactionResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionresult_free(ptr >>> 0, 1));\n/**\n * WASM wrapper around the native [`TransactionResult`].\n */\nclass TransactionResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionResult.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionresult_free(ptr, 0);\n    }\n    /**\n     * Returns the ID of the transaction.\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.executedtransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * Returns the executed transaction.\n     * @returns {ExecutedTransaction}\n     */\n    executedTransaction() {\n        const ret = wasm.transactionresult_executedTransaction(this.__wbg_ptr);\n        return ExecutedTransaction.__wrap(ret);\n    }\n    /**\n     * Returns notes that are expected to be created as a result of follow-up executions.\n     * @returns {NoteDetailsAndTag[]}\n     */\n    futureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionresult_futureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serializes the transaction result into bytes.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionresult_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a transaction result from bytes.\n     * @param {Uint8Array} bytes\n     * @returns {TransactionResult}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionresult_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionResult.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) TransactionResult.prototype[Symbol.dispose] = TransactionResult.prototype.free;\n\nconst TransactionScriptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscript_free(ptr >>> 0, 1));\n\nclass TransactionScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionScript.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionScriptFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscript_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.notescript_root(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionScript.prototype[Symbol.dispose] = TransactionScript.prototype.free;\n\nconst TransactionScriptInputPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscriptinputpair_free(ptr >>> 0, 1));\n\nclass TransactionScriptInputPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionScriptInputPair.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionScriptInputPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof TransactionScriptInputPair)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptInputPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscriptinputpair_free(ptr, 0);\n    }\n    /**\n     * @param {Word} word\n     * @param {FeltArray} felts\n     */\n    constructor(word, felts) {\n        _assertClass(word, Word);\n        var ptr0 = word.__destroy_into_raw();\n        _assertClass(felts, FeltArray);\n        const ret = wasm.transactionscriptinputpair_new(ptr0, felts.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        TransactionScriptInputPairFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Word}\n     */\n    word() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    felts() {\n        const ret = wasm.transactionscriptinputpair_felts(this.__wbg_ptr);\n        return FeltArray.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionScriptInputPair.prototype[Symbol.dispose] = TransactionScriptInputPair.prototype.free;\n\nconst TransactionScriptInputPairArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscriptinputpairarray_free(ptr >>> 0, 1));\n\nclass TransactionScriptInputPairArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptInputPairArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscriptinputpairarray_free(ptr, 0);\n    }\n    /**\n     * @param {TransactionScriptInputPair[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionscriptinputpairarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        TransactionScriptInputPairArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {TransactionScriptInputPair}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionscriptinputpairarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionScriptInputPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {TransactionScriptInputPair} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, TransactionScriptInputPair);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.transactionscriptinputpairarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {TransactionScriptInputPair} element\n     */\n    push(element) {\n        _assertClass(element, TransactionScriptInputPair);\n        wasm.transactionscriptinputpairarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotesarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) TransactionScriptInputPairArray.prototype[Symbol.dispose] = TransactionScriptInputPairArray.prototype.free;\n\nconst TransactionStatusFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionstatus_free(ptr >>> 0, 1));\n\nclass TransactionStatus {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionStatus.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionStatusFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionStatusFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionstatus_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionStatus}\n     */\n    static pending() {\n        const ret = wasm.transactionstatus_pending();\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @param {bigint} commit_timestamp\n     * @returns {TransactionStatus}\n     */\n    static committed(block_num, commit_timestamp) {\n        const ret = wasm.transactionstatus_committed(block_num, commit_timestamp);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @param {string} cause\n     * @returns {TransactionStatus}\n     */\n    static discarded(cause) {\n        const ptr0 = passStringToWasm0(cause, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionstatus_discarded(ptr0, len0);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPending() {\n        const ret = wasm.transactionstatus_isPending(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isCommitted() {\n        const ret = wasm.transactionstatus_isCommitted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isDiscarded() {\n        const ret = wasm.transactionstatus_isDiscarded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    getBlockNum() {\n        const ret = wasm.transactionstatus_getBlockNum(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {bigint | undefined}\n     */\n    getCommitTimestamp() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstatus_getCommitTimestamp(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionStatus.prototype[Symbol.dispose] = TransactionStatus.prototype.free;\n\nconst TransactionStoreUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionstoreupdate_free(ptr >>> 0, 1));\n\nclass TransactionStoreUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionStoreUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionStoreUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionStoreUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionstoreupdate_free(ptr, 0);\n    }\n    /**\n     * @returns {ExecutedTransaction}\n     */\n    executedTransaction() {\n        const ret = wasm.transactionstoreupdate_executedTransaction(this.__wbg_ptr);\n        return ExecutedTransaction.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    submissionHeight() {\n        const ret = wasm.transactionstoreupdate_submissionHeight(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    createdNotes() {\n        const ret = wasm.transactionstoreupdate_createdNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        const ret = wasm.transactionstoreupdate_accountDelta(this.__wbg_ptr);\n        return AccountDelta.__wrap(ret);\n    }\n    /**\n     * @returns {NoteDetailsAndTag[]}\n     */\n    futureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstoreupdate_futureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionstoreupdate_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionStoreUpdate}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstoreupdate_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionStoreUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) TransactionStoreUpdate.prototype[Symbol.dispose] = TransactionStoreUpdate.prototype.free;\n\nconst TransactionSummaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionsummary_free(ptr >>> 0, 1));\n\nclass TransactionSummary {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionSummary.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionSummaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionSummaryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionsummary_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionsummary_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionSummary}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_accountDelta(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {InputNotes}\n     */\n    inputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_inputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return InputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_outputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    salt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_salt(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionSummary.prototype[Symbol.dispose] = TransactionSummary.prototype.free;\n\nconst WebClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_webclient_free(ptr >>> 0, 1));\n\nclass WebClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WebClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_webclient_free(ptr, 0);\n    }\n    /**\n     * @returns {Promise<AccountHeader[]>}\n     */\n    getAccounts() {\n        const ret = wasm.webclient_getAccounts(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<Account | undefined>}\n     */\n    getAccount(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.webclient_getAccount(this.__wbg_ptr, account_id.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Word} pub_key\n     * @returns {Promise<AuthSecretKey>}\n     */\n    getAccountAuthByPubKey(pub_key) {\n        _assertClass(pub_key, Word);\n        const ret = wasm.webclient_getAccountAuthByPubKey(this.__wbg_ptr, pub_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    insertAccountAddress(account_id, address) {\n        _assertClass(account_id, AccountId);\n        _assertClass(address, Address);\n        const ret = wasm.webclient_insertAccountAddress(this.__wbg_ptr, account_id.__wbg_ptr, address.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    removeAccountAddress(account_id, address) {\n        _assertClass(account_id, AccountId);\n        _assertClass(address, Address);\n        const ret = wasm.webclient_removeAccountAddress(this.__wbg_ptr, account_id.__wbg_ptr, address.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @param {string} export_type\n     * @returns {Promise<NoteFile>}\n     */\n    exportNoteFile(note_id, export_type) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(export_type, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_exportNoteFile(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return takeObject(ret);\n    }\n    /**\n     * Retrieves the entire underlying web store and returns it as a `JsValue`\n     *\n     * Meant to be used in conjunction with the `force_import_store` method\n     * @returns {Promise<any>}\n     */\n    exportStore() {\n        const ret = wasm.webclient_exportStore(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<AccountFile>}\n     */\n    exportAccountFile(account_id) {\n        _assertClass(account_id, AccountId);\n        var ptr0 = account_id.__destroy_into_raw();\n        const ret = wasm.webclient_exportAccountFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountFile} account_file\n     * @returns {Promise<any>}\n     */\n    importAccountFile(account_file) {\n        _assertClass(account_file, AccountFile);\n        var ptr0 = account_file.__destroy_into_raw();\n        const ret = wasm.webclient_importAccountFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} init_seed\n     * @param {boolean} mutable\n     * @param {number} auth_scheme_id\n     * @returns {Promise<Account>}\n     */\n    importPublicAccountFromSeed(init_seed, mutable, auth_scheme_id) {\n        const ptr0 = passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_importPublicAccountFromSeed(this.__wbg_ptr, ptr0, len0, mutable, auth_scheme_id);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<any>}\n     */\n    importAccountById(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.webclient_importAccountById(this.__wbg_ptr, account_id.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFile} note_file\n     * @returns {Promise<NoteId>}\n     */\n    importNoteFile(note_file) {\n        _assertClass(note_file, NoteFile);\n        var ptr0 = note_file.__destroy_into_raw();\n        const ret = wasm.webclient_importNoteFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {any} store_dump\n     * @returns {Promise<any>}\n     */\n    forceImportStore(store_dump) {\n        const ret = wasm.webclient_forceImportStore(this.__wbg_ptr, addHeapObject(store_dump));\n        return takeObject(ret);\n    }\n    /**\n     * Creates a new client with a mock RPC API. Useful for testing purposes and proof-of-concept\n     * applications as it uses a mock chain that simulates the behavior of a real node.\n     * @param {Uint8Array | null} [seed]\n     * @param {Uint8Array | null} [serialized_mock_chain]\n     * @param {Uint8Array | null} [serialized_mock_note_transport_node]\n     * @returns {Promise<any>}\n     */\n    createMockClient(seed, serialized_mock_chain, serialized_mock_note_transport_node) {\n        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(serialized_mock_chain) ? 0 : passArray8ToWasm0(serialized_mock_chain, wasm.__wbindgen_export);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(serialized_mock_note_transport_node) ? 0 : passArray8ToWasm0(serialized_mock_note_transport_node, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createMockClient(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return takeObject(ret);\n    }\n    /**\n     * Returns the inner serialized mock chain if it exists.\n     * @returns {Uint8Array}\n     */\n    serializeMockChain() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_serializeMockChain(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the inner serialized mock note transport node if it exists.\n     * @returns {Uint8Array}\n     */\n    serializeMockNoteTransportNode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_serializeMockNoteTransportNode(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    proveBlock() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_proveBlock(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    usesMockChain() {\n        const ret = wasm.webclient_usesMockChain(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @param {boolean} mutable\n     * @param {number} auth_scheme_id\n     * @param {Uint8Array | null} [init_seed]\n     * @returns {Promise<Account>}\n     */\n    newWallet(storage_mode, mutable, auth_scheme_id, init_seed) {\n        _assertClass(storage_mode, AccountStorageMode);\n        var ptr0 = isLikeNone(init_seed) ? 0 : passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_newWallet(this.__wbg_ptr, storage_mode.__wbg_ptr, mutable, auth_scheme_id, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @param {boolean} non_fungible\n     * @param {string} token_symbol\n     * @param {number} decimals\n     * @param {bigint} max_supply\n     * @param {number} auth_scheme_id\n     * @returns {Promise<Account>}\n     */\n    newFaucet(storage_mode, non_fungible, token_symbol, decimals, max_supply, auth_scheme_id) {\n        _assertClass(storage_mode, AccountStorageMode);\n        const ptr0 = passStringToWasm0(token_symbol, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_newFaucet(this.__wbg_ptr, storage_mode.__wbg_ptr, non_fungible, ptr0, len0, decimals, max_supply, auth_scheme_id);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Account} account\n     * @param {boolean} overwrite\n     * @returns {Promise<void>}\n     */\n    newAccount(account, overwrite) {\n        _assertClass(account, Account);\n        const ret = wasm.webclient_newAccount(this.__wbg_ptr, account.__wbg_ptr, overwrite);\n        return takeObject(ret);\n    }\n    /**\n     * @param {SecretKey} secret_key\n     * @returns {Promise<void>}\n     */\n    addAccountSecretKeyToWebStore(secret_key) {\n        _assertClass(secret_key, SecretKey);\n        const ret = wasm.webclient_addAccountSecretKeyToWebStore(this.__wbg_ptr, secret_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Executes a transaction specified by the request against the specified account,\n     * proves it, submits it to the network, and updates the local database.\n     *\n     * If the transaction utilizes foreign account data, there is a chance that the client doesn't\n     * have the required block header in the local database. In these scenarios, a sync to\n     * the chain tip is performed, and the required block header is retrieved.\n     * @param {AccountId} account_id\n     * @param {TransactionRequest} transaction_request\n     * @returns {Promise<TransactionId>}\n     */\n    submitNewTransaction(account_id, transaction_request) {\n        _assertClass(account_id, AccountId);\n        _assertClass(transaction_request, TransactionRequest);\n        const ret = wasm.webclient_submitNewTransaction(this.__wbg_ptr, account_id.__wbg_ptr, transaction_request.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Executes a transaction specified by the request against the specified account but does not\n     * submit it to the network nor update the local database. The returned [`TransactionResult`]\n     * retains the execution artifacts needed to continue with the transaction lifecycle.\n     *\n     * If the transaction utilizes foreign account data, there is a chance that the client doesn't\n     * have the required block header in the local database. In these scenarios, a sync to\n     * the chain tip is performed, and the required block header is retrieved.\n     * @param {AccountId} account_id\n     * @param {TransactionRequest} transaction_request\n     * @returns {Promise<TransactionResult>}\n     */\n    executeTransaction(account_id, transaction_request) {\n        _assertClass(account_id, AccountId);\n        _assertClass(transaction_request, TransactionRequest);\n        const ret = wasm.webclient_executeTransaction(this.__wbg_ptr, account_id.__wbg_ptr, transaction_request.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Generates a transaction proof using either the provided prover or the client's default\n     * prover if none is supplied.\n     * @param {TransactionResult} transaction_result\n     * @param {TransactionProver | null} [prover]\n     * @returns {Promise<ProvenTransaction>}\n     */\n    proveTransaction(transaction_result, prover) {\n        _assertClass(transaction_result, TransactionResult);\n        let ptr0 = 0;\n        if (!isLikeNone(prover)) {\n            _assertClass(prover, TransactionProver);\n            ptr0 = prover.__destroy_into_raw();\n        }\n        const ret = wasm.webclient_proveTransaction(this.__wbg_ptr, transaction_result.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {ProvenTransaction} proven_transaction\n     * @param {TransactionResult} transaction_result\n     * @returns {Promise<number>}\n     */\n    submitProvenTransaction(proven_transaction, transaction_result) {\n        _assertClass(proven_transaction, ProvenTransaction);\n        _assertClass(transaction_result, TransactionResult);\n        const ret = wasm.webclient_submitProvenTransaction(this.__wbg_ptr, proven_transaction.__wbg_ptr, transaction_result.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {TransactionResult} transaction_result\n     * @param {number} submission_height\n     * @returns {Promise<TransactionStoreUpdate>}\n     */\n    applyTransaction(transaction_result, submission_height) {\n        _assertClass(transaction_result, TransactionResult);\n        const ret = wasm.webclient_applyTransaction(this.__wbg_ptr, transaction_result.__wbg_ptr, submission_height);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} target_account_id\n     * @param {AccountId} faucet_id\n     * @param {NoteType} note_type\n     * @param {bigint} amount\n     * @returns {TransactionRequest}\n     */\n    newMintTransactionRequest(target_account_id, faucet_id, note_type, amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(target_account_id, AccountId);\n            _assertClass(faucet_id, AccountId);\n            wasm.webclient_newMintTransactionRequest(retptr, this.__wbg_ptr, target_account_id.__wbg_ptr, faucet_id.__wbg_ptr, note_type, amount);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender_account_id\n     * @param {AccountId} target_account_id\n     * @param {AccountId} faucet_id\n     * @param {NoteType} note_type\n     * @param {bigint} amount\n     * @param {number | null} [recall_height]\n     * @param {number | null} [timelock_height]\n     * @returns {TransactionRequest}\n     */\n    newSendTransactionRequest(sender_account_id, target_account_id, faucet_id, note_type, amount, recall_height, timelock_height) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender_account_id, AccountId);\n            _assertClass(target_account_id, AccountId);\n            _assertClass(faucet_id, AccountId);\n            wasm.webclient_newSendTransactionRequest(retptr, this.__wbg_ptr, sender_account_id.__wbg_ptr, target_account_id.__wbg_ptr, faucet_id.__wbg_ptr, note_type, amount, isLikeNone(recall_height) ? 0x100000001 : (recall_height) >>> 0, isLikeNone(timelock_height) ? 0x100000001 : (timelock_height) >>> 0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string[]} list_of_note_ids\n     * @returns {TransactionRequest}\n     */\n    newConsumeTransactionRequest(list_of_note_ids) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(list_of_note_ids, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.webclient_newConsumeTransactionRequest(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender_account_id\n     * @param {AccountId} offered_asset_faucet_id\n     * @param {bigint} offered_asset_amount\n     * @param {AccountId} requested_asset_faucet_id\n     * @param {bigint} requested_asset_amount\n     * @param {NoteType} note_type\n     * @param {NoteType} payback_note_type\n     * @returns {TransactionRequest}\n     */\n    newSwapTransactionRequest(sender_account_id, offered_asset_faucet_id, offered_asset_amount, requested_asset_faucet_id, requested_asset_amount, note_type, payback_note_type) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender_account_id, AccountId);\n            _assertClass(offered_asset_faucet_id, AccountId);\n            _assertClass(requested_asset_faucet_id, AccountId);\n            wasm.webclient_newSwapTransactionRequest(retptr, this.__wbg_ptr, sender_account_id.__wbg_ptr, offered_asset_faucet_id.__wbg_ptr, offered_asset_amount, requested_asset_faucet_id.__wbg_ptr, requested_asset_amount, note_type, payback_note_type);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Send a private note via the note transport layer\n     * @param {Note} note\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    sendPrivateNote(note, address) {\n        _assertClass(note, Note);\n        var ptr0 = note.__destroy_into_raw();\n        _assertClass(address, Address);\n        var ptr1 = address.__destroy_into_raw();\n        const ret = wasm.webclient_sendPrivateNote(this.__wbg_ptr, ptr0, ptr1);\n        return takeObject(ret);\n    }\n    /**\n     * Fetch private notes from the note transport layer\n     *\n     * Uses an internal pagination mechanism to avoid fetching duplicate notes.\n     * @returns {Promise<void>}\n     */\n    fetchPrivateNotes() {\n        const ret = wasm.webclient_fetchPrivateNotes(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Fetch all private notes from the note transport layer\n     *\n     * Fetches all notes stored in the transport layer, with no pagination.\n     * Prefer using [`WebClient::fetch_private_notes`] for a more efficient, on-going,\n     * fetching mechanism.\n     * @returns {Promise<void>}\n     */\n    fetchAllPrivateNotes() {\n        const ret = wasm.webclient_fetchAllPrivateNotes(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFilter} filter\n     * @returns {Promise<InputNoteRecord[]>}\n     */\n    getInputNotes(filter) {\n        _assertClass(filter, NoteFilter);\n        var ptr0 = filter.__destroy_into_raw();\n        const ret = wasm.webclient_getInputNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @returns {Promise<InputNoteRecord | undefined>}\n     */\n    getInputNote(note_id) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getInputNote(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFilter} filter\n     * @returns {Promise<any>}\n     */\n    getOutputNotes(filter) {\n        _assertClass(filter, NoteFilter);\n        var ptr0 = filter.__destroy_into_raw();\n        const ret = wasm.webclient_getOutputNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @returns {Promise<any>}\n     */\n    getOutputNote(note_id) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getOutputNote(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId | null} [account_id]\n     * @returns {Promise<ConsumableNoteRecord[]>}\n     */\n    getConsumableNotes(account_id) {\n        let ptr0 = 0;\n        if (!isLikeNone(account_id)) {\n            _assertClass(account_id, AccountId);\n            ptr0 = account_id.__destroy_into_raw();\n        }\n        const ret = wasm.webclient_getConsumableNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * Retrieves the setting value for `key`, or `None` if it hasnt been set.\n     * @param {string} key\n     * @returns {Promise<any | undefined>}\n     */\n    getSetting(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getSetting(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Sets a setting key-value in the store. It can then be retrieved using `get_setting`.\n     * @param {string} key\n     * @param {any} value\n     * @returns {Promise<void>}\n     */\n    setSetting(key, value) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_setSetting(this.__wbg_ptr, ptr0, len0, addHeapObject(value));\n        return takeObject(ret);\n    }\n    /**\n     * Deletes a setting key-value from the store.\n     * @param {string} key\n     * @returns {Promise<void>}\n     */\n    removeSetting(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_removeSetting(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Returns all the existing setting keys from the store.\n     * @returns {Promise<string[]>}\n     */\n    listSettingKeys() {\n        const ret = wasm.webclient_listSettingKeys(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<SyncSummary>}\n     */\n    syncState() {\n        const ret = wasm.webclient_syncState(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<number>}\n     */\n    getSyncHeight() {\n        const ret = wasm.webclient_getSyncHeight(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteType} note_type\n     * @param {AccountId} offered_asset_faucet_id\n     * @param {bigint} offered_asset_amount\n     * @param {AccountId} requested_asset_faucet_id\n     * @param {bigint} requested_asset_amount\n     * @returns {NoteTag}\n     */\n    static buildSwapTag(note_type, offered_asset_faucet_id, offered_asset_amount, requested_asset_faucet_id, requested_asset_amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(offered_asset_faucet_id, AccountId);\n            _assertClass(requested_asset_faucet_id, AccountId);\n            wasm.webclient_buildSwapTag(retptr, note_type, offered_asset_faucet_id.__wbg_ptr, offered_asset_amount, requested_asset_faucet_id.__wbg_ptr, requested_asset_amount);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} tag\n     * @returns {Promise<void>}\n     */\n    addTag(tag) {\n        const ptr0 = passStringToWasm0(tag, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_addTag(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} tag\n     * @returns {Promise<void>}\n     */\n    removeTag(tag) {\n        const ptr0 = passStringToWasm0(tag, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_removeTag(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<any>}\n     */\n    listTags() {\n        const ret = wasm.webclient_listTags(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {TransactionFilter} transaction_filter\n     * @returns {Promise<TransactionRecord[]>}\n     */\n    getTransactions(transaction_filter) {\n        _assertClass(transaction_filter, TransactionFilter);\n        var ptr0 = transaction_filter.__destroy_into_raw();\n        const ret = wasm.webclient_getTransactions(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    constructor() {\n        const ret = wasm.webclient_new();\n        this.__wbg_ptr = ret >>> 0;\n        WebClientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Creates a new client with the given node URL and optional seed.\n     * If `node_url` is `None`, it defaults to the testnet endpoint.\n     * @param {string | null} [node_url]\n     * @param {string | null} [node_note_transport_url]\n     * @param {Uint8Array | null} [seed]\n     * @returns {Promise<any>}\n     */\n    createClient(node_url, node_note_transport_url, seed) {\n        var ptr0 = isLikeNone(node_url) ? 0 : passStringToWasm0(node_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(node_note_transport_url) ? 0 : passStringToWasm0(node_note_transport_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createClient(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return takeObject(ret);\n    }\n    /**\n     * Creates a new client with the given node URL, optional seed, and external keystore\n     * callbacks. If `node_url` is `None`, it defaults to the testnet endpoint.\n     * @param {string | null} [node_url]\n     * @param {string | null} [node_note_transport_url]\n     * @param {Uint8Array | null} [seed]\n     * @param {Function | null} [get_key_cb]\n     * @param {Function | null} [insert_key_cb]\n     * @param {Function | null} [sign_cb]\n     * @returns {Promise<any>}\n     */\n    createClientWithExternalKeystore(node_url, node_note_transport_url, seed, get_key_cb, insert_key_cb, sign_cb) {\n        var ptr0 = isLikeNone(node_url) ? 0 : passStringToWasm0(node_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(node_note_transport_url) ? 0 : passStringToWasm0(node_note_transport_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createClientWithExternalKeystore(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, isLikeNone(get_key_cb) ? 0 : addHeapObject(get_key_cb), isLikeNone(insert_key_cb) ? 0 : addHeapObject(insert_key_cb), isLikeNone(sign_cb) ? 0 : addHeapObject(sign_cb));\n        return takeObject(ret);\n    }\n    /**\n     * @returns {ScriptBuilder}\n     */\n    createScriptBuilder() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_createScriptBuilder(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptBuilder.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) WebClient.prototype[Symbol.dispose] = WebClient.prototype.free;\n\nconst WordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_word_free(ptr >>> 0, 1));\n\nclass Word {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Word.prototype);\n        obj.__wbg_ptr = ptr;\n        WordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Word)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_word_free(ptr, 0);\n    }\n    /**\n     * @param {BigUint64Array} u64_vec\n     */\n    constructor(u64_vec) {\n        const ptr0 = passArray64ToWasm0(u64_vec, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.word_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        WordFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Creates a Word from a hex string.\n     * Fails if the provided string is not a valid hex representation of a Word.\n     * @param {string} hex\n     * @returns {Word}\n     */\n    static fromHex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.word_fromHex(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Felt[]} felt_vec\n     * @returns {Word}\n     */\n    static newFromFelts(felt_vec) {\n        const ptr0 = passArrayJsValueToWasm0(felt_vec, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.word_newFromFelts(ptr0, len0);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toHex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_toHex(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.word_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Word}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.word_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {BigUint64Array}\n     */\n    toU64s() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.word_toU64s(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU64FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 8, 8);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    toFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asElements(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Word.prototype[Symbol.dispose] = Word.prototype.free;\n\nconst EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_Error_e83987f665cf5504 = function(arg0, arg1) {\n        const ret = Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_Number_bb48ca12f395cd08 = function(arg0) {\n        const ret = Number(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_bigint_get_as_i64_f3ebc5a755000afd = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbg___wbindgen_boolean_get_6d5a1ee65bab5f68 = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? v : undefined;\n        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n    };\n    imports.wbg.__wbg___wbindgen_debug_string_df47ffb5e35e6763 = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_in_bb933bd9e1b3bc0f = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_bigint_cb320707dcd35f0b = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_function_ee8a6c5833c90377 = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_null_5e69f72e906cc57c = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_object_c818261d21f283a4 = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_undefined_2d472862bd29a478 = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_jsval_eq_6b13ab83478b1c50 = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_jsval_loose_eq_b664b38a2f582147 = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_number_get_a20bf9b85341449d = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbg___wbindgen_string_get_e4f06c90489ad01b = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_throw_b855445ff6a94295 = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg__wbg_cb_unref_2454a539ea5790d9 = function(arg0) {\n        getObject(arg0)._wbg_cb_unref();\n    };\n    imports.wbg.__wbg_abort_28ad55c5825b004d = function(arg0, arg1) {\n        getObject(arg0).abort(getObject(arg1));\n    };\n    imports.wbg.__wbg_abort_e7eb059f72f9ed0c = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_account_new = function(arg0) {\n        const ret = Account.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_account_unwrap = function(arg0) {\n        const ret = Account.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_accountfile_new = function(arg0) {\n        const ret = AccountFile.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountheader_new = function(arg0) {\n        const ret = AccountHeader.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountid_new = function(arg0) {\n        const ret = AccountId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountid_unwrap = function(arg0) {\n        const ret = AccountId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_addNoteTag_948ab4cc7d3d784b = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getStringFromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        let v2;\n        if (arg4 !== 0) {\n            v2 = getStringFromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n        }\n        const ret = addNoteTag(v0, v1, v2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_b577eb3a177bc0fa = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_applyStateSync_687415d1bcf4dd8a = function(arg0) {\n        const ret = applyStateSync(JsStateSyncUpdate.__wrap(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_authsecretkey_new = function(arg0) {\n        const ret = AuthSecretKey.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_body_587542b2fd8e06c0 = function(arg0) {\n        const ret = getObject(arg0).body;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_ccc4520b36d3ccf4 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_byobRequest_2344e6975f27456e = function(arg0) {\n        const ret = getObject(arg0).byobRequest;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_byteLength_bcd42e4025299788 = function(arg0) {\n        const ret = getObject(arg0).byteLength;\n        return ret;\n    };\n    imports.wbg.__wbg_byteOffset_ca3a6cf7944b364b = function(arg0) {\n        const ret = getObject(arg0).byteOffset;\n        return ret;\n    };\n    imports.wbg.__wbg_call_525440f72fbfc0ea = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e45d2cf9fc925fcf = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e762c39fa8ea36bf = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_cancel_48ab6f9dc366e369 = function(arg0) {\n        const ret = getObject(arg0).cancel();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_catch_943836faa5d29bfb = function(arg0, arg1) {\n        const ret = getObject(arg0).catch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_clearTimeout_2e2c4939388cdfbb = function(arg0) {\n        const ret = clearTimeout(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_close_5a6caed3231b68cd = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_close_6956df845478561a = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_consumablenoterecord_new = function(arg0) {\n        const ret = ConsumableNoteRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_done_2042aa2670fb1db1 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_enqueue_7b18a650aec77898 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).enqueue(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_exportStore_13b5274b45367269 = function() {\n        const ret = exportStore();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_felt_new = function(arg0) {\n        const ret = Felt.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_felt_unwrap = function(arg0) {\n        const ret = Felt.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fetch_53eef7df7b439a49 = function(arg0, arg1) {\n        const ret = fetch(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_8725865ff47e7fcc = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).fetch(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetchednote_new = function(arg0) {\n        const ret = FetchedNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_forceImportStore_e4f1437d6b4cff0e = function(arg0) {\n        const ret = forceImportStore(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_foreignaccount_unwrap = function(arg0) {\n        const ret = ForeignAccount.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fungibleasset_new = function(arg0) {\n        const ret = FungibleAsset.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fungibleasset_unwrap = function(arg0) {\n        const ret = FungibleAsset.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fungibleassetdeltaitem_new = function(arg0) {\n        const ret = FungibleAssetDeltaItem.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountAddresses_57dcaf04403ffff6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountAddresses(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountAuthByPubKey_a99268a0c5e781fc = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountAuthByPubKey(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountCode_255c47880027604f = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountCode(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountHeaderByCommitment_2457b381278acd9d = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountHeaderByCommitment(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountHeader_3e3c0fd16ce78046 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountHeader(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountIds_1dc3cc9beb00dac4 = function() {\n        const ret = getAccountIds();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountStorageMaps_52d390f59d39870a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getAccountStorageMaps(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountStorage_e7e314d3a8c68188 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountStorage(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountVaultAssets_058aa7a3e85f9d7e = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountVaultAssets(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAllAccountHeaders_21ae58fbd74bc207 = function() {\n        const ret = getAllAccountHeaders();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getBlockHeaders_ffbe629419e49f24 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getBlockHeaders(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getForeignAccountCode_84f81a9fb264b2a8 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getForeignAccountCode(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotesFromIds_a4814ff3ee6838f4 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getInputNotesFromIds(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotesFromNullifiers_b125192521cb2707 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getInputNotesFromNullifiers(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotes_9e7daab3e11aada9 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = getInputNotes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getNoteScript_8db4a87f1daa5732 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getNoteScript(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getNoteTags_445672fbda7617ca = function() {\n        const ret = getNoteTags();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotesFromIds_a9f95eee5aea111a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getOutputNotesFromIds(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotesFromNullifiers_15708419209f0017 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getOutputNotesFromNullifiers(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotes_7e9034b7845d8547 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = getOutputNotes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainNodesAll_f7b99da4ecc2cf67 = function() {\n        const ret = getPartialBlockchainNodesAll();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainNodes_4b59f3cf3d67885a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getPartialBlockchainNodes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainPeaksByBlockNum_c3683954cf872601 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getPartialBlockchainPeaksByBlockNum(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getRandomValues_1c61fac11405ffdc = function() { return handleError(function (arg0, arg1) {\n        globalThis.crypto.getRandomValues(getArrayU8FromWasm0(arg0, arg1));\n    }, arguments) };\n    imports.wbg.__wbg_getReader_48e00749fe3f6089 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).getReader();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_getSetting_30d487e26ed3ecff = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getSetting(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getSyncHeight_f7c4ff032d6e8719 = function() {\n        const ret = getSyncHeight();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_14776bfb48a1bff9 = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_getTrackedBlockHeaders_0e922af05410981b = function() {\n        const ret = getTrackedBlockHeaders();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTransactions_7511822ed7df4a04 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getTransactions(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getUnspentInputNoteNullifiers_a53ee1887b305122 = function() {\n        const ret = getUnspentInputNoteNullifiers();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_7bed016f185add81 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_done_a0463af43a1fc764 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n    };\n    imports.wbg.__wbg_get_efcb449f58ec27c2 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_value_5ce96c9f81ce7398 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_with_ref_key_1dc361bd10053bfe = function(arg0, arg1) {\n        const ret = getObject(arg0)[getObject(arg1)];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getproceduresresultitem_new = function(arg0) {\n        const ret = GetProceduresResultItem.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_787fafc980c3ccdb = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_headers_b87d7eaba61c3278 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_inputnote_new = function(arg0) {\n        const ret = InputNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_inputnoterecord_new = function(arg0) {\n        const ret = InputNoteRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_insertAccountAddress_819a7abb57d5c50e = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = insertAccountAddress(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertAccountAuth_88fdf1ae9cfe0155 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            deferred1_0 = arg2;\n            deferred1_1 = arg3;\n            const ret = insertAccountAuth(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertBlockHeader_5e4c39a64aba945d = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            var v2 = getArrayU8FromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n            const ret = insertBlockHeader(getStringFromWasm0(arg0, arg1), v1, v2, arg6 !== 0);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertPartialBlockchainNodes_5139cc9702ff0a99 = function(arg0, arg1, arg2, arg3) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        var v1 = getArrayJsValueFromWasm0(arg2, arg3).slice();\n        wasm.__wbindgen_export3(arg2, arg3 * 4, 4);\n        const ret = insertPartialBlockchainNodes(v0, v1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_insertSetting_1e2fa0de524f2782 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = insertSetting(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertTransactionScript_8e5b6d2bcc70c826 = function(arg0, arg1, arg2, arg3) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        const ret = insertTransactionScript(v0, v1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_70beb1189ca63b38 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Promise_001fdd42afa1b7ef = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Promise;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_20c8e73002f7af98 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_isArray_96e0af9891d0945d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_isSafeInteger_d216eda7911dde36 = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_e5822695327a3c39 = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsaccountupdate_new = function(arg0) {\n        const ret = JsAccountUpdate.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsaccountupdate_unwrap = function(arg0) {\n        const ret = JsAccountUpdate.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsstoragemapentry_new = function(arg0) {\n        const ret = JsStorageMapEntry.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsstoragemapentry_unwrap = function(arg0) {\n        const ret = JsStorageMapEntry.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsstorageslot_new = function(arg0) {\n        const ret = JsStorageSlot.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsstorageslot_unwrap = function(arg0) {\n        const ret = JsStorageSlot.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsvaultasset_new = function(arg0) {\n        const ret = JsVaultAsset.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsvaultasset_unwrap = function(arg0) {\n        const ret = JsVaultAsset.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_length_69bca3cb64fc8748 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_cdd215e10d9dd507 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_listSettingKeys_6940be01c27a8e08 = function() {\n        const ret = listSettingKeys();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_lockAccount_17e6307335343eaa = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = lockAccount(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_new_0_f9740686d739025c = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1acc0b6eea89d040 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_2531773dac38ebb3 = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_3c3d849046688a66 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wasm_bindgen_func_elem_3677(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_new_5a79be3ab53b8aa5 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_9edf9838a2def39c = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_a7442b4b19c1a356 = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_e17d9f43105b08be = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_from_slice_92f4d78ca282a2d2 = function(arg0, arg1) {\n        const ret = new Uint8Array(getArrayU8FromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_no_args_ee98eee5275000a4 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_with_byte_offset_and_length_46e3e6a5e9f9e89b = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_with_str_and_init_0ae7728b6ec367b1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_020810e0ae8ebcb0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_2c826fe5dfec6b6a = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_note_new = function(arg0) {\n        const ret = Note.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteandargs_unwrap = function(arg0) {\n        const ret = NoteAndArgs.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noteconsumability_new = function(arg0) {\n        const ret = NoteConsumability.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteconsumability_unwrap = function(arg0) {\n        const ret = NoteConsumability.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notedetailsandtag_new = function(arg0) {\n        const ret = NoteDetailsAndTag.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_notedetailsandtag_unwrap = function(arg0) {\n        const ret = NoteDetailsAndTag.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notefile_new = function(arg0) {\n        const ret = NoteFile.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteid_new = function(arg0) {\n        const ret = NoteId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteid_unwrap = function(arg0) {\n        const ret = NoteId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noteidandargs_unwrap = function(arg0) {\n        const ret = NoteIdAndArgs.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noterecipient_unwrap = function(arg0) {\n        const ret = NoteRecipient.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notescript_new = function(arg0) {\n        const ret = NoteScript.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_openDatabase_f242cd782d300916 = function() {\n        const ret = openDatabase();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_outputnote_new = function(arg0) {\n        const ret = OutputNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_outputnote_unwrap = function(arg0) {\n        const ret = OutputNote.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_outputnotes_unwrap = function(arg0) {\n        const ret = OutputNotes.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_prototypesetcall_2a6620b6922694b2 = function(arg0, arg1, arg2) {\n        Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), getObject(arg2));\n    };\n    imports.wbg.__wbg_proventransaction_new = function(arg0) {\n        const ret = ProvenTransaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_pruneIrrelevantBlocks_ce5174b85cbd83fa = function() {\n        const ret = pruneIrrelevantBlocks();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_34d692c25c47d05b = function(arg0) {\n        const ret = getObject(arg0).queueMicrotask;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_9d76cacb20c84d58 = function(arg0) {\n        queueMicrotask(getObject(arg0));\n    };\n    imports.wbg.__wbg_read_48f1593df542f968 = function(arg0) {\n        const ret = getObject(arg0).read();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_releaseLock_5d0b5a68887b891d = function(arg0) {\n        getObject(arg0).releaseLock();\n    };\n    imports.wbg.__wbg_removeAccountAddress_94b451fd5476b672 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = removeAccountAddress(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_removeNoteTag_550b0385167f2dcf = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getStringFromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        let v2;\n        if (arg4 !== 0) {\n            v2 = getStringFromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n        }\n        const ret = removeNoteTag(v0, v1, v2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_removeSetting_9f59cbfbe95f4843 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = removeSetting(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_resolve_caf97c30b83f7053 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_respond_0f4dbf5386f5c73e = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).respond(arg1 >>> 0);\n    }, arguments) };\n    imports.wbg.__wbg_serializedinputnotedata_new = function(arg0) {\n        const ret = SerializedInputNoteData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedinputnotedata_unwrap = function(arg0) {\n        const ret = SerializedInputNoteData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_serializedoutputnotedata_new = function(arg0) {\n        const ret = SerializedOutputNoteData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedoutputnotedata_unwrap = function(arg0) {\n        const ret = SerializedOutputNoteData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_serializedtransactiondata_new = function(arg0) {\n        const ret = SerializedTransactionData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedtransactiondata_unwrap = function(arg0) {\n        const ret = SerializedTransactionData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_setTimeout_929c97a7c0f23d36 = function(arg0, arg1) {\n        const ret = setTimeout(getObject(arg0), arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_8b342d8cd9d2a02c = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_set_9e6516df7b7d0f19 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_set_body_3c365989753d61f4 = function(arg0, arg1) {\n        getObject(arg0).body = getObject(arg1);\n    };\n    imports.wbg.__wbg_set_c213c871859d6500 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_set_c2abbebe8b9ebee1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_set_cache_2f9deb19b92b81e3 = function(arg0, arg1) {\n        getObject(arg0).cache = __wbindgen_enum_RequestCache[arg1];\n    };\n    imports.wbg.__wbg_set_credentials_f621cd2d85c0c228 = function(arg0, arg1) {\n        getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];\n    };\n    imports.wbg.__wbg_set_headers_6926da238cd32ee4 = function(arg0, arg1) {\n        getObject(arg0).headers = getObject(arg1);\n    };\n    imports.wbg.__wbg_set_integrity_62a46fc792832f41 = function(arg0, arg1, arg2) {\n        getObject(arg0).integrity = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_method_c02d8cbbe204ac2d = function(arg0, arg1, arg2) {\n        getObject(arg0).method = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_mode_52ef73cfa79639cb = function(arg0, arg1) {\n        getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];\n    };\n    imports.wbg.__wbg_set_redirect_df0285496ec45ff8 = function(arg0, arg1) {\n        getObject(arg0).redirect = __wbindgen_enum_RequestRedirect[arg1];\n    };\n    imports.wbg.__wbg_set_referrer_ec9cf8a8a315d50c = function(arg0, arg1, arg2) {\n        getObject(arg0).referrer = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_referrer_policy_99c1f299b4e37446 = function(arg0, arg1) {\n        getObject(arg0).referrerPolicy = __wbindgen_enum_ReferrerPolicy[arg1];\n    };\n    imports.wbg.__wbg_set_signal_dda2cf7ccb6bee0f = function(arg0, arg1) {\n        getObject(arg0).signal = getObject(arg1);\n    };\n    imports.wbg.__wbg_signal_4db5aa055bf9eb9a = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_slotandkeys_unwrap = function(arg0) {\n        const ret = SlotAndKeys.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_89e1d9ac6a1b250e = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_8b530f326a9e48ac = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_6fdf4b64710cc91b = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_b45bfc5a37f6cfa2 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_status_de7eed5a7a5bfd5d = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_storageslot_unwrap = function(arg0) {\n        const ret = StorageSlot.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_syncsummary_new = function(arg0) {\n        const ret = SyncSummary.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_4f46f6544e6b4a28 = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_70d05cf780a18d77 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_toString_7da7c8dbec78fcb8 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionid_new = function(arg0) {\n        const ret = TransactionId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionid_unwrap = function(arg0) {\n        const ret = TransactionId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_transactionrecord_new = function(arg0) {\n        const ret = TransactionRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionresult_new = function(arg0) {\n        const ret = TransactionResult.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionscriptinputpair_unwrap = function(arg0) {\n        const ret = TransactionScriptInputPair.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_transactionstoreupdate_new = function(arg0) {\n        const ret = TransactionStoreUpdate.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_undoAccountStates_fe9da382937036bd = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = undoAccountStates(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertAccountCode_c93e9111b2c73274 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = upsertAccountCode(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertAccountRecord_88843ee6a71cc8b3 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred1_0;\n        let deferred1_1;\n        let deferred2_0;\n        let deferred2_1;\n        let deferred3_0;\n        let deferred3_1;\n        let deferred4_0;\n        let deferred4_1;\n        let deferred5_0;\n        let deferred5_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            deferred1_0 = arg2;\n            deferred1_1 = arg3;\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            deferred3_0 = arg6;\n            deferred3_1 = arg7;\n            deferred4_0 = arg8;\n            deferred4_1 = arg9;\n            deferred5_0 = arg11;\n            deferred5_1 = arg12;\n            let v6;\n            if (arg13 !== 0) {\n                v6 = getArrayU8FromWasm0(arg13, arg14).slice();\n                wasm.__wbindgen_export3(arg13, arg14 * 1, 1);\n            }\n            const ret = upsertAccountRecord(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7), getStringFromWasm0(arg8, arg9), arg10 !== 0, getStringFromWasm0(arg11, arg12), v6);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n            wasm.__wbindgen_export3(deferred4_0, deferred4_1, 1);\n            wasm.__wbindgen_export3(deferred5_0, deferred5_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertAccountStorage_71aea983d8e45253 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertAccountStorage(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertForeignAccountCode_a2ffdd0deb87c063 = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            const ret = upsertForeignAccountCode(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertInputNote_7733702c48e2ae17 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred4_0;\n        let deferred4_1;\n        let deferred6_0;\n        let deferred6_1;\n        let deferred7_0;\n        let deferred7_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            var v2 = getArrayU8FromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n            var v3 = getArrayU8FromWasm0(arg6, arg7).slice();\n            wasm.__wbindgen_export3(arg6, arg7 * 1, 1);\n            deferred4_0 = arg8;\n            deferred4_1 = arg9;\n            var v5 = getArrayU8FromWasm0(arg10, arg11).slice();\n            wasm.__wbindgen_export3(arg10, arg11 * 1, 1);\n            deferred6_0 = arg12;\n            deferred6_1 = arg13;\n            deferred7_0 = arg14;\n            deferred7_1 = arg15;\n            var v8 = getArrayU8FromWasm0(arg17, arg18).slice();\n            wasm.__wbindgen_export3(arg17, arg18 * 1, 1);\n            const ret = upsertInputNote(getStringFromWasm0(arg0, arg1), v1, v2, v3, getStringFromWasm0(arg8, arg9), v5, getStringFromWasm0(arg12, arg13), getStringFromWasm0(arg14, arg15), arg16, v8);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred4_0, deferred4_1, 1);\n            wasm.__wbindgen_export3(deferred6_0, deferred6_1, 1);\n            wasm.__wbindgen_export3(deferred7_0, deferred7_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertNoteScript_3c569a673eff21c9 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = upsertNoteScript(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertOutputNote_1a9c6b80bc3b2979 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            var v3 = getArrayU8FromWasm0(arg6, arg7).slice();\n            wasm.__wbindgen_export3(arg6, arg7 * 1, 1);\n            let v4;\n            if (arg8 !== 0) {\n                v4 = getStringFromWasm0(arg8, arg9).slice();\n                wasm.__wbindgen_export3(arg8, arg9 * 1, 1);\n            }\n            var v5 = getArrayU8FromWasm0(arg12, arg13).slice();\n            wasm.__wbindgen_export3(arg12, arg13 * 1, 1);\n            const ret = upsertOutputNote(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5), v3, v4, arg10 >>> 0, arg11, v5);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertStorageMapEntries_57da734cbee448bf = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertStorageMapEntries(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertTransactionRecord_e4a8b05f1b3714ea = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            var v3 = getArrayU8FromWasm0(arg7, arg8).slice();\n            wasm.__wbindgen_export3(arg7, arg8 * 1, 1);\n            let v4;\n            if (arg9 !== 0) {\n                v4 = getArrayU8FromWasm0(arg9, arg10).slice();\n                wasm.__wbindgen_export3(arg9, arg10 * 1, 1);\n            }\n            const ret = upsertTransactionRecord(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5), arg6, v3, v4);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertVaultAssets_ce549ede4457df6e = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertVaultAssets(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_value_692627309814bb8c = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_view_f6c15ac9fed63bbd = function(arg0) {\n        const ret = getObject(arg0).view;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_word_new = function(arg0) {\n        const ret = Word.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_word_unwrap = function(arg0) {\n        const ret = Word.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_cast_1ff30c89f8c13d4b = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"TransactionRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {\n        // Cast intrinsic for `Ref(String) -> Externref`.\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_25a0a844437d0e92 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"string\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_298dfd99998f1bbf = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"ConsumableNoteRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_3186144f3014a6e9 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"FetchedNote\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_356a649c76ea3d4a = function(arg0, arg1) {\n        // Cast intrinsic for `Closure(Closure { dtor_idx: 516, function: Function { arguments: [], shim_idx: 517, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n        const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_9308, __wasm_bindgen_func_elem_9309);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_4625c577ab2ec9ee = function(arg0) {\n        // Cast intrinsic for `U64 -> Externref`.\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_61180cf2da5580dc = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"AccountHeader\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_77bc3e92745e9a35 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        // Cast intrinsic for `Vector(U8) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_a0c9c97993851672 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"InputNoteRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_c8873871663829dd = function(arg0, arg1) {\n        // Cast intrinsic for `Closure(Closure { dtor_idx: 516, function: Function { arguments: [Externref], shim_idx: 521, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n        const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_9308, __wasm_bindgen_func_elem_9375);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_d6cd19b81560fd6e = function(arg0) {\n        // Cast intrinsic for `F64 -> Externref`.\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n\n    return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedBigUint64ArrayMemory0 = null;\n    cachedDataViewMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module);\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path);\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n        }\n    }\n\n\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nconst module = /* asset import */ new __webpack_require__.U(__webpack_require__(/*! assets/miden_client_web.wasm */ \"(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/assets/miden_client_web.wasm\"));\n                \n                    await __wbg_init({ module_or_path: module });\n\n\n//# sourceMappingURL=Cargo-acbd8ac5-acbd8ac5.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlbW94LWxhYnMvbWlkZW4tc2RrL2Rpc3Qvd29ya2Vycy9DYXJnby1hY2JkOGFjNS1hY2JkOGFjNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN4RiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixPQUFPO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMkU7QUFDMUYsZUFBZSw2REFBNkQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbURBQW1ELDJCQUEyQixJQUFJLDBCQUEwQixvQkFBb0I7QUFDek0sd0VBQXdFLG9CQUFvQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0JBQWdCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsdUJBQXVCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDJDQUEyQyxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsVUFBVTtBQUNWO0FBQ0E7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RixjQUFjO0FBQ2QsNkVBQTZFLDRCQUE0QjtBQUN6RyxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDZDQUE2QztBQUN4RztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUIsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyREFBMkQ7QUFDMUcsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLHFDQUFxQztBQUNyQyxVQUFVO0FBQ1Ysd0JBQXdCLG1CQUFtQix1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUMscUNBQXFDO0FBQ3JDLFVBQVU7QUFDVjtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQscUNBQXFDO0FBQ3JDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx1REFBdUQsc0JBQXNCLHNDQUFzQyxzQkFBc0Isc0JBQXNCLHVDQUF1QztBQUN0USw2Q0FBNkMseUNBQXlDLElBQUk7QUFDMUYsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUF1RCx3QkFBd0I7QUFDL0k7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsbUJBQW1CO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrREFBa0QscUNBQXFDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQXlEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG1EQUFtRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQseURBQXlELG1EQUFtRDtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixnQkFBZ0I7QUFDNUcsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyRUFBMkU7QUFDMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvRUFBb0UsSUFBSSwrQ0FBK0M7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkUsNENBQTRDLHNDQUFzQztBQUNsRixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMENBQTBDO0FBQ25HLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUIsNkNBQTZDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHlCQUF5QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRiw2QkFBNkI7QUFDbEgsK0JBQStCLGlCQUFpQixpREFBaUQ7QUFDakc7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkRBQTZEO0FBQzdEO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RCxpRkFBaUYsc0NBQXNDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlGQUFpRjtBQUM3SCxjQUFjLHdCQUF3QixpRkFBaUY7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkIsaUZBQWlGLElBQUk7QUFDaEwsd0NBQXdDLGlGQUFpRjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkIsMkNBQTJDLElBQUk7QUFDMUksd0NBQXdDLDRFQUE0RTtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMkJBQTJCLG9EQUFvRCxJQUFJO0FBQ25KLHdDQUF3Qyw0RUFBNEU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCLG1DQUFtQyxzQ0FBc0MsSUFBSTtBQUMxSCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUZBQXVGO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUZBQXVGO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUJBQW1CO0FBQ2pGLHFFQUFxRSx1QkFBdUI7QUFDNUY7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNGQUFzRixtQkFBbUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQ0FBcUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw2QkFBNkIsbUJBQW1CLDBCQUEwQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1DQUFtQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx5RUFBeUUsc0JBQXNCLG1CQUFtQixrQkFBa0IsVUFBVSxpQkFBaUIsZ0JBQWdCLFVBQVU7QUFDekwsK0VBQStFLHNCQUFzQjtBQUNyRztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsc0NBQXNDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOENBQThDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQixvQ0FBb0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsZUFBZTtBQUM1RSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQXdCLDRDQUE0QyxhQUFhO0FBQ3pJO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5QkFBeUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQ0FBZ0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDhDQUE4QztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCLGtEQUFrRCxJQUFJLHFCQUFxQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCLG1EQUFtRCxJQUFJO0FBQ2pIO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHVCQUF1Qix1Q0FBdUM7QUFDakgsd0RBQXdELHFEQUFxRDtBQUM3RztBQUNBLHlEQUF5RCxlQUFlLFlBQVk7QUFDcEY7QUFDQSxrSUFBa0ksdUJBQXVCO0FBQ3pKO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usd0JBQXdCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2QsNkRBQTZELGtCQUFrQjtBQUMvRSw2REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDZFQUE2RTtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdEQUF3RDtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlFQUFpRTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDJCQUEyQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw2Q0FBNkM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsOENBQThDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9EQUFvRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx1Q0FBdUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLCtCQUErQjtBQUNsRztBQUNBO0FBQ0EsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDZCQUE2QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDZCQUE2Qiw0QkFBNEIsSUFBSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrREFBa0Q7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNENBQTRDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSw4Q0FBOEMsNENBQTRDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBK0M7QUFDakYsa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDLGdEQUFnRDtBQUNsRixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0ZBQXdGO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0NBQWdDO0FBQzdGO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDhDQUE4QztBQUM1SCx1RUFBdUUsOENBQThDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnRUFBZ0UsbUJBQW1CLCtEQUErRDtBQUNqTTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0NBQWtDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw0RkFBNEYsZ0NBQWdDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEIsc0NBQXNDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtGQUFrRjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdEQUF3RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsb0JBQW9CO0FBQy9HO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9EQUFvRCxxQkFBcUIsZUFBZTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUJBQWlCLDZCQUE2QjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1DQUFtQztBQUNqRztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx3Q0FBd0M7QUFDekc7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQ0FBZ0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELCtCQUErQjtBQUMvRTtBQUNBLG1FQUFtRSxvRUFBb0U7QUFDdkk7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsbURBQW1ELG9DQUFvQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3RUFBd0U7QUFDM0g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQ0FBZ0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGlFQUFpRSxzQ0FBc0M7QUFDdkc7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxrR0FBa0csdUJBQXVCO0FBQ3pIO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDBCQUEwQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBd0Q7QUFDdkUsZUFBZSw2QkFBNkI7QUFDNUMsMENBQTBDLDhCQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9EQUFvRCwyQ0FBMkM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQ0FBMkM7QUFDakg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9ELCtDQUErQyw2QkFBNkI7QUFDNUUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLFVBQVUsd0JBQXdCLG1DQUFtQztBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUVBQXFFLElBQUksTUFBTTtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLCtDQUErQyxtQ0FBbUM7QUFDbEY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUsdURBQXVEO0FBQ3BJOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGdCQUFnQjtBQUN2RjtBQUNBO0FBQ0EsbURBQW1ELHVCQUF1QjtBQUMxRTtBQUNBO0FBQ0Esb0VBQW9FLHlDQUF5QztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsaUNBQWlDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQ0FBa0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDhCQUE4QjtBQUNqRztBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsNENBQTRDLCtCQUErQiwrQkFBK0IsK0JBQStCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQsNkRBQTZELHNFQUFzRTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsaUlBQWlJO0FBQ2pJLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBLDZEQUE2RCxXQUFXO0FBQ3hFLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CO0FBQ2hGO0FBQ0EsaU9BQWlPO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtCQUErQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxrREFBa0QsWUFBWSw0QkFBNEIsYUFBYSxzRkFBc0Y7QUFDN0w7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwrQ0FBK0M7QUFDdEcsd0JBQXdCO0FBQ3hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEIsZUFBZTtBQUNsRjtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNkJBQTZCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw2QkFBNkI7QUFDakg7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDZCQUE2QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsMEJBQTBCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFVBQVUsWUFBWSxlQUFlO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsa0NBQWtDO0FBQ2xDLHVFQUF1RSwyQ0FBMkM7QUFDbEg7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsc0NBQXNDLGlDQUFpQyxnQkFBZ0I7QUFDN0k7QUFDQTtBQUNBLHlEQUF5RCw0Q0FBNEM7QUFDckc7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwyRkFBMkYsWUFBWSxtREFBbUQ7QUFDMUo7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUEyRDtBQUMxRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixrQkFBa0I7QUFDbEI7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLHNFQUFzRTtBQUNwTCwwREFBMEQsWUFBWTtBQUN0RTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxZQUFZO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwrQ0FBK0M7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLDJCQUEyQjtBQUNwSCxpR0FBaUcscUNBQXFDO0FBQ3RJLGlGQUFpRiw2QkFBNkI7QUFDOUc7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RixtREFBbUQsd0RBQXdEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVSxlQUFlO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDBEQUEwRDtBQUMxRCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsOERBQThELDhCQUE4QjtBQUM1RjtBQUNBO0FBQ0Esa0VBQWtFLDhCQUE4QjtBQUNoRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0NBQXNDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0Esd0ZBQXdGLDJCQUEyQjtBQUNuSDtBQUNBO0FBQ0EsdUNBQXVDLG9FQUFvRTtBQUMzRztBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMkJBQTJCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSwwRUFBMEU7QUFDL0k7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHVEQUF1RDtBQUM1SDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHNCQUFzQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRywrQkFBK0I7QUFDaEk7QUFDQSwwR0FBMEcsZ0JBQWdCO0FBQzFIO0FBQ0Esd0ZBQXdGLGdCQUFnQjtBQUN4RztBQUNBO0FBQ0E7QUFDQSx3R0FBd0csNENBQTRDO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsK0JBQStCO0FBQ25KLDBHQUEwRyxnQkFBZ0I7QUFDMUg7QUFDQSx3RkFBd0YsZ0JBQWdCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCw0Q0FBNEM7QUFDNUo7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGdCQUFnQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsNENBQTRDO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLG1CQUFtQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0tBQWdLLHFCQUFxQjtBQUNyTDtBQUNBLG1GQUFtRixVQUFVO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0EsMENBQTBDLEdBQUc7QUFDN0M7QUFDQTtBQUNBLGtFQUFrRSx1RUFBdUU7QUFDekksa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxPQUFPO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSx1RkFBdUYsK0JBQStCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUVBQW1FO0FBQy9HLHlDQUF5Qyx3Q0FBd0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwwQ0FBMEM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBLGdDQUFnQyw2RUFBNkU7QUFDN0csZ0RBQWdELDJCQUEyQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZ0NBQWdDO0FBQ3BHLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxZQUFZO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0Q0FBNEM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDRDQUE0QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJEQUEyRDtBQUNsSCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBLGNBQWMsNkNBQTZDLGVBQWU7QUFDMUUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZ0NBQWdDO0FBQ2hDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQsMENBQTBDLHVDQUF1QyxHQUFHO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwyQkFBMkI7QUFDMUY7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBb0M7QUFDeEU7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDs7QUFFQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REOztBQUVBO0FBQ0EsdUNBQXVDLHVCQUF1QjtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sdUNBQXVDLGtCQUFrQjs7QUFFekQ7O0FBRUEsRUFBRTtBQUNGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlLE1BQU0sYUFBYTtBQUNqSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsbUJBQW1CLFdBQVcsS0FBSyxjQUFjO0FBQzNGO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxLQUFLLGNBQWM7QUFDM0U7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0EseUNBQXlDLE1BQU07QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQSw4RUFBOEUsc0JBQXNCLGlCQUFpQixlQUFlO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGtCQUFrQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsa0JBQWtCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsaUJBQWlCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsVUFBVTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBLDREQUE0RCxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE9BQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsaUJBQWlCLHFCQUFxQixVQUFVO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixVQUFVO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkJBQTZCO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpQ0FBaUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUNBQXFDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsa0NBQWtDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE9BQU87QUFDcEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxPQUFPO0FBQ3BFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUsscUJBQXFCLDBCQUEwQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxJQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCw4QkFBOEI7O0FBRWpGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOEJBQThCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVMsSUFBSSxZQUFZLElBQUksVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLDRCQUE0QjtBQUMzQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsY0FBYztBQUM3QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEtBQUs7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsV0FBVztBQUMxQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxLQUFLO0FBQ0wsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9DQUFvQyxnRUFBZ0UsaUJBQWlCO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQ0FBb0MseUVBQXlFLGlCQUFpQjtBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixVQUFVO0FBQ1Ysd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLFVBQVU7QUFDVix1RkFBdUY7QUFDdkY7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBOztBQUVBLGVBQWUsNkxBQXdEO0FBQ3ZFO0FBQ0EsdUNBQXVDLHdCQUF3Qjs7QUFFKzFEO0FBQzk1RCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxERUxMXFxEZXNrdG9wXFxjcmFiZGFvLWFnZW50XFxtaWRlbi13ZWItdHV0b3JpYWxzXFxub2RlX21vZHVsZXNcXEBkZW1veC1sYWJzXFxtaWRlbi1zZGtcXGRpc3RcXHdvcmtlcnNcXENhcmdvLWFjYmQ4YWM1LWFjYmQ4YWM1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgZGV4aWUgPSB7ZXhwb3J0czoge319O1xuXG4vKlxuICogRGV4aWUuanMgLSBhIG1pbmltYWxpc3RpYyB3cmFwcGVyIGZvciBJbmRleGVkREJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQnkgRGF2aWQgRmFobGFuZGVyLCBkYXZpZC5mYWhsYW5kZXJAZ21haWwuY29tXG4gKlxuICogVmVyc2lvbiA0LjAuOCwgV2VkIEp1bCAxMCAyMDI0XG4gKlxuICogaHR0cHM6Ly9kZXhpZS5vcmdcbiAqXG4gKiBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0LCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG4gKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDtcblx0fSkoY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbiAoKSB7XG5cdCAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXHQgICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdCAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cdCAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5cdCAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcblx0ICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcblx0ICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuXHQgICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcblx0ICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1Jcblx0ICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cdCAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9XG5cdCAgICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuXHQgICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG5cdCAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBfZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6XG5cdCAgICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG5cdCAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcblx0ICAgICAgICAgICAgICAgIGNvbW1vbmpzR2xvYmFsO1xuXG5cdCAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXHQgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXHQgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKSB7XG5cdCAgICAgICAgX2dsb2JhbC5Qcm9taXNlID0gUHJvbWlzZTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGV4dGVuZChvYmosIGV4dGVuc2lvbikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uICE9PSAnb2JqZWN0Jylcblx0ICAgICAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgICAgICBrZXlzKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIG9ialtrZXldID0gZXh0ZW5zaW9uW2tleV07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgIH1cblx0ICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblx0ICAgIHZhciBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cdCAgICBmdW5jdGlvbiBoYXNPd24ob2JqLCBwcm9wKSB7XG5cdCAgICAgICAgcmV0dXJuIF9oYXNPd24uY2FsbChvYmosIHByb3ApO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcHJvcHMocHJvdG8sIGV4dGVuc2lvbikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKVxuXHQgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oZ2V0UHJvdG8ocHJvdG8pKTtcblx0ICAgICAgICAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBrZXlzIDogUmVmbGVjdC5vd25LZXlzKShleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0ICAgIGZ1bmN0aW9uIHNldFByb3Aob2JqLCBwcm9wLCBmdW5jdGlvbk9yR2V0U2V0LCBvcHRpb25zKSB7XG5cdCAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBleHRlbmQoZnVuY3Rpb25PckdldFNldCAmJiBoYXNPd24oZnVuY3Rpb25PckdldFNldCwgXCJnZXRcIikgJiYgdHlwZW9mIGZ1bmN0aW9uT3JHZXRTZXQuZ2V0ID09PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgICAgeyBnZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuZ2V0LCBzZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuc2V0LCBjb25maWd1cmFibGU6IHRydWUgfSA6XG5cdCAgICAgICAgICAgIHsgdmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSwgb3B0aW9ucykpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVyaXZlKENoaWxkKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZnJvbTogZnVuY3Rpb24gKFBhcmVudCkge1xuXHQgICAgICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcblx0ICAgICAgICAgICAgICAgIHNldFByb3AoQ2hpbGQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIENoaWxkKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXh0ZW5kOiBwcm9wcy5iaW5kKG51bGwsIENoaWxkLnByb3RvdHlwZSlcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cdCAgICBmdW5jdGlvbiBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG5cdCAgICAgICAgdmFyIHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG5cdCAgICAgICAgdmFyIHByb3RvO1xuXHQgICAgICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuXHQgICAgfVxuXHQgICAgdmFyIF9zbGljZSA9IFtdLnNsaWNlO1xuXHQgICAgZnVuY3Rpb24gc2xpY2UoYXJncywgc3RhcnQsIGVuZCkge1xuXHQgICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcmdzLCBzdGFydCwgZW5kKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG92ZXJyaWRlKG9yaWdGdW5jLCBvdmVycmlkZWRGYWN0b3J5KSB7XG5cdCAgICAgICAgcmV0dXJuIG92ZXJyaWRlZEZhY3Rvcnkob3JpZ0Z1bmMpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYXNzZXJ0KGIpIHtcblx0ICAgICAgICBpZiAoIWIpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBGYWlsZWRcIik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhc2FwJDEoZm4pIHtcblx0ICAgICAgICBpZiAoX2dsb2JhbC5zZXRJbW1lZGlhdGUpXG5cdCAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG5cdCAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyYXksIGV4dHJhY3Rvcikge1xuXHQgICAgICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaXRlbSwgaSkge1xuXHQgICAgICAgICAgICB2YXIgbmFtZUFuZFZhbHVlID0gZXh0cmFjdG9yKGl0ZW0sIGkpO1xuXHQgICAgICAgICAgICBpZiAobmFtZUFuZFZhbHVlKVxuXHQgICAgICAgICAgICAgICAgcmVzdWx0W25hbWVBbmRWYWx1ZVswXV0gPSBuYW1lQW5kVmFsdWVbMV07XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSwge30pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuXHQgICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgJiYgaGFzT3duKG9iaiwga2V5UGF0aCkpXG5cdCAgICAgICAgICAgIHJldHVybiBvYmpba2V5UGF0aF07XG5cdCAgICAgICAgaWYgKCFrZXlQYXRoKVxuXHQgICAgICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgdmFyIHJ2ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWwgPSBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldKTtcblx0ICAgICAgICAgICAgICAgIHJ2LnB1c2godmFsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcblx0ICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpba2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKV07XG5cdCAgICAgICAgICAgIHJldHVybiBpbm5lck9iaiA9PSBudWxsID8gdW5kZWZpbmVkIDogZ2V0QnlLZXlQYXRoKGlubmVyT2JqLCBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICghb2JqIHx8IGtleVBhdGggPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIGlmICgnaXNGcm96ZW4nIGluIE9iamVjdCAmJiBPYmplY3QuaXNGcm96ZW4ob2JqKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4ga2V5UGF0aCkge1xuXHQgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiB2YWx1ZSk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0sIHZhbHVlW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuXHQgICAgICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShjdXJyZW50S2V5UGF0aCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbY3VycmVudEtleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iaiB8fCAhaGFzT3duKG9iaiwgY3VycmVudEtleVBhdGgpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbm5lck9iaiA9IChvYmpbY3VycmVudEtleVBhdGhdID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbm5lck9iaiwgcmVtYWluaW5nS2V5UGF0aCwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChrZXlQYXRoKSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2Uoa2V5UGF0aCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIG9ialtrZXlQYXRoXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVsQnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuXHQgICAgICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHVuZGVmaW5lZCk7XG5cdCAgICAgICAgZWxzZSBpZiAoJ2xlbmd0aCcgaW4ga2V5UGF0aClcblx0ICAgICAgICAgICAgW10ubWFwLmNhbGwoa2V5UGF0aCwgZnVuY3Rpb24gKGtwKSB7XG5cdCAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrcCwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqKSB7XG5cdCAgICAgICAgdmFyIHJ2ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopIHtcblx0ICAgICAgICAgICAgaWYgKGhhc093bihvYmosIG0pKVxuXHQgICAgICAgICAgICAgICAgcnZbbV0gPSBvYmpbbV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblx0ICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQ7XG5cdCAgICBmdW5jdGlvbiBmbGF0dGVuKGEpIHtcblx0ICAgICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhKTtcblx0ICAgIH1cblx0ICAgIHZhciBpbnRyaW5zaWNUeXBlTmFtZXMgPSBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcblx0ICAgICAgICAuc3BsaXQoJywnKS5jb25jYXQoZmxhdHRlbihbOCwgMTYsIDMyLCA2NF0ubWFwKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIFtcIkludFwiLCBcIlVpbnRcIiwgXCJGbG9hdFwiXS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKyBudW0gKyBcIkFycmF5XCI7IH0pOyB9KSkpLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSk7XG5cdCAgICB2YXIgaW50cmluc2ljVHlwZXMgPSBuZXcgU2V0KGludHJpbnNpY1R5cGVOYW1lcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIF9nbG9iYWxbdF07IH0pKTtcblx0ICAgIGZ1bmN0aW9uIGNsb25lU2ltcGxlT2JqZWN0VHJlZShvKSB7XG5cdCAgICAgICAgdmFyIHJ2ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgayBpbiBvKVxuXHQgICAgICAgICAgICBpZiAoaGFzT3duKG8sIGspKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdiA9IG9ba107XG5cdCAgICAgICAgICAgICAgICBydltrXSA9ICF2IHx8IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyB8fCBpbnRyaW5zaWNUeXBlcy5oYXModi5jb25zdHJ1Y3RvcikgPyB2IDogY2xvbmVTaW1wbGVPYmplY3RUcmVlKHYpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gb2JqZWN0SXNFbXB0eShvKSB7XG5cdCAgICAgICAgZm9yICh2YXIgayBpbiBvKVxuXHQgICAgICAgICAgICBpZiAoaGFzT3duKG8sIGspKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgdmFyIGNpcmN1bGFyUmVmcyA9IG51bGw7XG5cdCAgICBmdW5jdGlvbiBkZWVwQ2xvbmUoYW55KSB7XG5cdCAgICAgICAgY2lyY3VsYXJSZWZzID0gbmV3IFdlYWtNYXAoKTtcblx0ICAgICAgICB2YXIgcnYgPSBpbm5lckRlZXBDbG9uZShhbnkpO1xuXHQgICAgICAgIGNpcmN1bGFyUmVmcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaW5uZXJEZWVwQ2xvbmUoeCkge1xuXHQgICAgICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpXG5cdCAgICAgICAgICAgIHJldHVybiB4O1xuXHQgICAgICAgIHZhciBydiA9IGNpcmN1bGFyUmVmcy5nZXQoeCk7XG5cdCAgICAgICAgaWYgKHJ2KVxuXHQgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgaWYgKGlzQXJyYXkoeCkpIHtcblx0ICAgICAgICAgICAgcnYgPSBbXTtcblx0ICAgICAgICAgICAgY2lyY3VsYXJSZWZzLnNldCh4LCBydik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0geC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHJ2LnB1c2goaW5uZXJEZWVwQ2xvbmUoeFtpXSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGludHJpbnNpY1R5cGVzLmhhcyh4LmNvbnN0cnVjdG9yKSkge1xuXHQgICAgICAgICAgICBydiA9IHg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcHJvdG8gPSBnZXRQcm90byh4KTtcblx0ICAgICAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG5cdCAgICAgICAgICAgIGNpcmN1bGFyUmVmcy5zZXQoeCwgcnYpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChoYXNPd24oeCwgcHJvcCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBydltwcm9wXSA9IGlubmVyRGVlcENsb25lKHhbcHJvcF0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblx0ICAgIHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXHQgICAgZnVuY3Rpb24gdG9TdHJpbmdUYWcobykge1xuXHQgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcblx0ICAgIH1cblx0ICAgIHZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID9cblx0ICAgICAgICBTeW1ib2wuaXRlcmF0b3IgOlxuXHQgICAgICAgICdAQGl0ZXJhdG9yJztcblx0ICAgIHZhciBnZXRJdGVyYXRvck9mID0gdHlwZW9mIGl0ZXJhdG9yU3ltYm9sID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICB2YXIgaTtcblx0ICAgICAgICByZXR1cm4geCAhPSBudWxsICYmIChpID0geFtpdGVyYXRvclN5bWJvbF0pICYmIGkuYXBwbHkoeCk7XG5cdCAgICB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcblx0ICAgIGZ1bmN0aW9uIGRlbEFycmF5SXRlbShhLCB4KSB7XG5cdCAgICAgICAgdmFyIGkgPSBhLmluZGV4T2YoeCk7XG5cdCAgICAgICAgaWYgKGkgPj0gMClcblx0ICAgICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgcmV0dXJuIGkgPj0gMDtcblx0ICAgIH1cblx0ICAgIHZhciBOT19DSEFSX0FSUkFZID0ge307XG5cdCAgICBmdW5jdGlvbiBnZXRBcnJheU9mKGFycmF5TGlrZSkge1xuXHQgICAgICAgIHZhciBpLCBhLCB4LCBpdDtcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5TGlrZS5zbGljZSgpO1xuXHQgICAgICAgICAgICBpZiAodGhpcyA9PT0gTk9fQ0hBUl9BUlJBWSAmJiB0eXBlb2YgYXJyYXlMaWtlID09PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcblx0ICAgICAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcblx0ICAgICAgICAgICAgICAgIGEgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpXG5cdCAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHgudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGFycmF5TGlrZSA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuXHQgICAgICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG5cdCAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFycmF5TGlrZVtpXTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcblx0ICAgICAgICB3aGlsZSAoaS0tKVxuXHQgICAgICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgIHJldHVybiBhO1xuXHQgICAgfVxuXHQgICAgdmFyIGlzQXN5bmNGdW5jdGlvbiA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG5cdCAgICAgICAgPyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJzsgfVxuXHQgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cblx0ICAgIHZhciBkZXhpZUVycm9yTmFtZXMgPSBbXG5cdCAgICAgICAgJ01vZGlmeScsXG5cdCAgICAgICAgJ0J1bGsnLFxuXHQgICAgICAgICdPcGVuRmFpbGVkJyxcblx0ICAgICAgICAnVmVyc2lvbkNoYW5nZScsXG5cdCAgICAgICAgJ1NjaGVtYScsXG5cdCAgICAgICAgJ1VwZ3JhZGUnLFxuXHQgICAgICAgICdJbnZhbGlkVGFibGUnLFxuXHQgICAgICAgICdNaXNzaW5nQVBJJyxcblx0ICAgICAgICAnTm9TdWNoRGF0YWJhc2UnLFxuXHQgICAgICAgICdJbnZhbGlkQXJndW1lbnQnLFxuXHQgICAgICAgICdTdWJUcmFuc2FjdGlvbicsXG5cdCAgICAgICAgJ1Vuc3VwcG9ydGVkJyxcblx0ICAgICAgICAnSW50ZXJuYWwnLFxuXHQgICAgICAgICdEYXRhYmFzZUNsb3NlZCcsXG5cdCAgICAgICAgJ1ByZW1hdHVyZUNvbW1pdCcsXG5cdCAgICAgICAgJ0ZvcmVpZ25Bd2FpdCdcblx0ICAgIF07XG5cdCAgICB2YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcblx0ICAgICAgICAnVW5rbm93bicsXG5cdCAgICAgICAgJ0NvbnN0cmFpbnQnLFxuXHQgICAgICAgICdEYXRhJyxcblx0ICAgICAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG5cdCAgICAgICAgJ1JlYWRPbmx5Jyxcblx0ICAgICAgICAnVmVyc2lvbicsXG5cdCAgICAgICAgJ05vdEZvdW5kJyxcblx0ICAgICAgICAnSW52YWxpZFN0YXRlJyxcblx0ICAgICAgICAnSW52YWxpZEFjY2VzcycsXG5cdCAgICAgICAgJ0Fib3J0Jyxcblx0ICAgICAgICAnVGltZW91dCcsXG5cdCAgICAgICAgJ1F1b3RhRXhjZWVkZWQnLFxuXHQgICAgICAgICdTeW50YXgnLFxuXHQgICAgICAgICdEYXRhQ2xvbmUnXG5cdCAgICBdO1xuXHQgICAgdmFyIGVycm9yTGlzdCA9IGRleGllRXJyb3JOYW1lcy5jb25jYXQoaWRiRG9tRXJyb3JOYW1lcyk7XG5cdCAgICB2YXIgZGVmYXVsdFRleHRzID0ge1xuXHQgICAgICAgIFZlcnNpb25DaGFuZ2VkOiBcIkRhdGFiYXNlIHZlcnNpb24gY2hhbmdlZCBieSBvdGhlciBkYXRhYmFzZSBjb25uZWN0aW9uXCIsXG5cdCAgICAgICAgRGF0YWJhc2VDbG9zZWQ6IFwiRGF0YWJhc2UgaGFzIGJlZW4gY2xvc2VkXCIsXG5cdCAgICAgICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuXHQgICAgICAgIFRyYW5zYWN0aW9uSW5hY3RpdmU6IFwiVHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgY29tcGxldGVkIG9yIGZhaWxlZFwiLFxuXHQgICAgICAgIE1pc3NpbmdBUEk6IFwiSW5kZXhlZERCIEFQSSBtaXNzaW5nLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly90aW55dXJsLmNvbS95MnV1dnNrYlwiXG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gRGV4aWVFcnJvcihuYW1lLCBtc2cpIHtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcblx0ICAgIH1cblx0ICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEVycm9yKS5leHRlbmQoe1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cblx0ICAgIH0pO1xuXHQgICAgZnVuY3Rpb24gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcykge1xuXHQgICAgICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuXHQgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZhaWx1cmVzW2tleV0udG9TdHJpbmcoKTsgfSlcblx0ICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodiwgaSwgcykgeyByZXR1cm4gcy5pbmRleE9mKHYpID09PSBpOyB9KVxuXHQgICAgICAgICAgICAuam9pbignXFxuJyk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBNb2RpZnlFcnJvcihtc2csIGZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpIHtcblx0ICAgICAgICB0aGlzLmZhaWx1cmVzID0gZmFpbHVyZXM7XG5cdCAgICAgICAgdGhpcy5mYWlsZWRLZXlzID0gZmFpbGVkS2V5cztcblx0ICAgICAgICB0aGlzLnN1Y2Nlc3NDb3VudCA9IHN1Y2Nlc3NDb3VudDtcblx0ICAgICAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcblx0ICAgIH1cblx0ICAgIGRlcml2ZShNb2RpZnlFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcblx0ICAgIGZ1bmN0aW9uIEJ1bGtFcnJvcihtc2csIGZhaWx1cmVzKSB7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJCdWxrRXJyb3JcIjtcblx0ICAgICAgICB0aGlzLmZhaWx1cmVzID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBmYWlsdXJlc1twb3NdOyB9KTtcblx0ICAgICAgICB0aGlzLmZhaWx1cmVzQnlQb3MgPSBmYWlsdXJlcztcblx0ICAgICAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIHRoaXMuZmFpbHVyZXMpO1xuXHQgICAgfVxuXHQgICAgZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcblx0ICAgIHZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkgeyByZXR1cm4gKG9ialtuYW1lXSA9IG5hbWUgKyBcIkVycm9yXCIsIG9iaik7IH0sIHt9KTtcblx0ICAgIHZhciBCYXNlRXhjZXB0aW9uID0gRGV4aWVFcnJvcjtcblx0ICAgIHZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG5cdCAgICAgICAgdmFyIGZ1bGxOYW1lID0gbmFtZSArIFwiRXJyb3JcIjtcblx0ICAgICAgICBmdW5jdGlvbiBEZXhpZUVycm9yKG1zZ09ySW5uZXIsIGlubmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMubmFtZSA9IGZ1bGxOYW1lO1xuXHQgICAgICAgICAgICBpZiAoIW1zZ09ySW5uZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRUZXh0c1tuYW1lXSB8fCBmdWxsTmFtZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIi5jb25jYXQobXNnT3JJbm5lcikuY29uY2F0KCFpbm5lciA/ICcnIDogJ1xcbiAnICsgaW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyIHx8IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChtc2dPcklubmVyLm5hbWUsIFwiIFwiKS5jb25jYXQobXNnT3JJbm5lci5tZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuXHQgICAgICAgIG9ialtuYW1lXSA9IERleGllRXJyb3I7XG5cdCAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgIH0sIHt9KTtcblx0ICAgIGV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG5cdCAgICBleGNlcHRpb25zLlR5cGUgPSBUeXBlRXJyb3I7XG5cdCAgICBleGNlcHRpb25zLlJhbmdlID0gUmFuZ2VFcnJvcjtcblx0ICAgIHZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG5cdCAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcblx0ICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgfSwge30pO1xuXHQgICAgZnVuY3Rpb24gbWFwRXJyb3IoZG9tRXJyb3IsIG1lc3NhZ2UpIHtcblx0ICAgICAgICBpZiAoIWRvbUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgRGV4aWVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yIHx8ICFkb21FcnJvci5uYW1lIHx8ICFleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0pXG5cdCAgICAgICAgICAgIHJldHVybiBkb21FcnJvcjtcblx0ICAgICAgICB2YXIgcnYgPSBuZXcgZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKG1lc3NhZ2UgfHwgZG9tRXJyb3IubWVzc2FnZSwgZG9tRXJyb3IpO1xuXHQgICAgICAgIGlmIChcInN0YWNrXCIgaW4gZG9tRXJyb3IpIHtcblx0ICAgICAgICAgICAgc2V0UHJvcChydiwgXCJzdGFja1wiLCB7IGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVyLnN0YWNrO1xuXHQgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXHQgICAgdmFyIGZ1bGxOYW1lRXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuXHQgICAgICAgIGlmIChbXCJTeW50YXhcIiwgXCJUeXBlXCIsIFwiUmFuZ2VcIl0uaW5kZXhPZihuYW1lKSA9PT0gLTEpXG5cdCAgICAgICAgICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG5cdCAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgIH0sIHt9KTtcblx0ICAgIGZ1bGxOYW1lRXhjZXB0aW9ucy5Nb2RpZnlFcnJvciA9IE1vZGlmeUVycm9yO1xuXHQgICAgZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuXHQgICAgZnVsbE5hbWVFeGNlcHRpb25zLkJ1bGtFcnJvciA9IEJ1bGtFcnJvcjtcblxuXHQgICAgZnVuY3Rpb24gbm9wKCkgeyB9XG5cdCAgICBmdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cblx0ICAgIGZ1bmN0aW9uIHB1cmVGdW5jdGlvbkNoYWluKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMSA9PSBudWxsIHx8IGYxID09PSBtaXJyb3IpXG5cdCAgICAgICAgICAgIHJldHVybiBmMjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZjIoZjEodmFsKSk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNhbGxCb3RoKG9uMSwgb24yKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgb24xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIG9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBob29rQ3JlYXRpbmdDaGFpbihmMSwgZjIpIHtcblx0ICAgICAgICBpZiAoZjEgPT09IG5vcClcblx0ICAgICAgICAgICAgcmV0dXJuIGYyO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF0gPSByZXM7XG5cdCAgICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2Vzcyxcblx0ICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcblx0ICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG5cdCAgICAgICAgICAgIGlmIChvbmVycm9yKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG5cdCAgICAgICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcblx0ICAgICAgICBpZiAoZjEgPT09IG5vcClcblx0ICAgICAgICAgICAgcmV0dXJuIGYyO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2Vzcyxcblx0ICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcblx0ICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAob25zdWNjZXNzKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuXHQgICAgICAgICAgICBpZiAob25lcnJvcilcblx0ICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcblx0ICAgICAgICBpZiAoZjEgPT09IG5vcClcblx0ICAgICAgICAgICAgcmV0dXJuIGYyO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgZXh0ZW5kKG1vZGlmaWNhdGlvbnMsIHJlcyk7XG5cdCAgICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2Vzcyxcblx0ICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjtcblx0ICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG5cdCAgICAgICAgICAgIGlmIChvbmVycm9yKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG5cdCAgICAgICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG5cdCAgICAgICAgICAgICAgICAocmVzMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzMikgOlxuXHQgICAgICAgICAgICAgICAgKGV4dGVuZChyZXMsIHJlczIpKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG5cdCAgICAgICAgaWYgKGYxID09PSBub3ApXG5cdCAgICAgICAgICAgIHJldHVybiBmMjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIHJldHVybiBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG5cdCAgICAgICAgaWYgKGYxID09PSBub3ApXG5cdCAgICAgICAgICAgIHJldHVybiBmMjtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcywgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgICAvXihodHRwfGh0dHBzKTpcXC9cXC8obG9jYWxob3N0fDEyN1xcLjBcXC4wXFwuMSkvLnRlc3QobG9jYXRpb24uaHJlZik7XG5cdCAgICBmdW5jdGlvbiBzZXREZWJ1Zyh2YWx1ZSwgZmlsdGVyKSB7XG5cdCAgICAgICAgZGVidWcgPSB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIElOVEVSTkFMID0ge307XG5cdCAgICB2YXIgWk9ORV9FQ0hPX0xJTUlUID0gMTAwLCBfYSQxID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cblx0ICAgICAgICBbXSA6XG5cdCAgICAgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtnbG9iYWxQLCBnZXRQcm90byhnbG9iYWxQKSwgZ2xvYmFsUF07XG5cdCAgICAgICAgICAgIHZhciBuYXRpdmVQID0gY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtNTEyXCIsIG5ldyBVaW50OEFycmF5KFswXSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICAgICAgbmF0aXZlUCxcblx0ICAgICAgICAgICAgICAgIGdldFByb3RvKG5hdGl2ZVApLFxuXHQgICAgICAgICAgICAgICAgZ2xvYmFsUFxuXHQgICAgICAgICAgICBdO1xuXHQgICAgICAgIH0pKCksIHJlc29sdmVkTmF0aXZlUHJvbWlzZSA9IF9hJDFbMF0sIG5hdGl2ZVByb21pc2VQcm90byA9IF9hJDFbMV0sIHJlc29sdmVkR2xvYmFsUHJvbWlzZSA9IF9hJDFbMl0sIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xuXHQgICAgdmFyIE5hdGl2ZVByb21pc2UgPSByZXNvbHZlZE5hdGl2ZVByb21pc2UgJiYgcmVzb2x2ZWROYXRpdmVQcm9taXNlLmNvbnN0cnVjdG9yO1xuXHQgICAgdmFyIHBhdGNoR2xvYmFsUHJvbWlzZSA9ICEhcmVzb2x2ZWRHbG9iYWxQcm9taXNlO1xuXHQgICAgZnVuY3Rpb24gc2NoZWR1bGVQaHlzaWNhbFRpY2soKSB7XG5cdCAgICAgICAgcXVldWVNaWNyb3Rhc2socGh5c2ljYWxUaWNrKTtcblx0ICAgIH1cblx0ICAgIHZhciBhc2FwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG5cdCAgICAgICAgbWljcm90aWNrUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ3NdKTtcblx0ICAgICAgICBpZiAobmVlZHNOZXdQaHlzaWNhbFRpY2spIHtcblx0ICAgICAgICAgICAgc2NoZWR1bGVQaHlzaWNhbFRpY2soKTtcblx0ICAgICAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgdmFyIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWUsXG5cdCAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWUsXG5cdCAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXSxcblx0ICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdLFxuXHQgICAgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yO1xuXHQgICAgdmFyIGdsb2JhbFBTRCA9IHtcblx0ICAgICAgICBpZDogJ2dsb2JhbCcsXG5cdCAgICAgICAgZ2xvYmFsOiB0cnVlLFxuXHQgICAgICAgIHJlZjogMCxcblx0ICAgICAgICB1bmhhbmRsZWRzOiBbXSxcblx0ICAgICAgICBvbnVuaGFuZGxlZDogbm9wLFxuXHQgICAgICAgIHBncDogZmFsc2UsXG5cdCAgICAgICAgZW52OiB7fSxcblx0ICAgICAgICBmaW5hbGl6ZTogbm9wXG5cdCAgICB9O1xuXHQgICAgdmFyIFBTRCA9IGdsb2JhbFBTRDtcblx0ICAgIHZhciBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuXHQgICAgdmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDtcblx0ICAgIHZhciB0aWNrRmluYWxpemVycyA9IFtdO1xuXHQgICAgZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jylcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cdCAgICAgICAgdGhpcy5fbGliID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHBzZCA9ICh0aGlzLl9QU0QgPSBQU0QpO1xuXHQgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTClcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gYXJndW1lbnRzWzFdO1xuXHQgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGFyZ3VtZW50c1syXTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBmYWxzZSlcblx0ICAgICAgICAgICAgICAgIGhhbmRsZVJlamVjdGlvbih0aGlzLCB0aGlzLl92YWx1ZSk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcblx0ICAgICAgICArK3BzZC5yZWY7XG5cdCAgICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHRoaXMsIGZuKTtcblx0ICAgIH1cblx0ICAgIHZhciB0aGVuUHJvcCA9IHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcblx0ICAgICAgICAgICAgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUF3YWl0ID0gIXBzZC5nbG9iYWwgJiYgKHBzZCAhPT0gUFNEIHx8IG1pY3JvVGFza0lkICE9PSB0b3RhbEVjaG9lcyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2xlYW51cCA9IHBvc3NpYmxlQXdhaXQgJiYgIWRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKF90aGlzLCBuZXcgTGlzdGVuZXIobmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvbkZ1bGZpbGxlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCByZXNvbHZlLCByZWplY3QsIHBzZCkpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29uc29sZVRhc2spXG5cdCAgICAgICAgICAgICAgICAgICAgcnYuX2NvbnNvbGVUYXNrID0gdGhpcy5fY29uc29sZVRhc2s7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhlbi5wcm90b3R5cGUgPSBJTlRFUk5BTDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoZW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBzZXRQcm9wKHRoaXMsICd0aGVuJywgdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlID09PSBJTlRFUk5BTCA/XG5cdCAgICAgICAgICAgICAgICB0aGVuUHJvcCA6XG5cdCAgICAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcHJvcHMoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwge1xuXHQgICAgICAgIHRoZW46IHRoZW5Qcm9wLFxuXHQgICAgICAgIF90aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0ICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIobnVsbCwgbnVsbCwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIFBTRCkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgY2F0Y2g6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG5cdCAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcblx0ICAgICAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIGhhbmRsZXIgPSBhcmd1bWVudHNbMV07XG5cdCAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIDogdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUob25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xuXHQgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUob25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpOyB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbiAobXMsIG1zZykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gbXMgPCBJbmZpbml0eSA/XG5cdCAgICAgICAgICAgICAgICBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuVGltZW91dChtc2cpKTsgfSwgbXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuXHQgICAgICAgICAgICAgICAgfSkgOiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcblx0ICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgJ0RleGllLlByb21pc2UnKTtcblx0ICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuXHQgICAgZnVuY3Rpb24gTGlzdGVuZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCwgem9uZSkge1xuXHQgICAgICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG5cdCAgICAgICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcblx0ICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuXHQgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuXHQgICAgICAgIHRoaXMucHNkID0gem9uZTtcblx0ICAgIH1cblx0ICAgIHByb3BzKERleGllUHJvbWlzZSwge1xuXHQgICAgICAgIGFsbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpXG5cdCAgICAgICAgICAgICAgICAubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSwgaSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoYSkudGhlbihmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHg7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZXMpO1xuXHQgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTsgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmVzb2x2ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcblx0ICAgICAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpOyB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBQU0Q6IHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQU0Q7IH0sXG5cdCAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBQU0QgPSB2YWx1ZTsgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdG90YWxFY2hvZXM6IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b3RhbEVjaG9lczsgfSB9LFxuXHQgICAgICAgIG5ld1BTRDogbmV3U2NvcGUsXG5cdCAgICAgICAgdXNlUFNEOiB1c2VQU0QsXG5cdCAgICAgICAgc2NoZWR1bGVyOiB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNhcDsgfSxcblx0ICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgYXNhcCA9IHZhbHVlOyB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByZWplY3Rpb25NYXBwZXI6IHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3Rpb25NYXBwZXI7IH0sXG5cdCAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJlamVjdGlvbk1hcHBlciA9IHZhbHVlOyB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmb2xsb3c6IGZ1bmN0aW9uIChmbiwgem9uZVByb3BzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBzZCA9IFBTRDtcblx0ICAgICAgICAgICAgICAgICAgICBwc2QudW5oYW5kbGVkcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDtcblx0ICAgICAgICAgICAgICAgICAgICBwc2QuZmluYWxpemUgPSBjYWxsQm90aChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QoX3RoaXMudW5oYW5kbGVkc1swXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sIHBzZC5maW5hbGl6ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZm4oKTtcblx0ICAgICAgICAgICAgICAgIH0sIHpvbmVQcm9wcywgcmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBpZiAoTmF0aXZlUHJvbWlzZSkge1xuXHQgICAgICAgIGlmIChOYXRpdmVQcm9taXNlLmFsbFNldHRsZWQpXG5cdCAgICAgICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFsbFNldHRsZWRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTsgfSwgZnVuY3Rpb24gKHJlYXNvbikgeyByZXR1cm4gcmVzdWx0c1tpXSA9IHsgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cyk7IH0pOyB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJylcblx0ICAgICAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihbXSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcblx0ICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSwgZnVuY3Rpb24gKGZhaWx1cmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbaV0gPSBmYWlsdXJlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmbikge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSlcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuXHQgICAgICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICAgIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCBleCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuXHQgICAgICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG5cdCAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICByZWFzb24gPSByZWplY3Rpb25NYXBwZXIocmVhc29uKTtcblx0ICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IGZhbHNlO1xuXHQgICAgICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuXHQgICAgICAgIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSk7XG5cdCAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuXHQgICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcblx0ICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG5cdCAgICAgICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcblx0ICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXJzW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcblx0ICAgICAgICAtLXBzZC5yZWYgfHwgcHNkLmZpbmFsaXplKCk7XG5cdCAgICAgICAgaWYgKG51bVNjaGVkdWxlZENhbGxzID09PSAwKSB7XG5cdCAgICAgICAgICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG5cdCAgICAgICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcblx0ICAgICAgICAgICAgfSwgW10pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuXHQgICAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIucmVzb2x2ZSA6IGxpc3RlbmVyLnJlamVjdCkocHJvbWlzZS5fdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICArK2xpc3RlbmVyLnBzZC5yZWY7XG5cdCAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcblx0ICAgICAgICBhc2FwKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY2FsbExpc3RlbmVyKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHZhciByZXQsIHZhbHVlID0gcHJvbWlzZS5fdmFsdWU7XG5cdCAgICAgICAgICAgIGlmICghcHJvbWlzZS5fc3RhdGUgJiYgcmVqZWN0aW5nRXJyb3JzLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuXHQgICAgICAgICAgICByZXQgPSBkZWJ1ZyAmJiBwcm9taXNlLl9jb25zb2xlVGFzayA/IHByb21pc2UuX2NvbnNvbGVUYXNrLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBjYih2YWx1ZSk7IH0pIDogY2IodmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAoIXByb21pc2UuX3N0YXRlICYmIHJlamVjdGluZ0Vycm9ycy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsaXN0ZW5lci5yZXNvbHZlKHJldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIGxpc3RlbmVyLnJlamVjdChlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcblx0ICAgICAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHBoeXNpY2FsVGljaygpIHtcblx0ICAgICAgICB1c2VQU0QoZ2xvYmFsUFNELCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcblx0ICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG5cdCAgICAgICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG5cdCAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcblx0ICAgICAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcblx0ICAgICAgICB2YXIgY2FsbGJhY2tzLCBpLCBsO1xuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IG1pY3JvdGlja1F1ZXVlO1xuXHQgICAgICAgICAgICAgICAgbWljcm90aWNrUXVldWUgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2FsbGJhY2tzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcblx0ICAgICAgICBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlO1xuXHQgICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGZpbmFsaXplUGh5c2ljYWxUaWNrKCkge1xuXHQgICAgICAgIHZhciB1bmhhbmRsZWRFcnJzID0gdW5oYW5kbGVkRXJyb3JzO1xuXHQgICAgICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuXHQgICAgICAgIHVuaGFuZGxlZEVycnMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuXHQgICAgICAgICAgICBwLl9QU0Qub251bmhhbmRsZWQuY2FsbChudWxsLCBwLl92YWx1ZSwgcCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIGZpbmFsaXplcnMgPSB0aWNrRmluYWxpemVycy5zbGljZSgwKTtcblx0ICAgICAgICB2YXIgaSA9IGZpbmFsaXplcnMubGVuZ3RoO1xuXHQgICAgICAgIHdoaWxlIChpKVxuXHQgICAgICAgICAgICBmaW5hbGl6ZXJzWy0taV0oKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcblx0ICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdCAgICAgICAgICAgIGZuKCk7XG5cdCAgICAgICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aWNrRmluYWxpemVycy5wdXNoKGZpbmFsaXplcik7XG5cdCAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcblx0ICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG5cdCAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuXHQgICAgICAgIH0sIFtdKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSkge1xuXHQgICAgICAgIGlmICghdW5oYW5kbGVkRXJyb3JzLnNvbWUoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZTsgfSkpXG5cdCAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5wdXNoKHByb21pc2UpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpIHtcblx0ICAgICAgICB2YXIgaSA9IHVuaGFuZGxlZEVycm9ycy5sZW5ndGg7XG5cdCAgICAgICAgd2hpbGUgKGkpXG5cdCAgICAgICAgICAgIGlmICh1bmhhbmRsZWRFcnJvcnNbLS1pXS5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICB1bmhhbmRsZWRFcnJvcnMuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBQcm9taXNlUmVqZWN0KHJlYXNvbikge1xuXHQgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCBmYWxzZSwgcmVhc29uKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuXHQgICAgICAgIHZhciBwc2QgPSBQU0Q7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB2YXIgdGFzayA9IHsgYXdhaXRzOiAwLCBlY2hvZXM6IDAsIGlkOiAwIH07XG5cdCAgICB2YXIgdGFza0NvdW50ZXIgPSAwO1xuXHQgICAgdmFyIHpvbmVTdGFjayA9IFtdO1xuXHQgICAgdmFyIHpvbmVFY2hvZXMgPSAwO1xuXHQgICAgdmFyIHRvdGFsRWNob2VzID0gMDtcblx0ICAgIHZhciB6b25lX2lkX2NvdW50ZXIgPSAwO1xuXHQgICAgZnVuY3Rpb24gbmV3U2NvcGUoZm4sIHByb3BzLCBhMSwgYTIpIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gUFNELCBwc2QgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG5cdCAgICAgICAgcHNkLnBhcmVudCA9IHBhcmVudDtcblx0ICAgICAgICBwc2QucmVmID0gMDtcblx0ICAgICAgICBwc2QuZ2xvYmFsID0gZmFsc2U7XG5cdCAgICAgICAgcHNkLmlkID0gKyt6b25lX2lkX2NvdW50ZXI7XG5cdCAgICAgICAgZ2xvYmFsUFNELmVudjtcblx0ICAgICAgICBwc2QuZW52ID0gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuXHQgICAgICAgICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsXG5cdCAgICAgICAgICAgIFByb21pc2VQcm9wOiB7IHZhbHVlOiBEZXhpZVByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcblx0ICAgICAgICAgICAgYWxsOiBEZXhpZVByb21pc2UuYWxsLFxuXHQgICAgICAgICAgICByYWNlOiBEZXhpZVByb21pc2UucmFjZSxcblx0ICAgICAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG5cdCAgICAgICAgICAgIGFueTogRGV4aWVQcm9taXNlLmFueSxcblx0ICAgICAgICAgICAgcmVzb2x2ZTogRGV4aWVQcm9taXNlLnJlc29sdmUsXG5cdCAgICAgICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcblx0ICAgICAgICB9IDoge307XG5cdCAgICAgICAgaWYgKHByb3BzKVxuXHQgICAgICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG5cdCAgICAgICAgKytwYXJlbnQucmVmO1xuXHQgICAgICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciBydiA9IHVzZVBTRChwc2QsIGZuLCBhMSwgYTIpO1xuXHQgICAgICAgIGlmIChwc2QucmVmID09PSAwKVxuXHQgICAgICAgICAgICBwc2QuZmluYWxpemUoKTtcblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcblx0ICAgICAgICBpZiAoIXRhc2suaWQpXG5cdCAgICAgICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuXHQgICAgICAgICsrdGFzay5hd2FpdHM7XG5cdCAgICAgICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuXHQgICAgICAgIHJldHVybiB0YXNrLmlkO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG5cdCAgICAgICAgaWYgKCF0YXNrLmF3YWl0cylcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKVxuXHQgICAgICAgICAgICB0YXNrLmlkID0gMDtcblx0ICAgICAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzICogWk9ORV9FQ0hPX0xJTUlUO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKCgnJyArIG5hdGl2ZVByb21pc2VUaGVuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7XG5cdCAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyhwb3NzaWJsZVByb21pc2UpIHtcblx0ICAgICAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuXHQgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geDtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuXHQgICAgICAgICsrdG90YWxFY2hvZXM7XG5cdCAgICAgICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG5cdCAgICAgICAgICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgPSB0YXNrLmlkID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgem9uZVN0YWNrLnB1c2goUFNEKTtcblx0ICAgICAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB6b25lTGVhdmVFY2hvKCkge1xuXHQgICAgICAgIHZhciB6b25lID0gem9uZVN0YWNrW3pvbmVTdGFjay5sZW5ndGggLSAxXTtcblx0ICAgICAgICB6b25lU3RhY2sucG9wKCk7XG5cdCAgICAgICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuXHQgICAgICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuXHQgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhiRW50ZXJpbmdab25lID8gem9uZUVudGVyRWNoby5iaW5kKG51bGwsIHRhcmdldFpvbmUpIDogem9uZUxlYXZlRWNobyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0YXJnZXRab25lID09PSBQU0QpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICBQU0QgPSB0YXJnZXRab25lO1xuXHQgICAgICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKVxuXHQgICAgICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcblx0ICAgICAgICBpZiAocGF0Y2hHbG9iYWxQcm9taXNlKSB7XG5cdCAgICAgICAgICAgIHZhciBHbG9iYWxQcm9taXNlID0gZ2xvYmFsUFNELmVudi5Qcm9taXNlO1xuXHQgICAgICAgICAgICB2YXIgdGFyZ2V0RW52ID0gdGFyZ2V0Wm9uZS5lbnY7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50Wm9uZS5nbG9iYWwgfHwgdGFyZ2V0Wm9uZS5nbG9iYWwpIHtcblx0ICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZ2xvYmFsLCAnUHJvbWlzZScsIHRhcmdldEVudi5Qcm9taXNlUHJvcCk7XG5cdCAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG5cdCAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJhY2UgPSB0YXJnZXRFbnYucmFjZTtcblx0ICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVzb2x2ZSA9IHRhcmdldEVudi5yZXNvbHZlO1xuXHQgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbGxTZXR0bGVkKVxuXHQgICAgICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG5cdCAgICAgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbnkgPSB0YXJnZXRFbnYuYW55O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gc25hcFNob3QoKSB7XG5cdCAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG5cdCAgICAgICAgcmV0dXJuIHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcblx0ICAgICAgICAgICAgUHJvbWlzZTogR2xvYmFsUHJvbWlzZSxcblx0ICAgICAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuXHQgICAgICAgICAgICBhbGw6IEdsb2JhbFByb21pc2UuYWxsLFxuXHQgICAgICAgICAgICByYWNlOiBHbG9iYWxQcm9taXNlLnJhY2UsXG5cdCAgICAgICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcblx0ICAgICAgICAgICAgYW55OiBHbG9iYWxQcm9taXNlLmFueSxcblx0ICAgICAgICAgICAgcmVzb2x2ZTogR2xvYmFsUHJvbWlzZS5yZXNvbHZlLFxuXHQgICAgICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuXHQgICAgICAgIH0gOiB7fTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHVzZVBTRChwc2QsIGZuLCBhMSwgYTIsIGEzKSB7XG5cdCAgICAgICAgdmFyIG91dGVyU2NvcGUgPSBQU0Q7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBmbihhMSwgYTIsIGEzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCwgY2xlYW51cCkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcblx0ICAgICAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpXG5cdCAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuXHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBleGVjSW5HbG9iYWxDb250ZXh0KGNiKSB7XG5cdCAgICAgICAgaWYgKFByb21pc2UgPT09IE5hdGl2ZVByb21pc2UgJiYgdGFzay5lY2hvZXMgPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKHpvbmVFY2hvZXMgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGNiKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGNiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cblx0ICAgIGZ1bmN0aW9uIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pIHtcblx0ICAgICAgICBpZiAoIWRiLmlkYmRiIHx8ICghZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSAmJiAoIVBTRC5sZXRUaHJvdWdoICYmICFkYi5fdmlwKSkpIHtcblx0ICAgICAgICAgICAgaWYgKGRiLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGIuX3N0YXRlLmRiT3BlbkVycm9yKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFkYi5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFkYi5fc3RhdGUuYXV0b09wZW4pXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcblx0ICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBkYi5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcblx0ICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSh7IGRpc2FibGVBdXRvT3BlbjogZmFsc2UgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pOyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJylcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5pZGJ0cmFucy5jb21taXQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBtb2RlID09PSAncmVhZG9ubHknID8gcmVzdWx0IDogdHJhbnMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQ7IH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBERVhJRV9WRVJTSU9OID0gJzQuMC44Jztcblx0ICAgIHZhciBtYXhTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTM1KTtcblx0ICAgIHZhciBtaW5LZXkgPSAtSW5maW5pdHk7XG5cdCAgICB2YXIgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcblx0ICAgIHZhciBTVFJJTkdfRVhQRUNURUQgPSBcIlN0cmluZyBleHBlY3RlZC5cIjtcblx0ICAgIHZhciBjb25uZWN0aW9ucyA9IFtdO1xuXHQgICAgdmFyIERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcblx0ICAgIHZhciBSRUFET05MWSA9ICdyZWFkb25seSc7XG5cdCAgICB2YXIgUkVBRFdSSVRFID0gJ3JlYWR3cml0ZSc7XG5cblx0ICAgIGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuXHQgICAgICAgIHJldHVybiBmaWx0ZXIxID9cblx0ICAgICAgICAgICAgZmlsdGVyMiA/XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcblx0ICAgICAgICAgICAgICAgIGZpbHRlcjEgOlxuXHQgICAgICAgICAgICBmaWx0ZXIyO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgQW55UmFuZ2UgPSB7XG5cdCAgICAgICAgdHlwZTogMyAsXG5cdCAgICAgICAgbG93ZXI6IC1JbmZpbml0eSxcblx0ICAgICAgICBsb3dlck9wZW46IGZhbHNlLFxuXHQgICAgICAgIHVwcGVyOiBbW11dLFxuXHQgICAgICAgIHVwcGVyT3BlbjogZmFsc2Vcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcblx0ICAgICAgICAgICAgPyBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqW2tleVBhdGhdID09PSB1bmRlZmluZWQgJiYgKGtleVBhdGggaW4gb2JqKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBFbnRpdHkoKSB7XG5cdCAgICAgICAgdGhyb3cgZXhjZXB0aW9ucy5UeXBlKCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNtcChhLCBiKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFyIHRhID0gdHlwZShhKTtcblx0ICAgICAgICAgICAgdmFyIHRiID0gdHlwZShiKTtcblx0ICAgICAgICAgICAgaWYgKHRhICE9PSB0Yikge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhID09PSAnQXJyYXknKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRiID09PSAnQXJyYXknKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGIgPT09ICdiaW5hcnknKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YSA9PT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGIgPT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YSA9PT0gJ0RhdGUnKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRiICE9PSAnRGF0ZScpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRhKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuXHQgICAgICAgICAgICAgICAgY2FzZSAnRGF0ZSc6XG5cdCAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXlzKGdldFVpbnQ4QXJyYXkoYSksIGdldFVpbnQ4QXJyYXkoYikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2FzZSAnQXJyYXknOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGEsIGIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChfYSkgeyB9XG5cdCAgICAgICAgcmV0dXJuIE5hTjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYSwgYikge1xuXHQgICAgICAgIHZhciBhbCA9IGEubGVuZ3RoO1xuXHQgICAgICAgIHZhciBibCA9IGIubGVuZ3RoO1xuXHQgICAgICAgIHZhciBsID0gYWwgPCBibCA/IGFsIDogYmw7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgdmFyIHJlcyA9IGNtcChhW2ldLCBiW2ldKTtcblx0ICAgICAgICAgICAgaWYgKHJlcyAhPT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNvbXBhcmVVaW50OEFycmF5cyhhLCBiKSB7XG5cdCAgICAgICAgdmFyIGFsID0gYS5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGJsID0gYi5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGwgPSBhbCA8IGJsID8gYWwgOiBibDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhW2ldIDwgYltpXSA/IC0xIDogMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gdHlwZSh4KSB7XG5cdCAgICAgICAgdmFyIHQgPSB0eXBlb2YgeDtcblx0ICAgICAgICBpZiAodCAhPT0gJ29iamVjdCcpXG5cdCAgICAgICAgICAgIHJldHVybiB0O1xuXHQgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpXG5cdCAgICAgICAgICAgIHJldHVybiAnYmluYXJ5Jztcblx0ICAgICAgICB2YXIgdHNUYWcgPSB0b1N0cmluZ1RhZyh4KTtcblx0ICAgICAgICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6IHRzVGFnO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0VWludDhBcnJheShhKSB7XG5cdCAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuXHQgICAgICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpKVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBUYWJsZSA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuX3RyYW5zID0gZnVuY3Rpb24gKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuXHQgICAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLl90eCB8fCBQU0QudHJhbnM7XG5cdCAgICAgICAgICAgIHZhciB0YWJsZU5hbWUgPSB0aGlzLm5hbWU7XG5cdCAgICAgICAgICAgIHZhciB0YXNrID0gZGVidWcgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuY3JlYXRlVGFzayAmJiBjb25zb2xlLmNyZWF0ZVRhc2soXCJEZXhpZTogXCIuY29uY2F0KG1vZGUgPT09ICdyZWFkb25seScgPyAncmVhZCcgOiAnd3JpdGUnLCBcIiBcIikuY29uY2F0KHRoaXMubmFtZSkpO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRyYW5zLnNjaGVtYVt0YWJsZU5hbWVdKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciBwID0gdHJhbnMgJiYgdHJhbnMuZGIuX25vdmlwID09PSB0aGlzLmRiLl9ub3ZpcCA/XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpOyB9LCB7IHRyYW5zOiB0cmFucywgdHJhbnNsZXNzOiBQU0QudHJhbnNsZXNzIHx8IFBTRCB9KSA6XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcFRyYW5zYWN0aW9uKHRoaXMuZGIsIG1vZGUsIFt0aGlzLm5hbWVdLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICBpZiAodGFzaykge1xuXHQgICAgICAgICAgICAgICAgICAgIHAuX2NvbnNvbGVUYXNrID0gdGFzaztcblx0ICAgICAgICAgICAgICAgICAgICBwID0gcC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXlPckNyaXQsIGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmIChrZXlPckNyaXQgJiYga2V5T3JDcml0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQpLmZpcnN0KGNiKTtcblx0ICAgICAgICAgICAgaWYgKGtleU9yQ3JpdCA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UeXBlKFwiSW52YWxpZCBhcmd1bWVudCB0byBUYWJsZS5nZXQoKVwiKSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLmdldCh7IHRyYW5zOiB0cmFucywga2V5OiBrZXlPckNyaXQgfSlcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpOyB9KTtcblx0ICAgICAgICAgICAgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoaW5kZXhPckNyaXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yQ3JpdCA9PT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuXHQgICAgICAgICAgICBpZiAoaXNBcnJheShpbmRleE9yQ3JpdCkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgXCJbXCIuY29uY2F0KGluZGV4T3JDcml0LmpvaW4oJysnKSwgXCJdXCIpKTtcblx0ICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG5cdCAgICAgICAgICAgIGlmIChrZXlQYXRocy5sZW5ndGggPT09IDEpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgIC53aGVyZShrZXlQYXRoc1swXSlcblx0ICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGluZGV4T3JDcml0W2tleVBhdGhzWzBdXSk7XG5cdCAgICAgICAgICAgIHZhciBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGZ1bmN0aW9uIChpeCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGl4LmNvbXBvdW5kICYmXG5cdCAgICAgICAgICAgICAgICAgICAga2V5UGF0aHMuZXZlcnkoZnVuY3Rpb24gKGtleVBhdGgpIHsgcmV0dXJuIGl4LmtleVBhdGguaW5kZXhPZihrZXlQYXRoKSA+PSAwOyB9KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5UGF0aHMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGhzLmluZGV4T2YoaXgua2V5UGF0aFtpXSkgPT09IC0xKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5rZXlQYXRoLmxlbmd0aCAtIGIua2V5UGF0aC5sZW5ndGg7IH0pWzBdO1xuXHQgICAgICAgICAgICBpZiAoY29tcG91bmRJbmRleCAmJiB0aGlzLmRiLl9tYXhLZXkgIT09IG1heFN0cmluZykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzSW5WYWxpZE9yZGVyID0gY29tcG91bmRJbmRleC5rZXlQYXRoLnNsaWNlKDAsIGtleVBhdGhzLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgIC53aGVyZShrZXlQYXRoc0luVmFsaWRPcmRlcilcblx0ICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGtleVBhdGhzSW5WYWxpZE9yZGVyLm1hcChmdW5jdGlvbiAoa3ApIHsgcmV0dXJuIGluZGV4T3JDcml0W2twXTsgfSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghY29tcG91bmRJbmRleCAmJiBkZWJ1Zylcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBxdWVyeSBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaW5kZXhPckNyaXQpLCBcIiBvbiBcIikuY29uY2F0KHRoaXMubmFtZSwgXCIgd291bGQgYmVuZWZpdCBmcm9tIGEgXCIpICtcblx0ICAgICAgICAgICAgICAgICAgICBcImNvbXBvdW5kIGluZGV4IFtcIi5jb25jYXQoa2V5UGF0aHMuam9pbignKycpLCBcIl1cIikpO1xuXHQgICAgICAgICAgICB2YXIgaWR4QnlOYW1lID0gdGhpcy5zY2hlbWEuaWR4QnlOYW1lO1xuXHQgICAgICAgICAgICB2YXIgaWRiID0gdGhpcy5kYi5fZGVwcy5pbmRleGVkREI7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaWRiLmNtcChhLCBiKSA9PT0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX2EgPSBrZXlQYXRocy5yZWR1Y2UoZnVuY3Rpb24gKF9hLCBrZXlQYXRoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gX2FbMF0sIHByZXZGaWx0ZXJGbiA9IF9hWzFdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaWR4QnlOYW1lW2tleVBhdGhdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICAgICAgICAgIHByZXZJbmRleCB8fCBpbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZShwcmV2RmlsdGVyRm4sIGluZGV4ICYmIGluZGV4Lm11bHRpID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkocHJvcCkgJiYgcHJvcC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBlcXVhbHModmFsdWUsIGl0ZW0pOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gZXF1YWxzKHZhbHVlLCBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCkpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IHByZXZGaWx0ZXJGblxuXHQgICAgICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgfSwgW251bGwsIG51bGxdKSwgaWR4ID0gX2FbMF0sIGZpbHRlckZ1bmN0aW9uID0gX2FbMV07XG5cdCAgICAgICAgICAgIHJldHVybiBpZHggP1xuXHQgICAgICAgICAgICAgICAgdGhpcy53aGVyZShpZHgubmFtZSkuZXF1YWxzKGluZGV4T3JDcml0W2lkeC5rZXlQYXRoXSlcblx0ICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG5cdCAgICAgICAgICAgICAgICBjb21wb3VuZEluZGV4ID9cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMud2hlcmUoa2V5UGF0aHMpLmVxdWFscygnJyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmFuZChmaWx0ZXJGdW5jdGlvbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAodGhlblNob3J0Y3V0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmNvdW50KHRoZW5TaG9ydGN1dCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5vZmZzZXQob2Zmc2V0KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChudW1Sb3dzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmxpbWl0KG51bVJvd3MpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuZWFjaChjYWxsYmFjayk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICh0aGVuU2hvcnRjdXQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkudG9BcnJheSh0aGVuU2hvcnRjdXQpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLnRvQ29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcykpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuXHQgICAgICAgICAgICAgICAgXCJbXCIuY29uY2F0KGluZGV4LmpvaW4oJysnKSwgXCJdXCIpIDpcblx0ICAgICAgICAgICAgICAgIGluZGV4KSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLm1hcFRvQ2xhc3MgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgZGIgPSBfYS5kYiwgdGFibGVOYW1lID0gX2EubmFtZTtcblx0ICAgICAgICAgICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3Rvcjtcblx0ICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVudGl0eSkge1xuXHQgICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSAgKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJkYlwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGI7IH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhYmxlTmFtZTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcblx0ICAgICAgICAgICAgICAgIH0oY29uc3RydWN0b3IpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaW5oZXJpdGVkUHJvcHMgPSBuZXcgU2V0KCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlOyBwcm90bzsgcHJvdG8gPSBnZXRQcm90byhwcm90bykpIHtcblx0ICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gaW5oZXJpdGVkUHJvcHMuYWRkKHByb3BOYW1lKTsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHJlYWRIb29rID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvYmopXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcblx0ICAgICAgICAgICAgICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIG9iailcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWluaGVyaXRlZFByb3BzLmhhcyhtKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1ttXSA9IG9ialttXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2hlbWEucmVhZEhvb2spIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaG9vay5yZWFkaW5nLnVuc3Vic2NyaWJlKHRoaXMuc2NoZW1hLnJlYWRIb29rKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuXHQgICAgICAgICAgICB0aGlzLmhvb2soXCJyZWFkaW5nXCIsIHJlYWRIb29rKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmRlZmluZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwVG9DbGFzcyhDbGFzcyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcblx0ICAgICAgICAgICAgdmFyIG9ialRvQWRkID0gb2JqO1xuXHQgICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG5cdCAgICAgICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsLCB2YWx1ZXM6IFtvYmpUb0FkZF0gfSk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQ7IH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobGFzdFJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXlPck9iamVjdCwgbW9kaWZpY2F0aW9ucykge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShrZXlPck9iamVjdCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJHaXZlbiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBpdHMgcHJpbWFyeSBrZXlcIikpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleU9yT2JqZWN0KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuXHQgICAgICAgICAgICB2YXIgb2JqVG9BZGQgPSBvYmo7XG5cdCAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcblx0ICAgICAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsIH0pOyB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQ7IH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobGFzdFJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czogW2tleV0gfSk7IH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQ7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBBbnlSYW5nZSB9KTsgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZDsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0dldCA9IGZ1bmN0aW9uIChrZXlzKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLmdldE1hbnkoe1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMsXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zXG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKTsgfSk7IH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrQWRkID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcblx0ICAgICAgICAgICAgdmFyIHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciBvYmplY3RzVG9BZGQgPSBrZXlQYXRoICYmIGF1dG8gP1xuXHQgICAgICAgICAgICAgICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0cztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvQWRkLCB3YW50UmVzdWx0czogd2FudFJlc3VsdHMgfSlcblx0ICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtBZGQoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1PYmplY3RzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtQdXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMpO1xuXHQgICAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa1B1dCgpOiBrZXlzIGFyZ3VtZW50IGludmFsaWQgb24gdGFibGVzIHdpdGggaW5ib3VuZCBrZXlzXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdmFyIG9iamVjdHNUb1B1dCA9IGtleVBhdGggJiYgYXV0byA/XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3RzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAncHV0Jywga2V5czoga2V5cywgdmFsdWVzOiBvYmplY3RzVG9QdXQsIHdhbnRSZXN1bHRzOiB3YW50UmVzdWx0cyB9KVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa1B1dCgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bU9iamVjdHMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1VwZGF0ZSA9IGZ1bmN0aW9uIChrZXlzQW5kQ2hhbmdlcykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgY29yZVRhYmxlID0gdGhpcy5jb3JlO1xuXHQgICAgICAgICAgICB2YXIga2V5cyA9IGtleXNBbmRDaGFuZ2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleTsgfSk7XG5cdCAgICAgICAgICAgIHZhciBjaGFuZ2VTcGVjcyA9IGtleXNBbmRDaGFuZ2VzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmNoYW5nZXM7IH0pO1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0TWFwID0gW107XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoeyB0cmFuczogdHJhbnMsIGtleXM6IGtleXMsIGNhY2hlOiAnY2xvbmUnIH0pLnRoZW4oZnVuY3Rpb24gKG9ianMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0S2V5cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRPYmpzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAga2V5c0FuZENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIGlkeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2Eua2V5LCBjaGFuZ2VzID0gX2EuY2hhbmdlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9ianNbaWR4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IE9iamVjdC5rZXlzKGNoYW5nZXMpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gX2JbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5nZXNba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGggPT09IF90aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCh2YWx1ZSwga2V5KSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuQ29uc3RyYWludChcIkNhbm5vdCB1cGRhdGUgcHJpbWFyeSBrZXkgaW4gYnVsa1VwZGF0ZSgpXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TWFwLnB1c2goaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEtleXMucHVzaChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0T2Jqcy5wdXNoKG9iaik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRW50cmllcyA9IHJlc3VsdEtleXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLm11dGF0ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlc3VsdEtleXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVzdWx0T2Jqcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlczoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWNzOiBjaGFuZ2VTcGVjc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtRW50cmllcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKTsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfYltfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGVkT2Zmc2V0ID0gb2Zmc2V0TWFwW051bWJlcihvZmZzZXQpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZWRPZmZzZXQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlID0gZmFpbHVyZXNbb2Zmc2V0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmFpbHVyZXNbb2Zmc2V0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlc1ttYXBwZWRPZmZzZXRdID0gZmFpbHVyZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLmJ1bGtVcGRhdGUoKTogXCIpLmNvbmNhdChudW1GYWlsdXJlcywgXCIgb2YgXCIpLmNvbmNhdChudW1FbnRyaWVzLCBcIiBvcGVyYXRpb25zIGZhaWxlZFwiKSwgZmFpbHVyZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtEZWxldGUgPSBmdW5jdGlvbiAoa2V5cykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czoga2V5cyB9KTtcblx0ICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdCwgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa0RlbGV0ZSgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bUtleXMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIFRhYmxlO1xuXHQgICAgfSgpKTtcblxuXHQgICAgZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuXHQgICAgICAgIHZhciBldnMgPSB7fTtcblx0ICAgICAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG5cdCAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKC0taSlcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgICAgIGV2c1tldmVudE5hbWVdLnN1YnNjcmliZS5hcHBseShudWxsLCBhcmdzKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjdHg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGV2c1tldmVudE5hbWVdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBydi5hZGRFdmVudFR5cGUgPSBhZGQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgIGFkZChhcmd1bWVudHNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgZnVuY3Rpb24gYWRkKGV2ZW50TmFtZSwgY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0Jylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhZGRDb25maWd1cmVkRXZlbnRzKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgICAgIGlmICghY2hhaW5GdW5jdGlvbilcblx0ICAgICAgICAgICAgICAgIGNoYWluRnVuY3Rpb24gPSByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbjtcblx0ICAgICAgICAgICAgaWYgKCFkZWZhdWx0RnVuY3Rpb24pXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0RnVuY3Rpb24gPSBub3A7XG5cdCAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuXHQgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuXHQgICAgICAgICAgICAgICAgZmlyZTogZGVmYXVsdEZ1bmN0aW9uLFxuXHQgICAgICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdWJzY3JpYmVycy5pbmRleE9mKGNiKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5wdXNoKGNiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maXJlID0gY2hhaW5GdW5jdGlvbihjb250ZXh0LmZpcmUsIGNiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMgPSBjb250ZXh0LnN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuICE9PSBjYjsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maXJlID0gY29udGV4dC5zdWJzY3JpYmVycy5yZWR1Y2UoY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgZXZzW2V2ZW50TmFtZV0gPSBydltldmVudE5hbWVdID0gY29udGV4dDtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGFkZENvbmZpZ3VyZWRFdmVudHMoY2ZnKSB7XG5cdCAgICAgICAgICAgIGtleXMoY2ZnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBhcmdzID0gY2ZnW2V2ZW50TmFtZV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkZChldmVudE5hbWUsIGNmZ1tldmVudE5hbWVdWzBdLCBjZmdbZXZlbnROYW1lXVsxXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzID09PSAnYXNhcCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNhcCQxKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBtYWtlQ2xhc3NDb25zdHJ1Y3Rvcihwcm90b3R5cGUsIGNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgZGVyaXZlKGNvbnN0cnVjdG9yKS5mcm9tKHsgcHJvdG90eXBlOiBwcm90b3R5cGUgfSk7XG5cdCAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKGRiKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRhYmxlLnByb3RvdHlwZSwgZnVuY3Rpb24gVGFibGUobmFtZSwgdGFibGVTY2hlbWEsIHRyYW5zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcblx0ICAgICAgICAgICAgdGhpcy5fdHggPSB0cmFucztcblx0ICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSB0YWJsZVNjaGVtYTtcblx0ICAgICAgICAgICAgdGhpcy5ob29rID0gZGIuX2FsbFRhYmxlc1tuYW1lXSA/IGRiLl9hbGxUYWJsZXNbbmFtZV0uaG9vayA6IEV2ZW50cyhudWxsLCB7XG5cdCAgICAgICAgICAgICAgICBcImNyZWF0aW5nXCI6IFtob29rQ3JlYXRpbmdDaGFpbiwgbm9wXSxcblx0ICAgICAgICAgICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG5cdCAgICAgICAgICAgICAgICBcInVwZGF0aW5nXCI6IFtob29rVXBkYXRpbmdDaGFpbiwgbm9wXSxcblx0ICAgICAgICAgICAgICAgIFwiZGVsZXRpbmdcIjogW2hvb2tEZWxldGluZ0NoYWluLCBub3BdXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UoY3R4LCBpZ25vcmVMaW1pdEZpbHRlcikge1xuXHQgICAgICAgIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG5cdCAgICAgICAgICAgIChpZ25vcmVMaW1pdEZpbHRlciA/IGN0eC5qdXN0TGltaXQgOiAhY3R4LnJlcGxheUZpbHRlcik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGRGaWx0ZXIoY3R4LCBmbikge1xuXHQgICAgICAgIGN0eC5maWx0ZXIgPSBjb21iaW5lKGN0eC5maWx0ZXIsIGZuKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkZFJlcGxheUZpbHRlcihjdHgsIGZhY3RvcnksIGlzTGltaXRGaWx0ZXIpIHtcblx0ICAgICAgICB2YXIgY3VyciA9IGN0eC5yZXBsYXlGaWx0ZXI7XG5cdCAgICAgICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKTsgfSA6IGZhY3Rvcnk7XG5cdCAgICAgICAgY3R4Lmp1c3RMaW1pdCA9IGlzTGltaXRGaWx0ZXIgJiYgIWN1cnI7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG5cdCAgICAgICAgY3R4LmlzTWF0Y2ggPSBjb21iaW5lKGN0eC5pc01hdGNoLCBmbik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlU2NoZW1hKSB7XG5cdCAgICAgICAgaWYgKGN0eC5pc1ByaW1LZXkpXG5cdCAgICAgICAgICAgIHJldHVybiBjb3JlU2NoZW1hLnByaW1hcnlLZXk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gY29yZVNjaGVtYS5nZXRJbmRleEJ5S2V5UGF0aChjdHguaW5kZXgpO1xuXHQgICAgICAgIGlmICghaW5kZXgpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIktleVBhdGggXCIgKyBjdHguaW5kZXggKyBcIiBvbiBvYmplY3Qgc3RvcmUgXCIgKyBjb3JlU2NoZW1hLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcblx0ICAgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCB0cmFucykge1xuXHQgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuXHQgICAgICAgIHJldHVybiBjb3JlVGFibGUub3BlbkN1cnNvcih7XG5cdCAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgdmFsdWVzOiAhY3R4LmtleXNPbmx5LFxuXHQgICAgICAgICAgICByZXZlcnNlOiBjdHguZGlyID09PSAncHJldicsXG5cdCAgICAgICAgICAgIHVuaXF1ZTogISFjdHgudW5pcXVlLFxuXHQgICAgICAgICAgICBxdWVyeToge1xuXHQgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpdGVyKGN0eCwgZm4sIGNvcmVUcmFucywgY29yZVRhYmxlKSB7XG5cdCAgICAgICAgdmFyIGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuXHQgICAgICAgIGlmICghY3R4Lm9yKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBzZXRfMSA9IHt9O1xuXHQgICAgICAgICAgICB2YXIgdW5pb24gPSBmdW5jdGlvbiAoaXRlbSwgY3Vyc29yLCBhZHZhbmNlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjdXJzb3Iuc3RvcChyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjdXJzb3IuZmFpbChlcnIpOyB9KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duKHNldF8xLCBrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldF8xW2tleV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcblx0ICAgICAgICAgICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgY29yZVRyYW5zKSxcblx0ICAgICAgICAgICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpdGVyYXRlKGN1cnNvclByb21pc2UsIGZpbHRlciwgZm4sIHZhbHVlTWFwcGVyKSB7XG5cdCAgICAgICAgdmFyIG1hcHBlZEZuID0gdmFsdWVNYXBwZXIgPyBmdW5jdGlvbiAoeCwgYywgYSkgeyByZXR1cm4gZm4odmFsdWVNYXBwZXIoeCksIGMsIGEpOyB9IDogZm47XG5cdCAgICAgICAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuXHQgICAgICAgIHJldHVybiBjdXJzb3JQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGN1cnNvcikge1xuXHQgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnN0YXJ0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnNvci5jb250aW51ZSgpOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGZ1bmN0aW9uIChhZHZhbmNlcikgeyByZXR1cm4gYyA9IGFkdmFuY2VyOyB9LCBmdW5jdGlvbiAodmFsKSB7IGN1cnNvci5zdG9wKHZhbCk7IGMgPSBub3A7IH0sIGZ1bmN0aW9uIChlKSB7IGN1cnNvci5mYWlsKGUpOyBjID0gbm9wOyB9KSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgcmV0dXJuIGMgPSBhZHZhbmNlcjsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYygpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIFByb3BNb2RTeW1ib2wgPSBTeW1ib2woKTtcblx0ICAgIHZhciBQcm9wTW9kaWZpY2F0aW9uID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gUHJvcE1vZGlmaWNhdGlvbihzcGVjKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3BlYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFByb3BNb2RpZmljYXRpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5hZGQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRlcm0gPSB0aGlzLmFkZDtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHRlcm0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSksIHRydWUpLCB0ZXJtLCB0cnVlKS5zb3J0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlcm0gPT09ICdudW1iZXInKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKHZhbHVlKSB8fCAwKSArIHRlcm07XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlcm0gPT09ICdiaWdpbnQnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgKyB0ZXJtO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKSArIHRlcm07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGVybSBcIi5jb25jYXQodGVybSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHJhaGVuZF8xID0gdGhpcy5yZW1vdmU7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzdWJ0cmFoZW5kXzEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhc3VidHJhaGVuZF8xLmluY2x1ZGVzKGl0ZW0pOyB9KS5zb3J0KCkgOiBbXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VidHJhaGVuZF8xID09PSAnbnVtYmVyJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSAtIHN1YnRyYWhlbmRfMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VidHJhaGVuZF8xID09PSAnYmlnaW50Jykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpIC0gc3VidHJhaGVuZF8xO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKSAtIHN1YnRyYWhlbmRfMTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdWJ0cmFoZW5kIFwiLmNvbmNhdChzdWJ0cmFoZW5kXzEpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcHJlZml4VG9SZXBsYWNlID0gKF9hID0gdGhpcy5yZXBsYWNlUHJlZml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG5cdCAgICAgICAgICAgIGlmIChwcmVmaXhUb1JlcGxhY2UgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKHByZWZpeFRvUmVwbGFjZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VQcmVmaXhbMV0gKyB2YWx1ZS5zdWJzdHJpbmcocHJlZml4VG9SZXBsYWNlLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIFByb3BNb2RpZmljYXRpb247XG5cdCAgICB9KCkpO1xuXG5cdCAgICB2YXIgQ29sbGVjdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKGZuLCBjYikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cblx0ICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuXHQgICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZG9ubHknLCBmbikudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZm4pIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG5cdCAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcblx0ICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWR3cml0ZScsIGZuLCBcImxvY2tlZFwiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9hZGRBbGdvcml0aG0gPSBmdW5jdGlvbiAoZm4pIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIGNvcmVUcmFucykge1xuXHQgICAgICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHByb3BzKSB7XG5cdCAgICAgICAgICAgIHZhciBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpLCBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG5cdCAgICAgICAgICAgIGlmIChwcm9wcylcblx0ICAgICAgICAgICAgICAgIGV4dGVuZChjdHgsIHByb3BzKTtcblx0ICAgICAgICAgICAgcnYuX2N0eCA9IGN0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBpdGVyKGN0eCwgZm4sIHRyYW5zLCBjdHgudGFibGUuY29yZSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3RoaXMuX2N0eDtcblx0ICAgICAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuY291bnQoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVRhYmxlLnNjaGVtYSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gTWF0aC5taW4oY291bnQsIGN0eC5saW1pdCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGZ1bmN0aW9uICgpIHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudDsgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gKGtleVBhdGgsIGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJ0cyA9IGtleVBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCksIGxhc3RQYXJ0ID0gcGFydHNbMF0sIGxhc3RJbmRleCA9IHBhcnRzLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR2YWwob2JqW3BhcnRzW2ldXSwgaSAtIDEpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtsYXN0UGFydF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5fY3R4LmRpciA9PT0gXCJuZXh0XCIgPyAxIDogLTE7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYVZhbCA9IGdldHZhbChhLCBsYXN0SW5kZXgpLCBiVmFsID0gZ2V0dmFsKGIsIGxhc3RJbmRleCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYVZhbCA8IGJWYWwgPyAtb3JkZXIgOiBhVmFsID4gYlZhbCA/IG9yZGVyIDogMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYS5zb3J0KHNvcnRlcik7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlTWFwcGVyXzEgPSBjdHgudmFsdWVNYXBwZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfYS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU1hcHBlcl8xID8gcmVzdWx0Lm1hcCh2YWx1ZU1hcHBlcl8xKSA6IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhXzEgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcihjdHgsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhXzEucHVzaChpdGVtKTsgfSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFfMTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0O1xuXHQgICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkpIHtcblx0ICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXRMZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uob2Zmc2V0TGVmdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICgtLW9mZnNldExlZnQgPCAwKTsgfTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobnVtUm93cykge1xuXHQgICAgICAgICAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpO1xuXHQgICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcm93c0xlZnQgPSBudW1Sb3dzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoLS1yb3dzTGVmdCA8PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3dzTGVmdCA+PSAwO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudW50aWwgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24sIGJJbmNsdWRlU3RvcEVudHJ5KSB7XG5cdCAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYkluY2x1ZGVTdG9wRW50cnk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkudG9BcnJheShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdChjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBhZGRNYXRjaEZpbHRlcih0aGlzLl9jdHgsIGZpbHRlckZ1bmN0aW9uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmaWx0ZXIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLl9jdHgudGFibGUsIGluZGV4TmFtZSwgdGhpcyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSlcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKHRoaXMuX2N0eC5kaXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmRlc2MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hLZXkgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2hVbmlxdWVLZXkgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2hLZXkoY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaFByaW1hcnlLZXkgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcblx0ICAgICAgICAgICAgdmFyIGEgPSBbXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLmtleSk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucHJpbWFyeUtleXMgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGNiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG5cdCAgICAgICAgICAgIHZhciBhID0gW107XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5wcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgICAgICAgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS51bmlxdWVLZXlzID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpcnN0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubGFzdEtleSA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIGlkeCA9IGN0eC5pbmRleCAmJiBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAoIWlkeCB8fCAhaWR4Lm11bHRpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBzZXQgPSB7fTtcblx0ICAgICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0cktleSA9IGN1cnNvci5wcmltYXJ5S2V5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBoYXNPd24oc2V0LCBzdHJLZXkpO1xuXHQgICAgICAgICAgICAgICAgc2V0W3N0cktleV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGlmeWVyO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhjaGFuZ2VzKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbnVtS2V5cyA9IGtleVBhdGhzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGtleVBhdGhzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ1ZhbCA9IGdldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9wTW9kaWZpY2F0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbC5leGVjdXRlKG9yaWdWYWwpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdWYWwgIT09IHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbnl0aGluZ01vZGlmaWVkO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2EgPSBjb3JlVGFibGUuc2NoZW1hLnByaW1hcnlLZXksIG91dGJvdW5kID0gX2Eub3V0Ym91bmQsIGV4dHJhY3RLZXkgPSBfYS5leHRyYWN0S2V5O1xuXHQgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gX3RoaXMuZGIuX29wdGlvbnMubW9kaWZ5Q2h1bmtTaXplIHx8IDIwMDtcblx0ICAgICAgICAgICAgICAgIHZhciB0b3RhbEZhaWx1cmVzID0gW107XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc0NvdW50ID0gMDtcblx0ICAgICAgICAgICAgICAgIHZhciBmYWlsZWRLZXlzID0gW107XG5cdCAgICAgICAgICAgICAgICB2YXIgYXBwbHlNdXRhdGVSZXN1bHQgPSBmdW5jdGlvbiAoZXhwZWN0ZWRDb3VudCwgcmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gcmVzLmZhaWx1cmVzLCBudW1GYWlsdXJlcyA9IHJlcy5udW1GYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBrZXlzKGZhaWx1cmVzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF9hW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxGYWlsdXJlcy5wdXNoKGZhaWx1cmVzW3Bvc10pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvbmUoKS5wcmltYXJ5S2V5cygpLnRoZW4oZnVuY3Rpb24gKGtleXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3JpdGVyaWEgPSBpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJyB8fCBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykgJiYge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY3R4LmluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENodW5rID0gZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihsaW1pdCwga2V5cy5sZW5ndGggLSBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBcImltbXV0YWJsZVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1dFZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1dEtleXMgPSBvdXRib3VuZCA/IFtdIDogbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVLZXlzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ1ZhbHVlID0gdmFsdWVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHhfMSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlZXBDbG9uZShvcmlnVmFsdWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5OiBrZXlzW29mZnNldCArIGldXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZ5ZXIuY2FsbChjdHhfMSwgY3R4XzEudmFsdWUsIGN0eF8xKSAhPT0gZmFsc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eF8xLnZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb3V0Ym91bmQgJiYgY21wKGV4dHJhY3RLZXkob3JpZ1ZhbHVlKSwgZXh0cmFjdEtleShjdHhfMS52YWx1ZSkpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZXMucHVzaChjdHhfMS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRWYWx1ZXMucHVzaChjdHhfMS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0S2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhZGRWYWx1ZXMubGVuZ3RoID4gMCAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdhZGQnLCB2YWx1ZXM6IGFkZFZhbHVlcyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMuc3BsaWNlKHBhcnNlSW50KHBvcyksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHB1dFZhbHVlcy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiB0eXBlb2YgY2hhbmdlcyA9PT0gJ29iamVjdCcpKSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBwdXRLZXlzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWE6IGNyaXRlcmlhLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTcGVjOiB0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBZGRpdGlvbmFsQ2h1bms6IG9mZnNldCA+IDBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGFwcGx5TXV0YXRlUmVzdWx0KHB1dFZhbHVlcy5sZW5ndGgsIHJlcyk7IH0pOyB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChkZWxldGVLZXlzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZGVsZXRlS2V5cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWE6IGNyaXRlcmlhLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYXBwbHlNdXRhdGVSZXN1bHQoZGVsZXRlS2V5cy5sZW5ndGgsIHJlcyk7IH0pOyB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGggPiBvZmZzZXQgKyBjb3VudCAmJiBuZXh0Q2h1bmsob2Zmc2V0ICsgbGltaXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaHVuaygwKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsRmFpbHVyZXMubGVuZ3RoID4gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkVycm9yIG1vZGlmeWluZyBvbmUgb3IgbW9yZSBvYmplY3RzXCIsIHRvdGFsRmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgcmFuZ2UgPSBjdHgucmFuZ2U7XG5cdCAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuXHQgICAgICAgICAgICAgICAgKGN0eC5pc1ByaW1LZXkgfHwgcmFuZ2UudHlwZSA9PT0gMyApKVxuXHQgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3R4LnRhYmxlLmNvcmUuc2NoZW1hLnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvcmVSYW5nZSA9IHJhbmdlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5jb3VudCh7IHRyYW5zOiB0cmFucywgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlOiBjb3JlUmFuZ2UgfSB9KS50aGVuKGZ1bmN0aW9uIChjb3VudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnZGVsZXRlUmFuZ2UnLCByYW5nZTogY29yZVJhbmdlIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzOyBfYS5sYXN0UmVzdWx0OyBfYS5yZXN1bHRzOyB2YXIgbnVtRmFpbHVyZXMgPSBfYS5udW1GYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJDb3VsZCBub3QgZGVsZXRlIHNvbWUgdmFsdWVzXCIsIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gZmFpbHVyZXNbcG9zXTsgfSksIGNvdW50IC0gbnVtRmFpbHVyZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50IC0gbnVtRmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRlbGV0ZUNhbGxiYWNrKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xuXHQgICAgfSgpKTtcblx0ICAgIHZhciBkZWxldGVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7IHJldHVybiBjdHgudmFsdWUgPSBudWxsOyB9O1xuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcblx0ICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIENvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGtleVJhbmdlR2VuZXJhdG9yKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcblx0ICAgICAgICAgICAgdmFyIGtleVJhbmdlID0gQW55UmFuZ2UsIGVycm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgd2hlcmVDdHggPSB3aGVyZUNsYXVzZS5fY3R4O1xuXHQgICAgICAgICAgICB2YXIgdGFibGUgPSB3aGVyZUN0eC50YWJsZTtcblx0ICAgICAgICAgICAgdmFyIHJlYWRpbmdIb29rID0gdGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eCA9IHtcblx0ICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcblx0ICAgICAgICAgICAgICAgIGluZGV4OiB3aGVyZUN0eC5pbmRleCxcblx0ICAgICAgICAgICAgICAgIGlzUHJpbUtleTogKCF3aGVyZUN0eC5pbmRleCB8fCAodGFibGUuc2NoZW1hLnByaW1LZXkua2V5UGF0aCAmJiB3aGVyZUN0eC5pbmRleCA9PT0gdGFibGUuc2NoZW1hLnByaW1LZXkubmFtZSkpLFxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IGtleVJhbmdlLFxuXHQgICAgICAgICAgICAgICAga2V5c09ubHk6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgZGlyOiBcIm5leHRcIixcblx0ICAgICAgICAgICAgICAgIHVuaXF1ZTogXCJcIixcblx0ICAgICAgICAgICAgICAgIGFsZ29yaXRobTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGZpbHRlcjogbnVsbCxcblx0ICAgICAgICAgICAgICAgIHJlcGxheUZpbHRlcjogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGp1c3RMaW1pdDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIGlzTWF0Y2g6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG5cdCAgICAgICAgICAgICAgICBsaW1pdDogSW5maW5pdHksXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICBvcjogd2hlcmVDdHgub3IsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZU1hcHBlcjogcmVhZGluZ0hvb2sgIT09IG1pcnJvciA/IHJlYWRpbmdIb29rIDogbnVsbFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzaW1wbGVDb21wYXJlKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmVSZXZlcnNlKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZmFpbChjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSwgZXJyLCBUKSB7XG5cdCAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSBpbnN0YW5jZW9mIFdoZXJlQ2xhdXNlID9cblx0ICAgICAgICAgICAgbmV3IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLkNvbGxlY3Rpb24oY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcblx0ICAgICAgICAgICAgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2U7XG5cdCAgICAgICAgY29sbGVjdGlvbi5fY3R4LmVycm9yID0gVCA/IG5ldyBUKGVycikgOiBuZXcgVHlwZUVycm9yKGVycik7XG5cdCAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBlbXB0eUNvbGxlY3Rpb24od2hlcmVDbGF1c2UpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmdlRXF1YWwoXCJcIik7IH0pLmxpbWl0KDApO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gdXBwZXJGYWN0b3J5KGRpcikge1xuXHQgICAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cblx0ICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9VcHBlckNhc2UoKTsgfSA6XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBsb3dlckZhY3RvcnkoZGlyKSB7XG5cdCAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuXHQgICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9IDpcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9VcHBlckNhc2UoKTsgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGUsIGxvd2VyTmVlZGxlLCBjbXAsIGRpcikge1xuXHQgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihrZXkubGVuZ3RoLCBsb3dlck5lZWRsZS5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBsbHAgPSAtMTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciBsd3JLZXlDaGFyID0gbG93ZXJLZXlbaV07XG5cdCAgICAgICAgICAgIGlmIChsd3JLZXlDaGFyICE9PSBsb3dlck5lZWRsZVtpXSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIHVwcGVyTmVlZGxlW2ldKSA8IDApXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyB1cHBlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbG93ZXJOZWVkbGVbaV0pIDwgMClcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIGxvd2VyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcblx0ICAgICAgICAgICAgICAgIGlmIChsbHAgPj0gMClcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJLZXlbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsd3JLZXlDaGFyKSA8IDApXG5cdCAgICAgICAgICAgICAgICBsbHAgPSBpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGVuZ3RoIDwgbG93ZXJOZWVkbGUubGVuZ3RoICYmIGRpciA9PT0gXCJuZXh0XCIpXG5cdCAgICAgICAgICAgIHJldHVybiBrZXkgKyB1cHBlck5lZWRsZS5zdWJzdHIoa2V5Lmxlbmd0aCk7XG5cdCAgICAgICAgaWYgKGxlbmd0aCA8IGtleS5sZW5ndGggJiYgZGlyID09PSBcInByZXZcIilcblx0ICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgdXBwZXJOZWVkbGUubGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gKGxscCA8IDAgPyBudWxsIDoga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJOZWVkbGVbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHdoZXJlQ2xhdXNlLCBtYXRjaCwgbmVlZGxlcywgc3VmZml4KSB7XG5cdCAgICAgICAgdmFyIHVwcGVyLCBsb3dlciwgY29tcGFyZSwgdXBwZXJOZWVkbGVzLCBsb3dlck5lZWRsZXMsIGRpcmVjdGlvbiwgbmV4dEtleVN1ZmZpeCwgbmVlZGxlc0xlbiA9IG5lZWRsZXMubGVuZ3RoO1xuXHQgICAgICAgIGlmICghbmVlZGxlcy5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnOyB9KSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaW5pdERpcmVjdGlvbihkaXIpIHtcblx0ICAgICAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcblx0ICAgICAgICAgICAgbG93ZXIgPSBsb3dlckZhY3RvcnkoZGlyKTtcblx0ICAgICAgICAgICAgY29tcGFyZSA9IChkaXIgPT09IFwibmV4dFwiID8gc2ltcGxlQ29tcGFyZSA6IHNpbXBsZUNvbXBhcmVSZXZlcnNlKTtcblx0ICAgICAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IGxvd2VyOiBsb3dlcihuZWVkbGUpLCB1cHBlcjogdXBwZXIobmVlZGxlKSB9O1xuXHQgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHVwcGVyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi51cHBlcjsgfSk7XG5cdCAgICAgICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG5cdCAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRpcjtcblx0ICAgICAgICAgICAgbmV4dEtleVN1ZmZpeCA9IChkaXIgPT09IFwibmV4dFwiID8gXCJcIiA6IHN1ZmZpeCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuXHQgICAgICAgIHZhciBjID0gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHVwcGVyTmVlZGxlc1swXSwgbG93ZXJOZWVkbGVzW25lZWRsZXNMZW4gLSAxXSArIHN1ZmZpeCk7IH0pO1xuXHQgICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IDA7XG5cdCAgICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoKGxvd2VyS2V5LCBsb3dlck5lZWRsZXMsIGZpcnN0UG9zc2libGVOZWVkbGUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQb3NzaWJsZU5lZWRsZTsgaSA8IG5lZWRsZXNMZW47ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjYXNpbmcgPSBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlc1tpXSwgbG93ZXJOZWVkbGVzW2ldLCBjb21wYXJlLCBkaXJlY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UG9zc2libGVOZWVkbGUgPSBpICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbCB8fCBjb21wYXJlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nLCBjYXNpbmcpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICsgbmV4dEtleVN1ZmZpeCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBjO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3Blbikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHR5cGU6IDIgLFxuXHQgICAgICAgICAgICBsb3dlcjogbG93ZXIsXG5cdCAgICAgICAgICAgIHVwcGVyOiB1cHBlcixcblx0ICAgICAgICAgICAgbG93ZXJPcGVuOiBsb3dlck9wZW4sXG5cdCAgICAgICAgICAgIHVwcGVyT3BlbjogdXBwZXJPcGVuXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJhbmdlRXF1YWwodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0eXBlOiAxICxcblx0ICAgICAgICAgICAgbG93ZXI6IHZhbHVlLFxuXHQgICAgICAgICAgICB1cHBlcjogdmFsdWVcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgV2hlcmVDbGF1c2UgPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBXaGVyZUNsYXVzZSgpIHtcblx0ICAgICAgICB9XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdoZXJlQ2xhdXNlLnByb3RvdHlwZSwgXCJDb2xsZWN0aW9uXCIsIHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnRhYmxlLmRiLkNvbGxlY3Rpb247XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYmV0d2VlbiA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIsIGluY2x1ZGVMb3dlciwgaW5jbHVkZVVwcGVyKSB7XG5cdCAgICAgICAgICAgIGluY2x1ZGVMb3dlciA9IGluY2x1ZGVMb3dlciAhPT0gZmFsc2U7XG5cdCAgICAgICAgICAgIGluY2x1ZGVVcHBlciA9IGluY2x1ZGVVcHBlciA9PT0gdHJ1ZTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPiAwKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcik7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmdlRXF1YWwodmFsdWUpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hYm92ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgdHJ1ZSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFib3ZlT3JFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgZmFsc2UpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZWxvdyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZWxvd09yRXF1YWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBTVFJJTkdfRVhQRUNURUQpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKHN0ciwgc3RyICsgbWF4U3RyaW5nLCB0cnVlLCB0cnVlKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoSWdub3JlQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0ICAgICAgICAgICAgaWYgKHN0ciA9PT0gXCJcIilcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0c1dpdGgoc3RyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHguaW5kZXhPZihhWzBdKSA9PT0gMDsgfSwgW3N0cl0sIG1heFN0cmluZyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuZXF1YWxzSWdub3JlQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHggPT09IGFbMF07IH0sIFtzdHJdLCBcIlwiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hbnlPZklnbm9yZUNhc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIGEuaW5kZXhPZih4KSAhPT0gLTE7IH0sIHNldCwgXCJcIik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5zb21lKGZ1bmN0aW9uIChuKSB7IHJldHVybiB4LmluZGV4T2YobikgPT09IDA7IH0pOyB9LCBzZXQsIG1heFN0cmluZyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYW55T2YgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5fY21wO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgIHZhciBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZShzZXRbMF0sIHNldFtzZXQubGVuZ3RoIC0gMV0pOyB9KTtcblx0ICAgICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICBjb21wYXJlID0gKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIgP1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hc2NlbmRpbmcgOlxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kZXNjZW5kaW5nKTtcblx0ICAgICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgaSA9IDA7XG5cdCAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGtleSwgc2V0W2ldKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICArK2k7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHNldC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgc2V0W2ldKSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShzZXRbaV0pOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gYztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5ub3RFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKFtbbWluS2V5LCB2YWx1ZV0sIFt2YWx1ZSwgdGhpcy5kYi5fbWF4S2V5XV0sIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLm5vbmVPZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHNldC5zb3J0KHRoaXMuX2FzY2VuZGluZyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2V0LnJlZHVjZShmdW5jdGlvbiAocmVzLCB2YWwpIHsgcmV0dXJuIHJlcyA/XG5cdCAgICAgICAgICAgICAgICByZXMuY29uY2F0KFtbcmVzW3Jlcy5sZW5ndGggLSAxXVsxXSwgdmFsXV0pIDpcblx0ICAgICAgICAgICAgICAgIFtbbWluS2V5LCB2YWxdXTsgfSwgbnVsbCk7XG5cdCAgICAgICAgICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCB0aGlzLmRiLl9tYXhLZXldKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShyYW5nZXMsIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmluQW55UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VzLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBjbXAgPSB0aGlzLl9jbXAsIGFzY2VuZGluZyA9IHRoaXMuX2FzY2VuZGluZywgZGVzY2VuZGluZyA9IHRoaXMuX2Rlc2NlbmRpbmcsIG1pbiA9IHRoaXMuX21pbiwgbWF4ID0gdGhpcy5fbWF4O1xuXHQgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgIGlmICghcmFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChyYW5nZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiZcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG5cdCAgICAgICAgICAgICAgICAgICAgYXNjZW5kaW5nKHJhbmdlWzBdLCByYW5nZVsxXSkgPD0gMDtcblx0ICAgICAgICAgICAgfSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIiwgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBpbmNsdWRlTG93ZXJzID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5pbmNsdWRlTG93ZXJzICE9PSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGluY2x1ZGVVcHBlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVVwcGVycyA9PT0gdHJ1ZTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2VzLCBuZXdSYW5nZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBsID0gcmFuZ2VzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gbWluKHJhbmdlWzBdLCBuZXdSYW5nZVswXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzFdID0gbWF4KHJhbmdlWzFdLCBuZXdSYW5nZVsxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChpID09PSBsKVxuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHJhbmdlU29ydGVyKGEsIGIpIHsgcmV0dXJuIHNvcnREaXJlY3Rpb24oYVswXSwgYlswXSk7IH1cblx0ICAgICAgICAgICAgdmFyIHNldDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHNldCA9IHJhbmdlcy5yZWR1Y2UoYWRkUmFuZ2UsIFtdKTtcblx0ICAgICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcmFuZ2VQb3MgPSAwO1xuXHQgICAgICAgICAgICB2YXIga2V5SXNCZXlvbmRDdXJyZW50RW50cnkgPSBpbmNsdWRlVXBwZXJzID9cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMDsgfSA6XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+PSAwOyB9O1xuXHQgICAgICAgICAgICB2YXIga2V5SXNCZWZvcmVDdXJyZW50RW50cnkgPSBpbmNsdWRlTG93ZXJzID9cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+IDA7IH0gOlxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID49IDA7IH07XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAha2V5SXNCZXlvbmRDdXJyZW50RW50cnkoa2V5KSAmJiAha2V5SXNCZWZvcmVDdXJyZW50RW50cnkoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKTsgfSk7XG5cdCAgICAgICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuXHQgICAgICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGVja0tleSA9IGtleUlzQmVmb3JlQ3VycmVudEVudHJ5O1xuXHQgICAgICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICsrcmFuZ2VQb3M7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlUG9zID09PSBzZXQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA9PT0gMCB8fCBfdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnREaXJlY3Rpb24gPT09IGFzY2VuZGluZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBjO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhBbnlPZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKCFzZXQuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHNldC5tYXAoZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gW3N0ciwgc3RyICsgbWF4U3RyaW5nXTsgfSkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIFdoZXJlQ2xhdXNlO1xuXHQgICAgfSgpKTtcblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYikge1xuXHQgICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihXaGVyZUNsYXVzZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRhYmxlLCBpbmRleCwgb3JDb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4ID0ge1xuXHQgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuXHQgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4ID09PSBcIjppZFwiID8gbnVsbCA6IGluZGV4LFxuXHQgICAgICAgICAgICAgICAgb3I6IG9yQ29sbGVjdGlvblxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB0aGlzLl9jbXAgPSB0aGlzLl9hc2NlbmRpbmcgPSBjbXA7XG5cdCAgICAgICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGIsIGEpOyB9O1xuXHQgICAgICAgICAgICB0aGlzLl9tYXggPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpID4gMCA/IGEgOiBiOyB9O1xuXHQgICAgICAgICAgICB0aGlzLl9taW4gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGEgOiBiOyB9O1xuXHQgICAgICAgICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX0lEQktleVJhbmdlKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KSB7XG5cdCAgICAgICAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcblx0ICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0ICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuXHQgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgPSAnc3RvcmFnZW11dGF0ZWQnO1xuXHQgICAgdmFyIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSA9ICd4LXN0b3JhZ2VtdXRhdGVkLTEnO1xuXHQgICAgdmFyIGdsb2JhbEV2ZW50cyA9IEV2ZW50cyhudWxsLCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSk7XG5cblx0ICAgIHZhciBUcmFuc2FjdGlvbiA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKCkge1xuXHQgICAgICAgIH1cblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX2xvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG5cdCAgICAgICAgICAgICsrdGhpcy5fcmVjdWxvY2s7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbClcblx0ICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fdW5sb2NrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuXHQgICAgICAgICAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuXHQgICAgICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2Jsb2NrZWRGdW5jcy5sZW5ndGggPiAwICYmICF0aGlzLl9sb2NrZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX2xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vsb2NrICYmIFBTRC5sb2NrT3duZXJGb3IgIT09IHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tb2RlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBpZGJkYiA9IHRoaXMuZGIuaWRiZGI7XG5cdCAgICAgICAgICAgIHZhciBkYk9wZW5FcnJvciA9IHRoaXMuZGIuX3N0YXRlLmRiT3BlbkVycm9yO1xuXHQgICAgICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuXHQgICAgICAgICAgICBpZiAoIWlkYnRyYW5zICYmICFpZGJkYikge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNaXNzaW5nQVBJRXJyb3JcIjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcblx0ICAgICAgICAgICAgYXNzZXJ0KHRoaXMuX2NvbXBsZXRpb24uX3N0YXRlID09PSBudWxsKTtcblx0ICAgICAgICAgICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcblx0ICAgICAgICAgICAgICAgICh0aGlzLmRiLmNvcmVcblx0ICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZGIuY29yZS50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuXHQgICAgICAgICAgICAgICAgICAgIDogaWRiZGIudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSkpO1xuXHQgICAgICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWRidHJhbnMub25hYm9ydCA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgJiYgX3RoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5vbihcImFib3J0XCIpLmZpcmUoZXYpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWRidHJhbnMub25jb21wbGV0ZSA9IHdyYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCdtdXRhdGVkUGFydHMnIGluIGlkYnRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUoaWRidHJhbnNbXCJtdXRhdGVkUGFydHNcIl0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX3Byb21pc2UgPSBmdW5jdGlvbiAobW9kZSwgZm4sIGJXcml0ZUxvY2spIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnICYmIHRoaXMubW9kZSAhPT0gJ3JlYWR3cml0ZScpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlJlYWRPbmx5KFwiVHJhbnNhY3Rpb24gaXMgcmVhZG9ubHlcIikpO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9ja2VkKCkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goW2Z1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9jaygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIF90aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcC5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91bmxvY2soKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIF90aGlzKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fcm9vdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIChwcm9taXNlTGlrZSkge1xuXHQgICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcblx0ICAgICAgICAgICAgdmFyIHByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZShwcm9taXNlTGlrZSk7XG5cdCAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSB7XG5cdCAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb21pc2U7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nUXVldWUgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHJvb3QuaWRidHJhbnMub2JqZWN0U3RvcmUocm9vdC5zdG9yZU5hbWVzWzBdKTtcblx0ICAgICAgICAgICAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICsrcm9vdC5fc3BpbkNvdW50O1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldCgtSW5maW5pdHkpLm9uc3VjY2VzcyA9IHNwaW47XG5cdCAgICAgICAgICAgICAgICB9KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50V2FpdFByb21pc2UgPSByb290Ll93YWl0aW5nRm9yO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKTsgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IgPT09IGN1cnJlbnRXYWl0UHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkYnRyYW5zKVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICB2YXIgbWVtb2l6ZWRUYWJsZXMgPSAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgfHwgKHRoaXMuX21lbW9pemVkVGFibGVzID0ge30pKTtcblx0ICAgICAgICAgICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuXHQgICAgICAgICAgICB2YXIgdGFibGVTY2hlbWEgPSB0aGlzLnNjaGVtYVt0YWJsZU5hbWVdO1xuXHQgICAgICAgICAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uQm91bmRUYWJsZSA9IG5ldyB0aGlzLmRiLlRhYmxlKHRhYmxlTmFtZSwgdGFibGVTY2hlbWEsIHRoaXMpO1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdID0gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuXHQgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uO1xuXHQgICAgfSgpKTtcblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuXHQgICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihUcmFuc2FjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB0aGlzLmRiID0gZGI7XG5cdCAgICAgICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuc3RvcmVOYW1lcyA9IHN0b3JlTmFtZXM7XG5cdCAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG5cdCAgICAgICAgICAgIHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5ID0gY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5O1xuXHQgICAgICAgICAgICB0aGlzLmlkYnRyYW5zID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcblx0ICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuXHQgICAgICAgICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG5cdCAgICAgICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fd2FpdGluZ0ZvciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdRdWV1ZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QgPSByZWplY3Q7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5vbi5jb21wbGV0ZS5maXJlKCk7XG5cdCAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gX3RoaXMuYWN0aXZlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMucGFyZW50ID9cblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJlbnQuX3JlamVjdChlKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgd2FzQWN0aXZlICYmIF90aGlzLmlkYnRyYW5zICYmIF90aGlzLmlkYnRyYW5zLmFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlSW5kZXhTcGVjKG5hbWUsIGtleVBhdGgsIHVuaXF1ZSwgbXVsdGksIGF1dG8sIGNvbXBvdW5kLCBpc1ByaW1LZXkpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuXHQgICAgICAgICAgICB1bmlxdWU6IHVuaXF1ZSxcblx0ICAgICAgICAgICAgbXVsdGk6IG11bHRpLFxuXHQgICAgICAgICAgICBhdXRvOiBhdXRvLFxuXHQgICAgICAgICAgICBjb21wb3VuZDogY29tcG91bmQsXG5cdCAgICAgICAgICAgIHNyYzogKHVuaXF1ZSAmJiAhaXNQcmltS2V5ID8gJyYnIDogJycpICsgKG11bHRpID8gJyonIDogJycpICsgKGF1dG8gPyBcIisrXCIgOiBcIlwiKSArIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuXHQgICAgICAgICAgICBrZXlQYXRoIDpcblx0ICAgICAgICAgICAga2V5UGF0aCA/ICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJykgOiBcIlwiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZVNjaGVtYShuYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgcHJpbUtleTogcHJpbUtleSxcblx0ICAgICAgICAgICAgaW5kZXhlczogaW5kZXhlcyxcblx0ICAgICAgICAgICAgbWFwcGVkQ2xhc3M6IG51bGwsXG5cdCAgICAgICAgICAgIGlkeEJ5TmFtZTogYXJyYXlUb09iamVjdChpbmRleGVzLCBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIFtpbmRleC5uYW1lLCBpbmRleF07IH0pXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2FmYXJpTXVsdGlTdG9yZUZpeChzdG9yZU5hbWVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0b3JlTmFtZXMubGVuZ3RoID09PSAxID8gc3RvcmVOYW1lc1swXSA6IHN0b3JlTmFtZXM7XG5cdCAgICB9XG5cdCAgICB2YXIgZ2V0TWF4S2V5ID0gZnVuY3Rpb24gKElkYktleVJhbmdlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgSWRiS2V5UmFuZ2Uub25seShbW11dKTtcblx0ICAgICAgICAgICAgZ2V0TWF4S2V5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1tdXTsgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFtbXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIGdldE1heEtleSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFN0cmluZzsgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIG1heFN0cmluZztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuXHQgICAgICAgIGlmIChrZXlQYXRoID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpOyB9O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuXHQgICAgICAgIHZhciBzcGxpdCA9IGtleVBhdGguc3BsaXQoJy4nKTtcblx0ICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmpba2V5UGF0aF07IH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7IH07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhcnJheWlmeShhcnJheUxpa2UpIHtcblx0ICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnJheUxpa2UpO1xuXHQgICAgfVxuXHQgICAgdmFyIF9pZF9jb3VudGVyID0gMDtcblx0ICAgIGZ1bmN0aW9uIGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKSB7XG5cdCAgICAgICAgcmV0dXJuIGtleVBhdGggPT0gbnVsbCA/XG5cdCAgICAgICAgICAgIFwiOmlkXCIgOlxuXHQgICAgICAgICAgICB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuXHQgICAgICAgICAgICAgICAga2V5UGF0aCA6XG5cdCAgICAgICAgICAgICAgICBcIltcIi5jb25jYXQoa2V5UGF0aC5qb2luKCcrJyksIFwiXVwiKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZURCQ29yZShkYiwgSWRiS2V5UmFuZ2UsIHRtcFRyYW5zKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZXh0cmFjdFNjaGVtYShkYiwgdHJhbnMpIHtcblx0ICAgICAgICAgICAgdmFyIHRhYmxlcyA9IGFycmF5aWZ5KGRiLm9iamVjdFN0b3JlTmFtZXMpO1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgc2NoZW1hOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogZGIubmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAoZnVuY3Rpb24gKHRhYmxlKSB7IHJldHVybiB0cmFucy5vYmplY3RTdG9yZSh0YWJsZSk7IH0pLm1hcChmdW5jdGlvbiAoc3RvcmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50ID0gc3RvcmUuYXV0b0luY3JlbWVudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dGJvdW5kID0ga2V5UGF0aCA9PSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhCeUtleVBhdGggPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0b3JlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQ6IG91dGJvdW5kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IGF1dG9JbmNyZW1lbnQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChmdW5jdGlvbiAoaW5kZXhOYW1lKSB7IHJldHVybiBzdG9yZS5pbmRleChpbmRleE5hbWUpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5uYW1lLCB1bmlxdWUgPSBpbmRleC51bmlxdWUsIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5LCBrZXlQYXRoID0gaW5kZXgua2V5UGF0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aDoga2V5UGF0aCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpRW50cnk6IG11bHRpRW50cnksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogZnVuY3Rpb24gKGtleVBhdGgpIHsgcmV0dXJuIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV07IH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbXCI6aWRcIl0gPSByZXN1bHQucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGggIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBoYXNHZXRBbGw6IHRhYmxlcy5sZW5ndGggPiAwICYmICgnZ2V0QWxsJyBpbiB0cmFucy5vYmplY3RTdG9yZSh0YWJsZXNbMF0pKSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICEodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWFrZUlEQktleVJhbmdlKHJhbmdlKSB7XG5cdCAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSAzIClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gNCApXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBuZXZlciB0eXBlIHRvIElEQktleVJhbmdlXCIpO1xuXHQgICAgICAgICAgICB2YXIgbG93ZXIgPSByYW5nZS5sb3dlciwgdXBwZXIgPSByYW5nZS51cHBlciwgbG93ZXJPcGVuID0gcmFuZ2UubG93ZXJPcGVuLCB1cHBlck9wZW4gPSByYW5nZS51cHBlck9wZW47XG5cdCAgICAgICAgICAgIHZhciBpZGJSYW5nZSA9IGxvd2VyID09PSB1bmRlZmluZWQgP1xuXHQgICAgICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG5cdCAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG5cdCAgICAgICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UudXBwZXJCb3VuZCh1cHBlciwgISF1cHBlck9wZW4pIDpcblx0ICAgICAgICAgICAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuXHQgICAgICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsICEhbG93ZXJPcGVuKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCAhIWxvd2VyT3BlbiwgISF1cHBlck9wZW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gaWRiUmFuZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKSB7XG5cdCAgICAgICAgICAgIHZhciB0YWJsZU5hbWUgPSB0YWJsZVNjaGVtYS5uYW1lO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBtdXRhdGUoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCB0eXBlID0gX2EudHlwZSwga2V5cyA9IF9hLmtleXMsIHZhbHVlcyA9IF9hLnZhbHVlcywgcmFuZ2UgPSBfYS5yYW5nZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Ym91bmQgPSBzdG9yZS5rZXlQYXRoID09IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlzQWRkT3JQdXQgPSB0eXBlID09PSBcInB1dFwiIHx8IHR5cGUgPT09IFwiYWRkXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FkZE9yUHV0ICYmIHR5cGUgIT09ICdkZWxldGUnICYmIHR5cGUgIT09ICdkZWxldGVSYW5nZScpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3BlcmF0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IChrZXlzIHx8IHZhbHVlcyB8fCB7IGxlbmd0aDogMSB9KS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgdmFsdWVzICYmIGtleXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIGtleXMgYXJyYXkgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGdpdmVuIHZhbHVlcyBhcnJheS5cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbnVtRmFpbHVyZXM6IDAsIGZhaWx1cmVzOiB7fSwgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXFzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrbnVtRmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLCBmYWlsdXJlczogZmFpbHVyZXMsIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSAzIClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlLmRlbGV0ZShtYWtlSURCS2V5UmFuZ2UocmFuZ2UpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBpc0FkZE9yUHV0ID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBrZXlzXSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywgbnVsbF0gOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2tleXMsIG51bGxdLCBhcmdzMSA9IF9hWzBdLCBhcmdzMiA9IF9hWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBZGRPclB1dCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSAoYXJnczIgJiYgYXJnczJbaV0gIT09IHVuZGVmaW5lZCA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmVbdHlwZV0oYXJnczFbaV0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMuZm9yRWFjaChmdW5jdGlvbiAocmVxLCBpKSB7IHJldHVybiByZXEuZXJyb3IgIT0gbnVsbCAmJiAoZmFpbHVyZXNbaV0gPSByZXEuZXJyb3IpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1GYWlsdXJlczogbnVtRmFpbHVyZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlczogZmFpbHVyZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiB0eXBlID09PSBcImRlbGV0ZVwiID8ga2V5cyA6IHJlcXMubWFwKGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIHJlcS5yZXN1bHQ7IH0pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3VsdDogbGFzdFJlc3VsdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihldmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKF9hKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBfYS50cmFucywgdmFsdWVzID0gX2EudmFsdWVzLCBxdWVyeSA9IF9hLnF1ZXJ5LCByZXZlcnNlID0gX2EucmV2ZXJzZSwgdW5pcXVlID0gX2EudW5pcXVlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5pbmRleCwgcmFuZ2UgPSBxdWVyeS5yYW5nZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSByZXZlcnNlID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldnVuaXF1ZVwiIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldlwiIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dHVuaXF1ZVwiIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dFwiO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbikgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuX19faWQgPSArK19pZF9jb3VudGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJzb3JBZHZhbmNlID0gY3Vyc29yLmFkdmFuY2UuYmluZChjdXJzb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9UaHJvd0N1cnNvcklzU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdG9wcGVkXCIpOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IudHJhbnMgPSB0cmFucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHdyYXAocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdvdE9uZSA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydChmdW5jdGlvbiAoKSB7IHJldHVybiBnb3RPbmUtLSA/IF90aGlzLmNvbnRpbnVlKCkgOiBfdGhpcy5zdG9wKCk7IH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXM7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmVJdGVyYXRpb24sIHJlamVjdEl0ZXJhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24gPSB3cmFwKHJlc29sdmVJdGVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdEl0ZXJhdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSByZWplY3RJdGVyYXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3IgYmVoaW5kIGxhc3QgZW50cnlcIik7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBndWFyZGVkQ2FsbGJhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2UgPSBfY3Vyc29yQWR2YW5jZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvblByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZnVuY3Rpb24gcXVlcnkoaGFzR2V0QWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gcmVxdWVzdC50cmFucywgdmFsdWVzID0gcmVxdWVzdC52YWx1ZXMsIGxpbWl0ID0gcmVxdWVzdC5saW1pdCwgcXVlcnkgPSByZXF1ZXN0LnF1ZXJ5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9uSW5maW5pdExpbWl0ID0gbGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbGltaXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmluZGV4LCByYW5nZSA9IHF1ZXJ5LnJhbmdlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IFtdIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR2V0QWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gdmFsdWVzID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsS2V5cyhpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IGV2ZW50LnRhcmdldC5yZXN1bHQgfSk7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50XzEgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcV8xID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKGlkYktleVJhbmdlKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IoaWRiS2V5UmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFfMS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxXzEucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogcmVzdWx0XzEgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnRfMSA9PT0gbGltaXQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHRfMSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFfMS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IHRhYmxlTmFtZSxcblx0ICAgICAgICAgICAgICAgIHNjaGVtYTogdGFibGVTY2hlbWEsXG5cdCAgICAgICAgICAgICAgICBtdXRhdGU6IG11dGF0ZSxcblx0ICAgICAgICAgICAgICAgIGdldE1hbnk6IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCBrZXlzID0gX2Eua2V5cztcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb3VudCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja0NvdW50ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gZXZlbnQudGFyZ2V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHRbcmVxLl9wb3NdID0gcmVxLnJlc3VsdCkgIT0gbnVsbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjYWxsYmFja0NvdW50ID09PSBrZXlDb3VudClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5c1tpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9wb3MgPSBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzSGFuZGxlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2tleUNvdW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCBrZXkgPSBfYS5rZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnkoaGFzR2V0QWxsKSxcblx0ICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IG9wZW5DdXJzb3IsXG5cdCAgICAgICAgICAgICAgICBjb3VudDogZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gX2EucXVlcnksIHRyYW5zID0gX2EudHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGJLZXlSYW5nZSA/IHNvdXJjZS5jb3VudChpZGJLZXlSYW5nZSkgOiBzb3VyY2UuY291bnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7IHJldHVybiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIF9hID0gZXh0cmFjdFNjaGVtYShkYiwgdG1wVHJhbnMpLCBzY2hlbWEgPSBfYS5zY2hlbWEsIGhhc0dldEFsbCA9IF9hLmhhc0dldEFsbDtcblx0ICAgICAgICB2YXIgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAoZnVuY3Rpb24gKHRhYmxlU2NoZW1hKSB7IHJldHVybiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSk7IH0pO1xuXHQgICAgICAgIHZhciB0YWJsZU1hcCA9IHt9O1xuXHQgICAgICAgIHRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkgeyByZXR1cm4gdGFibGVNYXBbdGFibGUubmFtZV0gPSB0YWJsZTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcblx0ICAgICAgICAgICAgdGFibGU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFibGVNYXBbbmFtZV07XG5cdCAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYWJsZSAnXCIuY29uY2F0KG5hbWUsIFwiJyBub3QgZm91bmRcIikpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWFwW25hbWVdO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBNSU5fS0VZOiAtSW5maW5pdHksXG5cdCAgICAgICAgICAgIE1BWF9LRVk6IGdldE1heEtleShJZGJLZXlSYW5nZSksXG5cdCAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrKHN0YWNrSW1wbCwgbWlkZGxld2FyZXMpIHtcblx0ICAgICAgICByZXR1cm4gbWlkZGxld2FyZXMucmVkdWNlKGZ1bmN0aW9uIChkb3duLCBfYSkge1xuXHQgICAgICAgICAgICB2YXIgY3JlYXRlID0gX2EuY3JlYXRlO1xuXHQgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duKSwgY3JlYXRlKGRvd24pKSk7XG5cdCAgICAgICAgfSwgc3RhY2tJbXBsKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MobWlkZGxld2FyZXMsIGlkYmRiLCBfYSwgdG1wVHJhbnMpIHtcblx0ICAgICAgICB2YXIgSURCS2V5UmFuZ2UgPSBfYS5JREJLZXlSYW5nZTsgX2EuaW5kZXhlZERCO1xuXHQgICAgICAgIHZhciBkYmNvcmUgPSBjcmVhdGVNaWRkbGV3YXJlU3RhY2soY3JlYXRlREJDb3JlKGlkYmRiLCBJREJLZXlSYW5nZSwgdG1wVHJhbnMpLCBtaWRkbGV3YXJlcy5kYmNvcmUpO1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGRiY29yZTogZGJjb3JlXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgdG1wVHJhbnMpIHtcblx0ICAgICAgICB2YXIgaWRiZGIgPSB0bXBUcmFucy5kYjtcblx0ICAgICAgICB2YXIgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuXHQgICAgICAgIGRiLmNvcmUgPSBzdGFja3MuZGJjb3JlO1xuXHQgICAgICAgIGRiLnRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuXHQgICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGFibGUubmFtZTtcblx0ICAgICAgICAgICAgaWYgKGRiLmNvcmUuc2NoZW1hLnRhYmxlcy5zb21lKGZ1bmN0aW9uICh0YmwpIHsgcmV0dXJuIHRibC5uYW1lID09PSB0YWJsZU5hbWU7IH0pKSB7XG5cdCAgICAgICAgICAgICAgICB0YWJsZS5jb3JlID0gZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGRiW3RhYmxlTmFtZV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRiW3RhYmxlTmFtZV0uY29yZSA9IHRhYmxlLmNvcmU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2V0QXBpT25QbGFjZShkYiwgb2JqcywgdGFibGVOYW1lcywgZGJzY2hlbWEpIHtcblx0ICAgICAgICB0YWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICB2YXIgc2NoZW1hID0gZGJzY2hlbWFbdGFibGVOYW1lXTtcblx0ICAgICAgICAgICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wRGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXByb3BEZXNjIHx8IChcInZhbHVlXCIgaW4gcHJvcERlc2MgJiYgcHJvcERlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChvYmosIHRhYmxlTmFtZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRhYmxlKHRhYmxlTmFtZSk7IH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHRhYmxlTmFtZSwgeyB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkoZGIsIG9ianMpIHtcblx0ICAgICAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSlcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJ1blVwZ3JhZGVycyhkYiwgb2xkVmVyc2lvbiwgaWRiVXBncmFkZVRyYW5zLCByZWplY3QpIHtcblx0ICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuXHQgICAgICAgIGlmIChpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSAmJiAhZ2xvYmFsU2NoZW1hLiRtZXRhKSB7XG5cdCAgICAgICAgICAgIGdsb2JhbFNjaGVtYS4kbWV0YSA9IGNyZWF0ZVRhYmxlU2NoZW1hKFwiJG1ldGFcIiwgcGFyc2VJbmRleFN5bnRheChcIlwiKVswXSwgW10pO1xuXHQgICAgICAgICAgICBkYi5fc3RvcmVOYW1lcy5wdXNoKCckbWV0YScpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScsIGRiLl9zdG9yZU5hbWVzLCBnbG9iYWxTY2hlbWEpO1xuXHQgICAgICAgIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgIHRyYW5zLl9jb21wbGV0aW9uLmNhdGNoKHJlamVjdCk7XG5cdCAgICAgICAgdmFyIHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcblx0ICAgICAgICB2YXIgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG5cdCAgICAgICAgbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcblx0ICAgICAgICAgICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcblx0ICAgICAgICAgICAgaWYgKG9sZFZlcnNpb24gPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGtleXMoZ2xvYmFsU2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHRhYmxlTmFtZSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucyk7IH0pLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBnZXRFeGlzdGluZ1ZlcnNpb24oZGIsIHRyYW5zLCBvbGRWZXJzaW9uKVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvbGRWZXJzaW9uKSB7IHJldHVybiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwYXRjaEN1cnJlbnRWZXJzaW9uKGRiLCBpZGJVcGdyYWRlVHJhbnMpIHtcblx0ICAgICAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGRiLl9kYlNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICBpZiAoaWRiVXBncmFkZVRyYW5zLmRiLnZlcnNpb24gJSAxMCA9PT0gMCAmJiAhaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcblx0ICAgICAgICAgICAgaWRiVXBncmFkZVRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKCckbWV0YScpLmFkZChNYXRoLmNlaWwoKGlkYlVwZ3JhZGVUcmFucy5kYi52ZXJzaW9uIC8gMTApIC0gMSksICd2ZXJzaW9uJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIGRiLl9kYlNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICB2YXIgZGlmZiA9IGdldFNjaGVtYURpZmYoZ2xvYmFsU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuXHQgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHRhYmxlQ2hhbmdlKSB7XG5cdCAgICAgICAgICAgIGlmICh0YWJsZUNoYW5nZS5jaGFuZ2UubGVuZ3RoIHx8IHRhYmxlQ2hhbmdlLnJlY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gcGF0Y2ggaW5kZXhlcyBvZiB0YWJsZSBcIi5jb25jYXQodGFibGVDaGFuZ2UubmFtZSwgXCIgYmVjYXVzZSBpdCBoYXMgY2hhbmdlcyBvbiB0aGUgdHlwZSBvZiBpbmRleCBvciBwcmltYXJ5IGtleS5cIikpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzdG9yZSA9IGlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZSh0YWJsZUNoYW5nZS5uYW1lKTtcblx0ICAgICAgICAgICAgdGFibGVDaGFuZ2UuYWRkLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJEZXhpZSB1cGdyYWRlIHBhdGNoOiBDcmVhdGluZyBtaXNzaW5nIGluZGV4IFwiLmNvbmNhdCh0YWJsZUNoYW5nZS5uYW1lLCBcIi5cIikuY29uY2F0KGlkeC5zcmMpKTtcblx0ICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBkaWZmLmNoYW5nZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgdmFyIHRhYmxlQ2hhbmdlID0gX2FbX2ldO1xuXHQgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEodGFibGVDaGFuZ2UpO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVfMS52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRFeGlzdGluZ1ZlcnNpb24oZGIsIHRyYW5zLCBvbGRWZXJzaW9uKSB7XG5cdCAgICAgICAgaWYgKHRyYW5zLnN0b3JlTmFtZXMuaW5jbHVkZXMoJyRtZXRhJykpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRyYW5zLnRhYmxlKCckbWV0YScpLmdldCgndmVyc2lvbicpLnRoZW4oZnVuY3Rpb24gKG1ldGFWZXJzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWV0YVZlcnNpb24gIT0gbnVsbCA/IG1ldGFWZXJzaW9uIDogb2xkVmVyc2lvbjtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUob2xkVmVyc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucykge1xuXHQgICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuXHQgICAgICAgIHZhciB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcblx0ICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgIHZhciB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuX2NmZy52ZXJzaW9uID49IG9sZFZlcnNpb247IH0pO1xuXHQgICAgICAgIGlmICh2ZXJzVG9SdW4ubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2ZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuXHQgICAgICAgICAgICBxdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuXHQgICAgICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG9sZFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBuZXdTY2hlbWE7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpO1xuXHQgICAgICAgICAgICAgICAgZGlmZi5hZGQuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHR1cGxlWzBdLCB0dXBsZVsxXS5wcmltS2V5LCB0dXBsZVsxXS5pbmRleGVzKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5VcGdyYWRlKFwiTm90IHlldCBzdXBwb3J0IGZvciBjaGFuZ2luZyBwcmltYXJ5IGtleVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZV8xID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKGNoYW5nZS5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGFkZEluZGV4KHN0b3JlXzEsIGlkeCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVfMS5kZWxldGVJbmRleChpZHgubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZV8xLCBpZHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5mb3JFYWNoKGZ1bmN0aW9uIChpZHhOYW1lKSB7IHJldHVybiBzdG9yZV8xLmRlbGV0ZUluZGV4KGlkeE5hbWUpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHZhciBjb250ZW50VXBncmFkZSA9IHZlcnNpb24uX2NmZy5jb250ZW50VXBncmFkZTtcblx0ICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnMuX21lbW9pemVkVGFibGVzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHVwZ3JhZGVTY2hlbWFfMSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRpZmYuZGVsLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVTY2hlbWFfMVt0YWJsZV0gPSBvbGRTY2hlbWFbdGFibGVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBrZXlzKHVwZ3JhZGVTY2hlbWFfMSksIHVwZ3JhZGVTY2hlbWFfMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnMuc2NoZW1hID0gdXBncmFkZVNjaGVtYV8xO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VXBncmFkZUlzQXN5bmNfMSA9IGlzQXN5bmNGdW5jdGlvbihjb250ZW50VXBncmFkZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luY18xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZV8xO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVfMSA9IGNvbnRlbnRVcGdyYWRlKHRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmNfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVfMS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlXzEgJiYgdHlwZW9mIHJldHVyblZhbHVlXzEudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlXzEpIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVmFsdWVfMTsgfSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoaWRidHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG5cdCAgICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG5cdCAgICAgICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwgZGIuX3N0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG5cdCAgICAgICAgICAgICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBxdWV1ZS5wdXNoKGZ1bmN0aW9uIChpZGJ0cmFucykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRiLmlkYmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJyRtZXRhJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5jZWlsKGRiLmlkYmRiLnZlcnNpb24gLyAxMCkgPT09IHZlcnNpb24uX2NmZy52ZXJzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRiLmlkYmRiLmRlbGV0ZU9iamVjdFN0b3JlKCckbWV0YScpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGIuX2RiU2NoZW1hLiRtZXRhO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IGRiLl9zdG9yZU5hbWVzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSAhPT0gJyRtZXRhJzsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZGJ0cmFucy5vYmplY3RTdG9yZSgnJG1ldGEnKS5wdXQodmVyc2lvbi5fY2ZnLnZlcnNpb24sICd2ZXJzaW9uJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IERleGllUHJvbWlzZS5yZXNvbHZlKHF1ZXVlLnNoaWZ0KCkodHJhbnMuaWRidHJhbnMpKS50aGVuKHJ1blF1ZXVlKSA6XG5cdCAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnVuUXVldWUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhnbG9iYWxTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKSB7XG5cdCAgICAgICAgdmFyIGRpZmYgPSB7XG5cdCAgICAgICAgICAgIGRlbDogW10sXG5cdCAgICAgICAgICAgIGFkZDogW10sXG5cdCAgICAgICAgICAgIGNoYW5nZTogW11cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciB0YWJsZTtcblx0ICAgICAgICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuXHQgICAgICAgICAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pXG5cdCAgICAgICAgICAgICAgICBkaWZmLmRlbC5wdXNoKHRhYmxlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcblx0ICAgICAgICAgICAgdmFyIG9sZERlZiA9IG9sZFNjaGVtYVt0YWJsZV0sIG5ld0RlZiA9IG5ld1NjaGVtYVt0YWJsZV07XG5cdCAgICAgICAgICAgIGlmICghb2xkRGVmKSB7XG5cdCAgICAgICAgICAgICAgICBkaWZmLmFkZC5wdXNoKFt0YWJsZSwgbmV3RGVmXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRhYmxlLFxuXHQgICAgICAgICAgICAgICAgICAgIGRlZjogbmV3RGVmLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICBkZWw6IFtdLFxuXHQgICAgICAgICAgICAgICAgICAgIGFkZDogW10sXG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBbXVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGlmICgoXG5cdCAgICAgICAgICAgICAgICAnJyArIChvbGREZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgIT09ICgnJyArIChuZXdEZWYucHJpbUtleS5rZXlQYXRoIHx8ICcnKSkgfHxcblx0ICAgICAgICAgICAgICAgICAgICAob2xkRGVmLnByaW1LZXkuYXV0byAhPT0gbmV3RGVmLnByaW1LZXkuYXV0bykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbGRJbmRleGVzID0gb2xkRGVmLmlkeEJ5TmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW5kZXhlcyA9IG5ld0RlZi5pZHhCeU5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkeE5hbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdJbmRleGVzW2lkeE5hbWVdKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5wdXNoKGlkeE5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeE5hbWUgaW4gbmV3SW5kZXhlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSwgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRJZHgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkLnB1c2gobmV3SWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGlmZjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcblx0ICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSh0YWJsZU5hbWUsIHByaW1LZXkua2V5UGF0aCA/XG5cdCAgICAgICAgICAgIHsga2V5UGF0aDogcHJpbUtleS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSA6XG5cdCAgICAgICAgICAgIHsgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0pO1xuXHQgICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBhZGRJbmRleChzdG9yZSwgaWR4KTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHN0b3JlO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG5cdCAgICAgICAga2V5cyhuZXdTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBDcmVhdGluZyBtaXNzaW5nIHRhYmxlJywgdGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcblx0ICAgICAgICBbXS5zbGljZS5jYWxsKGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMpLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCAmJiBpZGJ0cmFucy5kYi5kZWxldGVPYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRkSW5kZXgoc3RvcmUsIGlkeCkge1xuXHQgICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KGlkeC5uYW1lLCBpZHgua2V5UGF0aCwgeyB1bmlxdWU6IGlkeC51bmlxdWUsIG11bHRpRW50cnk6IGlkeC5tdWx0aSB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpIHtcblx0ICAgICAgICB2YXIgZ2xvYmFsU2NoZW1hID0ge307XG5cdCAgICAgICAgdmFyIGRiU3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuXHQgICAgICAgIGRiU3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0ICAgICAgICAgICAgdmFyIHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcblx0ICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5rZXlQYXRoO1xuXHQgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGNyZWF0ZUluZGV4U3BlYyhuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCksIGtleVBhdGggfHwgXCJcIiwgdHJ1ZSwgZmFsc2UsICEhc3RvcmUuYXV0b0luY3JlbWVudCwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIHZhciBpbmRleGVzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG5cdCAgICAgICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhpZGJpbmRleC5uYW1lLCBrZXlQYXRoLCAhIWlkYmluZGV4LnVuaXF1ZSwgISFpZGJpbmRleC5tdWx0aUVudHJ5LCBmYWxzZSwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBnbG9iYWxTY2hlbWFbc3RvcmVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHN0b3JlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuXHQgICAgICAgIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuXHQgICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcblx0ICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuXHQgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykge1xuXHQgICAgICAgIHZhciBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcblx0ICAgICAgICB2YXIgZGlmZiA9IGdldFNjaGVtYURpZmYoaW5zdGFsbGVkU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuXHQgICAgICAgIHJldHVybiAhKGRpZmYuYWRkLmxlbmd0aCB8fCBkaWZmLmNoYW5nZS5zb21lKGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gY2guYWRkLmxlbmd0aCB8fCBjaC5jaGFuZ2UubGVuZ3RoOyB9KSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgc2NoZW1hLCBpZGJ0cmFucykge1xuXHQgICAgICAgIHZhciBzdG9yZU5hbWVzID0gaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG5cdCAgICAgICAgICAgIHZhciBzdG9yZSA9IGlkYnRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG5cdCAgICAgICAgICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXhOYW1lID0gc3RvcmUuaW5kZXhOYW1lc1tqXTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuXHQgICAgICAgICAgICAgICAgdmFyIGRleGllTmFtZSA9IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IGtleVBhdGggOiBcIltcIiArIHNsaWNlKGtleVBhdGgpLmpvaW4oJysnKSArIFwiXVwiO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVtzdG9yZU5hbWVdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4U3BlYyA9IHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFNwZWMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhTcGVjLm5hbWUgPSBpbmRleE5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2luZGV4TmFtZV0gPSBpbmRleFNwZWM7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG5cdCAgICAgICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuXHQgICAgICAgICAgICBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmIF9nbG9iYWwgaW5zdGFuY2VvZiBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmXG5cdCAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcblx0ICAgICAgICAgICAgZGIuX2hhc0dldEFsbCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXMpIHtcblx0ICAgICAgICByZXR1cm4gcHJpbUtleUFuZEluZGV4ZXMuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGluZGV4LCBpbmRleE51bSkge1xuXHQgICAgICAgICAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpO1xuXHQgICAgICAgICAgICB2YXIga2V5UGF0aCA9IC9eXFxbLy50ZXN0KG5hbWUpID8gbmFtZS5tYXRjaCgvXlxcWyguKilcXF0kLylbMV0uc3BsaXQoJysnKSA6IG5hbWU7XG5cdCAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCB8fCBudWxsLCAvXFwmLy50ZXN0KGluZGV4KSwgL1xcKi8udGVzdChpbmRleCksIC9cXCtcXCsvLnRlc3QoaW5kZXgpLCBpc0FycmF5KGtleVBhdGgpLCBpbmRleE51bSA9PT0gMCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBWZXJzaW9uID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gVmVyc2lvbigpIHtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVmVyc2lvbi5wcm90b3R5cGUuX3BhcnNlU3RvcmVzU3BlYyA9IGZ1bmN0aW9uIChzdG9yZXMsIG91dFNjaGVtYSkge1xuXHQgICAgICAgICAgICBrZXlzKHN0b3JlcykuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gaW5kZXhlcy5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHByaW1LZXkudW5pcXVlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5tdWx0aSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpLXZhbHVlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4LmF1dG8pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJPbmx5IHByaW1hcnkga2V5IGNhbiBiZSBtYXJrZWQgYXMgYXV0b0luY3JlbWVudCAoKyspXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBvdXRTY2hlbWFbdGFibGVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVmVyc2lvbi5wcm90b3R5cGUuc3RvcmVzID0gZnVuY3Rpb24gKHN0b3Jlcykge1xuXHQgICAgICAgICAgICB2YXIgZGIgPSB0aGlzLmRiO1xuXHQgICAgICAgICAgICB0aGlzLl9jZmcuc3RvcmVzU291cmNlID0gdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA/XG5cdCAgICAgICAgICAgICAgICBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKSA6XG5cdCAgICAgICAgICAgICAgICBzdG9yZXM7XG5cdCAgICAgICAgICAgIHZhciB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcblx0ICAgICAgICAgICAgdmFyIHN0b3Jlc1NwZWMgPSB7fTtcblx0ICAgICAgICAgICAgdmFyIGRic2NoZW1hID0ge307XG5cdCAgICAgICAgICAgIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHZlcnNpb24pIHtcblx0ICAgICAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcblx0ICAgICAgICAgICAgICAgIGRic2NoZW1hID0gKHZlcnNpb24uX2NmZy5kYnNjaGVtYSA9IHt9KTtcblx0ICAgICAgICAgICAgICAgIHZlcnNpb24uX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcblx0ICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuXHQgICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG5cdCAgICAgICAgICAgIGRiLl9zdG9yZU5hbWVzID0ga2V5cyhkYnNjaGVtYSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVmVyc2lvbi5wcm90b3R5cGUudXBncmFkZSA9IGZ1bmN0aW9uICh1cGdyYWRlRnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlID0gcHJvbWlzYWJsZUNoYWluKHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSB8fCBub3AsIHVwZ3JhZGVGdW5jdGlvbik7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIFZlcnNpb247XG5cdCAgICB9KCkpO1xuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IoZGIpIHtcblx0ICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVmVyc2lvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFZlcnNpb24odmVyc2lvbk51bWJlcikge1xuXHQgICAgICAgICAgICB0aGlzLmRiID0gZGI7XG5cdCAgICAgICAgICAgIHRoaXMuX2NmZyA9IHtcblx0ICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG5cdCAgICAgICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBkYnNjaGVtYToge30sXG5cdCAgICAgICAgICAgICAgICB0YWJsZXM6IHt9LFxuXHQgICAgICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpIHtcblx0ICAgICAgICB2YXIgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXTtcblx0ICAgICAgICBpZiAoIWRiTmFtZXNEQikge1xuXHQgICAgICAgICAgICBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdID0gbmV3IERleGllJDEoREJOQU1FU19EQiwge1xuXHQgICAgICAgICAgICAgICAgYWRkb25zOiBbXSxcblx0ICAgICAgICAgICAgICAgIGluZGV4ZWREQjogaW5kZXhlZERCLFxuXHQgICAgICAgICAgICAgICAgSURCS2V5UmFuZ2U6IElEQktleVJhbmdlLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogXCJuYW1lXCIgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBkYk5hbWVzREIudGFibGUoXCJkYm5hbWVzXCIpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikge1xuXHQgICAgICAgIHJldHVybiBpbmRleGVkREIgJiYgdHlwZW9mIGluZGV4ZWREQi5kYXRhYmFzZXMgPT09IFwiZnVuY3Rpb25cIjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldERhdGFiYXNlTmFtZXMoX2EpIHtcblx0ICAgICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuXHQgICAgICAgIHJldHVybiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKVxuXHQgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShpbmRleGVkREIuZGF0YWJhc2VzKCkpLnRoZW4oZnVuY3Rpb24gKGluZm9zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5mb3Ncblx0ICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLm5hbWU7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSAhPT0gREJOQU1FU19EQjsgfSk7XG5cdCAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgIDogZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnRvQ29sbGVjdGlvbigpLnByaW1hcnlLZXlzKCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBfb25EYXRhYmFzZUNyZWF0ZWQoX2EsIG5hbWUpIHtcblx0ICAgICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuXHQgICAgICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuXHQgICAgICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG5cdCAgICAgICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5wdXQoeyBuYW1lOiBuYW1lIH0pLmNhdGNoKG5vcCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBfb25EYXRhYmFzZURlbGV0ZWQoX2EsIG5hbWUpIHtcblx0ICAgICAgICB2YXIgaW5kZXhlZERCID0gX2EuaW5kZXhlZERCLCBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlO1xuXHQgICAgICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuXHQgICAgICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG5cdCAgICAgICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5kZWxldGUobmFtZSkuY2F0Y2gobm9wKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdmlwKGZuKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgUFNELmxldFRocm91Z2ggPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gZm4oKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaWRiUmVhZHkoKSB7XG5cdCAgICAgICAgdmFyIGlzU2FmYXJpID0gIW5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmXG5cdCAgICAgICAgICAgIC9TYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcblx0ICAgICAgICAgICAgIS9DaHJvbShlfGl1bSlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdCAgICAgICAgaWYgKCFpc1NhZmFyaSB8fCAhaW5kZXhlZERCLmRhdGFiYXNlcylcblx0ICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgIHZhciBpbnRlcnZhbElkO1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICB2YXIgdHJ5SWRiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhlZERCLmRhdGFiYXNlcygpLmZpbmFsbHkocmVzb2x2ZSk7IH07XG5cdCAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0cnlJZGIsIDEwMCk7XG5cdCAgICAgICAgICAgIHRyeUlkYigpO1xuXHQgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTsgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBfYTtcblx0ICAgIGZ1bmN0aW9uIGlzRW1wdHlSYW5nZShub2RlKSB7XG5cdCAgICAgICAgcmV0dXJuICEoXCJmcm9tXCIgaW4gbm9kZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgUmFuZ2VTZXQgPSBmdW5jdGlvbiAoZnJvbU9yVHJlZSwgdG8pIHtcblx0ICAgICAgICBpZiAodGhpcykge1xuXHQgICAgICAgICAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHsgZDogMSwgZnJvbTogZnJvbU9yVHJlZSwgdG86IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdG8gOiBmcm9tT3JUcmVlIH0gOiB7IGQ6IDAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcnYgPSBuZXcgUmFuZ2VTZXQoKTtcblx0ICAgICAgICAgICAgaWYgKGZyb21PclRyZWUgJiYgKFwiZFwiIGluIGZyb21PclRyZWUpKSB7XG5cdCAgICAgICAgICAgICAgICBleHRlbmQocnYsIGZyb21PclRyZWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcHJvcHMoUmFuZ2VTZXQucHJvdG90eXBlLCAoX2EgPSB7XG5cdCAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKHJhbmdlU2V0KSB7XG5cdCAgICAgICAgICAgICAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgYWRkS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgYWRkS2V5czogZnVuY3Rpb24gKGtleXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWRkUmFuZ2UoX3RoaXMsIGtleSwga2V5KTsgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgaGFzS2V5OiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcykubmV4dChrZXkpLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgY21wKG5vZGUuZnJvbSwga2V5KSA8PSAwICYmIGNtcChub2RlLnRvLCBrZXkpID49IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIF9hW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBfYSkpO1xuXHQgICAgZnVuY3Rpb24gYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0bykge1xuXHQgICAgICAgIHZhciBkaWZmID0gY21wKGZyb20sIHRvKTtcblx0ICAgICAgICBpZiAoaXNOYU4oZGlmZikpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICBpZiAoZGlmZiA+IDApXG5cdCAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoKTtcblx0ICAgICAgICBpZiAoaXNFbXB0eVJhbmdlKHRhcmdldCkpXG5cdCAgICAgICAgICAgIHJldHVybiBleHRlbmQodGFyZ2V0LCB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSB9KTtcblx0ICAgICAgICB2YXIgbGVmdCA9IHRhcmdldC5sO1xuXHQgICAgICAgIHZhciByaWdodCA9IHRhcmdldC5yO1xuXHQgICAgICAgIGlmIChjbXAodG8sIHRhcmdldC5mcm9tKSA8IDApIHtcblx0ICAgICAgICAgICAgbGVmdFxuXHQgICAgICAgICAgICAgICAgPyBhZGRSYW5nZShsZWZ0LCBmcm9tLCB0bylcblx0ICAgICAgICAgICAgICAgIDogKHRhcmdldC5sID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuXHQgICAgICAgICAgICByaWdodFxuXHQgICAgICAgICAgICAgICAgPyBhZGRSYW5nZShyaWdodCwgZnJvbSwgdG8pXG5cdCAgICAgICAgICAgICAgICA6ICh0YXJnZXQuciA9IHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxLCBsOiBudWxsLCByOiBudWxsIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuXHQgICAgICAgICAgICB0YXJnZXQuZnJvbSA9IGZyb207XG5cdCAgICAgICAgICAgIHRhcmdldC5sID0gbnVsbDtcblx0ICAgICAgICAgICAgdGFyZ2V0LmQgPSByaWdodCA/IHJpZ2h0LmQgKyAxIDogMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcblx0ICAgICAgICAgICAgdGFyZ2V0LnRvID0gdG87XG5cdCAgICAgICAgICAgIHRhcmdldC5yID0gbnVsbDtcblx0ICAgICAgICAgICAgdGFyZ2V0LmQgPSB0YXJnZXQubCA/IHRhcmdldC5sLmQgKyAxIDogMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJpZ2h0V2FzQ3V0T2ZmID0gIXRhcmdldC5yO1xuXHQgICAgICAgIGlmIChsZWZ0ICYmICF0YXJnZXQubCkge1xuXHQgICAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIGxlZnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmlnaHQgJiYgcmlnaHRXYXNDdXRPZmYpIHtcblx0ICAgICAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0LCByaWdodCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbWVyZ2VSYW5nZXModGFyZ2V0LCBuZXdTZXQpIHtcblx0ICAgICAgICBmdW5jdGlvbiBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBfYSkge1xuXHQgICAgICAgICAgICB2YXIgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIGwgPSBfYS5sLCByID0gX2Eucjtcblx0ICAgICAgICAgICAgYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0byk7XG5cdCAgICAgICAgICAgIGlmIChsKVxuXHQgICAgICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbCk7XG5cdCAgICAgICAgICAgIGlmIChyKVxuXHQgICAgICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghaXNFbXB0eVJhbmdlKG5ld1NldCkpXG5cdCAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIG5ld1NldCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByYW5nZXNPdmVybGFwKHJhbmdlU2V0MSwgcmFuZ2VTZXQyKSB7XG5cdCAgICAgICAgdmFyIGkxID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDIpO1xuXHQgICAgICAgIHZhciBuZXh0UmVzdWx0MSA9IGkxLm5leHQoKTtcblx0ICAgICAgICBpZiAobmV4dFJlc3VsdDEuZG9uZSlcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHZhciBhID0gbmV4dFJlc3VsdDEudmFsdWU7XG5cdCAgICAgICAgdmFyIGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuXHQgICAgICAgIHZhciBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTtcblx0ICAgICAgICB2YXIgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuXHQgICAgICAgIHdoaWxlICghbmV4dFJlc3VsdDEuZG9uZSAmJiAhbmV4dFJlc3VsdDIuZG9uZSkge1xuXHQgICAgICAgICAgICBpZiAoY21wKGIuZnJvbSwgYS50bykgPD0gMCAmJiBjbXAoYi50bywgYS5mcm9tKSA+PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIGNtcChhLmZyb20sIGIuZnJvbSkgPCAwXG5cdCAgICAgICAgICAgICAgICA/IChhID0gKG5leHRSZXN1bHQxID0gaTEubmV4dChiLmZyb20pKS52YWx1ZSlcblx0ICAgICAgICAgICAgICAgIDogKGIgPSAobmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSkpLnZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0UmFuZ2VTZXRJdGVyYXRvcihub2RlKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubCAmJiBjbXAoa2V5LCBzdGF0ZS5uLmZyb20pIDwgMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleVByb3ZpZGVkIHx8IGNtcChrZXksIHN0YXRlLm4udG8pIDw9IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0YXRlLm4sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5uLnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLnIsIHM6IDAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS51cDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJlYmFsYW5jZSh0YXJnZXQpIHtcblx0ICAgICAgICB2YXIgX2EsIF9iO1xuXHQgICAgICAgIHZhciBkaWZmID0gKCgoX2EgPSB0YXJnZXQucikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmQpIHx8IDApIC0gKCgoX2IgPSB0YXJnZXQubCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmQpIHx8IDApO1xuXHQgICAgICAgIHZhciByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcblx0ICAgICAgICBpZiAocikge1xuXHQgICAgICAgICAgICB2YXIgbCA9IHIgPT09IFwiclwiID8gXCJsXCIgOiBcInJcIjtcblx0ICAgICAgICAgICAgdmFyIHJvb3RDbG9uZSA9IF9fYXNzaWduKHt9LCB0YXJnZXQpO1xuXHQgICAgICAgICAgICB2YXIgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdO1xuXHQgICAgICAgICAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuXHQgICAgICAgICAgICB0YXJnZXQudG8gPSBvbGRSb290UmlnaHQudG87XG5cdCAgICAgICAgICAgIHRhcmdldFtyXSA9IG9sZFJvb3RSaWdodFtyXTtcblx0ICAgICAgICAgICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuXHQgICAgICAgICAgICB0YXJnZXRbbF0gPSByb290Q2xvbmU7XG5cdCAgICAgICAgICAgIHJvb3RDbG9uZS5kID0gY29tcHV0ZURlcHRoKHJvb3RDbG9uZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjb21wdXRlRGVwdGgoX2EpIHtcblx0ICAgICAgICB2YXIgciA9IF9hLnIsIGwgPSBfYS5sO1xuXHQgICAgICAgIHJldHVybiAociA/IChsID8gTWF0aC5tYXgoci5kLCBsLmQpIDogci5kKSA6IGwgPyBsLmQgOiAwKSArIDE7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodGFyZ2V0LCBuZXdTZXQpIHtcblx0ICAgICAgICBrZXlzKG5ld1NldCkuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuXHQgICAgICAgICAgICBpZiAodGFyZ2V0W3BhcnRdKVxuXHQgICAgICAgICAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0W3BhcnRdLCBuZXdTZXRbcGFydF0pO1xuXHQgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICB0YXJnZXRbcGFydF0gPSBjbG9uZVNpbXBsZU9iamVjdFRyZWUobmV3U2V0W3BhcnRdKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGFyZ2V0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBvYnNTZXRzT3ZlcmxhcChvczEsIG9zMikge1xuXHQgICAgICAgIHJldHVybiBvczEuYWxsIHx8IG9zMi5hbGwgfHwgT2JqZWN0LmtleXMob3MxKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9zMltrZXldICYmIHJhbmdlc092ZXJsYXAob3MyW2tleV0sIG9zMVtrZXldKTsgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYWNoZSA9IHt9O1xuXG5cdCAgICB2YXIgdW5zaWduYWxlZFBhcnRzID0ge307XG5cdCAgICB2YXIgaXNUYXNrRW5xdWV1ZWQgPSBmYWxzZTtcblx0ICAgIGZ1bmN0aW9uIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHBhcnQsIG9wdGltaXN0aWMpIHtcblx0ICAgICAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHVuc2lnbmFsZWRQYXJ0cywgcGFydCk7XG5cdCAgICAgICAgaWYgKCFpc1Rhc2tFbnF1ZXVlZCkge1xuXHQgICAgICAgICAgICBpc1Rhc2tFbnF1ZXVlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgaXNUYXNrRW5xdWV1ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHVuc2lnbmFsZWRQYXJ0cztcblx0ICAgICAgICAgICAgICAgIHVuc2lnbmFsZWRQYXJ0cyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3cocGFydHMsIGZhbHNlKTtcblx0ICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gc2lnbmFsU3Vic2NyaWJlcnNOb3codXBkYXRlZFBhcnRzLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuXHQgICAgICAgIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyA9PT0gdm9pZCAwKSB7IGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzID0gZmFsc2U7IH1cblx0ICAgICAgICB2YXIgcXVlcmllc1RvU2lnbmFsID0gbmV3IFNldCgpO1xuXHQgICAgICAgIGlmICh1cGRhdGVkUGFydHMuYWxsKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QudmFsdWVzKGNhY2hlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IF9hW19pXTtcblx0ICAgICAgICAgICAgICAgIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKHRibENhY2hlLCB1cGRhdGVkUGFydHMsIHF1ZXJpZXNUb1NpZ25hbCwgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXBkYXRlZFBhcnRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSAvXmlkYlxcOlxcL1xcLyguKilcXC8oLiopXFwvLy5leGVjKGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFydHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGJOYW1lID0gcGFydHNbMV0sIHRhYmxlTmFtZSA9IHBhcnRzWzJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGJsQ2FjaGUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RUYWJsZVN1YnNjcmliZXJzKHRibENhY2hlLCB1cGRhdGVkUGFydHMsIHF1ZXJpZXNUb1NpZ25hbCwgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHF1ZXJpZXNUb1NpZ25hbC5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiByZXF1ZXJ5KCk7IH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgb3V0UXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuXHQgICAgICAgIHZhciB1cGRhdGVkRW50cnlMaXN0cyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyh0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5KTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBpbmRleE5hbWUgPSBfYlswXSwgZW50cmllcyA9IF9iWzFdO1xuXHQgICAgICAgICAgICB2YXIgZmlsdGVyZWRFbnRyaWVzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgZW50cmllc18xID0gZW50cmllczsgX2MgPCBlbnRyaWVzXzEubGVuZ3RoOyBfYysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzXzFbX2NdO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9ic1NldHNPdmVybGFwKHVwZGF0ZWRQYXJ0cywgZW50cnkub2JzU2V0KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIG91dFF1ZXJpZXNUb1NpZ25hbC5hZGQocmVxdWVyeSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEVudHJpZXMucHVzaChlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKVxuXHQgICAgICAgICAgICAgICAgdXBkYXRlZEVudHJ5TGlzdHMucHVzaChbaW5kZXhOYW1lLCBmaWx0ZXJlZEVudHJpZXNdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgdXBkYXRlZEVudHJ5TGlzdHNfMSA9IHVwZGF0ZWRFbnRyeUxpc3RzOyBfZCA8IHVwZGF0ZWRFbnRyeUxpc3RzXzEubGVuZ3RoOyBfZCsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2UgPSB1cGRhdGVkRW50cnlMaXN0c18xW19kXSwgaW5kZXhOYW1lID0gX2VbMF0sIGZpbHRlcmVkRW50cmllcyA9IF9lWzFdO1xuXHQgICAgICAgICAgICAgICAgdGJsQ2FjaGUucXVlcmllcy5xdWVyeVtpbmRleE5hbWVdID0gZmlsdGVyZWRFbnRyaWVzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBkZXhpZU9wZW4oZGIpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBkYi5fc3RhdGU7XG5cdCAgICAgICAgdmFyIGluZGV4ZWREQiA9IGRiLl9kZXBzLmluZGV4ZWREQjtcblx0ICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCB8fCBkYi5pZGJkYilcblx0ICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGUuZGJPcGVuRXJyb3IgP1xuXHQgICAgICAgICAgICAgICAgcmVqZWN0aW9uKHN0YXRlLmRiT3BlbkVycm9yKSA6XG5cdCAgICAgICAgICAgICAgICBkYjsgfSk7XG5cdCAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IHRydWU7XG5cdCAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuXHQgICAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcblx0ICAgICAgICB2YXIgbmF0aXZlVmVyVG9PcGVuID0gTWF0aC5yb3VuZChkYi52ZXJubyAqIDEwKTtcblx0ICAgICAgICB2YXIgc2NoZW1hUGF0Y2hNb2RlID0gZmFsc2U7XG5cdCAgICAgICAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZCgpIHtcblx0ICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5DYW5jZWxsZXIgIT09IG9wZW5DYW5jZWxsZXIpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc29sdmVEYlJlYWR5ID0gc3RhdGUuZGJSZWFkeVJlc29sdmUsXG5cdCAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbCwgd2FzQ3JlYXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciB0cnlPcGVuREIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuXHQgICAgICAgICAgICBpZiAoIWluZGV4ZWREQilcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcblx0ICAgICAgICAgICAgdmFyIGRiTmFtZSA9IGRiLm5hbWU7XG5cdCAgICAgICAgICAgIHZhciByZXEgPSBzdGF0ZS5hdXRvU2NoZW1hIHx8ICFuYXRpdmVWZXJUb09wZW4gP1xuXHQgICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG5cdCAgICAgICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUsIG5hdGl2ZVZlclRvT3Blbik7XG5cdCAgICAgICAgICAgIGlmICghcmVxKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuXHQgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICByZXEub25ibG9ja2VkID0gd3JhcChkYi5fZmlyZU9uQmxvY2tlZCk7XG5cdCAgICAgICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSB3cmFwKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSAmJiAhZGIuX29wdGlvbnMuYWxsb3dFbXB0eURCKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBwcmV2ZW50RGVmYXVsdDtcblx0ICAgICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEucmVzdWx0LmNsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuTm9TdWNoRGF0YWJhc2UoXCJEYXRhYmFzZSBcIi5jb25jYXQoZGJOYW1lLCBcIiBkb2VzbnQgZXhpc3RcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZlciA9IGUub2xkVmVyc2lvbiA+IE1hdGgucG93KDIsIDYyKSA/IDAgOiBlLm9sZFZlcnNpb247XG5cdCAgICAgICAgICAgICAgICAgICAgd2FzQ3JlYXRlZCA9IG9sZFZlciA8IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIgPSByZXEucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQYXRjaE1vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hDdXJyZW50VmVyc2lvbihkYiwgdXBncmFkZVRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcnVuVXBncmFkZXJzKGRiLCBvbGRWZXIgLyAxMCwgdXBncmFkZVRyYW5zYWN0aW9uLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LCByZWplY3QpO1xuXHQgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkYmRiID0gZGIuaWRiZGIgPSByZXEucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmplY3RTdG9yZU5hbWVzLmxlbmd0aCA+IDApXG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChvYmplY3RTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCB0bXBUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpICYmICFzY2hlbWFQYXRjaE1vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXhpZSBTY2hlbWFEaWZmOiBTY2hlbWEgd2FzIGV4dGVuZGVkIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHBhc3NlZCB0byBkYi52ZXJzaW9uKCkuIERleGllIHdpbGwgYWRkIG1pc3NpbmcgcGFydHMgYW5kIGluY3JlbWVudCBuYXRpdmUgdmVyc2lvbiBudW1iZXIgdG8gd29ya2Fyb3VuZCB0aGlzLlwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGJkYi5jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVZlclRvT3BlbiA9IGlkYmRiLnZlcnNpb24gKyAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVBhdGNoTW9kZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ5T3BlbkRCKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgdG1wVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpO1xuXHQgICAgICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS52Y0ZpcmVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBkYi5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGlkYmRiLm9uY2xvc2UgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGlmICh3YXNDcmVhdGVkKVxuXHQgICAgICAgICAgICAgICAgICAgIF9vbkRhdGFiYXNlQ3JlYXRlZChkYi5fZGVwcywgZGJOYW1lKTtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgfSwgcmVqZWN0KTtcblx0ICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JcIjpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLlBSMTM5OF9tYXhMb29wLS07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IFdvcmthcm91bmQgZm9yIENocm9tZSBVbmtub3duRXJyb3Igb24gb3BlbigpJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlPcGVuREIoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiVmVyc2lvbkVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVZlclRvT3BlbiA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlVmVyVG9PcGVuID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgIH0pOyB9O1xuXHQgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmFjZShbXG5cdCAgICAgICAgICAgIG9wZW5DYW5jZWxsZXIsXG5cdCAgICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IERleGllUHJvbWlzZS5yZXNvbHZlKCkgOiBpZGJSZWFkeSgpKS50aGVuKHRyeU9wZW5EQilcblx0ICAgICAgICBdKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuXHQgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuXHQgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLm9uLnJlYWR5LmZpcmUoZGIudmlwKTsgfSkpLnRoZW4oZnVuY3Rpb24gZmlyZVJlbWFpbmRlcnMoKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXJzXzEgPSBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcChmdW5jdGlvbiAoKSB7IHJldHVybiByZW1haW5kZXJzXzEoZGIudmlwKTsgfSkpLnRoZW4oZmlyZVJlbWFpbmRlcnMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5DYW5jZWxsZXIgPT09IG9wZW5DYW5jZWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBlcnI7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cblx0ICAgICAgICAgICAgaWYgKG9wZW5DYW5jZWxsZXIgPT09IHN0YXRlLm9wZW5DYW5jZWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgIGRiLl9jbG9zZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcblx0ICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTtcblx0ICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVyeXRoaW5nXzEgPSB7fTtcblx0ICAgICAgICAgICAgICAgIGRiLnRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhYmxlLnNjaGVtYS5pbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4Lm5hbWUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi9cIikuY29uY2F0KGlkeC5uYW1lKV0gPSBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW1tdXV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZXJ5dGhpbmdfMVtcImlkYjovL1wiLmNvbmNhdChkYi5uYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlLm5hbWUsIFwiL1wiKV0gPSBldmVyeXRoaW5nXzFbXCJpZGI6Ly9cIi5jb25jYXQoZGIubmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZS5uYW1lLCBcIi86ZGVsc1wiKV0gPSBuZXcgUmFuZ2VTZXQoLUluZmluaXR5LCBbW1tdXV0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpLmZpcmUoZXZlcnl0aGluZ18xKTtcblx0ICAgICAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KGV2ZXJ5dGhpbmdfMSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGRiO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhd2FpdEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG5cdCAgICAgICAgdmFyIGNhbGxOZXh0ID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gaXRlcmF0b3IubmV4dChyZXN1bHQpOyB9LCBkb1Rocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpdGVyYXRvci50aHJvdyhlcnJvcik7IH0sIG9uU3VjY2VzcyA9IHN0ZXAoY2FsbE5leHQpLCBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKGdldE5leHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLCB2YWx1ZSA9IG5leHQudmFsdWU7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5kb25lID8gdmFsdWUgOlxuXHQgICAgICAgICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpc0FycmF5KHZhbHVlKSA/IFByb21pc2UuYWxsKHZhbHVlKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikgOiBvblN1Y2Nlc3ModmFsdWUpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0ZXAoY2FsbE5leHQpKCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuXHQgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICAgICAgICBpZiAoaSA8IDIpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuXHQgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcblx0ICAgICAgICB3aGlsZSAoLS1pKVxuXHQgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuXHQgICAgICAgIHZhciB0YWJsZXMgPSBmbGF0dGVuKGFyZ3MpO1xuXHQgICAgICAgIHJldHVybiBbbW9kZSwgdGFibGVzLCBzY29wZUZ1bmNdO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0cmFuc2xlc3MgPSBQU0QudHJhbnNsZXNzIHx8IFBTRDtcblx0ICAgICAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICB0cmFucy5leHBsaWNpdCA9IHRydWU7XG5cdCAgICAgICAgICAgIHZhciB6b25lUHJvcHMgPSB7XG5cdCAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICB0cmFuc2xlc3M6IHRyYW5zbGVzc1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLl9leHBsaWNpdCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgbnVsbCwgc2NvcGVGdW5jKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHNjb3BlRnVuYyk7XG5cdCAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZTtcblx0ICAgICAgICAgICAgdmFyIHByb21pc2VGb2xsb3dlZCA9IERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBzY29wZUZ1bmMuY2FsbCh0cmFucywgdHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIHpvbmVQcm9wcyk7XG5cdCAgICAgICAgICAgIHJldHVybiAocmV0dXJuVmFsdWUgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuXHQgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpLnRoZW4oZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRyYW5zLmFjdGl2ZSA/XG5cdCAgICAgICAgICAgICAgICAgICAgeFxuXHQgICAgICAgICAgICAgICAgICAgIDogcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlByZW1hdHVyZUNvbW1pdChcIlRyYW5zYWN0aW9uIGNvbW1pdHRlZCB0b28gZWFybHkuIFNlZSBodHRwOi8vYml0Lmx5LzJrZGNrTW5cIikpOyB9KVxuXHQgICAgICAgICAgICAgICAgOiBwcm9taXNlRm9sbG93ZWQudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXR1cm5WYWx1ZTsgfSkpLnRoZW4oZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbilcblx0ICAgICAgICAgICAgICAgICAgICB0cmFucy5fcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG5cdCAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0cmFucy5fcmVqZWN0KGUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHBhZChhLCB2YWx1ZSwgY291bnQpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gaXNBcnJheShhKSA/IGEuc2xpY2UoKSA6IFthXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpXG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZShkb3duKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duKSwgeyB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gZG93bi50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleExvb2t1cCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgdmFyIGFsbFZpcnR1YWxJbmRleGVzID0gW107XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRWaXJ0dWFsSW5kZXhlcyhrZXlQYXRoLCBrZXlUYWlsLCBsb3dMZXZlbEluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGhBbGlhcyA9IGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhMaXN0ID0gKGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gPSBpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdIHx8IFtdKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5TGVuZ3RoID0ga2V5UGF0aCA9PSBudWxsID8gMCA6IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IDEgOiBrZXlQYXRoLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXNWaXJ0dWFsID0ga2V5VGFpbCA+IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxJbmRleCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsb3dMZXZlbEluZGV4KSwgeyBuYW1lOiBpc1ZpcnR1YWxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIi5jb25jYXQoa2V5UGF0aEFsaWFzLCBcIih2aXJ0dWFsLWZyb206XCIpLmNvbmNhdChsb3dMZXZlbEluZGV4Lm5hbWUsIFwiKVwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb3dMZXZlbEluZGV4Lm5hbWUsIGxvd0xldmVsSW5kZXg6IGxvd0xldmVsSW5kZXgsIGlzVmlydHVhbDogaXNWaXJ0dWFsLCBrZXlUYWlsOiBrZXlUYWlsLCBrZXlMZW5ndGg6IGtleUxlbmd0aCwgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpLCB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWUgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhMaXN0LnB1c2godmlydHVhbEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXZpcnR1YWxJbmRleC5pc1ByaW1hcnlLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWxsVmlydHVhbEluZGV4ZXMucHVzaCh2aXJ0dWFsSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyh2aXJ0dWFsS2V5UGF0aCwga2V5VGFpbCArIDEsIGxvd0xldmVsSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpbmRleExpc3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEluZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzY2hlbWEuaW5kZXhlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfYVtfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgYWRkVmlydHVhbEluZGV4ZXMoaW5kZXgua2V5UGF0aCwgMCwgaW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluZGV4TG9va3VwW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbMF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSYW5nZShyYW5nZSwga2V5VGFpbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJhbmdlLnR5cGUgPT09IDEgID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnR5cGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyOiBwYWQocmFuZ2UubG93ZXIsIHJhbmdlLmxvd2VyT3BlbiA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyT3BlbjogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXI6IHBhZChyYW5nZS51cHBlciwgcmFuZ2UudXBwZXJPcGVuID8gZG93bi5NSU5fS0VZIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJPcGVuOiB0cnVlXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5pc1ZpcnR1YWwgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyBxdWVyeToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4Lmxvd0xldmVsSW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IH0pIDogcmVxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgc2NoZW1hOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2NoZW1hKSwgeyBwcmltYXJ5S2V5OiBwcmltYXJ5S2V5LCBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcywgZ2V0SW5kZXhCeUtleVBhdGg6IGZpbmRCZXN0SW5kZXggfSksIGNvdW50OiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5jb3VudCh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5OiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5xdWVyeSh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sIG9wZW5DdXJzb3I6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVxLnF1ZXJ5LmluZGV4LCBrZXlUYWlsID0gX2Eua2V5VGFpbCwgaXNWaXJ0dWFsID0gX2EuaXNWaXJ0dWFsLCBrZXlMZW5ndGggPSBfYS5rZXlMZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWaXJ0dWFsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jb250aW51ZShrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShwYWQoa2V5LCByZXEucmV2ZXJzZSA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCkpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnVuaXF1ZSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoY3Vyc29yLmtleS5zbGljZSgwLCBrZXlMZW5ndGgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXEucmV2ZXJzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZG93bi5NSU5fS0VZXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXJ0dWFsQ3Vyc29yID0gT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogeyB2YWx1ZTogX2NvbnRpbnVlIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVQcmltYXJ5S2V5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCBwcmltYXJ5S2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5KHBhZChrZXksIGRvd24uTUFYX0tFWSwga2V5VGFpbCksIHByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVswXSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNsaWNlKDAsIGtleUxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxDdXJzb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGN1cnNvcikgeyByZXR1cm4gY3Vyc29yICYmIGNyZWF0ZVZpcnR1YWxDdXJzb3IoY3Vyc29yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH0gfSk7XG5cdCAgICB9XG5cdCAgICB2YXIgdmlydHVhbEluZGV4TWlkZGxld2FyZSA9IHtcblx0ICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcblx0ICAgICAgICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcblx0ICAgICAgICBsZXZlbDogMSxcblx0ICAgICAgICBjcmVhdGU6IGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmVcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGdldE9iamVjdERpZmYoYSwgYiwgcnYsIHByZngpIHtcblx0ICAgICAgICBydiA9IHJ2IHx8IHt9O1xuXHQgICAgICAgIHByZnggPSBwcmZ4IHx8ICcnO1xuXHQgICAgICAgIGtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuXHQgICAgICAgICAgICBpZiAoIWhhc093bihiLCBwcm9wKSkge1xuXHQgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFwID0gYVtwcm9wXSwgYnAgPSBiW3Byb3BdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJiBhcCAmJiBicCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhcFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYXApO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBicFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYnApO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhcFR5cGVOYW1lICE9PSBicFR5cGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldE9iamVjdERpZmYoYXAsIGJwLCBydiwgcHJmeCArIHByb3AgKyAnLicpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApXG5cdCAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGtleXMoYikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuXHQgICAgICAgICAgICBpZiAoIWhhc093bihhLCBwcm9wKSkge1xuXHQgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpIHtcblx0ICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKVxuXHQgICAgICAgICAgICByZXR1cm4gcmVxLmtleXM7XG5cdCAgICAgICAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBob29rc01pZGRsZXdhcmUgPSB7XG5cdCAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG5cdCAgICAgICAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcblx0ICAgICAgICBsZXZlbDogMixcblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChkb3duQ29yZSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb3duQ29yZSksIHsgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkb3duVGFibGUgPSBkb3duQ29yZS50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBkb3duVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGFibGVNaWRkbGV3YXJlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25UYWJsZSksIHsgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeFRyYW5zID0gUFNELnRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBkeFRyYW5zLnRhYmxlKHRhYmxlTmFtZSkuaG9vaywgZGVsZXRpbmcgPSBfYS5kZWxldGluZywgY3JlYXRpbmcgPSBfYS5jcmVhdGluZywgdXBkYXRpbmcgPSBfYS51cGRhdGluZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXEudHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkUHV0T3JEZWxldGUocmVxKTsgfSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkUHV0T3JEZWxldGUocmVxKTsgfSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsZXRlUmFuZ2UocmVxKTsgfSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkUHV0T3JEZWxldGUocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHhUcmFucyA9IFBTRC50cmFucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gcmVxLmtleXMgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVxKSwgeyBrZXlzOiBrZXlzIH0pIDogX19hc3NpZ24oe30sIHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXMgPSBfX3NwcmVhZEFycmF5KFtdLCByZXEudmFsdWVzLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEua2V5cylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5cyA9IF9fc3ByZWFkQXJyYXkoW10sIHJlcS5rZXlzLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFeGlzdGluZ1ZhbHVlcyhkb3duVGFibGUsIHJlcSwga2V5cykudGhlbihmdW5jdGlvbiAoZXhpc3RpbmdWYWx1ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gZXhpc3RpbmdWYWx1ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGluZy5maXJlLmNhbGwoY3R4LCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcS50eXBlID09PSAnYWRkJyB8fCBleGlzdGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW5lcmF0ZWRQcmltYXJ5S2V5ID0gY3JlYXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCByZXEudmFsdWVzW2ldLCBkeFRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCAmJiBnZW5lcmF0ZWRQcmltYXJ5S2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5rZXlzW2ldID0ga2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJpbWFyeUtleS5vdXRib3VuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxLnZhbHVlc1tpXSwgcHJpbWFyeUtleS5rZXlQYXRoLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3REaWZmID0gZ2V0T2JqZWN0RGlmZihleGlzdGluZ1ZhbHVlLCByZXEudmFsdWVzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsQ2hhbmdlc18xID0gdXBkYXRpbmcuZmlyZS5jYWxsKGN0eCwgb2JqZWN0RGlmZiwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlc18xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFZhbHVlXzEgPSByZXEudmFsdWVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxDaGFuZ2VzXzEpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihyZXF1ZXN0ZWRWYWx1ZV8xLCBrZXlQYXRoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkVmFsdWVfMVtrZXlQYXRoXSA9IGFkZGl0aW9uYWxDaGFuZ2VzXzFba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxdWVzdGVkVmFsdWVfMSwga2V5UGF0aCwgYWRkaXRpb25hbENoYW5nZXNfMVtrZXlQYXRoXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gX2EuZmFpbHVyZXMsIHJlc3VsdHMgPSBfYS5yZXN1bHRzLCBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MocmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1tpXSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBmYWlsdXJlcywgcmVzdWx0czogcmVzdWx0cywgbnVtRmFpbHVyZXM6IG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGN0eCkgeyByZXR1cm4gY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZXJyb3IpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayhyZXEudHJhbnMsIHJlcS5yYW5nZSwgMTAwMDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFucywgcmFuZ2UsIGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHsgdHJhbnM6IHRyYW5zLCB2YWx1ZXM6IGZhbHNlLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IHJhbmdlIH0sIGxpbWl0OiBsaW1pdCB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfYS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHsgdHlwZTogJ2RlbGV0ZScsIGtleXM6IHJlc3VsdCwgdHJhbnM6IHRyYW5zIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWQgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsodHJhbnMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCByYW5nZSksIHsgbG93ZXI6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxvd2VyT3BlbjogdHJ1ZSB9KSwgbGltaXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNaWRkbGV3YXJlO1xuXHQgICAgICAgICAgICB9IH0pKTsgfVxuXHQgICAgfTtcblx0ICAgIGZ1bmN0aW9uIGdldEV4aXN0aW5nVmFsdWVzKHRhYmxlLCByZXEsIGVmZmVjdGl2ZUtleXMpIHtcblx0ICAgICAgICByZXR1cm4gcmVxLnR5cGUgPT09IFwiYWRkXCJcblx0ICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoW10pXG5cdCAgICAgICAgICAgIDogdGFibGUuZ2V0TWFueSh7IHRyYW5zOiByZXEudHJhbnMsIGtleXM6IGVmZmVjdGl2ZUtleXMsIGNhY2hlOiBcImltbXV0YWJsZVwiIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShrZXlzLCBjYWNoZSwgY2xvbmUpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBpZiAoIWNhY2hlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgY2FjaGUua2V5cy5sZW5ndGggJiYgaiA8IGtleXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjbXAoY2FjaGUua2V5c1tpXSwga2V5c1tqXSkgIT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZSA/IGRlZXBDbG9uZShjYWNoZS52YWx1ZXNbaV0pIDogY2FjaGUudmFsdWVzW2ldKTtcblx0ICAgICAgICAgICAgICAgICsrajtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoX2EpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlID0ge1xuXHQgICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuXHQgICAgICAgIGxldmVsOiAtMSxcblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBnZXRNYW55OiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUocmVxLmtleXMsIHJlcS50cmFuc1tcIl9jYWNoZVwiXSwgcmVxLmNhY2hlID09PSBcImNsb25lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShjYWNoZWRSZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHJlcS5rZXlzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiID8gZGVlcENsb25lKHJlcykgOiByZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSBcImFkZFwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBpc0NhY2hhYmxlQ29udGV4dChjdHgsIHRhYmxlKSB7XG5cdCAgICAgICAgcmV0dXJuIChjdHgudHJhbnMubW9kZSA9PT0gJ3JlYWRvbmx5JyAmJlxuXHQgICAgICAgICAgICAhIWN0eC5zdWJzY3IgJiZcblx0ICAgICAgICAgICAgIWN0eC50cmFucy5leHBsaWNpdCAmJlxuXHQgICAgICAgICAgICBjdHgudHJhbnMuZGIuX29wdGlvbnMuY2FjaGUgIT09ICdkaXNhYmxlZCcgJiZcblx0ICAgICAgICAgICAgIXRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5Lm91dGJvdW5kKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaXNDYWNoYWJsZVJlcXVlc3QodHlwZSwgcmVxKSB7XG5cdCAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ3F1ZXJ5Jzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXEudmFsdWVzICYmICFyZXEudW5pcXVlO1xuXHQgICAgICAgICAgICBjYXNlICdnZXQnOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICBjYXNlICdnZXRNYW55Jzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgY2FzZSAnY291bnQnOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICBjYXNlICdvcGVuQ3Vyc29yJzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSA9IHtcblx0ICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcblx0ICAgICAgICBsZXZlbDogMCxcblx0ICAgICAgICBuYW1lOiBcIk9ic2VydmFiaWxpdHlcIixcblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG5cdCAgICAgICAgICAgIHZhciBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuXHQgICAgICAgICAgICB2YXIgRlVMTF9SQU5HRSA9IG5ldyBSYW5nZVNldChjb3JlLk1JTl9LRVksIGNvcmUuTUFYX0tFWSk7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29yZSksIHsgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzdG9yZXMsIG1vZGUsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoUFNELnN1YnNjciAmJiBtb2RlICE9PSAncmVhZG9ubHknKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlJlYWRPbmx5KFwiUmVhZHdyaXRlIHRyYW5zYWN0aW9uIGluIGxpdmVRdWVyeSBjb250ZXh0LiBRdWVyaWVyIHNvdXJjZTogXCIuY29uY2F0KFBTRC5xdWVyaWVyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLnRyYW5zYWN0aW9uKHN0b3JlcywgbW9kZSwgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICB9LCB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gc2NoZW1hLnByaW1hcnlLZXksIGluZGV4ZXMgPSBzY2hlbWEuaW5kZXhlcztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdEtleSA9IHByaW1hcnlLZXkuZXh0cmFjdEtleSwgb3V0Ym91bmQgPSBwcmltYXJ5S2V5Lm91dGJvdW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzV2l0aEF1dG9JbmNQSyA9IHByaW1hcnlLZXkuYXV0b0luY3JlbWVudCAmJiBpbmRleGVzLmZpbHRlcihmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGluZGV4LmNvbXBvdW5kICYmIGluZGV4LmtleVBhdGguaW5jbHVkZXMocHJpbWFyeUtleS5rZXlQYXRoKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlQ2xvbmUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IG11dGF0ZTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gcmVxLnRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRQYXJ0cyA9IHJlcS5tdXRhdGVkUGFydHMgfHwgKHJlcS5tdXRhdGVkUGFydHMgPSB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmFuZ2VTZXQgPSBmdW5jdGlvbiAoaW5kZXhOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lLCBcIi9cIikuY29uY2F0KGluZGV4TmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtdXRhdGVkUGFydHNbcGFydF0gfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxzUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSByZXEudHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlcS50eXBlID09PSBcImRlbGV0ZVJhbmdlXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudHlwZSA9PT0gXCJkZWxldGVcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEua2V5c11cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSkuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQ7IH0pLCByZXEudmFsdWVzXVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSwga2V5cyA9IF9hWzBdLCBuZXdPYmpzID0gX2FbMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShrZXlzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkT2JqcyA9IHR5cGUgPT09ICdkZWxldGUnIHx8IGtleXMubGVuZ3RoID09PSBuZXdPYmpzLmxlbmd0aCA/IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKSA6IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRPYmpzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkT2JqcyB8fCBuZXdPYmpzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrQWZmZWN0ZWRJbmRleGVzKGdldFJhbmdlU2V0LCBzY2hlbWEsIG9sZE9ianMsIG5ld09ianMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7IGZyb206IGtleXMubG93ZXIsIHRvOiBrZXlzLnVwcGVyIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChyYW5nZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQocmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGdldFJhbmdlU2V0KGlkeC5uYW1lKS5hZGQoRlVMTF9SQU5HRSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMocmVzLnJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhlc1dpdGhBdXRvSW5jUEspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNXaXRoQXV0b0luY1BLLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHhWYWxzID0gcmVxLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGlkeC5leHRyYWN0S2V5KHYpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtQb3MgPSBpZHgua2V5UGF0aC5maW5kSW5kZXgoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AgPT09IHByaW1hcnlLZXkua2V5UGF0aDsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocGspIHsgcmV0dXJuIGlkeFZhbHNbcGtQb3NdID0gcGs7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KGlkeC5uYW1lKS5hZGRLZXlzKGlkeFZhbHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMubXV0YXRlZFBhcnRzID0gZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCh0cmFucy5tdXRhdGVkUGFydHMgfHwge30sIG11dGF0ZWRQYXJ0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZSA9IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2QgPSBfYS5xdWVyeSwgaW5kZXggPSBfZC5pbmRleCwgcmFuZ2UgPSBfZC5yYW5nZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlU2V0KChfYiA9IHJhbmdlLmxvd2VyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb3JlLk1JTl9LRVksIChfYyA9IHJhbmdlLnVwcGVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb3JlLk1BWF9LRVkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRTdWJzY3JpYmVycyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAocmVxKSB7IHJldHVybiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KHJlcS5rZXkpXTsgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldCgpLmFkZEtleXMocmVxLmtleXMpXTsgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGdldFJhbmdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZ2V0UmFuZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5DdXJzb3I6IGdldFJhbmdlLFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAga2V5cyhyZWFkU3Vic2NyaWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsb25lW21ldGhvZF0gPSBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyID0gUFNELnN1YnNjcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0xpdmVRdWVyeSA9ICEhc3Vic2NyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hhYmxlID0gaXNDYWNoYWJsZUNvbnRleHQoUFNELCB0YWJsZSkgJiYgaXNDYWNoYWJsZVJlcXVlc3QobWV0aG9kLCByZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ic1NldCA9IGNhY2hhYmxlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXEub2JzU2V0ID0ge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN1YnNjcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpdmVRdWVyeSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZVNldCA9IGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lLCBcIi9cIikuY29uY2F0KGluZGV4TmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob2JzU2V0W3BhcnRdIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob2JzU2V0W3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwa1JhbmdlU2V0XzEgPSBnZXRSYW5nZVNldChcIlwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsc1JhbmdlU2V0XzEgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHJlYWRTdWJzY3JpYmVyc1ttZXRob2RdKHJlcSksIHF1ZXJpZWRJbmRleCA9IF9hWzBdLCBxdWVyaWVkUmFuZ2VzID0gX2FbMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3F1ZXJ5JyAmJiBxdWVyaWVkSW5kZXguaXNQcmltYXJ5S2V5ICYmICFyZXEudmFsdWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZChxdWVyaWVkUmFuZ2VzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJhbmdlU2V0KHF1ZXJpZWRJbmRleC5uYW1lIHx8IFwiXCIpLmFkZChxdWVyaWVkUmFuZ2VzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyaWVkSW5kZXguaXNQcmltYXJ5S2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkKEZVTExfUkFOR0UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNQcm9taXNlXzEgPSBtZXRob2QgPT09IFwicXVlcnlcIiAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnF1ZXJ5KF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHZhbHVlczogZmFsc2UgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHJlcS52YWx1ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzUHJvbWlzZV8xLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdGluZ0tleXMgPSBfYS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldF8xLmFkZEtleXMocmVzdWx0aW5nS2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwS2V5cyA9IHJlcS52YWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzLnJlc3VsdC5tYXAoZXh0cmFjdEtleSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS52YWx1ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXRfMS5hZGRLZXlzKHBLZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleXMocEtleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvcl8xID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2FudFZhbHVlc18xID0gcmVxLnZhbHVlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjdXJzb3JfMSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjdXJzb3JfMSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldF8xLmFkZEtleShjdXJzb3JfMS5wcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3JfMS5rZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrZXkgPSBjdXJzb3JfMS5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkS2V5KHBrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbnRWYWx1ZXNfMSAmJiBwa1JhbmdlU2V0XzEuYWRkS2V5KGN1cnNvcl8xLnByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcl8xLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlQ2xvbmU7XG5cdCAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcykge1xuXHQgICAgICAgIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXgpIHtcblx0ICAgICAgICAgICAgdmFyIHJhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoaXgubmFtZSB8fCBcIlwiKTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gZXh0cmFjdEtleShvYmopIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGFkZEtleU9yS2V5cyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGl4Lm11bHRpRW50cnkgJiYgaXNBcnJheShrZXkpXG5cdCAgICAgICAgICAgICAgICA/IGtleS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHJhbmdlU2V0LmFkZEtleShrZXkpOyB9KVxuXHQgICAgICAgICAgICAgICAgOiByYW5nZVNldC5hZGRLZXkoa2V5KTsgfTtcblx0ICAgICAgICAgICAgKG9sZE9ianMgfHwgbmV3T2JqcykuZm9yRWFjaChmdW5jdGlvbiAoXywgaSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9sZEtleSA9IG9sZE9ianMgJiYgZXh0cmFjdEtleShvbGRPYmpzW2ldKTtcblx0ICAgICAgICAgICAgICAgIHZhciBuZXdLZXkgPSBuZXdPYmpzICYmIGV4dHJhY3RLZXkobmV3T2Jqc1tpXSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY21wKG9sZEtleSwgbmV3S2V5KSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5T3JLZXlzKG9sZEtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0tleSAhPSBudWxsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMobmV3S2V5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goYWRkQWZmZWN0ZWRJbmRleCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcSwgcmVzKSB7XG5cdCAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gMClcblx0ICAgICAgICAgICAgcmV0dXJuIHJlcTtcblx0ICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBudW1CdWxrT3BzID0gcmVxLmtleXNcblx0ICAgICAgICAgICAgPyByZXEua2V5cy5sZW5ndGhcblx0ICAgICAgICAgICAgOiAndmFsdWVzJyBpbiByZXEgJiYgcmVxLnZhbHVlc1xuXHQgICAgICAgICAgICAgICAgPyByZXEudmFsdWVzLmxlbmd0aFxuXHQgICAgICAgICAgICAgICAgOiAxO1xuXHQgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPT09IG51bUJ1bGtPcHMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjbG9uZSA9IF9fYXNzaWduKHt9LCByZXEpO1xuXHQgICAgICAgIGlmIChpc0FycmF5KGNsb25lLmtleXMpKSB7XG5cdCAgICAgICAgICAgIGNsb25lLmtleXMgPSBjbG9uZS5rZXlzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gIShpIGluIHJlcy5mYWlsdXJlcyk7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoJ3ZhbHVlcycgaW4gY2xvbmUgJiYgaXNBcnJheShjbG9uZS52YWx1ZXMpKSB7XG5cdCAgICAgICAgICAgIGNsb25lLnZhbHVlcyA9IGNsb25lLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICEoaSBpbiByZXMuZmFpbHVyZXMpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBpc0Fib3ZlTG93ZXIoa2V5LCByYW5nZSkge1xuXHQgICAgICAgIHJldHVybiByYW5nZS5sb3dlciA9PT0gdW5kZWZpbmVkXG5cdCAgICAgICAgICAgID8gdHJ1ZVxuXHQgICAgICAgICAgICA6IHJhbmdlLmxvd2VyT3BlblxuXHQgICAgICAgICAgICAgICAgPyBjbXAoa2V5LCByYW5nZS5sb3dlcikgPiAwXG5cdCAgICAgICAgICAgICAgICA6IGNtcChrZXksIHJhbmdlLmxvd2VyKSA+PSAwO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaXNCZWxvd1VwcGVyKGtleSwgcmFuZ2UpIHtcblx0ICAgICAgICByZXR1cm4gcmFuZ2UudXBwZXIgPT09IHVuZGVmaW5lZFxuXHQgICAgICAgICAgICA/IHRydWVcblx0ICAgICAgICAgICAgOiByYW5nZS51cHBlck9wZW5cblx0ICAgICAgICAgICAgICAgID8gY21wKGtleSwgcmFuZ2UudXBwZXIpIDwgMFxuXHQgICAgICAgICAgICAgICAgOiBjbXAoa2V5LCByYW5nZS51cHBlcikgPD0gMDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGlzV2l0aGluUmFuZ2Uoa2V5LCByYW5nZSkge1xuXHQgICAgICAgIHJldHVybiBpc0Fib3ZlTG93ZXIoa2V5LCByYW5nZSkgJiYgaXNCZWxvd1VwcGVyKGtleSwgcmFuZ2UpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhcHBseU9wdGltaXN0aWNPcHMocmVzdWx0LCByZXEsIG9wcywgdGFibGUsIGNhY2hlRW50cnksIGltbXV0YWJsZSkge1xuXHQgICAgICAgIGlmICghb3BzIHx8IG9wcy5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4O1xuXHQgICAgICAgIHZhciBtdWx0aUVudHJ5ID0gaW5kZXgubXVsdGlFbnRyeTtcblx0ICAgICAgICB2YXIgcXVlcnlSYW5nZSA9IHJlcS5xdWVyeS5yYW5nZTtcblx0ICAgICAgICB2YXIgcHJpbWFyeUtleSA9IHRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuXHQgICAgICAgIHZhciBleHRyYWN0UHJpbUtleSA9IHByaW1hcnlLZXkuZXh0cmFjdEtleTtcblx0ICAgICAgICB2YXIgZXh0cmFjdEluZGV4ID0gaW5kZXguZXh0cmFjdEtleTtcblx0ICAgICAgICB2YXIgZXh0cmFjdExvd0xldmVsSW5kZXggPSAoaW5kZXgubG93TGV2ZWxJbmRleCB8fCBpbmRleCkuZXh0cmFjdEtleTtcblx0ICAgICAgICB2YXIgZmluYWxSZXN1bHQgPSBvcHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG9wKSB7XG5cdCAgICAgICAgICAgIHZhciBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0O1xuXHQgICAgICAgICAgICB2YXIgaW5jbHVkZWRWYWx1ZXMgPSBbXTtcblx0ICAgICAgICAgICAgaWYgKG9wLnR5cGUgPT09ICdhZGQnIHx8IG9wLnR5cGUgPT09ICdwdXQnKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZWRQS3MgPSBuZXcgUmFuZ2VTZXQoKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcC52YWx1ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvcC52YWx1ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBrID0gZXh0cmFjdFByaW1LZXkodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlZFBLcy5oYXNLZXkocGspKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZXh0cmFjdEluZGV4KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgPyBrZXkuc29tZShmdW5jdGlvbiAoaykgeyByZXR1cm4gaXNXaXRoaW5SYW5nZShrLCBxdWVyeVJhbmdlKTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBpc1dpdGhpblJhbmdlKGtleSwgcXVlcnlSYW5nZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRQS3MuYWRkS2V5KHBrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcblx0ICAgICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0LmNvbmNhdChyZXEudmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gaW5jbHVkZWRWYWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlZFZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXlTZXRfMSA9IG5ldyBSYW5nZVNldCgpLmFkZEtleXMob3AudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RpZmVkUmVzdWx0ID0gcmVzdWx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFrZXlTZXRfMS5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoXG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IGluY2x1ZGVkVmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jbHVkZWRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5c1RvRGVsZXRlXzEgPSBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKG9wLmtleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAha2V5c1RvRGVsZXRlXzEuaGFzS2V5KHJlcS52YWx1ZXMgPyBleHRyYWN0UHJpbUtleShpdGVtKSA6IGl0ZW0pOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2VfMSA9IG9wLnJhbmdlO1xuXHQgICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhaXNXaXRoaW5SYW5nZShleHRyYWN0UHJpbUtleShpdGVtKSwgcmFuZ2VfMSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBtb2RpZmVkUmVzdWx0O1xuXHQgICAgICAgIH0sIHJlc3VsdCk7XG5cdCAgICAgICAgaWYgKGZpbmFsUmVzdWx0ID09PSByZXN1bHQpXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgZmluYWxSZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgICAgICByZXR1cm4gY21wKGV4dHJhY3RMb3dMZXZlbEluZGV4KGEpLCBleHRyYWN0TG93TGV2ZWxJbmRleChiKSkgfHxcblx0ICAgICAgICAgICAgICAgIGNtcChleHRyYWN0UHJpbUtleShhKSwgZXh0cmFjdFByaW1LZXkoYikpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmIChyZXEubGltaXQgJiYgcmVxLmxpbWl0IDwgSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgaWYgKGZpbmFsUmVzdWx0Lmxlbmd0aCA+IHJlcS5saW1pdCkge1xuXHQgICAgICAgICAgICAgICAgZmluYWxSZXN1bHQubGVuZ3RoID0gcmVxLmxpbWl0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPT09IHJlcS5saW1pdCAmJiBmaW5hbFJlc3VsdC5sZW5ndGggPCByZXEubGltaXQpIHtcblx0ICAgICAgICAgICAgICAgIGNhY2hlRW50cnkuZGlydHkgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBpbW11dGFibGUgPyBPYmplY3QuZnJlZXplKGZpbmFsUmVzdWx0KSA6IGZpbmFsUmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhcmVSYW5nZXNFcXVhbChyMSwgcjIpIHtcblx0ICAgICAgICByZXR1cm4gKGNtcChyMS5sb3dlciwgcjIubG93ZXIpID09PSAwICYmXG5cdCAgICAgICAgICAgIGNtcChyMS51cHBlciwgcjIudXBwZXIpID09PSAwICYmXG5cdCAgICAgICAgICAgICEhcjEubG93ZXJPcGVuID09PSAhIXIyLmxvd2VyT3BlbiAmJlxuXHQgICAgICAgICAgICAhIXIxLnVwcGVyT3BlbiA9PT0gISFyMi51cHBlck9wZW4pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb21wYXJlTG93ZXJzKGxvd2VyMSwgbG93ZXIyLCBsb3dlck9wZW4xLCBsb3dlck9wZW4yKSB7XG5cdCAgICAgICAgaWYgKGxvd2VyMSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICByZXR1cm4gbG93ZXIyICE9PSB1bmRlZmluZWQgPyAtMSA6IDA7XG5cdCAgICAgICAgaWYgKGxvd2VyMiA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICB2YXIgYyA9IGNtcChsb3dlcjEsIGxvd2VyMik7XG5cdCAgICAgICAgaWYgKGMgPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKGxvd2VyT3BlbjEgJiYgbG93ZXJPcGVuMilcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICBpZiAobG93ZXJPcGVuMSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICBpZiAobG93ZXJPcGVuMilcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGM7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjb21wYXJlVXBwZXJzKHVwcGVyMSwgdXBwZXIyLCB1cHBlck9wZW4xLCB1cHBlck9wZW4yKSB7XG5cdCAgICAgICAgaWYgKHVwcGVyMSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICByZXR1cm4gdXBwZXIyICE9PSB1bmRlZmluZWQgPyAxIDogMDtcblx0ICAgICAgICBpZiAodXBwZXIyID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICB2YXIgYyA9IGNtcCh1cHBlcjEsIHVwcGVyMik7XG5cdCAgICAgICAgaWYgKGMgPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKHVwcGVyT3BlbjEgJiYgdXBwZXJPcGVuMilcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICBpZiAodXBwZXJPcGVuMSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgaWYgKHVwcGVyT3BlbjIpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGM7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpc1N1cGVyUmFuZ2UocjEsIHIyKSB7XG5cdCAgICAgICAgcmV0dXJuIChjb21wYXJlTG93ZXJzKHIxLmxvd2VyLCByMi5sb3dlciwgcjEubG93ZXJPcGVuLCByMi5sb3dlck9wZW4pIDw9IDAgJiZcblx0ICAgICAgICAgICAgY29tcGFyZVVwcGVycyhyMS51cHBlciwgcjIudXBwZXIsIHIxLnVwcGVyT3BlbiwgcjIudXBwZXJPcGVuKSA+PSAwKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZmluZENvbXBhdGlibGVRdWVyeShkYk5hbWUsIHRhYmxlTmFtZSwgdHlwZSwgcmVxKSB7XG5cdCAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuXHQgICAgICAgIGlmICghdGJsQ2FjaGUpXG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB2YXIgcXVlcmllcyA9IHRibENhY2hlLnF1ZXJpZXNbdHlwZV07XG5cdCAgICAgICAgaWYgKCFxdWVyaWVzKVxuXHQgICAgICAgICAgICByZXR1cm4gW251bGwsIGZhbHNlLCB0YmxDYWNoZSwgbnVsbF07XG5cdCAgICAgICAgdmFyIGluZGV4TmFtZSA9IHJlcS5xdWVyeSA/IHJlcS5xdWVyeS5pbmRleC5uYW1lIDogbnVsbDtcblx0ICAgICAgICB2YXIgZW50cmllcyA9IHF1ZXJpZXNbaW5kZXhOYW1lIHx8ICcnXTtcblx0ICAgICAgICBpZiAoIWVudHJpZXMpXG5cdCAgICAgICAgICAgIHJldHVybiBbbnVsbCwgZmFsc2UsIHRibENhY2hlLCBudWxsXTtcblx0ICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSAncXVlcnknOlxuXHQgICAgICAgICAgICAgICAgdmFyIGVxdWFsRW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnJlcS5saW1pdCA9PT0gcmVxLmxpbWl0ICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlcS52YWx1ZXMgPT09IHJlcS52YWx1ZXMgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXJlUmFuZ2VzRXF1YWwoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXF1YWxFbnRyeSlcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcXVhbEVudHJ5LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyxcblx0ICAgICAgICAgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1cGVyRW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gJ2xpbWl0JyBpbiBlbnRyeS5yZXEgPyBlbnRyeS5yZXEubGltaXQgOiBJbmZpbml0eTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxpbWl0ID49IHJlcS5saW1pdCAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAocmVxLnZhbHVlcyA/IGVudHJ5LnJlcS52YWx1ZXMgOiB0cnVlKSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpc1N1cGVyUmFuZ2UoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtzdXBlckVudHJ5LCBmYWxzZSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuXHQgICAgICAgICAgICBjYXNlICdjb3VudCc6XG5cdCAgICAgICAgICAgICAgICB2YXIgY291bnRRdWVyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJlUmFuZ2VzRXF1YWwoZW50cnkucmVxLnF1ZXJ5LnJhbmdlLCByZXEucXVlcnkucmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW2NvdW50UXVlcnksICEhY291bnRRdWVyeSwgdGJsQ2FjaGUsIGVudHJpZXNdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9DYWNoZUVudHJ5KGNhY2hlRW50cnksIGNvbnRhaW5lciwgcmVxdWVyeSwgc2lnbmFsKSB7XG5cdCAgICAgICAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5hZGQocmVxdWVyeSk7XG5cdCAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuZGVsZXRlKHJlcXVlcnkpO1xuXHQgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBlbnF1ZUZvckRlbGV0aW9uKGNhY2hlRW50cnksIGNvbnRhaW5lcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeSwgY29udGFpbmVyKSB7XG5cdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LnN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShjb250YWluZXIsIGNhY2hlRW50cnkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSwgMzAwMCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYWNoZU1pZGRsZXdhcmUgPSB7XG5cdCAgICAgICAgc3RhY2s6ICdkYmNvcmUnLFxuXHQgICAgICAgIGxldmVsOiAwLFxuXHQgICAgICAgIG5hbWU6ICdDYWNoZScsXG5cdCAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoY29yZSkge1xuXHQgICAgICAgICAgICB2YXIgZGJOYW1lID0gY29yZS5zY2hlbWEubmFtZTtcblx0ICAgICAgICAgICAgdmFyIGNvcmVNVyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZGJ0cmFucyA9IGNvcmUudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjXzEgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduYWwgPSBhY18xLnNpZ25hbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHdhc0NvbW1pdHRlZCkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNfMS5hYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkU3Vic2NyaWJlcnNfMSA9IG5ldyBTZXQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0b3Jlc18xID0gc3RvcmVzOyBfaSA8IHN0b3Jlc18xLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gc3RvcmVzXzFbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQoc3RvcmVOYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YmxDYWNoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZShzdG9yZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wcyA9IHRibENhY2hlLm9wdGltaXN0aWNPcHMuZmlsdGVyKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AudHJhbnMgPT09IGlkYnRyYW5zOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGJ0cmFucy5fZXhwbGljaXQgJiYgd2FzQ29tbWl0dGVkICYmIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBPYmplY3QudmFsdWVzKHRibENhY2hlLnF1ZXJpZXMucXVlcnkpOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IF9iW19hXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBfZCA9IGVudHJpZXMuc2xpY2UoKTsgX2MgPCBfZC5sZW5ndGg7IF9jKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9kW19jXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYnNTZXRzT3ZlcmxhcChlbnRyeS5vYnNTZXQsIGlkYnRyYW5zLm11dGF0ZWRQYXJ0cykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3BzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzID0gdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC50cmFucyAhPT0gaWRidHJhbnM7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gMCwgX2YgPSBPYmplY3QudmFsdWVzKHRibENhY2hlLnF1ZXJpZXMucXVlcnkpOyBfZSA8IF9mLmxlbmd0aDsgX2UrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IF9mW19lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2cgPSAwLCBfaCA9IGVudHJpZXMuc2xpY2UoKTsgX2cgPCBfaC5sZW5ndGg7IF9nKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9oW19nXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5yZXMgIT0gbnVsbCAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLm11dGF0ZWRQYXJ0c1xuXHQgICAgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0NvbW1pdHRlZCAmJiAhZW50cnkuZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZWV6ZVJlc3VsdHMgPSBPYmplY3QuaXNGcm96ZW4oZW50cnkucmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZFJlcyA9IGFwcGx5T3B0aW1pc3RpY09wcyhlbnRyeS5yZXMsIGVudHJ5LnJlcSwgb3BzLCB0YWJsZSwgZW50cnksIGZyZWV6ZVJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShlbnRyaWVzLCBlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBhZmZlY3RlZFN1YnNjcmliZXJzXzEuYWRkKHJlcXVlcnkpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RSZXMgIT09IGVudHJ5LnJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzID0gbW9kUmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHsgcmVzdWx0OiBtb2RSZXMgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kaXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXJ5KSB7IHJldHVybiBhZmZlY3RlZFN1YnNjcmliZXJzXzEuYWRkKHJlcXVlcnkpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIHJlcXVlcnkoKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZW5kVHJhbnNhY3Rpb24oZmFsc2UpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZW5kVHJhbnNhY3Rpb24oZmFsc2UpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgZW5kVHJhbnNhY3Rpb24odHJ1ZSksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkYnRyYW5zO1xuXHQgICAgICAgICAgICAgICAgfSwgdGFibGU6IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG93blRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gZG93blRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZU1XID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25UYWJsZSksIHsgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBQU0QudHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5vdXRib3VuZCB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmRiLl9vcHRpb25zLmNhY2hlID09PSAnZGlzYWJsZWQnIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuZXhwbGljaXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRibENhY2hlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGRvd25UYWJsZS5tdXRhdGUocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JykgJiYgKHJlcS52YWx1ZXMubGVuZ3RoID49IDUwIHx8IGdldEVmZmVjdGl2ZUtleXMocHJpbUtleSwgcmVxKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSA9PSBudWxsOyB9KSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxV2l0aFJlc29sdmVkS2V5cyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHZhbHVlczogcmVxLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVdpdGhLZXkgPSAoKF9hID0gcHJpbUtleS5rZXlQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJy4nKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkZWVwQ2xvbmUodmFsdWUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX19hc3NpZ24oe30sIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgodmFsdWVXaXRoS2V5LCBwcmltS2V5LmtleVBhdGgsIHJlcy5yZXN1bHRzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVXaXRoS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJlcSA9IGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcVdpdGhSZXNvbHZlZEtleXMsIHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChhZGp1c3RlZFJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcS5tdXRhdGVkUGFydHMgJiYgc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocmVxLm11dGF0ZWRQYXJ0cyk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKHRibENhY2hlLm9wdGltaXN0aWNPcHMsIHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRSZXEgPSBhZGp1c3RPcHRpbWlzdGljRnJvbUZhaWx1cmVzKHRibENhY2hlLCByZXEsIHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0ZWRSZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLnB1c2goYWRqdXN0ZWRSZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBxdWVyeTogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhY2hhYmxlQ29udGV4dChQU0QsIGRvd25UYWJsZSkgfHwgIWlzQ2FjaGFibGVSZXF1ZXN0KFwicXVlcnlcIiwgcmVxKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZXplUmVzdWx0cyA9ICgoX2EgPSBQU0QudHJhbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYi5fb3B0aW9ucy5jYWNoZSkgPT09ICdpbW11dGFibGUnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gUFNELCByZXF1ZXJ5ID0gX2IucmVxdWVyeSwgc2lnbmFsID0gX2Iuc2lnbmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gZmluZENvbXBhdGlibGVRdWVyeShkYk5hbWUsIHRhYmxlTmFtZSwgJ3F1ZXJ5JywgcmVxKSwgY2FjaGVFbnRyeSA9IF9jWzBdLCBleGFjdE1hdGNoID0gX2NbMV0sIHRibENhY2hlID0gX2NbMl0sIGNvbnRhaW5lciA9IF9jWzNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkgJiYgZXhhY3RNYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkub2JzU2V0ID0gcmVxLm9ic1NldDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZG93blRhYmxlLnF1ZXJ5KHJlcSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXMucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkucmVzID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJlZXplUmVzdWx0cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZXN1bHQubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyZXN1bHRbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGRlZXBDbG9uZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgJiYgY2FjaGVFbnRyeSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShjb250YWluZXIsIGNhY2hlRW50cnkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic1NldDogcmVxLm9ic1NldCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IG5ldyBTZXQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3F1ZXJ5Jyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxOiByZXEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnR5OiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnB1c2goY2FjaGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBbY2FjaGVFbnRyeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGJsQ2FjaGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHt9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDoge30sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpzOiBuZXcgTWFwKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY09wczogW10sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzOiB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5W3JlcS5xdWVyeS5pbmRleC5uYW1lIHx8ICcnXSA9IGNvbnRhaW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyLCByZXF1ZXJ5LCBzaWduYWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGFwcGx5T3B0aW1pc3RpY09wcyhyZXMucmVzdWx0LCByZXEsIHRibENhY2hlID09PSBudWxsIHx8IHRibENhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCBkb3duVGFibGUsIGNhY2hlRW50cnksIGZyZWV6ZVJlc3VsdHMpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNVztcblx0ICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBjb3JlTVc7XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHZpcGlmeSh0YXJnZXQsIHZpcERiKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkYicpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcERiO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBEZXhpZSQxID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRGV4aWUobmFtZSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlcyA9IHt9O1xuXHQgICAgICAgICAgICB0aGlzLnZlcm5vID0gMDtcblx0ICAgICAgICAgICAgdmFyIGRlcHMgPSBEZXhpZS5kZXBlbmRlbmNpZXM7XG5cdCAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zID0gX19hc3NpZ24oe1xuXHQgICAgICAgICAgICAgICAgYWRkb25zOiBEZXhpZS5hZGRvbnMsIGF1dG9PcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgaW5kZXhlZERCOiBkZXBzLmluZGV4ZWREQiwgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsIGNhY2hlOiAnY2xvbmVkJyB9LCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVwcyA9IHtcblx0ICAgICAgICAgICAgICAgIGluZGV4ZWREQjogb3B0aW9ucy5pbmRleGVkREIsXG5cdCAgICAgICAgICAgICAgICBJREJLZXlSYW5nZTogb3B0aW9ucy5JREJLZXlSYW5nZVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgYWRkb25zID0gb3B0aW9ucy5hZGRvbnM7XG5cdCAgICAgICAgICAgIHRoaXMuX2RiU2NoZW1hID0ge307XG5cdCAgICAgICAgICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3N0b3JlTmFtZXMgPSBbXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxsVGFibGVzID0ge307XG5cdCAgICAgICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9ub3ZpcCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcblx0ICAgICAgICAgICAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgaXNCZWluZ09wZW5lZDogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBkYlJlYWR5UmVzb2x2ZTogbm9wLFxuXHQgICAgICAgICAgICAgICAgZGJSZWFkeVByb21pc2U6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBjYW5jZWxPcGVuOiBub3AsXG5cdCAgICAgICAgICAgICAgICBvcGVuQ2FuY2VsbGVyOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgYXV0b1NjaGVtYTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIFBSMTM5OF9tYXhMb29wOiAzLFxuXHQgICAgICAgICAgICAgICAgYXV0b09wZW46IG9wdGlvbnMuYXV0b09wZW4sXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG5cdCAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJwb3B1bGF0ZVwiLCBcImJsb2NrZWRcIiwgXCJ2ZXJzaW9uY2hhbmdlXCIsIFwiY2xvc2VcIiwgeyByZWFkeTogW3Byb21pc2FibGVDaGFpbiwgbm9wXSB9KTtcblx0ICAgICAgICAgICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBiU3RpY2t5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgRGV4aWUudmlwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3RoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNvbXBsZXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmRiT3BlbkVycm9yKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucHVzaChzdWJzY3JpYmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiU3RpY2t5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYl8xID0gX3RoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJTdGlja3kpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYl8xLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYl8xLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5UYWJsZSA9IGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuVHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuV2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gdXBncmFkZSBkYXRhYmFzZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLlwiKSk7XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5cIikpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIiwgZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWV2Lm5ld1ZlcnNpb24gfHwgZXYubmV3VmVyc2lvbiA8IGV2Lm9sZFZlcnNpb24pXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV4aWUuZGVsZXRlKCdcIi5jb25jYXQoX3RoaXMubmFtZSwgXCInKSB3YXMgYmxvY2tlZFwiKSk7XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVXBncmFkZSAnXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiJyBibG9ja2VkIGJ5IG90aGVyIGNvbm5lY3Rpb24gaG9sZGluZyB2ZXJzaW9uIFwiKS5jb25jYXQoZXYub2xkVmVyc2lvbiAvIDEwKSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9tYXhLZXkgPSBnZXRNYXhLZXkob3B0aW9ucy5JREJLZXlSYW5nZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbikgeyByZXR1cm4gbmV3IF90aGlzLlRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBfdGhpcy5fb3B0aW9ucy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudFRyYW5zYWN0aW9uKTsgfTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlyZU9uQmxvY2tlZCA9IGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMub24oXCJibG9ja2VkXCIpLmZpcmUoZXYpO1xuXHQgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNcblx0ICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm5hbWUgPT09IF90aGlzLm5hbWUgJiYgYyAhPT0gX3RoaXMgJiYgIWMuX3N0YXRlLnZjRmlyZWQ7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7IH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB0aGlzLnVzZShjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSk7XG5cdCAgICAgICAgICAgIHRoaXMudXNlKGNhY2hlTWlkZGxld2FyZSk7XG5cdCAgICAgICAgICAgIHRoaXMudXNlKG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlKTtcblx0ICAgICAgICAgICAgdGhpcy51c2UodmlydHVhbEluZGV4TWlkZGxld2FyZSk7XG5cdCAgICAgICAgICAgIHRoaXMudXNlKGhvb2tzTWlkZGxld2FyZSk7XG5cdCAgICAgICAgICAgIHZhciB2aXBEQiA9IG5ldyBQcm94eSh0aGlzLCB7XG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfLCBwcm9wLCByZWNlaXZlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnX3ZpcCcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAndGFibGUnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhYmxlTmFtZSkgeyByZXR1cm4gdmlwaWZ5KF90aGlzLnRhYmxlKHRhYmxlTmFtZSksIHZpcERCKTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBSZWZsZWN0LmdldChfLCBwcm9wLCByZWNlaXZlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJ2IGluc3RhbmNlb2YgVGFibGUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBpZnkocnYsIHZpcERCKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3RhYmxlcycpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydi5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHZpcGlmeSh0LCB2aXBEQik7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnX2NyZWF0ZVRyYW5zYWN0aW9uJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eCA9IHJ2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwaWZ5KHR4LCB2aXBEQik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy52aXAgPSB2aXBEQjtcblx0ICAgICAgICAgICAgYWRkb25zLmZvckVhY2goZnVuY3Rpb24gKGFkZG9uKSB7IHJldHVybiBhZGRvbihfdGhpcyk7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUudmVyc2lvbiA9IGZ1bmN0aW9uICh2ZXJzaW9uTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIGlmIChpc05hTih2ZXJzaW9uTnVtYmVyKSB8fCB2ZXJzaW9uTnVtYmVyIDwgMC4xKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHlwZShcIkdpdmVuIHZlcnNpb24gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuXHQgICAgICAgICAgICB2ZXJzaW9uTnVtYmVyID0gTWF0aC5yb3VuZCh2ZXJzaW9uTnVtYmVyICogMTApIC8gMTA7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJDYW5ub3QgYWRkIHZlcnNpb24gd2hlbiBkYXRhYmFzZSBpcyBvcGVuXCIpO1xuXHQgICAgICAgICAgICB0aGlzLnZlcm5vID0gTWF0aC5tYXgodGhpcy52ZXJubywgdmVyc2lvbk51bWJlcik7XG5cdCAgICAgICAgICAgIHZhciB2ZXJzaW9ucyA9IHRoaXMuX3ZlcnNpb25zO1xuXHQgICAgICAgICAgICB2YXIgdmVyc2lvbkluc3RhbmNlID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA9PT0gdmVyc2lvbk51bWJlcjsgfSlbMF07XG5cdCAgICAgICAgICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuXHQgICAgICAgICAgICB2ZXJzaW9uSW5zdGFuY2UgPSBuZXcgdGhpcy5WZXJzaW9uKHZlcnNpb25OdW1iZXIpO1xuXHQgICAgICAgICAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb25JbnN0YW5jZSk7XG5cdCAgICAgICAgICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuXHQgICAgICAgICAgICB2ZXJzaW9uSW5zdGFuY2Uuc3RvcmVzKHt9KTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuYXV0b1NjaGVtYSA9IGZhbHNlO1xuXHQgICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLl93aGVuUmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlkYmRiICYmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUgfHwgUFNELmxldFRocm91Z2ggfHwgdGhpcy5fdmlwKSkgPyBmbigpIDogbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoX3RoaXMuX3N0YXRlLmRiT3BlbkVycm9yKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc3RhdGUuYXV0b09wZW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oKS5jYXRjaChub3ApO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgfSkudGhlbihmbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IF9hLnN0YWNrLCBjcmVhdGUgPSBfYS5jcmVhdGUsIGxldmVsID0gX2EubGV2ZWwsIG5hbWUgPSBfYS5uYW1lO1xuXHQgICAgICAgICAgICBpZiAobmFtZSlcblx0ICAgICAgICAgICAgICAgIHRoaXMudW51c2UoeyBzdGFjazogc3RhY2ssIG5hbWU6IG5hbWUgfSk7XG5cdCAgICAgICAgICAgIHZhciBtaWRkbGV3YXJlcyA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSB8fCAodGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gW10pO1xuXHQgICAgICAgICAgICBtaWRkbGV3YXJlcy5wdXNoKHsgc3RhY2s6IHN0YWNrLCBjcmVhdGU6IGNyZWF0ZSwgbGV2ZWw6IGxldmVsID09IG51bGwgPyAxMCA6IGxldmVsLCBuYW1lOiBuYW1lIH0pO1xuXHQgICAgICAgICAgICBtaWRkbGV3YXJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmxldmVsIC0gYi5sZXZlbDsgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLnVudXNlID0gZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IF9hLnN0YWNrLCBuYW1lID0gX2EubmFtZSwgY3JlYXRlID0gX2EuY3JlYXRlO1xuXHQgICAgICAgICAgICBpZiAoc3RhY2sgJiYgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10uZmlsdGVyKGZ1bmN0aW9uIChtdykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUgPyBtdy5jcmVhdGUgIT09IGNyZWF0ZSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPyBtdy5uYW1lICE9PSBuYW1lIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHVzZVBTRChnbG9iYWxQU0QsXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRleGllT3BlbihfdGhpcyk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIHZhciBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuXHQgICAgICAgICAgICBpZiAoaWR4ID49IDApXG5cdCAgICAgICAgICAgICAgICBjb25uZWN0aW9ucy5zcGxpY2UoaWR4LCAxKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaWRiZGIpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGJkYi5jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5pZGJkYiA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8geyBkaXNhYmxlQXV0b09wZW46IHRydWUgfSA6IF9hLCBkaXNhYmxlQXV0b09wZW4gPSBfYi5kaXNhYmxlQXV0b09wZW47XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICBpZiAoZGlzYWJsZUF1dG9PcGVuKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuYXV0b09wZW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5hdXRvT3BlbiA9IHRoaXMuX29wdGlvbnMuYXV0b09wZW4gfHxcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoY2xvc2VPcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmIChjbG9zZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBjbG9zZU9wdGlvbnMgPSB7IGRpc2FibGVBdXRvT3BlbjogdHJ1ZSB9OyB9XG5cdCAgICAgICAgICAgIHZhciBoYXNJbnZhbGlkQXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCc7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZG9EZWxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoY2xvc2VPcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gX3RoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKF90aGlzLm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX29uRGF0YWJhc2VEZWxldGVkKF90aGlzLl9kZXBzLCBfdGhpcy5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IF90aGlzLl9maXJlT25CbG9ja2VkO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYXNJbnZhbGlkQXJndW1lbnRzKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgY2xvc2VPcHRpb25zIGFyZ3VtZW50IHRvIGRiLmRlbGV0ZSgpXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGRvRGVsZXRlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvRGVsZXRlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmJhY2tlbmREQiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGI7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGJkYiAhPT0gbnVsbDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5oYXNCZWVuQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZGJPcGVuRXJyb3IgPSB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIGRiT3BlbkVycm9yICYmIChkYk9wZW5FcnJvci5uYW1lID09PSAnRGF0YWJhc2VDbG9zZWQnKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5oYXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvciAhPT0gbnVsbDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5keW5hbWljYWxseU9wZW5lZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV4aWUucHJvdG90eXBlLCBcInRhYmxlc1wiLCB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBrZXlzKHRoaXMuX2FsbFRhYmxlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5fYWxsVGFibGVzW25hbWVdOyB9KTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGFyZ3MgPSBleHRyYWN0VHJhbnNhY3Rpb25BcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5fdHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAobW9kZSwgdGFibGVzLCBzY29wZUZ1bmMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHBhcmVudFRyYW5zYWN0aW9uID0gUFNELnRyYW5zO1xuXHQgICAgICAgICAgICBpZiAoIXBhcmVudFRyYW5zYWN0aW9uIHx8IHBhcmVudFRyYW5zYWN0aW9uLmRiICE9PSB0aGlzIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSlcblx0ICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcblx0ICAgICAgICAgICAgdmFyIG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG5cdCAgICAgICAgICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKTtcblx0ICAgICAgICAgICAgdmFyIGlkYk1vZGUsIHN0b3JlTmFtZXM7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gdGFibGUgaW5zdGFuY2VvZiBfdGhpcy5UYWJsZSA/IHRhYmxlLm5hbWUgOiB0YWJsZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlTmFtZSAhPT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhYmxlIGFyZ3VtZW50IHRvIERleGllLnRyYW5zYWN0aW9uKCkuIE9ubHkgVGFibGUgb3IgU3RyaW5nIGFyZSBhbGxvd2VkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuXHQgICAgICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyd1wiIHx8IG1vZGUgPT0gUkVBRFdSSVRFKVxuXHQgICAgICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFEV1JJVEU7XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uLm1vZGUgPT09IFJFQURPTkxZICYmIGlkYk1vZGUgPT09IFJFQURXUklURSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uICYmIHBhcmVudFRyYW5zYWN0aW9uLnN0b3JlTmFtZXMuaW5kZXhPZihzdG9yZU5hbWUpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIlRhYmxlIFwiICsgc3RvcmVOYW1lICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG5vdCBpbmNsdWRlZCBpbiBwYXJlbnQgdHJhbnNhY3Rpb24uXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUgJiYgcGFyZW50VHJhbnNhY3Rpb24gJiYgIXBhcmVudFRyYW5zYWN0aW9uLmFjdGl2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNhY3Rpb24gP1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmVqZWN0KGUpOyB9KSA6XG5cdCAgICAgICAgICAgICAgICAgICAgcmVqZWN0aW9uKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBlbnRlclRyYW5zYWN0aW9uID0gZW50ZXJUcmFuc2FjdGlvblNjb3BlLmJpbmQobnVsbCwgdGhpcywgaWRiTW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYyk7XG5cdCAgICAgICAgICAgIHJldHVybiAocGFyZW50VHJhbnNhY3Rpb24gP1xuXHQgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcblx0ICAgICAgICAgICAgICAgIFBTRC50cmFucyA/XG5cdCAgICAgICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbik7IH0pIDpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICBpZiAoIWhhc093bih0aGlzLl9hbGxUYWJsZXMsIHRhYmxlTmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRUYWJsZShcIlRhYmxlIFwiLmNvbmNhdCh0YWJsZU5hbWUsIFwiIGRvZXMgbm90IGV4aXN0XCIpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsVGFibGVzW3RhYmxlTmFtZV07XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gRGV4aWU7XG5cdCAgICB9KCkpO1xuXG5cdCAgICB2YXIgc3ltYm9sT2JzZXJ2YWJsZSA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG5cdCAgICAgICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuXHQgICAgICAgIDogXCJAQG9ic2VydmFibGVcIjtcblx0ICAgIHZhciBPYnNlcnZhYmxlID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoeCwgZXJyb3IsIGNvbXBsZXRlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoIXggfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHsgbmV4dDogeCwgZXJyb3I6IGVycm9yLCBjb21wbGV0ZTogY29tcGxldGUgfSA6IHgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIE9ic2VydmFibGU7XG5cdCAgICB9KCkpO1xuXG5cdCAgICB2YXIgZG9tRGVwcztcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZG9tRGVwcyA9IHtcblx0ICAgICAgICAgICAgaW5kZXhlZERCOiBfZ2xvYmFsLmluZGV4ZWREQiB8fCBfZ2xvYmFsLm1vekluZGV4ZWREQiB8fCBfZ2xvYmFsLndlYmtpdEluZGV4ZWREQiB8fCBfZ2xvYmFsLm1zSW5kZXhlZERCLFxuXHQgICAgICAgICAgICBJREJLZXlSYW5nZTogX2dsb2JhbC5JREJLZXlSYW5nZSB8fCBfZ2xvYmFsLndlYmtpdElEQktleVJhbmdlXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgZG9tRGVwcyA9IHsgaW5kZXhlZERCOiBudWxsLCBJREJLZXlSYW5nZTogbnVsbCB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBsaXZlUXVlcnkocXVlcmllcikge1xuXHQgICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsdWU7XG5cdCAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcblx0ICAgICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUoY3R4KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IG5ld1Njb3BlKHF1ZXJpZXIsIGN0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnYgPSBydi5maW5hbGx5KGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2FzUm9vdEV4ZWMgJiYgZW5kTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY2xvc2VkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBhYm9ydENvbnRyb2xsZXI7XG5cdCAgICAgICAgICAgIHZhciBhY2N1bU11dHMgPSB7fTtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRPYnMgPSB7fTtcblx0ICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcblx0ICAgICAgICAgICAgICAgIGdldCBjbG9zZWQoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlZDtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydGVkTGlzdGVuaW5nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pO1xuXHQgICAgICAgICAgICB2YXIgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgZG9RdWVyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4ZWNJbkdsb2JhbENvbnRleHQoX2RvUXVlcnkpOyB9O1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGROb3RpZnkoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb2JzU2V0c092ZXJsYXAoY3VycmVudE9icywgYWNjdW1NdXRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgbXV0YXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIChwYXJ0cykge1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChhY2N1bU11dHMsIHBhcnRzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvUXVlcnkoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdmFyIF9kb1F1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fFxuXHQgICAgICAgICAgICAgICAgICAgICFkb21EZXBzLmluZGV4ZWREQilcblx0ICAgICAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG5cdCAgICAgICAgICAgICAgICB2YXIgc3Vic2NyID0ge307XG5cdCAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKVxuXHQgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJzY3I6IHN1YnNjcixcblx0ICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVyeTogZG9RdWVyeSxcblx0ICAgICAgICAgICAgICAgICAgICBxdWVyaWVyOiBxdWVyaWVyLFxuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zOiBudWxsXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgdmFyIHJldCA9IGV4ZWN1dGUoY3R4KTtcblx0ICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fCBjdHguc2lnbmFsLmFib3J0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50T2JzID0gc3Vic2NyO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SXNFbXB0eShjdXJyZW50T2JzKSAmJiAhc3RhcnRlZExpc3RlbmluZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIG11dGF0aW9uTGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkTGlzdGVuaW5nID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZXhlY0luR2xvYmFsQ29udGV4dChmdW5jdGlvbiAoKSB7IHJldHVybiAhY2xvc2VkICYmIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChyZXN1bHQpOyB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghWydEYXRhYmFzZUNsb3NlZEVycm9yJywgJ0Fib3J0RXJyb3InXS5pbmNsdWRlcyhlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjSW5HbG9iYWxDb250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGRvUXVlcnksIDApO1xuXHQgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIG9ic2VydmFibGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNWYWx1ZTsgfTtcblx0ICAgICAgICBvYnNlcnZhYmxlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3VycmVudFZhbHVlOyB9O1xuXHQgICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgRGV4aWUgPSBEZXhpZSQxO1xuXHQgICAgcHJvcHMoRGV4aWUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmdWxsTmFtZUV4Y2VwdGlvbnMpLCB7XG5cdCAgICAgICAgZGVsZXRlOiBmdW5jdGlvbiAoZGF0YWJhc2VOYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUsIHsgYWRkb25zOiBbXSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZXhpc3RzOiBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERleGllKG5hbWUsIHsgYWRkb25zOiBbXSB9KS5vcGVuKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcblx0ICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXREYXRhYmFzZU5hbWVzOiBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzKERleGllLmRlcGVuZGVuY2llcykudGhlbihjYik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGRlZmluZUNsYXNzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gQ2xhc3M7XG5cdCAgICAgICAgfSwgaWdub3JlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzY29wZUZ1bmMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG5cdCAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgc2NvcGVGdW5jKSA6XG5cdCAgICAgICAgICAgICAgICBzY29wZUZ1bmMoKTtcblx0ICAgICAgICB9LCB2aXA6IHZpcCwgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpeiwgYXJncyB8fCBbXSkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocnYpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBjdXJyZW50VHJhbnNhY3Rpb246IHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQU0QudHJhbnMgfHwgbnVsbDsgfVxuXHQgICAgICAgIH0sIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlT3JGdW5jdGlvbiwgb3B0aW9uYWxUaW1lb3V0KSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgICAgICAgIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKHByb21pc2VPckZ1bmN0aW9uKSA6XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlT3JGdW5jdGlvbilcblx0ICAgICAgICAgICAgICAgIC50aW1lb3V0KG9wdGlvbmFsVGltZW91dCB8fCA2MDAwMCk7XG5cdCAgICAgICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuXHQgICAgICAgICAgICAgICAgUFNELnRyYW5zLndhaXRGb3IocHJvbWlzZSkgOlxuXHQgICAgICAgICAgICAgICAgcHJvbWlzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcblx0ICAgICAgICBkZWJ1Zzoge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlYnVnOyB9LFxuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgc2V0RGVidWcodmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZXJpdmU6IGRlcml2ZSwgZXh0ZW5kOiBleHRlbmQsIHByb3BzOiBwcm9wcywgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuXHQgICAgICAgIEV2ZW50czogRXZlbnRzLCBvbjogZ2xvYmFsRXZlbnRzLCBsaXZlUXVlcnk6IGxpdmVRdWVyeSwgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldDogZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCxcblx0ICAgICAgICBnZXRCeUtleVBhdGg6IGdldEJ5S2V5UGF0aCwgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsIGRlbEJ5S2V5UGF0aDogZGVsQnlLZXlQYXRoLCBzaGFsbG93Q2xvbmU6IHNoYWxsb3dDbG9uZSwgZGVlcENsb25lOiBkZWVwQ2xvbmUsIGdldE9iamVjdERpZmY6IGdldE9iamVjdERpZmYsIGNtcDogY21wLCBhc2FwOiBhc2FwJDEsXG5cdCAgICAgICAgbWluS2V5OiBtaW5LZXksXG5cdCAgICAgICAgYWRkb25zOiBbXSxcblx0ICAgICAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbnMsXG5cdCAgICAgICAgZXJybmFtZXM6IGVycm5hbWVzLFxuXHQgICAgICAgIGRlcGVuZGVuY2llczogZG9tRGVwcywgY2FjaGU6IGNhY2hlLFxuXHQgICAgICAgIHNlbVZlcjogREVYSUVfVkVSU0lPTiwgdmVyc2lvbjogREVYSUVfVkVSU0lPTi5zcGxpdCgnLicpXG5cdCAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHBhcnNlSW50KG4pOyB9KVxuXHQgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwLCBjLCBpKSB7IHJldHVybiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKTsgfSkgfSkpO1xuXHQgICAgRGV4aWUubWF4S2V5ID0gZ2V0TWF4S2V5KERleGllLmRlcGVuZGVuY2llcy5JREJLZXlSYW5nZSk7XG5cblx0ICAgIGlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBmdW5jdGlvbiAodXBkYXRlZFBhcnRzKSB7XG5cdCAgICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMTtcblx0ICAgICAgICAgICAgICAgIGV2ZW50XzEgPSBuZXcgQ3VzdG9tRXZlbnQoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB1cGRhdGVkUGFydHNcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnRfMSk7XG5cdCAgICAgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIGRldGFpbCA9IF9hLmRldGFpbDtcblx0ICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcblx0ICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGV0YWlsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcHJvcGFnYXRlTG9jYWxseSh1cGRhdGVQYXJ0cykge1xuXHQgICAgICAgIHZhciB3YXNNZSA9IHByb3BhZ2F0aW5nTG9jYWxseTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuXHQgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZSh1cGRhdGVQYXJ0cyk7XG5cdCAgICAgICAgICAgIHNpZ25hbFN1YnNjcmliZXJzTm93KHVwZGF0ZVBhcnRzLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHdhc01lO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcblxuXHQgICAgdmFyIGJjO1xuXHQgICAgdmFyIGNyZWF0ZUJDID0gZnVuY3Rpb24gKCkgeyB9O1xuXHQgICAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIGNyZWF0ZUJDID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSk7XG5cdCAgICAgICAgICAgIGJjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikgeyByZXR1cm4gZXYuZGF0YSAmJiBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpOyB9O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY3JlYXRlQkMoKTtcblx0ICAgICAgICBpZiAodHlwZW9mIGJjLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGJjLnVucmVmKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgZnVuY3Rpb24gKGNoYW5nZWRQYXJ0cykge1xuXHQgICAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuXHQgICAgICAgICAgICAgICAgYmMucG9zdE1lc3NhZ2UoY2hhbmdlZFBhcnRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKCFEZXhpZSQxLmRpc2FibGVCZkNhY2hlICYmIGV2ZW50LnBlcnNpc3RlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0RleGllOiBoYW5kbGluZyBwZXJzaXN0ZWQgcGFnZWhpZGUnKTtcblx0ICAgICAgICAgICAgICAgIGJjID09PSBudWxsIHx8IGJjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiYy5jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb25uZWN0aW9uc18xID0gY29ubmVjdGlvbnM7IF9pIDwgY29ubmVjdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSBjb25uZWN0aW9uc18xW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSh7IGRpc2FibGVBdXRvT3BlbjogZmFsc2UgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoIURleGllJDEuZGlzYWJsZUJmQ2FjaGUgJiYgZXZlbnQucGVyc2lzdGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IGhhbmRsaW5nIHBlcnNpc3RlZCBwYWdlc2hvdycpO1xuXHQgICAgICAgICAgICAgICAgY3JlYXRlQkMoKTtcblx0ICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoeyBhbGw6IG5ldyBSYW5nZVNldCgtSW5maW5pdHksIFtbXV0pIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7IGFkZDogdmFsdWUgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7IHJlbW92ZTogdmFsdWUgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHJlcGxhY2VQcmVmaXgoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcE1vZGlmaWNhdGlvbih7IHJlcGxhY2VQcmVmaXg6IFthLCBiXSB9KTtcblx0ICAgIH1cblxuXHQgICAgRGV4aWVQcm9taXNlLnJlamVjdGlvbk1hcHBlciA9IG1hcEVycm9yO1xuXHQgICAgc2V0RGVidWcoZGVidWcpO1xuXG5cdCAgICB2YXIgbmFtZWRFeHBvcnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHQgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcblx0ICAgICAgICBEZXhpZTogRGV4aWUkMSxcblx0ICAgICAgICBsaXZlUXVlcnk6IGxpdmVRdWVyeSxcblx0ICAgICAgICBFbnRpdHk6IEVudGl0eSxcblx0ICAgICAgICBjbXA6IGNtcCxcblx0ICAgICAgICBQcm9wTW9kU3ltYm9sOiBQcm9wTW9kU3ltYm9sLFxuXHQgICAgICAgIFByb3BNb2RpZmljYXRpb246IFByb3BNb2RpZmljYXRpb24sXG5cdCAgICAgICAgcmVwbGFjZVByZWZpeDogcmVwbGFjZVByZWZpeCxcblx0ICAgICAgICBhZGQ6IGFkZCxcblx0ICAgICAgICByZW1vdmU6IHJlbW92ZSxcblx0ICAgICAgICAnZGVmYXVsdCc6IERleGllJDEsXG5cdCAgICAgICAgUmFuZ2VTZXQ6IFJhbmdlU2V0LFxuXHQgICAgICAgIG1lcmdlUmFuZ2VzOiBtZXJnZVJhbmdlcyxcblx0ICAgICAgICByYW5nZXNPdmVybGFwOiByYW5nZXNPdmVybGFwXG5cdCAgICB9KTtcblxuXHQgICAgX19hc3NpZ24oRGV4aWUkMSwgbmFtZWRFeHBvcnRzLCB7IGRlZmF1bHQ6IERleGllJDEgfSk7XG5cblx0ICAgIHJldHVybiBEZXhpZSQxO1xuXG5cdH0pKTtcblx0XG59IChkZXhpZSkpO1xuXG52YXIgZGV4aWVFeHBvcnRzID0gZGV4aWUuZXhwb3J0cztcbnZhciBfRGV4aWUgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZGV4aWVFeHBvcnRzKTtcblxuLy8gTWFraW5nIHRoZSBtb2R1bGUgdmVyc2lvbiBjb25zdW1hYmxlIHZpYSByZXF1aXJlIC0gdG8gcHJvaGliaXRcbi8vIG11bHRpcGxlIG9jY3VycmFuY2llcyBvZiB0aGUgc2FtZSBtb2R1bGUgaW4gdGhlIHNhbWUgYXBwXG4vLyAoZHVhbCBwYWNrYWdlIGhhemFyZCwgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYWNrYWdlcy5odG1sI2R1YWwtcGFja2FnZS1oYXphcmQpXG5jb25zdCBEZXhpZVN5bWJvbCA9IFN5bWJvbC5mb3IoXCJEZXhpZVwiKTtcbmNvbnN0IERleGllID0gZ2xvYmFsVGhpc1tEZXhpZVN5bWJvbF0gfHwgKGdsb2JhbFRoaXNbRGV4aWVTeW1ib2xdID0gX0RleGllKTtcbmlmIChfRGV4aWUuc2VtVmVyICE9PSBEZXhpZS5zZW1WZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFR3byBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgRGV4aWUgbG9hZGVkIGluIHRoZSBzYW1lIGFwcDogJHtfRGV4aWUuc2VtVmVyfSBhbmQgJHtEZXhpZS5zZW1WZXJ9YCk7XG59XG5cbi8vIEhlbHBlciBmb3IgdW5kZWZpbmVkIHZhbHVlcywgbGlrZSBtYXAgZm9yIE9wdGlvbjxUPiBpbiBSdXN0LlxuLy8gQSBiZXR0ZXIgbmFtZSBmb3IgdGhpcyBpcyB3ZWxjb21lLlxuY29uc3QgbWFwT3B0aW9uID0gKHZhbHVlLCBmdW5jKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZCA/IGZ1bmModmFsdWUpIDogdW5kZWZpbmVkO1xufTtcbi8vIEFueXRoaW5nIGNhbiBiZSB0aHJvd24gYXMgYW4gZXJyb3IgaW4gcmF3IEpTIChhbHNvIHRoZSBUUyBjb21waWxlciBjYW4ndCB0eXBlLWNoZWNrIGV4Y2VwdGlvbnMpLFxuLy8gc28gd2UgYWxsb3cgaXQgaGVyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBsb2dXZWJTdG9yZUVycm9yID0gKGVycm9yLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBEZXhpZS5EZXhpZUVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvckNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7ZXJyb3JDb250ZXh0fTogSW5kZXhkYiBlcnJvciAoJHtlcnJvci5uYW1lfSk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEluZGV4ZGIgZXJyb3I6ICgke2Vycm9yLm5hbWV9KTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIG1hcE9wdGlvbihlcnJvci5zdGFjaywgKHN0YWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdGFja3RyYWNlOiBcXG4gJHtzdGFja31gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcE9wdGlvbihlcnJvci5pbm5lciwgKGlubmVyRXhjZXB0aW9uKSA9PiBsb2dXZWJTdG9yZUVycm9yKGlubmVyRXhjZXB0aW9uKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5leHBlY3RlZCBlcnJvciB3aGlsZSBhY2Nlc3NpbmcgaW5kZXhkYjogJHtlcnJvci50b1N0cmluZygpfWApO1xuICAgICAgICBtYXBPcHRpb24oZXJyb3Iuc3RhY2ssIChzdGFjaykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU3RhY2t0cmFjZTogJHtzdGFja31gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBHb3QgYW4gZXhjZXB0aW9uIHdpdGggYSBub24tZXJyb3IgdmFsdWUsIGFzIEpTT046IFxcbiAke0pTT04uc3RyaW5naWZ5KGVycm9yKX0uIEFzIFN0cmluZyBcXG4gJHtTdHJpbmcoZXJyb3IpfSBgKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbn07XG5jb25zdCB1aW50OEFycmF5VG9CYXNlNjQgPSAoYnl0ZXMpID0+IHtcbiAgICBjb25zdCBiaW5hcnkgPSBieXRlcy5yZWR1Y2UoKGFjYywgYnl0ZSkgPT4gYWNjICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSwgXCJcIik7XG4gICAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcbn07XG5cbmNvbnN0IERBVEFCQVNFX05BTUUgPSBcIk1pZGVuQ2xpZW50REJcIjtcbmFzeW5jIGZ1bmN0aW9uIG9wZW5EYXRhYmFzZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcIk9wZW5pbmcgZGF0YWJhc2UuLi5cIik7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGIub3BlbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGFiYXNlIG9wZW5lZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBvcGVuIGRhdGFiYXNlXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIFRhYmxlO1xuKGZ1bmN0aW9uIChUYWJsZSkge1xuICAgIFRhYmxlW1wiQWNjb3VudENvZGVcIl0gPSBcImFjY291bnRDb2RlXCI7XG4gICAgVGFibGVbXCJBY2NvdW50U3RvcmFnZVwiXSA9IFwiYWNjb3VudFN0b3JhZ2VcIjtcbiAgICBUYWJsZVtcIkFjY291bnRBc3NldHNcIl0gPSBcImFjY291bnRBc3NldHNcIjtcbiAgICBUYWJsZVtcIlN0b3JhZ2VNYXBFbnRyaWVzXCJdID0gXCJzdG9yYWdlTWFwRW50cmllc1wiO1xuICAgIFRhYmxlW1wiQWNjb3VudEF1dGhcIl0gPSBcImFjY291bnRBdXRoXCI7XG4gICAgVGFibGVbXCJBY2NvdW50c1wiXSA9IFwiYWNjb3VudHNcIjtcbiAgICBUYWJsZVtcIkFkZHJlc3Nlc1wiXSA9IFwiYWRkcmVzc2VzXCI7XG4gICAgVGFibGVbXCJUcmFuc2FjdGlvbnNcIl0gPSBcInRyYW5zYWN0aW9uc1wiO1xuICAgIFRhYmxlW1wiVHJhbnNhY3Rpb25TY3JpcHRzXCJdID0gXCJ0cmFuc2FjdGlvblNjcmlwdHNcIjtcbiAgICBUYWJsZVtcIklucHV0Tm90ZXNcIl0gPSBcImlucHV0Tm90ZXNcIjtcbiAgICBUYWJsZVtcIk91dHB1dE5vdGVzXCJdID0gXCJvdXRwdXROb3Rlc1wiO1xuICAgIFRhYmxlW1wiTm90ZXNTY3JpcHRzXCJdID0gXCJub3Rlc1NjcmlwdHNcIjtcbiAgICBUYWJsZVtcIlN0YXRlU3luY1wiXSA9IFwic3RhdGVTeW5jXCI7XG4gICAgVGFibGVbXCJCbG9ja0hlYWRlcnNcIl0gPSBcImJsb2NrSGVhZGVyc1wiO1xuICAgIFRhYmxlW1wiUGFydGlhbEJsb2NrY2hhaW5Ob2Rlc1wiXSA9IFwicGFydGlhbEJsb2NrY2hhaW5Ob2Rlc1wiO1xuICAgIFRhYmxlW1wiVGFnc1wiXSA9IFwidGFnc1wiO1xuICAgIFRhYmxlW1wiRm9yZWlnbkFjY291bnRDb2RlXCJdID0gXCJmb3JlaWduQWNjb3VudENvZGVcIjtcbiAgICBUYWJsZVtcIlNldHRpbmdzXCJdID0gXCJzZXR0aW5nc1wiO1xuICAgIFRhYmxlW1wiVHJhY2tlZEFjY291bnRzXCJdID0gXCJ0cmFja2VkQWNjb3VudHNcIjtcbn0pKFRhYmxlIHx8IChUYWJsZSA9IHt9KSk7XG5jb25zdCBkYiA9IG5ldyBEZXhpZShEQVRBQkFTRV9OQU1FKTtcbmRiLnZlcnNpb24oMSkuc3RvcmVzKHtcbiAgICBbVGFibGUuQWNjb3VudENvZGVdOiBpbmRleGVzKFwicm9vdFwiKSxcbiAgICBbVGFibGUuQWNjb3VudFN0b3JhZ2VdOiBpbmRleGVzKFwiW2NvbW1pdG1lbnQrc2xvdEluZGV4XVwiLCBcImNvbW1pdG1lbnRcIiksXG4gICAgW1RhYmxlLlN0b3JhZ2VNYXBFbnRyaWVzXTogaW5kZXhlcyhcIltyb290K2tleV1cIiwgXCJyb290XCIpLFxuICAgIFtUYWJsZS5BY2NvdW50QXNzZXRzXTogaW5kZXhlcyhcIltyb290K3ZhdWx0S2V5XVwiLCBcInJvb3RcIiwgXCJmYXVjZXRJZFByZWZpeFwiKSxcbiAgICBbVGFibGUuQWNjb3VudEF1dGhdOiBpbmRleGVzKFwicHViS2V5XCIpLFxuICAgIFtUYWJsZS5BY2NvdW50c106IGluZGV4ZXMoXCImYWNjb3VudENvbW1pdG1lbnRcIiwgXCJpZFwiLCBcIltpZCtub25jZV1cIiwgXCJjb2RlUm9vdFwiLCBcInN0b3JhZ2VSb290XCIsIFwidmF1bHRSb290XCIpLFxuICAgIFtUYWJsZS5BZGRyZXNzZXNdOiBpbmRleGVzKFwiYWRkcmVzc1wiLCBcImlkXCIpLFxuICAgIFtUYWJsZS5UcmFuc2FjdGlvbnNdOiBpbmRleGVzKFwiaWRcIiwgXCJzdGF0dXNWYXJpYW50XCIpLFxuICAgIFtUYWJsZS5UcmFuc2FjdGlvblNjcmlwdHNdOiBpbmRleGVzKFwic2NyaXB0Um9vdFwiKSxcbiAgICBbVGFibGUuSW5wdXROb3Rlc106IGluZGV4ZXMoXCJub3RlSWRcIiwgXCJudWxsaWZpZXJcIiwgXCJzdGF0ZURpc2NyaW1pbmFudFwiKSxcbiAgICBbVGFibGUuT3V0cHV0Tm90ZXNdOiBpbmRleGVzKFwibm90ZUlkXCIsIFwicmVjaXBpZW50RGlnZXN0XCIsIFwic3RhdGVEaXNjcmltaW5hbnRcIiwgXCJudWxsaWZpZXJcIiksXG4gICAgW1RhYmxlLk5vdGVzU2NyaXB0c106IGluZGV4ZXMoXCJzY3JpcHRSb290XCIpLFxuICAgIFtUYWJsZS5TdGF0ZVN5bmNdOiBpbmRleGVzKFwiaWRcIiksXG4gICAgW1RhYmxlLkJsb2NrSGVhZGVyc106IGluZGV4ZXMoXCJibG9ja051bVwiLCBcImhhc0NsaWVudE5vdGVzXCIpLFxuICAgIFtUYWJsZS5QYXJ0aWFsQmxvY2tjaGFpbk5vZGVzXTogaW5kZXhlcyhcImlkXCIpLFxuICAgIFtUYWJsZS5UYWdzXTogaW5kZXhlcyhcImlkKytcIiwgXCJ0YWdcIiwgXCJzb3VyY2Vfbm90ZV9pZFwiLCBcInNvdXJjZV9hY2NvdW50X2lkXCIpLFxuICAgIFtUYWJsZS5Gb3JlaWduQWNjb3VudENvZGVdOiBpbmRleGVzKFwiYWNjb3VudElkXCIpLFxuICAgIFtUYWJsZS5TZXR0aW5nc106IGluZGV4ZXMoXCJrZXlcIiksXG4gICAgW1RhYmxlLlRyYWNrZWRBY2NvdW50c106IGluZGV4ZXMoXCImaWRcIiksXG59KTtcbmZ1bmN0aW9uIGluZGV4ZXMoLi4uaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMuam9pbihcIixcIik7XG59XG5kYi5vbihcInBvcHVsYXRlXCIsICgpID0+IHtcbiAgICAvLyBQb3B1bGF0ZSB0aGUgc3RhdGVTeW5jIHRhYmxlIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBzdGF0ZVN5bmNcbiAgICAgICAgLnB1dCh7IGlkOiAxLCBibG9ja051bTogXCIwXCIgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBwb3B1bGF0ZSBEQlwiKSk7XG59KTtcbmNvbnN0IGFjY291bnRDb2RlcyA9IGRiLnRhYmxlKFRhYmxlLkFjY291bnRDb2RlKTtcbmNvbnN0IGFjY291bnRTdG9yYWdlcyA9IGRiLnRhYmxlKFRhYmxlLkFjY291bnRTdG9yYWdlKTtcbmNvbnN0IHN0b3JhZ2VNYXBFbnRyaWVzID0gZGIudGFibGUoVGFibGUuU3RvcmFnZU1hcEVudHJpZXMpO1xuY29uc3QgYWNjb3VudEFzc2V0cyA9IGRiLnRhYmxlKFRhYmxlLkFjY291bnRBc3NldHMpO1xuY29uc3QgYWNjb3VudEF1dGhzID0gZGIudGFibGUoVGFibGUuQWNjb3VudEF1dGgpO1xuY29uc3QgYWNjb3VudHMgPSBkYi50YWJsZShUYWJsZS5BY2NvdW50cyk7XG5jb25zdCBhZGRyZXNzZXMgPSBkYi50YWJsZShUYWJsZS5BZGRyZXNzZXMpO1xuY29uc3QgdHJhbnNhY3Rpb25zID0gZGIudGFibGUoVGFibGUuVHJhbnNhY3Rpb25zKTtcbmNvbnN0IHRyYW5zYWN0aW9uU2NyaXB0cyA9IGRiLnRhYmxlKFRhYmxlLlRyYW5zYWN0aW9uU2NyaXB0cyk7XG5jb25zdCBpbnB1dE5vdGVzID0gZGIudGFibGUoVGFibGUuSW5wdXROb3Rlcyk7XG5jb25zdCBvdXRwdXROb3RlcyA9IGRiLnRhYmxlKFRhYmxlLk91dHB1dE5vdGVzKTtcbmNvbnN0IG5vdGVzU2NyaXB0cyA9IGRiLnRhYmxlKFRhYmxlLk5vdGVzU2NyaXB0cyk7XG5jb25zdCBzdGF0ZVN5bmMgPSBkYi50YWJsZShUYWJsZS5TdGF0ZVN5bmMpO1xuY29uc3QgYmxvY2tIZWFkZXJzID0gZGIudGFibGUoVGFibGUuQmxvY2tIZWFkZXJzKTtcbmNvbnN0IHBhcnRpYWxCbG9ja2NoYWluTm9kZXMgPSBkYi50YWJsZShUYWJsZS5QYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKTtcbmNvbnN0IHRhZ3MgPSBkYi50YWJsZShUYWJsZS5UYWdzKTtcbmNvbnN0IGZvcmVpZ25BY2NvdW50Q29kZSA9IGRiLnRhYmxlKFRhYmxlLkZvcmVpZ25BY2NvdW50Q29kZSk7XG5jb25zdCBzZXR0aW5ncyA9IGRiLnRhYmxlKFRhYmxlLlNldHRpbmdzKTtcbmNvbnN0IHRyYWNrZWRBY2NvdW50cyA9IGRiLnRhYmxlKFRhYmxlLlRyYWNrZWRBY2NvdW50cyk7XG5cbi8vIEdFVCBGVU5DVElPTlNcbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRJZHMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhY2tlZCA9IGF3YWl0IHRyYWNrZWRBY2NvdW50cy50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiB0cmFja2VkLm1hcCgoZW50cnkpID0+IGVudHJ5LmlkKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRXJyb3Igd2hpbGUgZmV0Y2hpbmcgYWNjb3VudCBJRHNcIik7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFsbEFjY291bnRIZWFkZXJzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBhIE1hcCB0byB0cmFjayB0aGUgbGF0ZXN0IHJlY29yZCBmb3IgZWFjaCBpZCBiYXNlZCBvbiBub25jZVxuICAgICAgICBjb25zdCBsYXRlc3RSZWNvcmRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBhd2FpdCBhY2NvdW50cy5lYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjb3JkID0gbGF0ZXN0UmVjb3Jkc01hcC5nZXQocmVjb3JkLmlkKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdSZWNvcmQgfHxcbiAgICAgICAgICAgICAgICBCaWdJbnQocmVjb3JkLm5vbmNlKSA+IEJpZ0ludChleGlzdGluZ1JlY29yZC5ub25jZSkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RSZWNvcmRzTWFwLnNldChyZWNvcmQuaWQsIHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBsYXRlc3QgcmVjb3JkcyBmcm9tIHRoZSBNYXBcbiAgICAgICAgY29uc3QgbGF0ZXN0UmVjb3JkcyA9IEFycmF5LmZyb20obGF0ZXN0UmVjb3Jkc01hcC52YWx1ZXMoKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdE9iamVjdCA9IGF3YWl0IFByb21pc2UuYWxsKGxhdGVzdFJlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGxldCBhY2NvdW50U2VlZEJhc2U2NCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYWNjb3VudFNlZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVkQXNCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJlY29yZC5hY2NvdW50U2VlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlZWRBc0J5dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFNlZWRCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQoc2VlZEFzQnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHJlY29yZC5pZCxcbiAgICAgICAgICAgICAgICBub25jZTogcmVjb3JkLm5vbmNlLFxuICAgICAgICAgICAgICAgIHZhdWx0Um9vdDogcmVjb3JkLnZhdWx0Um9vdCwgLy8gRmFsbGJhY2sgaWYgbWlzc2luZ1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VSb290OiByZWNvcmQuc3RvcmFnZVJvb3QgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBjb2RlUm9vdDogcmVjb3JkLmNvZGVSb290IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgYWNjb3VudFNlZWQ6IGFjY291bnRTZWVkQmFzZTY0LCAvLyBudWxsIG9yIGJhc2U2NCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsb2NrZWQ6IHJlY29yZC5sb2NrZWQsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkOiByZWNvcmQuY29tbWl0dGVkLCAvLyBVc2UgYWN0dWFsIHZhbHVlIG9yIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBhY2NvdW50Q29tbWl0bWVudDogcmVjb3JkLmFjY291bnRDb21taXRtZW50IHx8IFwiXCIsIC8vIEtlZXAgb3JpZ2luYWwgZmllbGQgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0T2JqZWN0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJFcnJvciB3aGlsZSBmZXRjaGluZyBhY2NvdW50IGhlYWRlcnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEhlYWRlcihhY2NvdW50SWQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYWNjb3VudHNcbiAgICAgICAgICAgIC53aGVyZShcImlkXCIpXG4gICAgICAgICAgICAuZXF1YWxzKGFjY291bnRJZClcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGlmIChhbGxNYXRjaGluZ1JlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGFjY291bnQgaGVhZGVyIHJlY29yZCBmb3VuZCBmb3IgZ2l2ZW4gSUQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCBub25jZSB0byBCaWdJbnQgYW5kIHNvcnRcbiAgICAgICAgLy8gTm90ZTogVGhpcyBhc3N1bWVzIGFsbCBub25jZXMgYXJlIHZhbGlkIEJpZ0ludCBzdHJpbmdzLlxuICAgICAgICBjb25zdCBzb3J0ZWRSZWNvcmRzID0gYWxsTWF0Y2hpbmdSZWNvcmRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludEEgPSBCaWdJbnQoYS5ub25jZSk7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnRCID0gQmlnSW50KGIubm9uY2UpO1xuICAgICAgICAgICAgcmV0dXJuIGJpZ0ludEEgPiBiaWdJbnRCID8gLTEgOiBiaWdJbnRBIDwgYmlnSW50QiA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHJlY29yZCBpcyB0aGUgbW9zdCByZWNlbnQgb25lIGR1ZSB0byB0aGUgc29ydGluZ1xuICAgICAgICBjb25zdCBtb3N0UmVjZW50UmVjb3JkID0gc29ydGVkUmVjb3Jkc1swXTtcbiAgICAgICAgaWYgKG1vc3RSZWNlbnRSZWNvcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjY291bnRTZWVkQmFzZTY0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobW9zdFJlY2VudFJlY29yZC5hY2NvdW50U2VlZCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFjY291bnRTZWVkIGlzIHByb2Nlc3NlZCBhcyBhIFVpbnQ4QXJyYXkgYW5kIGNvbnZlcnRlZCB0byBCYXNlNjRcbiAgICAgICAgICAgIGlmIChtb3N0UmVjZW50UmVjb3JkLmFjY291bnRTZWVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50U2VlZEJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChtb3N0UmVjZW50UmVjb3JkLmFjY291bnRTZWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBBY2NvdW50SGVhZGVyID0ge1xuICAgICAgICAgICAgaWQ6IG1vc3RSZWNlbnRSZWNvcmQuaWQsXG4gICAgICAgICAgICBub25jZTogbW9zdFJlY2VudFJlY29yZC5ub25jZSxcbiAgICAgICAgICAgIHZhdWx0Um9vdDogbW9zdFJlY2VudFJlY29yZC52YXVsdFJvb3QsXG4gICAgICAgICAgICBzdG9yYWdlUm9vdDogbW9zdFJlY2VudFJlY29yZC5zdG9yYWdlUm9vdCxcbiAgICAgICAgICAgIGNvZGVSb290OiBtb3N0UmVjZW50UmVjb3JkLmNvZGVSb290LFxuICAgICAgICAgICAgYWNjb3VudFNlZWQ6IGFjY291bnRTZWVkQmFzZTY0LFxuICAgICAgICAgICAgbG9ja2VkOiBtb3N0UmVjZW50UmVjb3JkLmxvY2tlZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRIZWFkZXI7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3Igd2hpbGUgZmV0Y2hpbmcgYWNjb3VudCBoZWFkZXIgZm9yIGlkOiAke2FjY291bnRJZH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50SGVhZGVyQnlDb21taXRtZW50KGFjY291bnRDb21taXRtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGNvbW1pdG1lbnRcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYWNjb3VudHNcbiAgICAgICAgICAgIC53aGVyZShcImFjY291bnRDb21taXRtZW50XCIpXG4gICAgICAgICAgICAuZXF1YWxzKGFjY291bnRDb21taXRtZW50KVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKGFsbE1hdGNoaW5nUmVjb3Jkcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgb25seSBvbmUgbWF0Y2hcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdSZWNvcmQgPSBhbGxNYXRjaGluZ1JlY29yZHNbMF07XG4gICAgICAgIGlmIChtYXRjaGluZ1JlY29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGFjY291bnQgaGVhZGVyIHJlY29yZCBmb3VuZCBmb3IgZ2l2ZW4gY29tbWl0bWVudC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWNjb3VudFNlZWRCYXNlNjQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXRjaGluZ1JlY29yZC5hY2NvdW50U2VlZCkge1xuICAgICAgICAgICAgYWNjb3VudFNlZWRCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobWF0Y2hpbmdSZWNvcmQuYWNjb3VudFNlZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEFjY291bnRIZWFkZXIgPSB7XG4gICAgICAgICAgICBpZDogbWF0Y2hpbmdSZWNvcmQuaWQsXG4gICAgICAgICAgICBub25jZTogbWF0Y2hpbmdSZWNvcmQubm9uY2UsXG4gICAgICAgICAgICB2YXVsdFJvb3Q6IG1hdGNoaW5nUmVjb3JkLnZhdWx0Um9vdCxcbiAgICAgICAgICAgIHN0b3JhZ2VSb290OiBtYXRjaGluZ1JlY29yZC5zdG9yYWdlUm9vdCxcbiAgICAgICAgICAgIGNvZGVSb290OiBtYXRjaGluZ1JlY29yZC5jb2RlUm9vdCxcbiAgICAgICAgICAgIGFjY291bnRTZWVkOiBhY2NvdW50U2VlZEJhc2U2NCxcbiAgICAgICAgICAgIGxvY2tlZDogbWF0Y2hpbmdSZWNvcmQubG9ja2VkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWNjb3VudEhlYWRlcjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBmZXRjaGluZyBhY2NvdW50IGhlYWRlciBmb3IgY29tbWl0bWVudCAke2FjY291bnRDb21taXRtZW50fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRDb2RlKGNvZGVSb290KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHJvb3RcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYWNjb3VudENvZGVzXG4gICAgICAgICAgICAud2hlcmUoXCJyb290XCIpXG4gICAgICAgICAgICAuZXF1YWxzKGNvZGVSb290KVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHJlY29yZCBpcyB0aGUgb25seSBvbmUgZHVlIHRvIHRoZSB1bmlxdWVuZXNzIGNvbnN0cmFpbnRcbiAgICAgICAgY29uc3QgY29kZVJlY29yZCA9IGFsbE1hdGNoaW5nUmVjb3Jkc1swXTtcbiAgICAgICAgaWYgKGNvZGVSZWNvcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyByZWNvcmRzIGZvdW5kIGZvciBnaXZlbiBjb2RlIHJvb3QuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCB0aGUgY29kZSBCbG9iIHRvIGFuIEFycmF5QnVmZmVyXG4gICAgICAgIGNvbnN0IGNvZGVCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQoY29kZVJlY29yZC5jb2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6IGNvZGVSZWNvcmQucm9vdCxcbiAgICAgICAgICAgIGNvZGU6IGNvZGVCYXNlNjQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgZmV0Y2hpbmcgYWNjb3VudCBjb2RlIGZvciByb290ICR7Y29kZVJvb3R9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudFN0b3JhZ2Uoc3RvcmFnZUNvbW1pdG1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBhY2NvdW50U3RvcmFnZXNcbiAgICAgICAgICAgIC53aGVyZShcImNvbW1pdG1lbnRcIilcbiAgICAgICAgICAgIC5lcXVhbHMoc3RvcmFnZUNvbW1pdG1lbnQpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBzbG90cyA9IGFsbE1hdGNoaW5nUmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzbG90SW5kZXg6IHJlY29yZC5zbG90SW5kZXgsXG4gICAgICAgICAgICAgICAgc2xvdFZhbHVlOiByZWNvcmQuc2xvdFZhbHVlLFxuICAgICAgICAgICAgICAgIHNsb3RUeXBlOiByZWNvcmQuc2xvdFR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNsb3RzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGZldGNoaW5nIGFjY291bnQgc3RvcmFnZSBmb3IgY29tbWl0bWVudCAke3N0b3JhZ2VDb21taXRtZW50fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRTdG9yYWdlTWFwcyhyb290cykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IHN0b3JhZ2VNYXBFbnRyaWVzXG4gICAgICAgICAgICAud2hlcmUoXCJyb290XCIpXG4gICAgICAgICAgICAuYW55T2Yocm9vdHMpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gYWxsTWF0Y2hpbmdSZWNvcmRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGZldGNoaW5nIGFjY291bnQgc3RvcmFnZSBtYXBzIGZvciByb290cyAke3Jvb3RzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50VmF1bHRBc3NldHModmF1bHRSb290KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHJvb3RcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYWNjb3VudEFzc2V0c1xuICAgICAgICAgICAgLndoZXJlKFwicm9vdFwiKVxuICAgICAgICAgICAgLmVxdWFscyh2YXVsdFJvb3QpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICAvLyBNYXAgdGhlIHJlY29yZHMgdG8gdGhlaXIgYXNzZXQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IGFsbE1hdGNoaW5nUmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhc3NldDogcmVjb3JkLmFzc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhc3NldHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgZmV0Y2hpbmcgYWNjb3VudCB2YXVsdCBmb3Igcm9vdCAke3ZhdWx0Um9vdH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50QXV0aEJ5UHViS2V5KHB1YktleSkge1xuICAgIC8vIFRyeSB0byBnZXQgdGhlIGFjY291bnQgYXV0aCBmcm9tIHRoZSBzdG9yZVxuICAgIGNvbnN0IGFjY291bnRTZWNyZXRLZXkgPSBhd2FpdCBhY2NvdW50QXV0aHNcbiAgICAgICAgLndoZXJlKFwicHViS2V5XCIpXG4gICAgICAgIC5lcXVhbHMocHViS2V5KVxuICAgICAgICAuZmlyc3QoKTtcbiAgICAvLyBJZiBpdCdzIG5vdCBpbiB0aGUgY2FjaGUsIHRocm93IGFuIGVycm9yXG4gICAgaWYgKCFhY2NvdW50U2VjcmV0S2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgYXV0aCBub3QgZm91bmQgaW4gY2FjaGUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBzZWNyZXRLZXk6IGFjY291bnRTZWNyZXRLZXkuc2VjcmV0S2V5LFxuICAgIH07XG4gICAgcmV0dXJuIGRhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50QWRkcmVzc2VzKGFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiBhY2NvdW50SWRcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgYWRkcmVzc2VzXG4gICAgICAgICAgICAud2hlcmUoXCJpZFwiKVxuICAgICAgICAgICAgLmVxdWFscyhhY2NvdW50SWQpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBpZiAoYWxsTWF0Y2hpbmdSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBhZGRyZXNzIHJlY29yZHMgZm91bmQgZm9yIGdpdmVuIGFjY291bnQgSUQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxNYXRjaGluZ1JlY29yZHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3Igd2hpbGUgZmV0Y2hpbmcgYWNjb3VudCBhZGRyZXNzZXMgZm9yIGlkOiAke2FjY291bnRJZH1gKTtcbiAgICB9XG59XG4vLyBJTlNFUlQgRlVOQ1RJT05TXG5hc3luYyBmdW5jdGlvbiB1cHNlcnRBY2NvdW50Q29kZShjb2RlUm9vdCwgY29kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGRhdGEgb2JqZWN0IHRvIGluc2VydFxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcm9vdDogY29kZVJvb3QsIC8vIFVzaW5nIGNvZGVSb290IGFzIHRoZSBrZXlcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluc2VydCB1c2luZyBEZXhpZVxuICAgICAgICBhd2FpdCBhY2NvdW50Q29kZXMucHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBjb2RlIHdpdGggcm9vdDogJHtjb2RlUm9vdH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRBY2NvdW50U3RvcmFnZShzdG9yYWdlU2xvdHMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvY2Vzc2VkU2xvdHMgPSBzdG9yYWdlU2xvdHMubWFwKChzbG90KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IHNsb3QuY29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICBzbG90SW5kZXg6IHNsb3Quc2xvdEluZGV4LFxuICAgICAgICAgICAgICAgIHNsb3RWYWx1ZTogc2xvdC5zbG90VmFsdWUsXG4gICAgICAgICAgICAgICAgc2xvdFR5cGU6IHNsb3Quc2xvdFR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgYWNjb3VudFN0b3JhZ2VzLmJ1bGtQdXQocHJvY2Vzc2VkU2xvdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBzdG9yYWdlIHNsb3RzYCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0U3RvcmFnZU1hcEVudHJpZXMoZW50cmllcykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm9jZXNzZWRFbnRyaWVzID0gZW50cmllcy5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvb3Q6IGVudHJ5LnJvb3QsXG4gICAgICAgICAgICAgICAga2V5OiBlbnRyeS5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2VNYXBFbnRyaWVzLmJ1bGtQdXQocHJvY2Vzc2VkRW50cmllcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIHN0b3JhZ2UgbWFwIGVudHJpZXNgKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRWYXVsdEFzc2V0cyhhc3NldHMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvY2Vzc2VkQXNzZXRzID0gYXNzZXRzLm1hcCgoYXNzZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm9vdDogYXNzZXQucm9vdCxcbiAgICAgICAgICAgICAgICB2YXVsdEtleTogYXNzZXQudmF1bHRLZXksXG4gICAgICAgICAgICAgICAgZmF1Y2V0SWRQcmVmaXg6IGFzc2V0LmZhdWNldElkUHJlZml4LFxuICAgICAgICAgICAgICAgIGFzc2V0OiBhc3NldC5hc3NldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBhY2NvdW50QXNzZXRzLmJ1bGtQdXQocHJvY2Vzc2VkQXNzZXRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgYXNzZXRzYCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0QWNjb3VudFJlY29yZChhY2NvdW50SWQsIGNvZGVSb290LCBzdG9yYWdlUm9vdCwgdmF1bHRSb290LCBub25jZSwgY29tbWl0dGVkLCBjb21taXRtZW50LCBhY2NvdW50U2VlZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBpZDogYWNjb3VudElkLFxuICAgICAgICAgICAgY29kZVJvb3QsXG4gICAgICAgICAgICBzdG9yYWdlUm9vdCxcbiAgICAgICAgICAgIHZhdWx0Um9vdCxcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgY29tbWl0dGVkLFxuICAgICAgICAgICAgYWNjb3VudFNlZWQsXG4gICAgICAgICAgICBhY2NvdW50Q29tbWl0bWVudDogY29tbWl0bWVudCxcbiAgICAgICAgICAgIGxvY2tlZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IGFjY291bnRzLnB1dChkYXRhKTtcbiAgICAgICAgYXdhaXQgdHJhY2tlZEFjY291bnRzLnB1dCh7IGlkOiBhY2NvdW50SWQgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIGFjY291bnQ6ICR7YWNjb3VudElkfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluc2VydEFjY291bnRBdXRoKHB1YktleSwgc2VjcmV0S2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgZGF0YSBvYmplY3QgdG8gaW5zZXJ0XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBwdWJLZXk6IHB1YktleSxcbiAgICAgICAgICAgIHNlY3JldEtleTogc2VjcmV0S2V5LFxuICAgICAgICB9O1xuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbnNlcnQgdXNpbmcgRGV4aWVcbiAgICAgICAgYXdhaXQgYWNjb3VudEF1dGhzLmFkZChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgYWNjb3VudCBhdXRoIGZvciBwdWJLZXk6ICR7cHViS2V5fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluc2VydEFjY291bnRBZGRyZXNzKGFkZHJlc3MsIGFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGRhdGEgb2JqZWN0IHRvIGluc2VydFxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGlkOiBhY2NvdW50SWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluc2VydCB1c2luZyBEZXhpZVxuICAgICAgICBhd2FpdCBhZGRyZXNzZXMucHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBhZGRyZXNzIHdpdGggdmFsdWU6ICR7U3RyaW5nKGFkZHJlc3MpfSBmb3IgdGhlIGFjY291bnQgSUQgJHthY2NvdW50SWR9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlQWNjb3VudEFkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGRlbGV0ZSB1c2luZyBEZXhpZVxuICAgICAgICBhd2FpdCBhZGRyZXNzZXMud2hlcmUoXCJhZGRyZXNzXCIpLmVxdWFscyhhZGRyZXNzKS5kZWxldGUoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciByZW1vdmluZyBhZGRyZXNzIHdpdGggdmFsdWU6ICR7U3RyaW5nKGFkZHJlc3MpfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydEZvcmVpZ25BY2NvdW50Q29kZShhY2NvdW50SWQsIGNvZGUsIGNvZGVSb290KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdXBzZXJ0QWNjb3VudENvZGUoY29kZVJvb3QsIGNvZGUpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgICAgY29kZVJvb3QsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IGZvcmVpZ25BY2NvdW50Q29kZS5wdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgdXBzZXJ0aW5nIGZvcmVpZ24gYWNjb3VudCBjb2RlIGZvciBhY2NvdW50OiAke2FjY291bnRJZH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRGb3JlaWduQWNjb3VudENvZGUoYWNjb3VudElkcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZvcmVpZ25BY2NvdW50cyA9IGF3YWl0IGZvcmVpZ25BY2NvdW50Q29kZVxuICAgICAgICAgICAgLndoZXJlKFwiYWNjb3VudElkXCIpXG4gICAgICAgICAgICAuYW55T2YoYWNjb3VudElkcylcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGlmIChmb3JlaWduQWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHJlY29yZHMgZm91bmQgZm9yIHRoZSBnaXZlbiBhY2NvdW50IElEcy5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gTm8gcmVjb3JkcyBmb3VuZFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVSb290cyA9IGZvcmVpZ25BY2NvdW50cy5tYXAoKGFjY291bnQpID0+IGFjY291bnQuY29kZVJvb3QpO1xuICAgICAgICBjb25zdCBhY2NvdW50Q29kZSA9IGF3YWl0IGFjY291bnRDb2Rlc1xuICAgICAgICAgICAgLndoZXJlKFwicm9vdFwiKVxuICAgICAgICAgICAgLmFueU9mKGNvZGVSb290cylcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZENvZGUgPSBmb3JlaWduQWNjb3VudHNcbiAgICAgICAgICAgIC5tYXAoKGZvcmVpZ25BY2NvdW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvZGUgPSBhY2NvdW50Q29kZS5maW5kKChjb2RlKSA9PiBjb2RlLnJvb3QgPT09IGZvcmVpZ25BY2NvdW50LmNvZGVSb290KTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0NvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2RlQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG1hdGNoaW5nQ29kZS5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWNjb3VudElkOiBmb3JlaWduQWNjb3VudC5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgY29kZTogY29kZUJhc2U2NCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChtYXRjaGluZ0NvZGUpID0+IG1hdGNoaW5nQ29kZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZENvZGU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkVycm9yIGZldGNoaW5nIGZvcmVpZ24gYWNjb3VudCBjb2RlXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxvY2tBY2NvdW50KGFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGFjY291bnRzLndoZXJlKFwiaWRcIikuZXF1YWxzKGFjY291bnRJZCkubW9kaWZ5KHsgbG9ja2VkOiB0cnVlIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGxvY2tpbmcgYWNjb3VudDogJHthY2NvdW50SWR9YCk7XG4gICAgfVxufVxuLy8gRGVsZXRlIGZ1bmN0aW9uc1xuYXN5bmMgZnVuY3Rpb24gdW5kb0FjY291bnRTdGF0ZXMoYWNjb3VudENvbW1pdG1lbnRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYWNjb3VudHNcbiAgICAgICAgICAgIC53aGVyZShcImFjY291bnRDb21taXRtZW50XCIpXG4gICAgICAgICAgICAuYW55T2YoYWNjb3VudENvbW1pdG1lbnRzKVxuICAgICAgICAgICAgLmRlbGV0ZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIHVuZG9pbmcgYWNjb3VudCBzdGF0ZXM6ICR7YWNjb3VudENvbW1pdG1lbnRzLmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbn1cblxuLy8gSU5TRVJUIEZVTkNUSU9OU1xuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0QmxvY2tIZWFkZXIoYmxvY2tOdW0sIGhlYWRlciwgcGFydGlhbEJsb2NrY2hhaW5QZWFrcywgaGFzQ2xpZW50Tm90ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYmxvY2tOdW06IGJsb2NrTnVtLFxuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgcGFydGlhbEJsb2NrY2hhaW5QZWFrcyxcbiAgICAgICAgICAgIGhhc0NsaWVudE5vdGVzOiBoYXNDbGllbnROb3Rlcy50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleGlzdGluZ0Jsb2NrSGVhZGVyID0gYXdhaXQgYmxvY2tIZWFkZXJzLmdldChibG9ja051bSk7XG4gICAgICAgIGlmICghZXhpc3RpbmdCbG9ja0hlYWRlcikge1xuICAgICAgICAgICAgYXdhaXQgYmxvY2tIZWFkZXJzLmFkZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmxvY2sgaGVhZGVyIGFscmVhZHkgZXhpc3RzLCBjaGVja2luZyBmb3IgdXBkYXRlLlwiKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzQ2xpZW50Tm90ZXMgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIGZhbHNlXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdCbG9ja0hlYWRlci5oYXNDbGllbnROb3RlcyA9PT0gXCJmYWxzZVwiICYmIGhhc0NsaWVudE5vdGVzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmxvY2tIZWFkZXJzLnVwZGF0ZShibG9ja051bSwge1xuICAgICAgICAgICAgICAgICAgICBoYXNDbGllbnROb3RlczogaGFzQ2xpZW50Tm90ZXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgaGFzQ2xpZW50Tm90ZXMgdG8gdHJ1ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHVwZGF0ZSBuZWVkZWQgZm9yIGhhc0NsaWVudE5vdGVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbnNlcnRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKGlkcywgbm9kZXMpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJyYXlzIGFyZSBub3Qgb2YgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgIGlmIChpZHMubGVuZ3RoICE9PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlkcyBhbmQgbm9kZXMgYXJyYXlzIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGFycmF5IG9mIG9iamVjdHMgd2l0aCBpZCBhbmQgbm9kZVxuICAgICAgICBjb25zdCBkYXRhID0gbm9kZXMubWFwKChub2RlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIGlkOiBpZHNbaW5kZXhdLFxuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBVc2UgYnVsa1B1dCB0byBhZGQvb3ZlcndyaXRlIHRoZSBlbnRyaWVzXG4gICAgICAgIGF3YWl0IHBhcnRpYWxCbG9ja2NoYWluTm9kZXMuYnVsa1B1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gaW5zZXJ0IHBhcnRpYWwgYmxvY2tjaGFpbiBub2Rlc1wiKTtcbiAgICB9XG59XG4vLyBHRVQgRlVOQ1RJT05TXG5hc3luYyBmdW5jdGlvbiBnZXRCbG9ja0hlYWRlcnMoYmxvY2tOdW1iZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGJsb2NrSGVhZGVycy5idWxrR2V0KGJsb2NrTnVtYmVycyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChyZXN1bHQuaGVhZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHJlc3VsdC5wYXJ0aWFsQmxvY2tjaGFpblBlYWtzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bTogcmVzdWx0LmJsb2NrTnVtLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGhlYWRlckJhc2U2NCxcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbEJsb2NrY2hhaW5QZWFrczogcGFydGlhbEJsb2NrY2hhaW5QZWFrc0Jhc2U2NCxcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2xpZW50Tm90ZXM6IHJlc3VsdC5oYXNDbGllbnROb3RlcyA9PT0gXCJ0cnVlXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkUmVzdWx0cztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IGJsb2NrIGhlYWRlcnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0VHJhY2tlZEJsb2NrSGVhZGVycygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4gcm9vdFxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBibG9ja0hlYWRlcnNcbiAgICAgICAgICAgIC53aGVyZShcImhhc0NsaWVudE5vdGVzXCIpXG4gICAgICAgICAgICAuZXF1YWxzKFwidHJ1ZVwiKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhbGwgcmVjb3JkcyB3aXRoIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkUmVjb3JkcyA9IGF3YWl0IFByb21pc2UuYWxsKGFsbE1hdGNoaW5nUmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHJlY29yZC5oZWFkZXIpO1xuICAgICAgICAgICAgY29uc3QgcGFydGlhbEJsb2NrY2hhaW5QZWFrc0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChyZWNvcmQucGFydGlhbEJsb2NrY2hhaW5QZWFrcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtOiByZWNvcmQuYmxvY2tOdW0sXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBoZWFkZXJCYXNlNjQsXG4gICAgICAgICAgICAgICAgcGFydGlhbEJsb2NrY2hhaW5QZWFrczogcGFydGlhbEJsb2NrY2hhaW5QZWFrc0Jhc2U2NCxcbiAgICAgICAgICAgICAgICBoYXNDbGllbnROb3RlczogcmVjb3JkLmhhc0NsaWVudE5vdGVzID09PSBcInRydWVcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZFJlY29yZHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCB0cmFja2VkIGJsb2NrIGhlYWRlcnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UGFydGlhbEJsb2NrY2hhaW5QZWFrc0J5QmxvY2tOdW0oYmxvY2tOdW0pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9ja0hlYWRlciA9IGF3YWl0IGJsb2NrSGVhZGVycy5nZXQoYmxvY2tOdW0pO1xuICAgICAgICBpZiAoYmxvY2tIZWFkZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBlYWtzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpYWxCbG9ja2NoYWluUGVha3NCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQoYmxvY2tIZWFkZXIucGFydGlhbEJsb2NrY2hhaW5QZWFrcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZWFrczogcGFydGlhbEJsb2NrY2hhaW5QZWFrc0Jhc2U2NCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IHBhcnRpYWwgYmxvY2tjaGFpbiBwZWFrc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzQWxsKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxCbG9ja2NoYWluTm9kZXNBbGwgPSBhd2FpdCBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWxCbG9ja2NoYWluTm9kZXNBbGw7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBwYXJ0aWFsIGJsb2NrY2hhaW4gbm9kZXNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UGFydGlhbEJsb2NrY2hhaW5Ob2RlcyhpZHMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGFydGlhbEJsb2NrY2hhaW5Ob2Rlcy5idWxrR2V0KGlkcyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgcGFydGlhbCBibG9ja2NoYWluIG5vZGVzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHBydW5lSXJyZWxldmFudEJsb2NrcygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzeW5jSGVpZ2h0ID0gYXdhaXQgc3RhdGVTeW5jLmdldCgxKTtcbiAgICAgICAgaWYgKHN5bmNIZWlnaHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlN5bmNIZWlnaHQgaXMgdW5kZWZpbmVkIC0tIGlzIHRoZSBzdGF0ZSBzeW5jIHRhYmxlIGVtcHR5P1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBibG9ja0hlYWRlcnNcbiAgICAgICAgICAgIC53aGVyZShcImhhc0NsaWVudE5vdGVzXCIpXG4gICAgICAgICAgICAuZXF1YWxzKFwiZmFsc2VcIilcbiAgICAgICAgICAgIC5hbmQoKHJlY29yZCkgPT4gcmVjb3JkLmJsb2NrTnVtICE9PSBcIjBcIiAmJiByZWNvcmQuYmxvY2tOdW0gIT09IHN5bmNIZWlnaHQuYmxvY2tOdW0pXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBhd2FpdCBibG9ja0hlYWRlcnMuYnVsa0RlbGV0ZShhbGxNYXRjaGluZ1JlY29yZHMubWFwKChyKSA9PiByLmJsb2NrTnVtKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIHBydW5lIGlycmVsZXZhbnQgYmxvY2tzXCIpO1xuICAgIH1cbn1cblxuLy8gRGlzYWJsaW5nIGBhbnlgIGNoZWNrcyBzaW5jZSB0aGlzIGZpbGUgbW9zdGx5IGRlYWxzIHdpdGggZXhwb3J0aW5nIERCIHR5cGVzLlxuLyogZXNsaW50LWRpc2FibGUgIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qIGVzbGludC1kaXNhYmxlICBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAqL1xuLyogZXNsaW50LWRpc2FibGUgIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAqL1xuYXN5bmMgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JFeHBvcnQob2JqKSB7XG4gICAgc3dpdGNoIChvYmoudHlwZSkge1xuICAgICAgICBjYXNlIFwiVWludDhBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIkJsb2JcIjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX190eXBlOiBcIkJsb2JcIixcbiAgICAgICAgICAgICAgICBkYXRhOiB1aW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoYXdhaXQgb2JqLnZhbHVlLmFycmF5QnVmZmVyKCkpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKG9iai52YWx1ZS5tYXAoKHYpID0+IHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9yRXhwb3J0KHsgdHlwZTogZ2V0SW5wdXRUeXBlKHYpLCB2YWx1ZTogdiB9KSkpO1xuICAgICAgICBjYXNlIFwiUmVjb3JkXCI6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKG9iai52YWx1ZSkubWFwKGFzeW5jIChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JFeHBvcnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXRJbnB1dFR5cGUodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pKSk7XG4gICAgICAgIGNhc2UgXCJQcmltaXRpdmVcIjpcbiAgICAgICAgICAgIHJldHVybiBvYmoudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIFwiVWludDhBcnJheVwiO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpXG4gICAgICAgIHJldHVybiBcIkJsb2JcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIFwiUmVjb3JkXCI7XG4gICAgcmV0dXJuIFwiUHJpbWl0aXZlXCI7XG59XG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm1Gb3JFeHBvcnQob2JqKSB7XG4gICAgcmV0dXJuIHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9yRXhwb3J0KHsgdHlwZTogZ2V0SW5wdXRUeXBlKG9iaiksIHZhbHVlOiBvYmogfSk7XG59XG5hc3luYyBmdW5jdGlvbiBleHBvcnRTdG9yZSgpIHtcbiAgICBjb25zdCBkYkpzb24gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlIG9mIGRiLnRhYmxlcykge1xuICAgICAgICBjb25zdCByZWNvcmRzID0gYXdhaXQgdGFibGUudG9BcnJheSgpO1xuICAgICAgICBkYkpzb25bdGFibGUubmFtZV0gPSBhd2FpdCBQcm9taXNlLmFsbChyZWNvcmRzLm1hcCh0cmFuc2Zvcm1Gb3JFeHBvcnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRiSnNvbik7XG59XG5cbi8vIERpc2FibGluZyBgYW55YCBjaGVja3Mgc2luY2UgdGhpcyBmaWxlIG1vc3RseSBkZWFsc1xuLy8gd2l0aCBpbXBvcnRpbmcgREIgdHlwZXMgYW5kIHdlJ3JlIHRlc3RpbmcgdGhpcyB3aGljaFxuLy8gc2hvdWxkIGJlIGVub3VnaCArIHRoZSBUUyBjb21waWxlci5cbi8qIGVzbGludC1kaXNhYmxlICovXG5hc3luYyBmdW5jdGlvbiByZWN1cnNpdmVseVRyYW5zZm9ybUZvckltcG9ydChvYmopIHtcbiAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJCbG9iXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2Jhc2U2NFRvVWludDhBcnJheShvYmoudmFsdWUuZGF0YSldKTtcbiAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwob2JqLnZhbHVlLm1hcCgodikgPT4gcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JJbXBvcnQoeyB0eXBlOiBnZXRJbXBvcnRUeXBlKHYpLCB2YWx1ZTogdiB9KSkpO1xuICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKG9iai52YWx1ZSkubWFwKGFzeW5jIChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JJbXBvcnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXRJbXBvcnRUeXBlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKSkpO1xuICAgICAgICBjYXNlIFwiUHJpbWl0aXZlXCI6XG4gICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEltcG9ydFR5cGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLl9fdHlwZSA9PT0gXCJCbG9iXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiQmxvYlwiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCI7XG4gICAgcmV0dXJuIFwiUHJpbWl0aXZlXCI7XG59XG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm1Gb3JJbXBvcnQob2JqKSB7XG4gICAgcmV0dXJuIHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9ySW1wb3J0KHtcbiAgICAgICAgdHlwZTogZ2V0SW1wb3J0VHlwZShvYmopLFxuICAgICAgICB2YWx1ZTogb2JqLFxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZm9yY2VJbXBvcnRTdG9yZShqc29uU3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFkYi5pc09wZW4pIHtcbiAgICAgICAgICAgIGF3YWl0IG9wZW5EYXRhYmFzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYkpzb24gPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICBpZiAodHlwZW9mIGRiSnNvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGJKc29uID0gSlNPTi5wYXJzZShkYkpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb25UYWJsZU5hbWVzID0gT2JqZWN0LmtleXMoZGJKc29uKTtcbiAgICAgICAgY29uc3QgZGJUYWJsZU5hbWVzID0gZGIudGFibGVzLm1hcCgodCkgPT4gdC5uYW1lKTtcbiAgICAgICAgaWYgKGpzb25UYWJsZU5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGFibGVzIGZvdW5kIGluIHRoZSBwcm92aWRlZCBKU09OLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBkYi50cmFuc2FjdGlvbihcInJ3XCIsIGRiVGFibGVOYW1lcywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGIudGFibGVzLm1hcCgodCkgPT4gdC5jbGVhcigpKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiBqc29uVGFibGVOYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gZGIudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRiVGFibGVOYW1lcy5pbmNsdWRlcyh0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGFibGUgXCIke3RhYmxlTmFtZX1cIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZGF0YWJhc2Ugc2NoZW1hLiBTa2lwcGluZy5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSBkYkpzb25bdGFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFJlY29yZHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZWNvcmRzLm1hcCh0cmFuc2Zvcm1Gb3JJbXBvcnQpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0YWJsZS5idWxrUHV0KHRyYW5zZm9ybWVkUmVjb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN0b3JlIGltcG9ydGVkIHN1Y2Nlc3NmdWxseS5cIik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjQpIHtcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE91dHB1dE5vdGVzKHN0YXRlcykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3RlcyA9IHN0YXRlcy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgPyBhd2FpdCBvdXRwdXROb3Rlcy50b0FycmF5KClcbiAgICAgICAgICAgIDogYXdhaXQgb3V0cHV0Tm90ZXMud2hlcmUoXCJzdGF0ZURpc2NyaW1pbmFudFwiKS5hbnlPZihzdGF0ZXMpLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NPdXRwdXROb3Rlcyhub3Rlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBvdXRwdXQgbm90ZXNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5wdXROb3RlcyhzdGF0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgbm90ZXM7XG4gICAgICAgIGlmIChzdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBub3RlcyA9IGF3YWl0IGlucHV0Tm90ZXMudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm90ZXMgPSBhd2FpdCBpbnB1dE5vdGVzXG4gICAgICAgICAgICAgICAgLndoZXJlKFwic3RhdGVEaXNjcmltaW5hbnRcIilcbiAgICAgICAgICAgICAgICAuYW55T2Yoc3RhdGVzKVxuICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NJbnB1dE5vdGVzKG5vdGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IGlucHV0IG5vdGVzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldElucHV0Tm90ZXNGcm9tSWRzKG5vdGVJZHMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgbm90ZXMgPSBhd2FpdCBpbnB1dE5vdGVzLndoZXJlKFwibm90ZUlkXCIpLmFueU9mKG5vdGVJZHMpLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NJbnB1dE5vdGVzKG5vdGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IGlucHV0IG5vdGVzIGZyb20gSURzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldElucHV0Tm90ZXNGcm9tTnVsbGlmaWVycyhudWxsaWZpZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG5vdGVzID0gYXdhaXQgaW5wdXROb3Rlcy53aGVyZShcIm51bGxpZmllclwiKS5hbnlPZihudWxsaWZpZXJzKS50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzSW5wdXROb3Rlcyhub3Rlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBpbnB1dCBub3RlcyBmcm9tIG51bGxpZmllcnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0T3V0cHV0Tm90ZXNGcm9tTnVsbGlmaWVycyhudWxsaWZpZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG5vdGVzID0gYXdhaXQgb3V0cHV0Tm90ZXNcbiAgICAgICAgICAgIC53aGVyZShcIm51bGxpZmllclwiKVxuICAgICAgICAgICAgLmFueU9mKG51bGxpZmllcnMpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc091dHB1dE5vdGVzKG5vdGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IG91dHB1dCBub3RlcyBmcm9tIG51bGxpZmllcnNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0T3V0cHV0Tm90ZXNGcm9tSWRzKG5vdGVJZHMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgbm90ZXMgPSBhd2FpdCBvdXRwdXROb3Rlcy53aGVyZShcIm5vdGVJZFwiKS5hbnlPZihub3RlSWRzKS50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzT3V0cHV0Tm90ZXMobm90ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgb3V0cHV0IG5vdGVzIGZyb20gSURzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFVuc3BlbnRJbnB1dE5vdGVOdWxsaWZpZXJzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5vdGVzID0gYXdhaXQgaW5wdXROb3Rlc1xuICAgICAgICAgICAgLndoZXJlKFwic3RhdGVEaXNjcmltaW5hbnRcIilcbiAgICAgICAgICAgIC5hbnlPZihbMiwgNCwgNV0pXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gbm90ZXMubWFwKChub3RlKSA9PiBub3RlLm51bGxpZmllcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCB1bnNwZW50IGlucHV0IG5vdGUgbnVsbGlmaWVyc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXROb3RlU2NyaXB0KHNjcmlwdFJvb3QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBub3RlU2NyaXB0ID0gYXdhaXQgbm90ZXNTY3JpcHRzXG4gICAgICAgICAgICAud2hlcmUoXCJzY3JpcHRSb290XCIpXG4gICAgICAgICAgICAuZXF1YWxzKHNjcmlwdFJvb3QpXG4gICAgICAgICAgICAuZmlyc3QoKTtcbiAgICAgICAgcmV0dXJuIG5vdGVTY3JpcHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBub3RlIHNjcmlwdCBmcm9tIHJvb3RcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0SW5wdXROb3RlKG5vdGVJZCwgYXNzZXRzLCBzZXJpYWxOdW1iZXIsIGlucHV0cywgc2NyaXB0Um9vdCwgc2VyaWFsaXplZE5vdGVTY3JpcHQsIG51bGxpZmllciwgc2VyaWFsaXplZENyZWF0ZWRBdCwgc3RhdGVEaXNjcmltaW5hbnQsIHN0YXRlKSB7XG4gICAgcmV0dXJuIGRiLnRyYW5zYWN0aW9uKFwicndcIiwgaW5wdXROb3Rlcywgbm90ZXNTY3JpcHRzLCBhc3luYyAodHgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbm90ZUlkLFxuICAgICAgICAgICAgICAgIGFzc2V0cyxcbiAgICAgICAgICAgICAgICBzZXJpYWxOdW1iZXIsXG4gICAgICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgICAgIHNjcmlwdFJvb3QsXG4gICAgICAgICAgICAgICAgbnVsbGlmaWVyLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHN0YXRlRGlzY3JpbWluYW50LFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRDcmVhdGVkQXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXdhaXQgdHguaW5wdXROb3Rlcy5wdXQoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBub3RlU2NyaXB0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzY3JpcHRSb290LFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb3RlU2NyaXB0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IHR4Lm5vdGVzU2NyaXB0cy5wdXQobm90ZVNjcmlwdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBub3RlOiAke25vdGVJZH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0T3V0cHV0Tm90ZShub3RlSWQsIGFzc2V0cywgcmVjaXBpZW50RGlnZXN0LCBtZXRhZGF0YSwgbnVsbGlmaWVyLCBleHBlY3RlZEhlaWdodCwgc3RhdGVEaXNjcmltaW5hbnQsIHN0YXRlKSB7XG4gICAgcmV0dXJuIGRiLnRyYW5zYWN0aW9uKFwicndcIiwgb3V0cHV0Tm90ZXMsIG5vdGVzU2NyaXB0cywgYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIG5vdGVJZCxcbiAgICAgICAgICAgICAgICBhc3NldHMsXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50RGlnZXN0LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIG51bGxpZmllcjogbnVsbGlmaWVyID8gbnVsbGlmaWVyIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0YXRlRGlzY3JpbWluYW50LFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IHR4Lm91dHB1dE5vdGVzLnB1dChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgbm90ZTogJHtub3RlSWR9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbnB1dE5vdGVzKG5vdGVzKSB7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKG5vdGVzLm1hcChhc3luYyAobm90ZSkgPT4ge1xuICAgICAgICBjb25zdCBhc3NldHNCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5hc3NldHMpO1xuICAgICAgICBjb25zdCBzZXJpYWxOdW1iZXJCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5zZXJpYWxOdW1iZXIpO1xuICAgICAgICBjb25zdCBpbnB1dHNCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5pbnB1dHMpO1xuICAgICAgICBsZXQgc2VyaWFsaXplZE5vdGVTY3JpcHRCYXNlNjQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChub3RlLnNjcmlwdFJvb3QpIHtcbiAgICAgICAgICAgIGxldCByZWNvcmQgPSBhd2FpdCBub3Rlc1NjcmlwdHMuZ2V0KG5vdGUuc2NyaXB0Um9vdCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vdGVTY3JpcHRCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQocmVjb3JkLnNlcmlhbGl6ZWROb3RlU2NyaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzc2V0czogYXNzZXRzQmFzZTY0LFxuICAgICAgICAgICAgc2VyaWFsTnVtYmVyOiBzZXJpYWxOdW1iZXJCYXNlNjQsXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0c0Jhc2U2NCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbm90ZS5zZXJpYWxpemVkQ3JlYXRlZEF0LFxuICAgICAgICAgICAgc2VyaWFsaXplZE5vdGVTY3JpcHQ6IHNlcmlhbGl6ZWROb3RlU2NyaXB0QmFzZTY0LFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlQmFzZTY0LFxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NPdXRwdXROb3Rlcyhub3Rlcykge1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChub3Rlcy5tYXAoKG5vdGUpID0+IHtcbiAgICAgICAgY29uc3QgYXNzZXRzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUuYXNzZXRzKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5tZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHN0YXRlQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUuc3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXNzZXRzOiBhc3NldHNCYXNlNjQsXG4gICAgICAgICAgICByZWNpcGllbnREaWdlc3Q6IG5vdGUucmVjaXBpZW50RGlnZXN0LFxuICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhQmFzZTY0LFxuICAgICAgICAgICAgZXhwZWN0ZWRIZWlnaHQ6IG5vdGUuZXhwZWN0ZWRIZWlnaHQsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVCYXNlNjQsXG4gICAgICAgIH07XG4gICAgfSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0Tm90ZVNjcmlwdChzY3JpcHRSb290LCBzZXJpYWxpemVkTm90ZVNjcmlwdCkge1xuICAgIHJldHVybiBkYi50cmFuc2FjdGlvbihcInJ3XCIsIG91dHB1dE5vdGVzLCBub3Rlc1NjcmlwdHMsIGFzeW5jICh0eCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgbm90ZVNjcmlwdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Um9vdCxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm90ZVNjcmlwdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0eC5ub3Rlc1NjcmlwdHMucHV0KG5vdGVTY3JpcHREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgbm90ZSBzY3JpcHQ6ICR7c2NyaXB0Um9vdH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTZXR0aW5nKGtleSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiBrZXlcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgc2V0dGluZ3NcbiAgICAgICAgICAgIC53aGVyZShcImtleVwiKVxuICAgICAgICAgICAgLmVxdWFscyhrZXkpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBpZiAoYWxsTWF0Y2hpbmdSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBzZXR0aW5nIHJlY29yZCBmb3VuZCBmb3IgZ2l2ZW4ga2V5LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBtYXRjaFxuICAgICAgICBjb25zdCBtYXRjaGluZ1JlY29yZCA9IGFsbE1hdGNoaW5nUmVjb3Jkc1swXTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgc2V0dGluZyB2YWx1ZSB0byBiYXNlNjRcbiAgICAgICAgY29uc3QgdmFsdWVCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobWF0Y2hpbmdSZWNvcmQudmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBtYXRjaGluZ1JlY29yZC5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVCYXNlNjQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3Igd2hpbGUgZmV0Y2hpbmcgc2V0dGluZyBrZXk6ICR7a2V5fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluc2VydFNldHRpbmcoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgc2V0dGluZ3MucHV0KHNldHRpbmcpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBzZXR0aW5nIHdpdGgga2V5OiAke2tleX0gYW5kIHZhbHVlKGJhc2U2NCk6ICR7dWludDhBcnJheVRvQmFzZTY0KHZhbHVlKX1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmVTZXR0aW5nKGtleSkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHNldHRpbmdzLndoZXJlKFwia2V5XCIpLmVxdWFscyhrZXkpLmRlbGV0ZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGRlbGV0aW5nIHNldHRpbmcgd2l0aCBrZXk6ICR7a2V5fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxpc3RTZXR0aW5nS2V5cygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgc2V0dGluZ3NcbiAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgICAgIC50aGVuKChzZXR0aW5ncykgPT4gc2V0dGluZ3MubWFwKChzZXR0aW5nKSA9PiBzZXR0aW5nLmtleSkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBsaXN0aW5nIHNldHRpbmcga2V5c2ApO1xuICAgIH1cbn1cblxuY29uc3QgSURTX0ZJTFRFUl9QUkVGSVggPSBcIklkczpcIjtcbmNvbnN0IEVYUElSRURfQkVGT1JFX0ZJTFRFUl9QUkVGSVggPSBcIkV4cGlyZWRQZW5kaW5nOlwiO1xuY29uc3QgU1RBVFVTX0NPTU1JVFRFRF9WQVJJQU5UID0gMTtcbmNvbnN0IFNUQVRVU19ESVNDQVJERURfVkFSSUFOVCA9IDI7XG5hc3luYyBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbnMoZmlsdGVyKSB7XG4gICAgbGV0IHRyYW5zYWN0aW9uUmVjb3JkcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IFwiVW5jb21taXR0ZWRcIikge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25SZWNvcmRzID0gYXdhaXQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnN0YXR1c1ZhcmlhbnQgIT09IFNUQVRVU19DT01NSVRURURfVkFSSUFOVClcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlci5zdGFydHNXaXRoKElEU19GSUxURVJfUFJFRklYKSkge1xuICAgICAgICAgICAgY29uc3QgaWRzU3RyaW5nID0gZmlsdGVyLnN1YnN0cmluZyhJRFNfRklMVEVSX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgaWRzID0gaWRzU3RyaW5nLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIGlmIChpZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uUmVjb3JkcyA9IGF3YWl0IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUoXCJpZFwiKVxuICAgICAgICAgICAgICAgICAgICAuYW55T2YoaWRzKVxuICAgICAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25SZWNvcmRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyLnN0YXJ0c1dpdGgoRVhQSVJFRF9CRUZPUkVfRklMVEVSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtU3RyaW5nID0gZmlsdGVyLnN1YnN0cmluZyhFWFBJUkVEX0JFRk9SRV9GSUxURVJfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bSA9IHBhcnNlSW50KGJsb2NrTnVtU3RyaW5nKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uUmVjb3JkcyA9IGF3YWl0IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC5ibG9ja051bSA8IGJsb2NrTnVtICYmXG4gICAgICAgICAgICAgICAgdHguc3RhdHVzVmFyaWFudCAhPT0gU1RBVFVTX0NPTU1JVFRFRF9WQVJJQU5UICYmXG4gICAgICAgICAgICAgICAgdHguc3RhdHVzVmFyaWFudCAhPT0gU1RBVFVTX0RJU0NBUkRFRF9WQVJJQU5UKVxuICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblJlY29yZHMgPSBhd2FpdCB0cmFuc2FjdGlvbnMudG9BcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvblJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NyaXB0Um9vdHMgPSB0cmFuc2FjdGlvblJlY29yZHNcbiAgICAgICAgICAgIC5tYXAoKHRyYW5zYWN0aW9uUmVjb3JkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHNjcmlwdFJvb3QpID0+IHNjcmlwdFJvb3QgIT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgc2NyaXB0cyA9IGF3YWl0IHRyYW5zYWN0aW9uU2NyaXB0c1xuICAgICAgICAgICAgLndoZXJlKFwic2NyaXB0Um9vdFwiKVxuICAgICAgICAgICAgLmFueU9mKHNjcmlwdFJvb3RzKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIHNjcmlwdFJvb3QgdG8gc2NyaXB0IGZvciBxdWljayBsb29rdXBcbiAgICAgICAgY29uc3Qgc2NyaXB0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcmlwdC50eFNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdE1hcC5zZXQoc2NyaXB0LnNjcmlwdFJvb3QsIHNjcmlwdC50eFNjcmlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRUcmFuc2FjdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvblJlY29yZHMubWFwKCh0cmFuc2FjdGlvblJlY29yZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4U2NyaXB0QmFzZTY0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFNjcmlwdCA9IHNjcmlwdE1hcC5nZXQodHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4U2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR4U2NyaXB0QmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHR4U2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHRyYW5zYWN0aW9uUmVjb3JkLmRldGFpbHMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHRyYW5zYWN0aW9uUmVjb3JkLnN0YXR1cyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0cmFuc2FjdGlvblJlY29yZC5pZCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzQmFzZTY0LFxuICAgICAgICAgICAgICAgIHNjcmlwdFJvb3Q6IHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3QsXG4gICAgICAgICAgICAgICAgdHhTY3JpcHQ6IHR4U2NyaXB0QmFzZTY0LFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtOiB0cmFuc2FjdGlvblJlY29yZC5ibG9ja051bS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0YXR1c1ZhcmlhbnQ6IHRyYW5zYWN0aW9uUmVjb3JkLnN0YXR1c1ZhcmlhbnQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNCYXNlNjQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZFRyYW5zYWN0aW9ucztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbnNlcnRUcmFuc2FjdGlvblNjcmlwdChzY3JpcHRSb290LCB0eFNjcmlwdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdFJvb3RBcnJheSA9IG5ldyBVaW50OEFycmF5KHNjcmlwdFJvb3QpO1xuICAgICAgICBjb25zdCBzY3JpcHRSb290QmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHNjcmlwdFJvb3RBcnJheSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBzY3JpcHRSb290OiBzY3JpcHRSb290QmFzZTY0LFxuICAgICAgICAgICAgdHhTY3JpcHQ6IG1hcE9wdGlvbih0eFNjcmlwdCwgKHR4U2NyaXB0KSA9PiBuZXcgVWludDhBcnJheSh0eFNjcmlwdCkpLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0cmFuc2FjdGlvblNjcmlwdHMucHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gaW5zZXJ0IHRyYW5zYWN0aW9uIHNjcmlwdFwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRUcmFuc2FjdGlvblJlY29yZCh0cmFuc2FjdGlvbklkLCBkZXRhaWxzLCBibG9ja051bSwgc3RhdHVzVmFyaWFudCwgc3RhdHVzLCBzY3JpcHRSb290KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGlkOiB0cmFuc2FjdGlvbklkLFxuICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgIHNjcmlwdFJvb3Q6IG1hcE9wdGlvbihzY3JpcHRSb290LCAocm9vdCkgPT4gdWludDhBcnJheVRvQmFzZTY0KHJvb3QpKSxcbiAgICAgICAgICAgIGJsb2NrTnVtOiBwYXJzZUludChibG9ja051bSwgMTApLFxuICAgICAgICAgICAgc3RhdHVzVmFyaWFudCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb25zLnB1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gaW5zZXJ0IHByb3ZlbiB0cmFuc2FjdGlvbiBkYXRhXCIpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Tm90ZVRhZ3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlY29yZHMgPSBhd2FpdCB0YWdzLnRvQXJyYXkoKTtcbiAgICAgICAgbGV0IHByb2Nlc3NlZFJlY29yZHMgPSByZWNvcmRzLm1hcCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICByZWNvcmQuc291cmNlTm90ZUlkID1cbiAgICAgICAgICAgICAgICByZWNvcmQuc291cmNlTm90ZUlkID09IFwiXCIgPyB1bmRlZmluZWQgOiByZWNvcmQuc291cmNlTm90ZUlkO1xuICAgICAgICAgICAgcmVjb3JkLnNvdXJjZUFjY291bnRJZCA9XG4gICAgICAgICAgICAgICAgcmVjb3JkLnNvdXJjZUFjY291bnRJZCA9PSBcIlwiID8gdW5kZWZpbmVkIDogcmVjb3JkLnNvdXJjZUFjY291bnRJZDtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkUmVjb3JkcztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRXJyb3IgZmV0Y2ggdGFnIHJlY29yZFwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTeW5jSGVpZ2h0KCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHN0YXRlU3luYy5nZXQoMSk7IC8vIFNpbmNlIGlkIGlzIHRoZSBwcmltYXJ5IGtleSBhbmQgYWx3YXlzIDFcbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW06IHJlY29yZC5ibG9ja051bSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkVycm9yIGZldGNoaW5nIHN5bmMgaGVpZ2h0XCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZE5vdGVUYWcodGFnLCBzb3VyY2VOb3RlSWQsIHNvdXJjZUFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB0YWdBcnJheSA9IG5ldyBVaW50OEFycmF5KHRhZyk7XG4gICAgICAgIGxldCB0YWdCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQodGFnQXJyYXkpO1xuICAgICAgICBhd2FpdCB0YWdzLmFkZCh7XG4gICAgICAgICAgICB0YWc6IHRhZ0Jhc2U2NCxcbiAgICAgICAgICAgIHNvdXJjZU5vdGVJZDogc291cmNlTm90ZUlkID8gc291cmNlTm90ZUlkIDogXCJcIixcbiAgICAgICAgICAgIHNvdXJjZUFjY291bnRJZDogc291cmNlQWNjb3VudElkID8gc291cmNlQWNjb3VudElkIDogXCJcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBhZGQgbm90ZSB0YWdcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlTm90ZVRhZyh0YWcsIHNvdXJjZU5vdGVJZCwgc291cmNlQWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHRhZ0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGFnKTtcbiAgICAgICAgbGV0IHRhZ0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NCh0YWdBcnJheSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0YWdzXG4gICAgICAgICAgICAud2hlcmUoe1xuICAgICAgICAgICAgdGFnOiB0YWdCYXNlNjQsXG4gICAgICAgICAgICBzb3VyY2VOb3RlSWQ6IHNvdXJjZU5vdGVJZCA/IHNvdXJjZU5vdGVJZCA6IFwiXCIsXG4gICAgICAgICAgICBzb3VyY2VBY2NvdW50SWQ6IHNvdXJjZUFjY291bnRJZCA/IHNvdXJjZUFjY291bnRJZCA6IFwiXCIsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZGVsZXRlKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkZhaWxlZCB0byByZW1vdmUgbm90ZSB0YWdcIik7XG4gICAgfVxufVxuLypcbiAqIFRha2VzIGEgYEpzU3RhdGVTeW5jVXBkYXRlYCBvYmplY3QgYW5kIHdyaXRlcyB0aGUgc3RhdGUgdXBkYXRlIGludG8gdGhlIHN0b3JlLlxuICogQHBhcmFtIHtKc1N0YXRlU3luY1VwZGF0ZX1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlTdGF0ZVN5bmMoc3RhdGVVcGRhdGUpIHtcbiAgICBjb25zdCB7IGJsb2NrTnVtLCAvLyBUYXJnZXQgYmxvY2sgbnVtYmVyIGZvciB0aGlzIHN5bmNcbiAgICBmbGF0dGVuZWROZXdCbG9ja0hlYWRlcnMsIC8vIFNlcmlhbGl6ZWQgYmxvY2sgaGVhZGVycyB0byBiZSByZWNvbnN0cnVjdGVkXG4gICAgZmxhdHRlbmVkUGFydGlhbEJsb2NrQ2hhaW5QZWFrcywgLy8gU2VyaWFsaXplZCBibG9ja2NoYWluIHBlYWtzIGZvciB2ZXJpZmljYXRpb25cbiAgICBuZXdCbG9ja051bXMsIC8vIEJsb2NrIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byBuZXcgaGVhZGVyc1xuICAgIGJsb2NrSGFzUmVsZXZhbnROb3RlcywgLy8gRmxhZ3MgaW5kaWNhdGluZyB3aGljaCBibG9ja3MgaGF2ZSByZWxldmFudCBub3Rlc1xuICAgIHNlcmlhbGl6ZWROb2RlSWRzLCAvLyBJRHMgZm9yIG5ldyBhdXRoZW50aWNhdGlvbiBub2Rlc1xuICAgIHNlcmlhbGl6ZWROb2RlcywgLy8gQXV0aGVudGljYXRpb24gbm9kZSBkYXRhIGZvciBtZXJrbGUgcHJvb2ZzXG4gICAgY29tbWl0dGVkTm90ZUlkcywgLy8gTm90ZSB0YWdzIHRvIGJlIGNsZWFuZWQgdXAvcmVtb3ZlZFxuICAgIHNlcmlhbGl6ZWRJbnB1dE5vdGVzLCAvLyBJbnB1dCBub3RlcyBjb25zdW1lZCBpbiB0cmFuc2FjdGlvbnNcbiAgICBzZXJpYWxpemVkT3V0cHV0Tm90ZXMsIC8vIE91dHB1dCBub3RlcyBjcmVhdGVkIGluIHRyYW5zYWN0aW9uc1xuICAgIGFjY291bnRVcGRhdGVzLCAvLyBBY2NvdW50IHN0YXRlIGNoYW5nZXNcbiAgICB0cmFuc2FjdGlvblVwZGF0ZXMsIC8vIFRyYW5zYWN0aW9uIHJlY29yZHMgYW5kIHNjcmlwdHNcbiAgICAgfSA9IHN0YXRlVXBkYXRlO1xuICAgIC8vIEJsb2NrIGhlYWRlcnMgYW5kIEJsb2NrY2hhaW4gcGVha3MgYXJlIGZsYXR0ZW5lZCBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIHRoaXMgZnVuY3Rpb24sIGhlcmUgd2UgcmVidWlsZCB0aGVtLlxuICAgIGNvbnN0IG5ld0Jsb2NrSGVhZGVycyA9IHJlY29uc3RydWN0RmxhdHRlbmVkVmVjKGZsYXR0ZW5lZE5ld0Jsb2NrSGVhZGVycyk7XG4gICAgY29uc3QgcGFydGlhbEJsb2NrY2hhaW5QZWFrcyA9IHJlY29uc3RydWN0RmxhdHRlbmVkVmVjKGZsYXR0ZW5lZFBhcnRpYWxCbG9ja0NoYWluUGVha3MpO1xuICAgIC8vIENyZWF0ZSBwcm9taXNlcyB0byBpbnNlcnQgZWFjaCBpbnB1dCBub3RlLiBFYWNoIG5vdGUgd2lsbCBoYXZlIGl0cyBvd24gdHJhbnNhY3Rpb24sXG4gICAgLy8gYW5kIHRoZXJlZm9yZSwgbmVzdGVkIGluc2lkZSB0aGUgZmluYWwgdHJhbnNhY3Rpb24gaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gICAgbGV0IGlucHV0Tm90ZXNXcml0ZU9wID0gUHJvbWlzZS5hbGwoc2VyaWFsaXplZElucHV0Tm90ZXMubWFwKChub3RlKSA9PiB7XG4gICAgICAgIHJldHVybiB1cHNlcnRJbnB1dE5vdGUobm90ZS5ub3RlSWQsIG5vdGUubm90ZUFzc2V0cywgbm90ZS5zZXJpYWxOdW1iZXIsIG5vdGUuaW5wdXRzLCBub3RlLm5vdGVTY3JpcHRSb290LCBub3RlLm5vdGVTY3JpcHQsIG5vdGUubnVsbGlmaWVyLCBub3RlLmNyZWF0ZWRBdCwgbm90ZS5zdGF0ZURpc2NyaW1pbmFudCwgbm90ZS5zdGF0ZSk7XG4gICAgfSkpO1xuICAgIC8vIFNlZSBjb21tZW50IGFib3ZlLCB0aGUgc2FtZSB0aGluZyBhcHBsaWVzIGhlcmUsIGJ1dCBmb3IgT3V0cHV0IE5vdGVzLlxuICAgIGxldCBvdXRwdXROb3Rlc1dyaXRlT3AgPSBQcm9taXNlLmFsbChzZXJpYWxpemVkT3V0cHV0Tm90ZXMubWFwKChub3RlKSA9PiB7XG4gICAgICAgIHJldHVybiB1cHNlcnRPdXRwdXROb3RlKG5vdGUubm90ZUlkLCBub3RlLm5vdGVBc3NldHMsIG5vdGUucmVjaXBpZW50RGlnZXN0LCBub3RlLm1ldGFkYXRhLCBub3RlLm51bGxpZmllciwgbm90ZS5leHBlY3RlZEhlaWdodCwgbm90ZS5zdGF0ZURpc2NyaW1pbmFudCwgbm90ZS5zdGF0ZSk7XG4gICAgfSkpO1xuICAgIC8vIFByb21pc2VzIHRvIGluc2VydCBlYWNoIHRyYW5zYWN0aW9uIHVwZGF0ZS5cbiAgICBsZXQgdHJhbnNhY3Rpb25Xcml0ZU9wID0gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25VcGRhdGVzLm1hcCgodHJhbnNhY3Rpb25SZWNvcmQpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2VzID0gW1xuICAgICAgICAgICAgdXBzZXJ0VHJhbnNhY3Rpb25SZWNvcmQodHJhbnNhY3Rpb25SZWNvcmQuaWQsIHRyYW5zYWN0aW9uUmVjb3JkLmRldGFpbHMsIHRyYW5zYWN0aW9uUmVjb3JkLmJsb2NrTnVtLCB0cmFuc2FjdGlvblJlY29yZC5zdGF0dXNWYXJpYW50LCB0cmFuc2FjdGlvblJlY29yZC5zdGF0dXMsIHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3QpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdCAmJiB0cmFuc2FjdGlvblJlY29yZC50eFNjcmlwdCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnNlcnRUcmFuc2FjdGlvblNjcmlwdCh0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290LCB0cmFuc2FjdGlvblJlY29yZC50eFNjcmlwdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkpO1xuICAgIC8vIFByb21pc2VzIHRvIGluc2VydCBlYWNoIGFjY291bnQgdXBkYXRlLlxuICAgIGxldCBhY2NvdW50VXBkYXRlc1dyaXRlT3AgPSBQcm9taXNlLmFsbChhY2NvdW50VXBkYXRlcy5mbGF0TWFwKChhY2NvdW50VXBkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB1cHNlcnRBY2NvdW50U3RvcmFnZShhY2NvdW50VXBkYXRlLnN0b3JhZ2VTbG90cyksXG4gICAgICAgICAgICB1cHNlcnRTdG9yYWdlTWFwRW50cmllcyhhY2NvdW50VXBkYXRlLnN0b3JhZ2VNYXBFbnRyaWVzKSxcbiAgICAgICAgICAgIHVwc2VydFZhdWx0QXNzZXRzKGFjY291bnRVcGRhdGUuYXNzZXRzKSxcbiAgICAgICAgICAgIHVwc2VydEFjY291bnRSZWNvcmQoYWNjb3VudFVwZGF0ZS5hY2NvdW50SWQsIGFjY291bnRVcGRhdGUuY29kZVJvb3QsIGFjY291bnRVcGRhdGUuc3RvcmFnZVJvb3QsIGFjY291bnRVcGRhdGUuYXNzZXRWYXVsdFJvb3QsIGFjY291bnRVcGRhdGUubm9uY2UsIGFjY291bnRVcGRhdGUuY29tbWl0dGVkLCBhY2NvdW50VXBkYXRlLmFjY291bnRDb21taXRtZW50LCBhY2NvdW50VXBkYXRlLmFjY291bnRTZWVkKSxcbiAgICAgICAgXTtcbiAgICB9KSk7XG4gICAgY29uc3QgdGFibGVzVG9BY2Nlc3MgPSBbXG4gICAgICAgIHN0YXRlU3luYyxcbiAgICAgICAgaW5wdXROb3RlcyxcbiAgICAgICAgb3V0cHV0Tm90ZXMsXG4gICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgYmxvY2tIZWFkZXJzLFxuICAgICAgICBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzLFxuICAgICAgICB0YWdzLFxuICAgIF07XG4gICAgLy8gV3JpdGUgZXZlcnl0aGluZyBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGF0b21pY2FsbHkgZG8gdGhlIG9wZXJhdGlvbnNcbiAgICAvLyBiZWxvdywgc2luY2UgZXZlcnkgb3BlcmF0aW9uIGhlcmUgKG9yIGF0IGxlYXN0LCBtb3N0IG9mIHRoZW0pLCBpcyBkb25lIGluIGEgbmVzdGVkIHRyYW5zYWN0aW9uLlxuICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMsIGNoZWNrOiBodHRwczovL2RleGllLm9yZy9kb2NzL0RleGllL0RleGllLnRyYW5zYWN0aW9uKClcbiAgICByZXR1cm4gYXdhaXQgZGIudHJhbnNhY3Rpb24oXCJyd1wiLCB0YWJsZXNUb0FjY2VzcywgYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgdW5kZXIgYSBzaW5nbGUgcHJvbWlzZSBzaW5jZSBvdGhlcndpc2UgdGhlIHR4IGV4cGlyZXMuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGlucHV0Tm90ZXNXcml0ZU9wLFxuICAgICAgICAgICAgb3V0cHV0Tm90ZXNXcml0ZU9wLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25Xcml0ZU9wLFxuICAgICAgICAgICAgYWNjb3VudFVwZGF0ZXNXcml0ZU9wLFxuICAgICAgICAgICAgdXBkYXRlU3luY0hlaWdodCh0eCwgYmxvY2tOdW0pLFxuICAgICAgICAgICAgdXBkYXRlUGFydGlhbEJsb2NrY2hhaW5Ob2Rlcyh0eCwgc2VyaWFsaXplZE5vZGVJZHMsIHNlcmlhbGl6ZWROb2RlcyksXG4gICAgICAgICAgICB1cGRhdGVDb21taXR0ZWROb3RlVGFncyh0eCwgY29tbWl0dGVkTm90ZUlkcyksXG4gICAgICAgICAgICBQcm9taXNlLmFsbChuZXdCbG9ja0hlYWRlcnMubWFwKChuZXdCbG9ja0hlYWRlciwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVCbG9ja0hlYWRlcih0eCwgbmV3QmxvY2tOdW1zW2ldLCBuZXdCbG9ja0hlYWRlciwgcGFydGlhbEJsb2NrY2hhaW5QZWFrc1tpXSwgYmxvY2tIYXNSZWxldmFudE5vdGVzW2ldID09IDEpO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICBdKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVN5bmNIZWlnaHQodHgsIGJsb2NrTnVtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdHguc3RhdGVTeW5jLnVwZGF0ZSgxLCB7IGJsb2NrTnVtOiBibG9ja051bSB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHVwZGF0ZSBzeW5jIGhlaWdodFwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVCbG9ja0hlYWRlcih0eCwgYmxvY2tOdW0sIGJsb2NrSGVhZGVyLCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzLCBoYXNDbGllbnROb3Rlcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBibG9ja051bTogYmxvY2tOdW0sXG4gICAgICAgICAgICBoZWFkZXI6IGJsb2NrSGVhZGVyLFxuICAgICAgICAgICAgcGFydGlhbEJsb2NrY2hhaW5QZWFrcyxcbiAgICAgICAgICAgIGhhc0NsaWVudE5vdGVzOiBoYXNDbGllbnROb3Rlcy50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleGlzdGluZ0Jsb2NrSGVhZGVyID0gYXdhaXQgdHguYmxvY2tIZWFkZXJzLmdldChibG9ja051bSk7XG4gICAgICAgIGlmICghZXhpc3RpbmdCbG9ja0hlYWRlcikge1xuICAgICAgICAgICAgYXdhaXQgdHguYmxvY2tIZWFkZXJzLmFkZChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBpbnNlcnQgYmxvY2sgaGVhZGVyXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBhcnRpYWxCbG9ja2NoYWluTm9kZXModHgsIG5vZGVJbmRleGVzLCBub2Rlcykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhcnJheXMgYXJlIG5vdCBvZiB0aGUgc2FtZSBsZW5ndGhcbiAgICAgICAgaWYgKG5vZGVJbmRleGVzLmxlbmd0aCAhPT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlSW5kZXhlcyBhbmQgbm9kZXMgYXJyYXlzIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlSW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGlkIGFuZCBub2RlXG4gICAgICAgIGNvbnN0IGRhdGEgPSBub2Rlcy5tYXAoKG5vZGUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IG5vZGVJbmRleGVzW2luZGV4XSxcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVXNlIGJ1bGtQdXQgdG8gYWRkL292ZXJ3cml0ZSB0aGUgZW50cmllc1xuICAgICAgICBhd2FpdCB0eC5wYXJ0aWFsQmxvY2tjaGFpbk5vZGVzLmJ1bGtQdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIHVwZGF0ZSBwYXJ0aWFsIGJsb2NrY2hhaW4gbm9kZXNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ29tbWl0dGVkTm90ZVRhZ3ModHgsIGlucHV0Tm90ZUlkcykge1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXROb3RlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub3RlSWQgPSBpbnB1dE5vdGVJZHNbaV07XG4gICAgICAgICAgICAvLyBSZW1vdmUgbm90ZSB0YWdzXG4gICAgICAgICAgICBhd2FpdCB0eC50YWdzLndoZXJlKFwic291cmNlX25vdGVfaWRcIikuZXF1YWxzKG5vdGVJZCkuZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHB1ZGF0ZSBjb21taXR0ZWQgbm90ZSB0YWdzXCIpO1xuICAgIH1cbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byByZWNvbnN0cnVjdCBhcnJheXMgZnJvbSBmbGF0dGVuZWQgZGF0YVxuZnVuY3Rpb24gcmVjb25zdHJ1Y3RGbGF0dGVuZWRWZWMoZmxhdHRlbmVkVmVjKSB7XG4gICAgY29uc3QgZGF0YSA9IGZsYXR0ZW5lZFZlYy5kYXRhKCk7XG4gICAgY29uc3QgbGVuZ3RocyA9IGZsYXR0ZW5lZFZlYy5sZW5ndGhzKCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZW5ndGhzLmZvckVhY2goKGxlbmd0aCkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChkYXRhLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCkpO1xuICAgICAgICBpbmRleCArPSBsZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxubGV0IHdhc207XG5cbmxldCBjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50OEFycmF5TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuXG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcblxuY29uc3QgTUFYX1NBRkFSSV9ERUNPREVfQllURVMgPSAyMTQ2NDM1MDcyO1xubGV0IG51bUJ5dGVzRGVjb2RlZCA9IDA7XG5mdW5jdGlvbiBkZWNvZGVUZXh0KHB0ciwgbGVuKSB7XG4gICAgbnVtQnl0ZXNEZWNvZGVkICs9IGxlbjtcbiAgICBpZiAobnVtQnl0ZXNEZWNvZGVkID49IE1BWF9TQUZBUklfREVDT0RFX0JZVEVTKSB7XG4gICAgICAgIGNhY2hlZFRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgIG51bUJ5dGVzRGVjb2RlZCA9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZShnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZGVjb2RlVGV4dChwdHIsIGxlbik7XG59XG5cbmxldCBoZWFwID0gbmV3IEFycmF5KDEyOCkuZmlsbCh1bmRlZmluZWQpO1xuXG5oZWFwLnB1c2godW5kZWZpbmVkLCBudWxsLCB0cnVlLCBmYWxzZSk7XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3QoaWR4KSB7IHJldHVybiBoZWFwW2lkeF07IH1cblxubGV0IFdBU01fVkVDVE9SX0xFTiA9IDA7XG5cbmNvbnN0IGNhY2hlZFRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbmlmICghKCdlbmNvZGVJbnRvJyBpbiBjYWNoZWRUZXh0RW5jb2RlcikpIHtcbiAgICBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvID0gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgdmlldy5zZXQoYnVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWQ6IGFyZy5sZW5ndGgsXG4gICAgICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFzc1N0cmluZ1RvV2FzbTAoYXJnLCBtYWxsb2MsIHJlYWxsb2MpIHtcblxuICAgIGlmIChyZWFsbG9jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhidWYubGVuZ3RoLCAxKSA+Pj4gMDtcbiAgICAgICAgZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuLCAxKSA+Pj4gMDtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4QXJyYXlNZW1vcnkwKCk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhcmcuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICBpZiAoY29kZSA+IDB4N0YpIGJyZWFrO1xuICAgICAgICBtZW1bcHRyICsgb2Zmc2V0XSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCAhPT0gbGVuKSB7XG4gICAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIGxlbiA9IG9mZnNldCArIGFyZy5sZW5ndGggKiAzLCAxKSA+Pj4gMDtcbiAgICAgICAgY29uc3QgdmlldyA9IGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyICsgb2Zmc2V0LCBwdHIgKyBsZW4pO1xuICAgICAgICBjb25zdCByZXQgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHJldC53cml0dGVuO1xuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBvZmZzZXQsIDEpID4+PiAwO1xuICAgIH1cblxuICAgIFdBU01fVkVDVE9SX0xFTiA9IG9mZnNldDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5sZXQgY2FjaGVkRGF0YVZpZXdNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RGF0YVZpZXdNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWREYXRhVmlld01lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkRGF0YVZpZXdNZW1vcnkwLmJ1ZmZlci5kZXRhY2hlZCA9PT0gdHJ1ZSB8fCAoY2FjaGVkRGF0YVZpZXdNZW1vcnkwLmJ1ZmZlci5kZXRhY2hlZCA9PT0gdW5kZWZpbmVkICYmIGNhY2hlZERhdGFWaWV3TWVtb3J5MC5idWZmZXIgIT09IHdhc20ubWVtb3J5LmJ1ZmZlcikpIHtcbiAgICAgICAgY2FjaGVkRGF0YVZpZXdNZW1vcnkwID0gbmV3IERhdGFWaWV3KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWREYXRhVmlld01lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGlzTGlrZU5vbmUoeCkge1xuICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGVidWdTdHJpbmcodmFsKSB7XG4gICAgLy8gcHJpbWl0aXZlIHR5cGVzXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICBgJHt2YWx9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsfVwiYDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWwuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1N5bWJvbCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFN5bWJvbCgke2Rlc2NyaXB0aW9ufSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbC5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgJiYgbmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYEZ1bmN0aW9uKCR7bmFtZX0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnRnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9iamVjdHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGxldCBkZWJ1ZyA9ICdbJztcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnICs9IGRlYnVnU3RyaW5nKHZhbFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWJ1ZyArPSAnLCAnICsgZGVidWdTdHJpbmcodmFsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyArPSAnXSc7XG4gICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgYnVpbHQtaW5cbiAgICBjb25zdCBidWlsdEluTWF0Y2hlcyA9IC9cXFtvYmplY3QgKFteXFxdXSspXFxdLy5leGVjKHRvU3RyaW5nLmNhbGwodmFsKSk7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAoYnVpbHRJbk1hdGNoZXMgJiYgYnVpbHRJbk1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjbGFzc05hbWUgPSBidWlsdEluTWF0Y2hlc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWlsZWQgdG8gbWF0Y2ggdGhlIHN0YW5kYXJkICdbb2JqZWN0IENsYXNzTmFtZV0nXG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUgPT0gJ09iamVjdCcpIHtcbiAgICAgICAgLy8gd2UncmUgYSB1c2VyIGRlZmluZWQgY2xhc3Mgb3IgT2JqZWN0XG4gICAgICAgIC8vIEpTT04uc3RyaW5naWZ5IGF2b2lkcyBwcm9ibGVtcyB3aXRoIGN5Y2xlcywgYW5kIGlzIGdlbmVyYWxseSBtdWNoXG4gICAgICAgIC8vIGVhc2llciB0aGFuIGxvb3BpbmcgdGhyb3VnaCBvd25Qcm9wZXJ0aWVzIG9mIGB2YWxgLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QoJyArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyAnKSc7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiAnT2JqZWN0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlcnJvcnNcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbC5uYW1lfTogJHt2YWwubWVzc2FnZX1cXG4ke3ZhbC5zdGFja31gO1xuICAgIH1cbiAgICAvLyBUT0RPIHdlIGNvdWxkIHRlc3QgZm9yIG1vcmUgdGhpbmdzIGhlcmUsIGxpa2UgYFNldGBzIGFuZCBgTWFwYHMuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMTMyKSByZXR1cm47XG4gICAgaGVhcFtpZHhdID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGlkeDtcbn1cblxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoaWR4KTtcbiAgICBkcm9wT2JqZWN0KGlkeCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZiwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDQoYWRkSGVhcE9iamVjdChlKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgY29uc3QgbWVtID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IHB0cjsgaSA8IHB0ciArIDQgKiBsZW47IGkgKz0gNCkge1xuICAgICAgICByZXN1bHQucHVzaCh0YWtlT2JqZWN0KG1lbS5nZXRVaW50MzIoaSwgdHJ1ZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgQ0xPU1VSRV9EVE9SUyA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShzdGF0ZSA9PiBzdGF0ZS5kdG9yKHN0YXRlLmEsIHN0YXRlLmIpKTtcblxuZnVuY3Rpb24gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcblxuICAgICAgICAvLyBGaXJzdCB1cCB3aXRoIGEgY2xvc3VyZSB3ZSBpbmNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZVxuICAgICAgICAvLyBjb3VudC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIFJ1c3QgY2xvc3VyZSBlbnZpcm9ubWVudCB3b24ndFxuICAgICAgICAvLyBiZSBkZWFsbG9jYXRlZCB3aGlsZSB3ZSdyZSBpbnZva2luZyBpdC5cbiAgICAgICAgc3RhdGUuY250Kys7XG4gICAgICAgIGNvbnN0IGEgPSBzdGF0ZS5hO1xuICAgICAgICBzdGF0ZS5hID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKGEsIHN0YXRlLmIsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RhdGUuYSA9IGE7XG4gICAgICAgICAgICByZWFsLl93YmdfY2JfdW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVhbC5fd2JnX2NiX3VucmVmID0gKCkgPT4ge1xuICAgICAgICBpZiAoLS1zdGF0ZS5jbnQgPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlLmR0b3Ioc3RhdGUuYSwgc3RhdGUuYik7XG4gICAgICAgICAgICBzdGF0ZS5hID0gMDtcbiAgICAgICAgICAgIENMT1NVUkVfRFRPUlMudW5yZWdpc3RlcihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENMT1NVUkVfRFRPUlMucmVnaXN0ZXIocmVhbCwgc3RhdGUsIHN0YXRlKTtcbiAgICByZXR1cm4gcmVhbDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENsYXNzKGluc3RhbmNlLCBrbGFzcykge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2Yga2xhc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJHtrbGFzcy5uYW1lfWApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFzc0FycmF5OFRvV2FzbTAoYXJnLCBtYWxsb2MpIHtcbiAgICBjb25zdCBwdHIgPSBtYWxsb2MoYXJnLmxlbmd0aCAqIDEsIDEpID4+PiAwO1xuICAgIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc2V0KGFyZywgcHRyIC8gMSk7XG4gICAgV0FTTV9WRUNUT1JfTEVOID0gYXJnLmxlbmd0aDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5sZXQgc3RhY2tfcG9pbnRlciA9IDEyODtcblxuZnVuY3Rpb24gYWRkQm9ycm93ZWRPYmplY3Qob2JqKSB7XG4gICAgaWYgKHN0YWNrX3BvaW50ZXIgPT0gMSkgdGhyb3cgbmV3IEVycm9yKCdvdXQgb2YganMgc3RhY2snKTtcbiAgICBoZWFwWy0tc3RhY2tfcG9pbnRlcl0gPSBvYmo7XG4gICAgcmV0dXJuIHN0YWNrX3BvaW50ZXI7XG59XG5cbmZ1bmN0aW9uIHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFycmF5LCBtYWxsb2MpIHtcbiAgICBjb25zdCBwdHIgPSBtYWxsb2MoYXJyYXkubGVuZ3RoICogNCwgNCkgPj4+IDA7XG4gICAgY29uc3QgbWVtID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW0uc2V0VWludDMyKHB0ciArIDQgKiBpLCBhZGRIZWFwT2JqZWN0KGFycmF5W2ldKSwgdHJ1ZSk7XG4gICAgfVxuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5sZXQgY2FjaGVkQmlnVWludDY0QXJyYXlNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0QmlnVWludDY0QXJyYXlNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRCaWdVaW50NjRBcnJheU1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkQmlnVWludDY0QXJyYXlNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkQmlnVWludDY0QXJyYXlNZW1vcnkwID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRCaWdVaW50NjRBcnJheU1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIHBhc3NBcnJheTY0VG9XYXNtMChhcmcsIG1hbGxvYykge1xuICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhhcmcubGVuZ3RoICogOCwgOCkgPj4+IDA7XG4gICAgZ2V0QmlnVWludDY0QXJyYXlNZW1vcnkwKCkuc2V0KGFyZywgcHRyIC8gOCk7XG4gICAgV0FTTV9WRUNUT1JfTEVOID0gYXJnLmxlbmd0aDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU2NEZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZ2V0QmlnVWludDY0QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gOCwgcHRyIC8gOCArIGxlbik7XG59XG5cbmxldCBjYWNoZWRVaW50MzJBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50MzJBcnJheU1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQzMkFycmF5TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50MzJBcnJheU1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50MzJBcnJheU1lbW9yeTAgPSBuZXcgVWludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFVpbnQzMkFycmF5TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlVMzJGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGdldFVpbnQzMkFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDQsIHB0ciAvIDQgKyBsZW4pO1xufVxuZnVuY3Rpb24gX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzNzUoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIHdhc20uX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzNzUoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85MzA5KGFyZzAsIGFyZzEpIHtcbiAgICB3YXNtLl9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85MzA5KGFyZzAsIGFyZzEpO1xufVxuXG5mdW5jdGlvbiBfX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fMzY3NyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgd2FzbS5fX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fMzY3NyhhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpLCBhZGRIZWFwT2JqZWN0KGFyZzMpKTtcbn1cblxuLyoqXG4gKiBAZW51bSB7MH1cbiAqL1xuY29uc3QgQWNjb3VudEludGVyZmFjZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEJhc2ljV2FsbGV0OiAwLCBcIjBcIjogXCJCYXNpY1dhbGxldFwiLFxufSk7XG4vKipcbiAqIEBlbnVtIHswIHwgMSB8IDIgfCAzfVxuICovXG5jb25zdCBBY2NvdW50VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEZ1bmdpYmxlRmF1Y2V0OiAwLCBcIjBcIjogXCJGdW5naWJsZUZhdWNldFwiLFxuICAgIE5vbkZ1bmdpYmxlRmF1Y2V0OiAxLCBcIjFcIjogXCJOb25GdW5naWJsZUZhdWNldFwiLFxuICAgIFJlZ3VsYXJBY2NvdW50SW1tdXRhYmxlQ29kZTogMiwgXCIyXCI6IFwiUmVndWxhckFjY291bnRJbW11dGFibGVDb2RlXCIsXG4gICAgUmVndWxhckFjY291bnRVcGRhdGFibGVDb2RlOiAzLCBcIjNcIjogXCJSZWd1bGFyQWNjb3VudFVwZGF0YWJsZUNvZGVcIixcbn0pO1xuLyoqXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4fVxuICovXG5jb25zdCBJbnB1dE5vdGVTdGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIEV4cGVjdGVkOiAwLCBcIjBcIjogXCJFeHBlY3RlZFwiLFxuICAgIFVudmVyaWZpZWQ6IDEsIFwiMVwiOiBcIlVudmVyaWZpZWRcIixcbiAgICBDb21taXR0ZWQ6IDIsIFwiMlwiOiBcIkNvbW1pdHRlZFwiLFxuICAgIEludmFsaWQ6IDMsIFwiM1wiOiBcIkludmFsaWRcIixcbiAgICBQcm9jZXNzaW5nQXV0aGVudGljYXRlZDogNCwgXCI0XCI6IFwiUHJvY2Vzc2luZ0F1dGhlbnRpY2F0ZWRcIixcbiAgICBQcm9jZXNzaW5nVW5hdXRoZW50aWNhdGVkOiA1LCBcIjVcIjogXCJQcm9jZXNzaW5nVW5hdXRoZW50aWNhdGVkXCIsXG4gICAgQ29uc3VtZWRBdXRoZW50aWNhdGVkTG9jYWw6IDYsIFwiNlwiOiBcIkNvbnN1bWVkQXV0aGVudGljYXRlZExvY2FsXCIsXG4gICAgQ29uc3VtZWRVbmF1dGhlbnRpY2F0ZWRMb2NhbDogNywgXCI3XCI6IFwiQ29uc3VtZWRVbmF1dGhlbnRpY2F0ZWRMb2NhbFwiLFxuICAgIENvbnN1bWVkRXh0ZXJuYWw6IDgsIFwiOFwiOiBcIkNvbnN1bWVkRXh0ZXJuYWxcIixcbn0pO1xuLyoqXG4gKiBAZW51bSB7MCB8IDEgfCAyfVxuICovXG5jb25zdCBOZXR3b3JrSWQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBNYWlubmV0OiAwLCBcIjBcIjogXCJNYWlubmV0XCIsXG4gICAgVGVzdG5ldDogMSwgXCIxXCI6IFwiVGVzdG5ldFwiLFxuICAgIERldm5ldDogMiwgXCIyXCI6IFwiRGV2bmV0XCIsXG59KTtcbi8qKlxuICogQGVudW0gezAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOH1cbiAqL1xuY29uc3QgTm90ZUZpbHRlclR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgQWxsOiAwLCBcIjBcIjogXCJBbGxcIixcbiAgICBDb25zdW1lZDogMSwgXCIxXCI6IFwiQ29uc3VtZWRcIixcbiAgICBDb21taXR0ZWQ6IDIsIFwiMlwiOiBcIkNvbW1pdHRlZFwiLFxuICAgIEV4cGVjdGVkOiAzLCBcIjNcIjogXCJFeHBlY3RlZFwiLFxuICAgIFByb2Nlc3Npbmc6IDQsIFwiNFwiOiBcIlByb2Nlc3NpbmdcIixcbiAgICBMaXN0OiA1LCBcIjVcIjogXCJMaXN0XCIsXG4gICAgVW5pcXVlOiA2LCBcIjZcIjogXCJVbmlxdWVcIixcbiAgICBOdWxsaWZpZXJzOiA3LCBcIjdcIjogXCJOdWxsaWZpZXJzXCIsXG4gICAgVW52ZXJpZmllZDogOCwgXCI4XCI6IFwiVW52ZXJpZmllZFwiLFxufSk7XG4vKipcbiAqIEBlbnVtIHsyIHwgMyB8IDF9XG4gKi9cbmNvbnN0IE5vdGVUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLyoqXG4gICAgICogTm90ZXMgd2l0aCB0aGlzIHR5cGUgaGF2ZSBvbmx5IHRoZWlyIGhhc2ggcHVibGlzaGVkIHRvIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIFByaXZhdGU6IDIsIFwiMlwiOiBcIlByaXZhdGVcIixcbiAgICAvKipcbiAgICAgKiBOb3RlcyB3aXRoIHRoaXMgdHlwZSBhcmUgc2hhcmVkIHdpdGggdGhlIG5ldHdvcmsgZW5jcnlwdGVkLlxuICAgICAqL1xuICAgIEVuY3J5cHRlZDogMywgXCIzXCI6IFwiRW5jcnlwdGVkXCIsXG4gICAgLyoqXG4gICAgICogTm90ZXMgd2l0aCB0aGlzIHR5cGUgYXJlIGZ1bGx5IHNoYXJlZCB3aXRoIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIFB1YmxpYzogMSwgXCIxXCI6IFwiUHVibGljXCIsXG59KTtcbi8qKlxuICogQGVudW0gezAgfCAxIHwgMn1cbiAqL1xuY29uc3QgU2lnbmluZ0lucHV0c1R5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBUcmFuc2FjdGlvblN1bW1hcnk6IDAsIFwiMFwiOiBcIlRyYW5zYWN0aW9uU3VtbWFyeVwiLFxuICAgIEFyYml0cmFyeTogMSwgXCIxXCI6IFwiQXJiaXRyYXJ5XCIsXG4gICAgQmxpbmQ6IDIsIFwiMlwiOiBcIkJsaW5kXCIsXG59KTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX0FkZHJlc3NJbnRlcmZhY2UgPSBbXCJCYXNpY1dhbGxldFwiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX1JlYWRhYmxlU3RyZWFtVHlwZSA9IFtcImJ5dGVzXCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVmZXJyZXJQb2xpY3kgPSBbXCJcIiwgXCJuby1yZWZlcnJlclwiLCBcIm5vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlXCIsIFwib3JpZ2luXCIsIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsIFwidW5zYWZlLXVybFwiLCBcInNhbWUtb3JpZ2luXCIsIFwic3RyaWN0LW9yaWdpblwiLCBcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIl07XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0Q2FjaGUgPSBbXCJkZWZhdWx0XCIsIFwibm8tc3RvcmVcIiwgXCJyZWxvYWRcIiwgXCJuby1jYWNoZVwiLCBcImZvcmNlLWNhY2hlXCIsIFwib25seS1pZi1jYWNoZWRcIl07XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0Q3JlZGVudGlhbHMgPSBbXCJvbWl0XCIsIFwic2FtZS1vcmlnaW5cIiwgXCJpbmNsdWRlXCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdE1vZGUgPSBbXCJzYW1lLW9yaWdpblwiLCBcIm5vLWNvcnNcIiwgXCJjb3JzXCIsIFwibmF2aWdhdGVcIl07XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0UmVkaXJlY3QgPSBbXCJmb2xsb3dcIiwgXCJlcnJvclwiLCBcIm1hbnVhbFwiXTtcblxuY29uc3QgQWNjb3VudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEFjY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBub25jZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X25vbmNlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBc3NldFZhdWx0fVxuICAgICAqL1xuICAgIHZhdWx0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfdmF1bHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQXNzZXRWYXVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlfVxuICAgICAqL1xuICAgIHN0b3JhZ2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9zdG9yYWdlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudENvZGV9XG4gICAgICovXG4gICAgY29kZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2NvZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudENvZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmF1Y2V0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNGYXVjZXQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlZ3VsYXJBY2NvdW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNSZWd1bGFyQWNjb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVXBkYXRhYmxlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNVcGRhdGFibGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1B1YmxpYygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzUHVibGljKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQcml2YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNQcml2YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOZXR3b3JrKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNOZXR3b3JrKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOZXcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc05ldyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmRbXX1cbiAgICAgKi9cbiAgICBnZXRQdWJsaWNLZXlzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRfZ2V0UHVibGljS2V5cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50YXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudEFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudEFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50YXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEFjY291bnRBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50fVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FjY291bnR9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIEFjY291bnQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50YXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIEFjY291bnQpO1xuICAgICAgICB3YXNtLmFjY291bnRhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudEFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50QXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRCdWlsZGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRidWlsZGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRCdWlsZGVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50QnVpbGRlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50QnVpbGRlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50QnVpbGRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGJ1aWxkZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGluaXRfc2VlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXRfc2VlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoaW5pdF9zZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFjY291bnRidWlsZGVyX25ldyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHIwID4+PiAwO1xuICAgICAgICAgICAgQWNjb3VudEJ1aWxkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudFR5cGV9IGFjY291bnRfdHlwZVxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50QnVpbGRlcn1cbiAgICAgKi9cbiAgICBhY2NvdW50VHlwZShhY2NvdW50X3R5cGUpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcl9hY2NvdW50VHlwZShwdHIsIGFjY291bnRfdHlwZSk7XG4gICAgICAgIHJldHVybiBBY2NvdW50QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50U3RvcmFnZU1vZGV9IHN0b3JhZ2VfbW9kZVxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50QnVpbGRlcn1cbiAgICAgKi9cbiAgICBzdG9yYWdlTW9kZShzdG9yYWdlX21vZGUpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JhZ2VfbW9kZSwgQWNjb3VudFN0b3JhZ2VNb2RlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcl9zdG9yYWdlTW9kZShwdHIsIHN0b3JhZ2VfbW9kZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudENvbXBvbmVudH0gYWNjb3VudF9jb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aENvbXBvbmVudChhY2NvdW50X2NvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9jb21wb25lbnQsIEFjY291bnRDb21wb25lbnQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVyX3dpdGhDb21wb25lbnQocHRyLCBhY2NvdW50X2NvbXBvbmVudC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudENvbXBvbmVudH0gYWNjb3VudF9jb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEF1dGhDb21wb25lbnQoYWNjb3VudF9jb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfY29tcG9uZW50LCBBY2NvdW50Q29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcl93aXRoQXV0aENvbXBvbmVudChwdHIsIGFjY291bnRfY29tcG9uZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhOb0F1dGhDb21wb25lbnQoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJfd2l0aE5vQXV0aENvbXBvbmVudChwdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50QnVpbGRlclJlc3VsdH1cbiAgICAgKi9cbiAgICBidWlsZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGJ1aWxkZXJfYnVpbGQocmV0cHRyLCBwdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudEJ1aWxkZXJSZXN1bHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRCdWlsZGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50QnVpbGRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudEJ1aWxkZXJSZXN1bHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGJ1aWxkZXJyZXN1bHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudEJ1aWxkZXJSZXN1bHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRCdWlsZGVyUmVzdWx0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRCdWlsZGVyUmVzdWx0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRCdWlsZGVyUmVzdWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50YnVpbGRlcnJlc3VsdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50fVxuICAgICAqL1xuICAgIGdldCBhY2NvdW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVycmVzdWx0X2FjY291bnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgZ2V0IHNlZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJyZXN1bHRfc2VlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudEJ1aWxkZXJSZXN1bHQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRCdWlsZGVyUmVzdWx0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50Q29kZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50Y29kZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50Q29kZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudENvZGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudENvZGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudENvZGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRjb2RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gbWFzdF9yb290XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUHJvY2VkdXJlKG1hc3Rfcm9vdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MobWFzdF9yb290LCBXb3JkKTtcbiAgICAgICAgdmFyIHB0cjAgPSBtYXN0X3Jvb3QuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfaGFzUHJvY2VkdXJlKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRDb2RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50Q29kZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudENvbXBvbmVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50Y29tcG9uZW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRDb21wb25lbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudENvbXBvbmVudEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50Q29tcG9uZW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50Y29tcG9uZW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRfY29kZVxuICAgICAqIEBwYXJhbSB7U2NyaXB0QnVpbGRlcn0gYnVpbGRlclxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVNsb3RbXX0gc3RvcmFnZV9zbG90c1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50Q29tcG9uZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKGFjY291bnRfY29kZSwgYnVpbGRlciwgc3RvcmFnZV9zbG90cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWNjb3VudF9jb2RlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGJ1aWxkZXIsIFNjcmlwdEJ1aWxkZXIpO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKHN0b3JhZ2Vfc2xvdHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGNvbXBvbmVudF9jb21waWxlKHJldHB0ciwgcHRyMCwgbGVuMCwgYnVpbGRlci5fX3diZ19wdHIsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudENvbXBvbmVudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudENvbXBvbmVudH1cbiAgICAgKi9cbiAgICB3aXRoU3VwcG9ydHNBbGxUeXBlcygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29tcG9uZW50X3dpdGhTdXBwb3J0c0FsbFR5cGVzKHB0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50Q29tcG9uZW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvY2VkdXJlX25hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldFByb2NlZHVyZUhhc2gocHJvY2VkdXJlX25hbWUpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkM18wO1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9jZWR1cmVfbmFtZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGNvbXBvbmVudF9nZXRQcm9jZWR1cmVIYXNoKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IHB0cjI7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMSA9IGxlbjI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkM18wLCBkZWZlcnJlZDNfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0dldFByb2NlZHVyZXNSZXN1bHRJdGVtW119XG4gICAgICovXG4gICAgZ2V0UHJvY2VkdXJlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50Y29tcG9uZW50X2dldFByb2NlZHVyZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2VjcmV0S2V5fSBzZWNyZXRfa2V5XG4gICAgICogQHJldHVybnMge0FjY291bnRDb21wb25lbnR9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUF1dGhDb21wb25lbnQoc2VjcmV0X2tleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VjcmV0X2tleSwgU2VjcmV0S2V5KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGNvbXBvbmVudF9jcmVhdGVBdXRoQ29tcG9uZW50KHJldHB0ciwgc2VjcmV0X2tleS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudENvbXBvbmVudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BhY2thZ2V9IF9wYWNrYWdlXG4gICAgICogQHBhcmFtIHtTdG9yYWdlU2xvdEFycmF5fSBzdG9yYWdlX3Nsb3RzXG4gICAgICogQHJldHVybnMge0FjY291bnRDb21wb25lbnR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21QYWNrYWdlKF9wYWNrYWdlLCBzdG9yYWdlX3Nsb3RzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhfcGFja2FnZSwgUGFja2FnZSk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmFnZV9zbG90cywgU3RvcmFnZVNsb3RBcnJheSk7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRjb21wb25lbnRfZnJvbVBhY2thZ2UocmV0cHRyLCBfcGFja2FnZS5fX3diZ19wdHIsIHN0b3JhZ2Vfc2xvdHMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRDb21wb25lbnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRDb21wb25lbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRDb21wb25lbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnREZWx0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50ZGVsdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudERlbHRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50RGVsdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudERlbHRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnREZWx0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGRlbHRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0FjY291bnREZWx0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50ZGVsdGFfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudERlbHRhLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZURlbHRhfVxuICAgICAqL1xuICAgIHN0b3JhZ2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX3N0b3JhZ2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VEZWx0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRWYXVsdERlbHRhfVxuICAgICAqL1xuICAgIHZhdWx0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV92YXVsdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50VmF1bHREZWx0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgbm9uY2VEZWx0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfbm9uY2VEZWx0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudERlbHRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50RGVsdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRGaWxlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRmaWxlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRGaWxlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50RmlsZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50RmlsZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50RmlsZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGZpbGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBgQWNjb3VudEZpbGVgIGludG8gYSBieXRlIGFycmF5XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRmaWxlX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhIGJ5dGUgYXJyYXkgaW50byBhbiBgQWNjb3VudEZpbGVgXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50RmlsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50ZmlsZV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50RmlsZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudEZpbGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRGaWxlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50SGVhZGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRoZWFkZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudEhlYWRlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudEhlYWRlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50SGVhZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRIZWFkZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRoZWFkZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBub25jZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX25vbmNlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHZhdWx0Q29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHN0b3JhZ2VDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfc3RvcmFnZUNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29kZUNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9jb2RlQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudEhlYWRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudEhlYWRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudElkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRpZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50SWQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRJZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50SWRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBBY2NvdW50SWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRJZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGlkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChoZXgsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfZnJvbUhleChwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGYXVjZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX2lzRmF1Y2V0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWd1bGFyQWNjb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfaXNSZWd1bGFyQWNjb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUHVibGljKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9pc1B1YmxpYyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUHJpdmF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfaXNQcml2YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOZXR3b3JrKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9pc05ldHdvcmsodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50aWRfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgdHVybiB0aGUgQWNjb3VudCBJRCBpbnRvIGl0cyBiZWNoMzIgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUbyBhdm9pZCBhIHBvdGVudGlhbFxuICAgICAqIHdyb25nZnVsIGVuY29kaW5nLCB0aGlzIGZ1bmN0aW9uIHdpbGwgZXhwZWN0IG9ubHkgSURzIGZvciBlaXRoZXIgbWFpbm5ldCAoXCJtbVwiKSxcbiAgICAgKiB0ZXN0bmV0IChcIm10c3RcIikgb3IgZGV2bmV0IChcIm1kZXZcIikuIFRvIHVzZSBhIGN1c3RvbSBiZWNoMzIgcHJlZml4LCBzZWVcbiAgICAgKiBgU2VsZjo6dG9fYmVjaF8zMl9jdXN0b21gLlxuICAgICAqIEBwYXJhbSB7TmV0d29ya0lkfSBuZXR3b3JrX2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50SW50ZXJmYWNlfSBhY2NvdW50X2ludGVyZmFjZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CZWNoMzIobmV0d29ya19pZCwgYWNjb3VudF9pbnRlcmZhY2UpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGlkX3RvQmVjaDMyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIG5ldHdvcmtfaWQsIGFjY291bnRfaW50ZXJmYWNlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBsZW4xO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR1cm4gdGhpcyBBY2NvdW50IElEIGludG8gaXRzIGJlY2gzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYSBjdXN0b21cbiAgICAgKiBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXN0b21fbmV0d29ya19pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudEludGVyZmFjZX0gYWNjb3VudF9pbnRlcmZhY2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvQmVjaDMyQ3VzdG9tKGN1c3RvbV9uZXR3b3JrX2lkLCBhY2NvdW50X2ludGVyZmFjZSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGN1c3RvbV9uZXR3b3JrX2lkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50aWRfdG9CZWNoMzJDdXN0b20ocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgYWNjb3VudF9pbnRlcmZhY2UpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IHB0cjI7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMSA9IGxlbjI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkM18wLCBkZWZlcnJlZDNfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgcHJlZml4KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9wcmVmaXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgc3VmZml4KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9zdWZmaXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRJZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudElkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50SWRBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50aWRhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50SWRBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRJZEFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50aWRhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZGFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEFjY291bnRJZEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50aWRhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50aWRhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBBY2NvdW50SWQpO1xuICAgICAgICB3YXNtLmFjY291bnRpZGFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRJZEFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50SWRBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudFN0b3JhZ2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2VfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudFN0b3JhZ2Uge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRTdG9yYWdlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRTdG9yYWdlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRTdG9yYWdlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRJdGVtKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VfZ2V0SXRlbSh0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtXb3JkfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRNYXBJdGVtKGluZGV4LCBrZXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGtleSwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VfZ2V0TWFwSXRlbSh0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIGtleS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSB0aGUgbWFwIHNsb3QgYXQgYGluZGV4YC5cbiAgICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBzbG90IGlzbid0IGEgbWFwIG9yIGBpbmRleGAgaXMgb3V0IG9mIGJvdW5kcyAoMC0yNTUpLlxuICAgICAqIFJldHVybnMgYFtdYCBpZiB0aGUgbWFwIGV4aXN0cyBidXQgaXMgZW1wdHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0pzU3RvcmFnZU1hcEVudHJ5W10gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0TWFwRW50cmllcyhpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRzdG9yYWdlX2dldE1hcEVudHJpZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudFN0b3JhZ2UucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRTdG9yYWdlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50U3RvcmFnZURlbHRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlZGVsdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudFN0b3JhZ2VEZWx0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudFN0b3JhZ2VEZWx0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50U3RvcmFnZURlbHRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRTdG9yYWdlRGVsdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlZGVsdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VkZWx0YV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlRGVsdGF9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHN0b3JhZ2VkZWx0YV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZURlbHRhLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VkZWx0YV9pc0VtcHR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmRbXX1cbiAgICAgKi9cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHN0b3JhZ2VkZWx0YV92YWx1ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50U3RvcmFnZURlbHRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50U3RvcmFnZURlbHRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50U3RvcmFnZU1vZGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2Vtb2RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRTdG9yYWdlTW9kZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudFN0b3JhZ2VNb2RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRTdG9yYWdlTW9kZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50U3RvcmFnZU1vZGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlbW9kZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZU1vZGV9XG4gICAgICovXG4gICAgc3RhdGljIHByaXZhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX3ByaXZhdGUoKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlTW9kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgcHVibGljKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV9wdWJsaWMoKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlTW9kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfbmV0d29yaygpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VNb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZU1vZGV9XG4gICAgICovXG4gICAgc3RhdGljIHRyeUZyb21TdHIocykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX3RyeUZyb21TdHIocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlTW9kZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFzU3RyKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfYXNTdHIocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50U3RvcmFnZU1vZGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRTdG9yYWdlTW9kZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2VyZXF1aXJlbWVudHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZXJlcXVpcmVtZW50c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlcmVxdWlyZW1lbnRzX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTbG90QW5kS2V5c1tdfSBzbG90c19hbmRfa2V5c1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNsb3RBbmRLZXlzQXJyYXkoc2xvdHNfYW5kX2tleXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKHNsb3RzX2FuZF9rZXlzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFjY291bnRzdG9yYWdlcmVxdWlyZW1lbnRzX2Zyb21TbG90QW5kS2V5c0FycmF5KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50VmF1bHREZWx0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50dmF1bHRkZWx0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50VmF1bHREZWx0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudFZhdWx0RGVsdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudFZhdWx0RGVsdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudFZhdWx0RGVsdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnR2YXVsdGRlbHRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnR2YXVsdGRlbHRhX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFZhdWx0RGVsdGF9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHZhdWx0ZGVsdGFfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudFZhdWx0RGVsdGEuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZWRlbHRhX2lzRW1wdHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldERlbHRhfVxuICAgICAqL1xuICAgIGZ1bmdpYmxlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnR2YXVsdGRlbHRhX2Z1bmdpYmxlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZ1bmdpYmxlQXNzZXREZWx0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXRbXX1cbiAgICAgKi9cbiAgICBhZGRlZEZ1bmdpYmxlQXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnR2YXVsdGRlbHRhX2FkZGVkRnVuZ2libGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0W119XG4gICAgICovXG4gICAgcmVtb3ZlZEZ1bmdpYmxlQXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnR2YXVsdGRlbHRhX3JlbW92ZWRGdW5naWJsZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRWYXVsdERlbHRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50VmF1bHREZWx0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWRkcmVzc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hZGRyZXNzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFkZHJlc3Mge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFkZHJlc3MucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWRkcmVzc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBZGRyZXNzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hZGRyZXNzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtfaW50ZXJmYWNlXVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQWNjb3VudElkKGFjY291bnRfaWQsIF9pbnRlcmZhY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoX2ludGVyZmFjZSkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoX2ludGVyZmFjZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFkZHJlc3NfZnJvbUFjY291bnRJZChyZXRwdHIsIGFjY291bnRfaWQuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJlY2gzMlxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmVjaDMyKGJlY2gzMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYmVjaDMyLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hZGRyZXNzX2Zyb21CZWNoMzIocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FkZHJlc3NJbnRlcmZhY2V9XG4gICAgICovXG4gICAgaW50ZXJmYWNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFkZHJlc3NfaW50ZXJmYWNlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX193YmluZGdlbl9lbnVtX0FkZHJlc3NJbnRlcmZhY2VbcjBdO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGFjY291bnRJZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hZGRyZXNzX2FjY291bnRJZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICB0b05vdGVUYWcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWRkcmVzc190b05vdGVUYWcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZXR3b3JrSWR9IG5ldHdvcmtfaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvQmVjaDMyKG5ldHdvcmtfaWQpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWRkcmVzc190b0JlY2gzMihyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBuZXR3b3JrX2lkKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gcjA7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IHIxO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgcHRyMSA9IDA7IGxlbjEgPSAwO1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBwdHIxO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBsZW4xO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChwdHIxLCBsZW4xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBZGRyZXNzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBZGRyZXNzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBZHZpY2VJbnB1dHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWR2aWNlaW5wdXRzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFkdmljZUlucHV0cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWR2aWNlSW5wdXRzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFkdmljZUlucHV0c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBZHZpY2VJbnB1dHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FkdmljZWlucHV0c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgc3RhY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWR2aWNlaW5wdXRzX3N0YWNrKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IGtleVxuICAgICAqIEByZXR1cm5zIHtGZWx0W10gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgbWFwcGVkVmFsdWVzKGtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moa2V5LCBXb3JkKTtcbiAgICAgICAgICAgIHdhc20uYWR2aWNlaW5wdXRzX21hcHBlZFZhbHVlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBrZXkuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFkdmljZUlucHV0cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWR2aWNlSW5wdXRzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBZHZpY2VNYXBGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWR2aWNlbWFwX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFkdmljZU1hcCB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFkdmljZU1hcEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWR2aWNlbWFwX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VyZXF1aXJlbWVudHNfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBBZHZpY2VNYXBGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBrZXlcbiAgICAgKiBAcGFyYW0ge0ZlbHRBcnJheX0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGluc2VydChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhrZXksIFdvcmQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHZhbHVlLCBGZWx0QXJyYXkpO1xuICAgICAgICAgICAgd2FzbS5hZHZpY2VtYXBfaW5zZXJ0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGtleS5fX3diZ19wdHIsIHZhbHVlLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBZHZpY2VNYXAucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFkdmljZU1hcC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQXNzZXRWYXVsdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hc3NldHZhdWx0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFzc2V0VmF1bHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFzc2V0VmF1bHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQXNzZXRWYXVsdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBc3NldFZhdWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hc3NldHZhdWx0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBmYXVjZXRfaWRcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGdldEJhbGFuY2UoZmF1Y2V0X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYXNzZXR2YXVsdF9nZXRCYWxhbmNlKHRoaXMuX193YmdfcHRyLCBmYXVjZXRfaWQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldFtdfVxuICAgICAqL1xuICAgIGZ1bmdpYmxlQXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFzc2V0dmF1bHRfZnVuZ2libGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBc3NldFZhdWx0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBc3NldFZhdWx0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBdXRoU2VjcmV0S2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2F1dGhzZWNyZXRrZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQXV0aFNlY3JldEtleSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQXV0aFNlY3JldEtleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBdXRoU2VjcmV0S2V5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEF1dGhTZWNyZXRLZXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2F1dGhzZWNyZXRrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBnZXRScG9GYWxjb241MTJQdWJsaWNLZXlBc1dvcmQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYXV0aHNlY3JldGtleV9nZXRScG9GYWxjb241MTJQdWJsaWNLZXlBc1dvcmQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICBnZXRScG9GYWxjb241MTJTZWNyZXRLZXlBc0ZlbHRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmF1dGhzZWNyZXRrZXlfZ2V0UnBvRmFsY29uNTEyU2VjcmV0S2V5QXNGZWx0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgZ2V0RWNkc2FLMjU2S2VjY2FrUHVibGljS2V5QXNXb3JkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmF1dGhzZWNyZXRrZXlfZ2V0RWNkc2FLMjU2S2VjY2FrUHVibGljS2V5QXNXb3JkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgZ2V0RWNkc2FLMjU2S2VjY2FrU2VjcmV0S2V5QXNGZWx0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hdXRoc2VjcmV0a2V5X2dldEVjZHNhSzI1NktlY2Nha1NlY3JldEtleUFzRmVsdHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBdXRoU2VjcmV0S2V5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBdXRoU2VjcmV0S2V5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Jhc2ljZnVuZ2libGVmYXVjZXRjb21wb25lbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Jhc2ljZnVuZ2libGVmYXVjZXRjb21wb25lbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnR9IGFjY291bnRcbiAgICAgKiBAcmV0dXJucyB7QmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUFjY291bnQoYWNjb3VudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudCwgQWNjb3VudCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGFjY291bnQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmJhc2ljZnVuZ2libGVmYXVjZXRjb21wb25lbnRfZnJvbUFjY291bnQocmV0cHRyLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Rva2VuU3ltYm9sfVxuICAgICAqL1xuICAgIHN5bWJvbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfcHJlZml4KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRva2VuU3ltYm9sLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGRlY2ltYWxzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJhc2ljZnVuZ2libGVmYXVjZXRjb21wb25lbnRfZGVjaW1hbHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBtYXhTdXBwbHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX3N1ZmZpeCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQmxvY2tIZWFkZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYmxvY2toZWFkZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQmxvY2tIZWFkZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEJsb2NrSGVhZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEJsb2NrSGVhZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEJsb2NrSGVhZGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ibG9ja2hlYWRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl92ZXJzaW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHN1YkNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfc3ViQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBwcmV2QmxvY2tDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBibG9ja051bSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl9ibG9ja051bSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNoYWluQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX3N0b3JhZ2VDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGFjY291bnRSb290KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfY29kZUNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgbnVsbGlmaWVyUm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl9udWxsaWZpZXJSb290KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIG5vdGVSb290KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX25vdGVSb290KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHR4Q29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl90eENvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgdHhLZXJuZWxDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVycmVzdWx0X3NlZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcHJvb2ZDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX3Byb29mQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRpbWVzdGFtcCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl90aW1lc3RhbXAodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQmxvY2tIZWFkZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEJsb2NrSGVhZGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBDb25zdW1hYmxlTm90ZVJlY29yZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19jb25zdW1hYmxlbm90ZXJlY29yZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBDb25zdW1hYmxlTm90ZVJlY29yZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQ29uc3VtYWJsZU5vdGVSZWNvcmQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQ29uc3VtYWJsZU5vdGVSZWNvcmRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQ29uc3VtYWJsZU5vdGVSZWNvcmRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2NvbnN1bWFibGVub3RlcmVjb3JkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnB1dE5vdGVSZWNvcmR9IGlucHV0X25vdGVfcmVjb3JkXG4gICAgICogQHBhcmFtIHtOb3RlQ29uc3VtYWJpbGl0eVtdfSBub3RlX2NvbnN1bWFiaWxpdHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnB1dF9ub3RlX3JlY29yZCwgbm90ZV9jb25zdW1hYmlsaXR5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhpbnB1dF9ub3RlX3JlY29yZCwgSW5wdXROb3RlUmVjb3JkKTtcbiAgICAgICAgdmFyIHB0cjAgPSBpbnB1dF9ub3RlX3JlY29yZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKG5vdGVfY29uc3VtYWJpbGl0eSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY29uc3VtYWJsZW5vdGVyZWNvcmRfbmV3KHB0cjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQ29uc3VtYWJsZU5vdGVSZWNvcmRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZVJlY29yZH1cbiAgICAgKi9cbiAgICBpbnB1dE5vdGVSZWNvcmQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY29uc3VtYWJsZW5vdGVyZWNvcmRfaW5wdXROb3RlUmVjb3JkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIElucHV0Tm90ZVJlY29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVDb25zdW1hYmlsaXR5W119XG4gICAgICovXG4gICAgbm90ZUNvbnN1bWFiaWxpdHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uY29uc3VtYWJsZW5vdGVyZWNvcmRfbm90ZUNvbnN1bWFiaWxpdHkocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBDb25zdW1hYmxlTm90ZVJlY29yZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQ29uc3VtYWJsZU5vdGVSZWNvcmQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEVuZHBvaW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2VuZHBvaW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBuZXR3b3JrIGVuZHBvaW50IGZvciBjb25uZWN0aW5nIHRvIE1pZGVuIG5vZGVzLlxuICpcbiAqIEFuIGVuZHBvaW50IGNvbnNpc3RzIG9mIGEgcHJvdG9jb2wgKGh0dHAvaHR0cHMpLCBob3N0LCBhbmQgb3B0aW9uYWwgcG9ydC5cbiAqIFByb3ZpZGVzIGNvbnZlbmllbnQgY29uc3RydWN0b3JzIGZvciBjb21tb24gbmV0d29yayBjb25maWd1cmF0aW9ucy5cbiAqL1xuY2xhc3MgRW5kcG9pbnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEVuZHBvaW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEVuZHBvaW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEVuZHBvaW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19lbmRwb2ludF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW5kcG9pbnQgZnJvbSBhIFVSTCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBzdHJpbmcgKGUuZy4sIDxodHRwczovL2xvY2FsaG9zdDo1NzI5MT4pXG4gICAgICogQHRocm93cyB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIFVSTCBpcyBpbnZhbGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5lbmRwb2ludF9uZXcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByMCA+Pj4gMDtcbiAgICAgICAgICAgIEVuZHBvaW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbmRwb2ludCBmb3IgdGhlIE1pZGVuIHRlc3RuZXQuXG4gICAgICogQHJldHVybnMge0VuZHBvaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZXN0bmV0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVuZHBvaW50X3Rlc3RuZXQoKTtcbiAgICAgICAgcmV0dXJuIEVuZHBvaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbmRwb2ludCBmb3IgdGhlIE1pZGVuIGRldm5ldC5cbiAgICAgKiBAcmV0dXJucyB7RW5kcG9pbnR9XG4gICAgICovXG4gICAgc3RhdGljIGRldm5ldCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lbmRwb2ludF9kZXZuZXQoKTtcbiAgICAgICAgcmV0dXJuIEVuZHBvaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbmRwb2ludCBmb3IgYSBsb2NhbCBNaWRlbiBub2RlLlxuICAgICAqXG4gICAgICogVXNlcyA8aHR0cDovL2xvY2FsaG9zdDo1NzI5MT5cbiAgICAgKiBAcmV0dXJucyB7RW5kcG9pbnR9XG4gICAgICovXG4gICAgc3RhdGljIGxvY2FsaG9zdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lbmRwb2ludF9sb2NhbGhvc3QoKTtcbiAgICAgICAgcmV0dXJuIEVuZHBvaW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm90b2NvbCBvZiB0aGUgZW5kcG9pbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmVuZHBvaW50X3Byb3RvY29sKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob3N0IG9mIHRoZSBlbmRwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBob3N0KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5lbmRwb2ludF9ob3N0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3J0IG9mIHRoZSBlbmRwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBwb3J0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVuZHBvaW50X3BvcnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAweEZGRkZGRiA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbmRwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5lbmRwb2ludF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEVuZHBvaW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBFbmRwb2ludC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRXhlY3V0ZWRUcmFuc2FjdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19leGVjdXRlZHRyYW5zYWN0aW9uX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEV4ZWN1dGVkVHJhbnNhY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEV4ZWN1dGVkVHJhbnNhY3Rpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRXhlY3V0ZWRUcmFuc2FjdGlvbkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBFeGVjdXRlZFRyYW5zYWN0aW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19leGVjdXRlZHRyYW5zYWN0aW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGFjY291bnRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2FjY291bnRJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SGVhZGVyfVxuICAgICAqL1xuICAgIGluaXRpYWxBY2NvdW50SGVhZGVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25faW5pdGlhbEFjY291bnRIZWFkZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEhlYWRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRIZWFkZXJ9XG4gICAgICovXG4gICAgZmluYWxBY2NvdW50SGVhZGVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25fZmluYWxBY2NvdW50SGVhZGVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRIZWFkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGVzfVxuICAgICAqL1xuICAgIGlucHV0Tm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9pbnB1dE5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIElucHV0Tm90ZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3Rlc31cbiAgICAgKi9cbiAgICBvdXRwdXROb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX291dHB1dE5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25BcmdzfVxuICAgICAqL1xuICAgIHR4QXJncygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX3R4QXJncyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbkFyZ3MuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCbG9ja0hlYWRlcn1cbiAgICAgKi9cbiAgICBibG9ja0hlYWRlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2Jsb2NrSGVhZGVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJsb2NrSGVhZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudERlbHRhfVxuICAgICAqL1xuICAgIGFjY291bnREZWx0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2FjY291bnREZWx0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50RGVsdGEuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBFeGVjdXRlZFRyYW5zYWN0aW9uLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBFeGVjdXRlZFRyYW5zYWN0aW9uLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGZWx0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ZlbHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRmVsdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRmVsdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGZWx0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgRmVsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRmVsdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZmVsdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmVsdF9uZXcodmFsdWUpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRmVsdEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGFzSW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZlbHRfYXNJbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZlbHRfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGZWx0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGZWx0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGZWx0QXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZmVsdGFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZlbHRBcnJheSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRmVsdEFycmF5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZlbHRBcnJheUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGZWx0QXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ZlbHRhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmVsdFtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZWx0YXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRmVsdEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0ZlbHR9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZmVsdGFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7RmVsdH0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgRmVsdCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmZlbHRhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmVsdH0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgRmVsdCk7XG4gICAgICAgIHdhc20uZmVsdGFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmVsdGFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGZWx0QXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZlbHRBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRmV0Y2hlZE5vdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZmV0Y2hlZG5vdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIG5vdGUgZmV0Y2hlZCBmcm9tIGEgTWlkZW4gbm9kZSB2aWEgUlBDLlxuICovXG5jbGFzcyBGZXRjaGVkTm90ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRmV0Y2hlZE5vdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRmV0Y2hlZE5vdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRmV0Y2hlZE5vdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ZldGNoZWRub3RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbm90ZSB3aXRoIGFuIG9wdGlvbmFsIGBJbnB1dE5vdGVgLlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkfSBub3RlX2lkXG4gICAgICogQHBhcmFtIHtOb3RlTWV0YWRhdGF9IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtJbnB1dE5vdGUgfCBudWxsfSBbaW5wdXRfbm90ZV1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlX2lkLCBtZXRhZGF0YSwgaW5wdXRfbm90ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9pZCwgTm90ZUlkKTtcbiAgICAgICAgdmFyIHB0cjAgPSBub3RlX2lkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MobWV0YWRhdGEsIE5vdGVNZXRhZGF0YSk7XG4gICAgICAgIHZhciBwdHIxID0gbWV0YWRhdGEuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGxldCBwdHIyID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGlucHV0X25vdGUpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoaW5wdXRfbm90ZSwgSW5wdXROb3RlKTtcbiAgICAgICAgICAgIHB0cjIgPSBpbnB1dF9ub3RlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmV0Y2hlZG5vdGVfbmV3KHB0cjAsIHB0cjEsIHB0cjIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRmV0Y2hlZE5vdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBub3RlLlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgZ2V0IG5vdGVJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZXRjaGVkbm90ZV9ub3RlSWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbm90ZSdzIG1ldGFkYXRhLCBpbmNsdWRpbmcgc2VuZGVyLCB0YWcsIGFuZCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIEF2YWlsYWJsZSBmb3IgYm90aCBwcml2YXRlIGFuZCBwdWJsaWMgbm90ZXMuXG4gICAgICogQHJldHVybnMge05vdGVNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmV0Y2hlZG5vdGVfbWV0YWRhdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZU1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbCBbYElucHV0Tm90ZWBdIHdpdGggaW5jbHVzaW9uIHByb29mLlxuICAgICAqXG4gICAgICogRm9yIHB1YmxpYyBub3RlcywgaXQgY29udGFpbnMgdGhlIGNvbXBsZXRlIG5vdGUgZGF0YSBhbmQgaW5jbHVzaW9uIHByb29mLlxuICAgICAqIEZvciBwcml2YXRlIG5vdGVzLCBpdCB3aWxsIGJlIGBgTm9uZWAuXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgaW5wdXROb3RlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZldGNoZWRub3RlX2lucHV0Tm90ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBJbnB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlVHlwZX1cbiAgICAgKi9cbiAgICBnZXQgbm90ZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmV0Y2hlZG5vdGVfbm90ZVR5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRmV0Y2hlZE5vdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZldGNoZWROb3RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGbGF0dGVuZWRVOFZlY0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mbGF0dGVuZWR1OHZlY19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGbGF0dGVuZWRVOFZlYyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRmxhdHRlbmVkVThWZWMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRmxhdHRlbmVkVThWZWNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRmxhdHRlbmVkVThWZWNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ZsYXR0ZW5lZHU4dmVjX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mbGF0dGVuZWR1OHZlY19kYXRhKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQzMkFycmF5fVxuICAgICAqL1xuICAgIGxlbmd0aHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZmxhdHRlbmVkdTh2ZWNfbGVuZ3RocyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VTMyRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bV9pbm5lcl92ZWNzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZsYXR0ZW5lZHU4dmVjX251bV9pbm5lcl92ZWNzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZsYXR0ZW5lZFU4VmVjLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGbGF0dGVuZWRVOFZlYy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRm9yZWlnbkFjY291bnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZm9yZWlnbmFjY291bnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRm9yZWlnbkFjY291bnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZvcmVpZ25BY2NvdW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZvcmVpZ25BY2NvdW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgRm9yZWlnbkFjY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZvcmVpZ25BY2NvdW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mb3JlaWduYWNjb3VudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c30gc3RvcmFnZV9yZXF1aXJlbWVudHNcbiAgICAgKiBAcmV0dXJucyB7Rm9yZWlnbkFjY291bnR9XG4gICAgICovXG4gICAgc3RhdGljIHB1YmxpYyhhY2NvdW50X2lkLCBzdG9yYWdlX3JlcXVpcmVtZW50cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gYWNjb3VudF9pZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yYWdlX3JlcXVpcmVtZW50cywgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMpO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSBzdG9yYWdlX3JlcXVpcmVtZW50cy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uZm9yZWlnbmFjY291bnRfcHVibGljKHJldHB0ciwgcHRyMCwgcHRyMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGb3JlaWduQWNjb3VudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHN9XG4gICAgICovXG4gICAgc3RvcmFnZV9zbG90X3JlcXVpcmVtZW50cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mb3JlaWduYWNjb3VudF9zdG9yYWdlX3Nsb3RfcmVxdWlyZW1lbnRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGFjY291bnRfaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZm9yZWlnbmFjY291bnRfYWNjb3VudF9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGb3JlaWduQWNjb3VudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRm9yZWlnbkFjY291bnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZvcmVpZ25BY2NvdW50QXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZm9yZWlnbmFjY291bnRhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGb3JlaWduQWNjb3VudEFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRm9yZWlnbkFjY291bnRBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZm9yZWlnbmFjY291bnRhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Rm9yZWlnbkFjY291bnRbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZm9yZWlnbmFjY291bnRhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBGb3JlaWduQWNjb3VudEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0ZvcmVpZ25BY2NvdW50fVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZvcmVpZ25hY2NvdW50YXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZvcmVpZ25BY2NvdW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Rm9yZWlnbkFjY291bnR9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIEZvcmVpZ25BY2NvdW50KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uZm9yZWlnbmFjY291bnRhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Rm9yZWlnbkFjY291bnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIEZvcmVpZ25BY2NvdW50KTtcbiAgICAgICAgd2FzbS5mb3JlaWduYWNjb3VudGFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZm9yZWlnbmFjY291bnRhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRm9yZWlnbkFjY291bnRBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRm9yZWlnbkFjY291bnRBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRnVuZ2libGVBc3NldEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mdW5naWJsZWFzc2V0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZ1bmdpYmxlQXNzZXQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZ1bmdpYmxlQXNzZXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRnVuZ2libGVBc3NldEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEZ1bmdpYmxlQXNzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Z1bmdpYmxlYXNzZXRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGFtb3VudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZhdWNldF9pZCwgYW1vdW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldF9uZXcoZmF1Y2V0X2lkLl9fd2JnX3B0ciwgYW1vdW50KTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBmYXVjZXRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0X2Ftb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgaW50b1dvcmQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldF9pbnRvV29yZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRnVuZ2libGVBc3NldC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRnVuZ2libGVBc3NldC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRnVuZ2libGVBc3NldERlbHRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Z1bmdpYmxlYXNzZXRkZWx0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGdW5naWJsZUFzc2V0RGVsdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZ1bmdpYmxlQXNzZXREZWx0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGdW5naWJsZUFzc2V0RGVsdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRnVuZ2libGVBc3NldERlbHRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mdW5naWJsZWFzc2V0ZGVsdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldGRlbHRhX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldERlbHRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZ1bmdpYmxlYXNzZXRkZWx0YV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGdW5naWJsZUFzc2V0RGVsdGEuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0ZGVsdGFfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBmYXVjZXRfaWRcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGFtb3VudChmYXVjZXRfaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHdhc20uZnVuZ2libGVhc3NldGRlbHRhX2Ftb3VudChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBmYXVjZXRfaWQuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEJpZ0ludDY0KHJldHB0ciArIDggKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IHIyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bUFzc2V0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0ZGVsdGFfbnVtQXNzZXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXREZWx0YUl0ZW1bXX1cbiAgICAgKi9cbiAgICBhc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZnVuZ2libGVhc3NldGRlbHRhX2Fzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZ1bmdpYmxlQXNzZXREZWx0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRnVuZ2libGVBc3NldERlbHRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGdW5naWJsZUFzc2V0RGVsdGFJdGVtRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Z1bmdpYmxlYXNzZXRkZWx0YWl0ZW1fZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRnVuZ2libGVBc3NldERlbHRhSXRlbSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRnVuZ2libGVBc3NldERlbHRhSXRlbS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGdW5naWJsZUFzc2V0RGVsdGFJdGVtRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW1GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Z1bmdpYmxlYXNzZXRkZWx0YWl0ZW1fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGdldCBmYXVjZXRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZnVuZ2libGVhc3NldF9hbW91bnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRnVuZ2libGVBc3NldERlbHRhSXRlbS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRnVuZ2libGVBc3NldERlbHRhSXRlbS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW1GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZ2V0cHJvY2VkdXJlc3Jlc3VsdGl0ZW1fZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW0ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEdldFByb2NlZHVyZXNSZXN1bHRJdGVtLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEdldFByb2NlZHVyZXNSZXN1bHRJdGVtRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEdldFByb2NlZHVyZXNSZXN1bHRJdGVtRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19nZXRwcm9jZWR1cmVzcmVzdWx0aXRlbV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGdldCBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNBdXRoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdldHByb2NlZHVyZXNyZXN1bHRpdGVtX2lzQXV0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW0ucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IElucHV0Tm90ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbnB1dG5vdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgSW5wdXROb3RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShJbnB1dE5vdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSW5wdXROb3RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIElucHV0Tm90ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfaW5wdXRub3RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZX1cbiAgICAgKi9cbiAgICBub3RlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZV9ub3RlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJbmNsdXNpb25Qcm9vZiB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBwcm9vZigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVfcHJvb2YodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTm90ZUluY2x1c2lvblByb29mLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUxvY2F0aW9uIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGxvY2F0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZV9sb2NhdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBOb3RlTG9jYXRpb24uX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBJbnB1dE5vdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IElucHV0Tm90ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSW5wdXROb3RlUmVjb3JkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2lucHV0bm90ZXJlY29yZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBJbnB1dE5vdGVSZWNvcmQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKElucHV0Tm90ZVJlY29yZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBJbnB1dE5vdGVSZWNvcmRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW5wdXROb3RlUmVjb3JkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbnB1dG5vdGVyZWNvcmRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGVTdGF0ZX1cbiAgICAgKi9cbiAgICBzdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfc3RhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZURldGFpbHN9XG4gICAgICovXG4gICAgZGV0YWlscygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfZGV0YWlscyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRGV0YWlscy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVNZXRhZGF0YSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBtZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfbWV0YWRhdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTm90ZU1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSW5jbHVzaW9uUHJvb2YgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgaW5jbHVzaW9uUHJvb2YoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2luY2x1c2lvblByb29mKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IE5vdGVJbmNsdXNpb25Qcm9vZi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBjb25zdW1lclRyYW5zYWN0aW9uSWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uaW5wdXRub3RlcmVjb3JkX2NvbnN1bWVyVHJhbnNhY3Rpb25JZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBudWxsaWZpZXIoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmlucHV0bm90ZXJlY29yZF9udWxsaWZpZXIocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQXV0aGVudGljYXRlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfaXNBdXRoZW50aWNhdGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb25zdW1lZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfaXNDb25zdW1lZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUHJvY2Vzc2luZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfaXNQcm9jZXNzaW5nKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZX1cbiAgICAgKi9cbiAgICB0b0lucHV0Tm90ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5pbnB1dG5vdGVyZWNvcmRfdG9JbnB1dE5vdGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJbnB1dE5vdGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIElucHV0Tm90ZVJlY29yZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSW5wdXROb3RlUmVjb3JkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBJbnB1dE5vdGVzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2lucHV0bm90ZXNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgSW5wdXROb3RlcyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSW5wdXROb3Rlcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBJbnB1dE5vdGVzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIElucHV0Tm90ZXNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2lucHV0bm90ZXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1Ob3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVzX251bU5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVzX2lzRW1wdHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3RlfVxuICAgICAqL1xuICAgIGdldE5vdGUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVzX2dldE5vdGUodGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIElucHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZVtdfVxuICAgICAqL1xuICAgIG5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmlucHV0bm90ZXNfbm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBJbnB1dE5vdGVzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBJbnB1dE5vdGVzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW50b3VuZGVybHlpbmdieXRlc291cmNlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEludG9VbmRlcmx5aW5nQnl0ZVNvdXJjZSB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEludG9VbmRlcmx5aW5nQnl0ZVNvdXJjZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfaW50b3VuZGVybHlpbmdieXRlc291cmNlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtVHlwZX1cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2VfdHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBfX3diaW5kZ2VuX2VudW1fUmVhZGFibGVTdHJlYW1UeXBlW3JldF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2VfYXV0b0FsbG9jYXRlQ2h1bmtTaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfSBjb250cm9sbGVyXG4gICAgICovXG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICB3YXNtLmludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV9zdGFydCh0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChjb250cm9sbGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0gY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdieXRlc291cmNlX3B1bGwodGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoY29udHJvbGxlcikpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uaW50b3VuZGVybHlpbmdieXRlc291cmNlX2NhbmNlbChwdHIpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSW50b1VuZGVybHlpbmdCeXRlU291cmNlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2UucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEludG9VbmRlcmx5aW5nU2lua0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbnRvdW5kZXJseWluZ3NpbmtfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgSW50b1VuZGVybHlpbmdTaW5rIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW50b1VuZGVybHlpbmdTaW5rRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbnRvdW5kZXJseWluZ3NpbmtfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gY2h1bmtcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdzaW5rX3dyaXRlKHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGNodW5rKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdzaW5rX2Nsb3NlKHB0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSByZWFzb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFib3J0KHJlYXNvbikge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nc2lua19hYm9ydChwdHIsIGFkZEhlYXBPYmplY3QocmVhc29uKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBJbnRvVW5kZXJseWluZ1NpbmsucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEludG9VbmRlcmx5aW5nU2luay5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSW50b1VuZGVybHlpbmdTb3VyY2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW50b3VuZGVybHlpbmdzb3VyY2VfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgSW50b1VuZGVybHlpbmdTb3VyY2Uge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbnRvVW5kZXJseWluZ1NvdXJjZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfaW50b3VuZGVybHlpbmdzb3VyY2VfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nc291cmNlX3B1bGwodGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoY29udHJvbGxlcikpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uaW50b3VuZGVybHlpbmdzb3VyY2VfY2FuY2VsKHB0cik7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBJbnRvVW5kZXJseWluZ1NvdXJjZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSW50b1VuZGVybHlpbmdTb3VyY2UucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEpzQWNjb3VudFVwZGF0ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19qc2FjY291bnR1cGRhdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiB1cGRhdGUgdG8gYSBzaW5nbGUgYWNjb3VudCdzIHN0YXRlLlxuICovXG5jbGFzcyBKc0FjY291bnRVcGRhdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpzQWNjb3VudFVwZGF0ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBKc0FjY291bnRVcGRhdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBKc0FjY291bnRVcGRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yYWdlUm9vdDogdGhpcy5zdG9yYWdlUm9vdCxcbiAgICAgICAgICAgIHN0b3JhZ2VTbG90czogdGhpcy5zdG9yYWdlU2xvdHMsXG4gICAgICAgICAgICBzdG9yYWdlTWFwRW50cmllczogdGhpcy5zdG9yYWdlTWFwRW50cmllcyxcbiAgICAgICAgICAgIGFzc2V0VmF1bHRSb290OiB0aGlzLmFzc2V0VmF1bHRSb290LFxuICAgICAgICAgICAgYXNzZXRzOiB0aGlzLmFzc2V0cyxcbiAgICAgICAgICAgIGFjY291bnRJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICBjb2RlUm9vdDogdGhpcy5jb2RlUm9vdCxcbiAgICAgICAgICAgIGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIGFjY291bnRDb21taXRtZW50OiB0aGlzLmFjY291bnRDb21taXRtZW50LFxuICAgICAgICAgICAgYWNjb3VudFNlZWQ6IHRoaXMuYWNjb3VudFNlZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEpzQWNjb3VudFVwZGF0ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNhY2NvdW50dXBkYXRlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSBhY2NvdW50J3Mgc3RvcmFnZSB0cmllLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHN0b3JhZ2VSb290KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIGFjY291bnQncyBzdG9yYWdlIHRyaWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RvcmFnZVJvb3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIHN0b3JhZ2Ugc2xvdCBkYXRhIGZvciB0aGlzIGFjY291bnQuXG4gICAgICogQHJldHVybnMge0pzU3RvcmFnZVNsb3RbXX1cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZVNsb3RzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVNsb3RzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIHN0b3JhZ2Ugc2xvdCBkYXRhIGZvciB0aGlzIGFjY291bnQuXG4gICAgICogQHBhcmFtIHtKc1N0b3JhZ2VTbG90W119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RvcmFnZVNsb3RzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVNsb3RzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplZCBzdG9yYWdlIG1hcCBlbnRyaWVzIGZvciB0aGlzIGFjY291bnQuXG4gICAgICogQHJldHVybnMge0pzU3RvcmFnZU1hcEVudHJ5W119XG4gICAgICovXG4gICAgZ2V0IHN0b3JhZ2VNYXBFbnRyaWVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZU1hcEVudHJpZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgc3RvcmFnZSBtYXAgZW50cmllcyBmb3IgdGhpcyBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7SnNTdG9yYWdlTWFwRW50cnlbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdG9yYWdlTWFwRW50cmllcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VNYXBFbnRyaWVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSBhY2NvdW50J3MgYXNzZXQgdmF1bHQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYXNzZXRWYXVsdFJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYXNzZXRWYXVsdFJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgYWNjb3VudCdzIGFzc2V0IHZhdWx0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGFzc2V0VmF1bHRSb290KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2Fzc2V0VmF1bHRSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY291bnQncyBhc3NldCB2YXVsdC5cbiAgICAgKiBAcmV0dXJucyB7SnNWYXVsdEFzc2V0W119XG4gICAgICovXG4gICAgZ2V0IGFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2Fzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY291bnQncyBhc3NldCB2YXVsdC5cbiAgICAgKiBAcGFyYW0ge0pzVmF1bHRBc3NldFtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGFzc2V0cyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2Fzc2V0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElEIGZvciB0aGlzIGFjY291bnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudElkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRJZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSUQgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBhY2NvdW50SWQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudElkKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSBhY2NvdW50J3MgZXhlY3V0YWJsZSBjb2RlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGNvZGVSb290KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2NvZGVSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIGFjY291bnQncyBleGVjdXRhYmxlIGNvZGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgY29kZVJvb3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfY29kZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgYWNjb3VudCB1cGRhdGUgaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21taXR0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9jb21taXR0ZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgYWNjb3VudCB1cGRhdGUgaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBjb21taXR0ZWQoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfY29tbWl0dGVkKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY291bnQncyB0cmFuc2FjdGlvbiBub25jZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBub25jZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9ub25jZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY291bnQncyB0cmFuc2FjdGlvbiBub25jZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBub25jZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9ub25jZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjcnlwdG9ncmFwaGljIGNvbW1pdG1lbnQgcmVwcmVzZW50aW5nIHRoaXMgYWNjb3VudCdzIGN1cnJlbnQgc3RhdGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudENvbW1pdG1lbnQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudENvbW1pdG1lbnQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjcnlwdG9ncmFwaGljIGNvbW1pdG1lbnQgcmVwcmVzZW50aW5nIHRoaXMgYWNjb3VudCdzIGN1cnJlbnQgc3RhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYWNjb3VudENvbW1pdG1lbnQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudENvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBzZWVkIGRhdGEgZm9yIHRoZSBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBhY2NvdW50U2VlZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRTZWVkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgc2VlZCBkYXRhIGZvciB0aGUgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgYWNjb3VudFNlZWQoYXJnMCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudFNlZWQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSnNBY2NvdW50VXBkYXRlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBKc0FjY291bnRVcGRhdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEpzU3RhdGVTeW5jVXBkYXRlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2pzc3RhdGVzeW5jdXBkYXRlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGRhdGEgZm9yIGEgc3luYyB1cGRhdGUsXG4gKiB3aGljaCB3aWxsIGJlIHJlY2VpdmVkIGJ5IHRoZSBhcHBseVN0YXRlU3luYyBKUyBmdW5jdGlvbi5cbiAqIHVuZGVyIHN5bmMuanNcbiAqL1xuY2xhc3MgSnNTdGF0ZVN5bmNVcGRhdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpzU3RhdGVTeW5jVXBkYXRlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEpzU3RhdGVTeW5jVXBkYXRlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEpzU3RhdGVTeW5jVXBkYXRlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc3N0YXRlc3luY3VwZGF0ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBibG9jayBudW1iZXIgZm9yIHRoaXMgdXBkYXRlLCBzdG9yZWQgYXMgYSBzdHJpbmcgc2luY2UgaXQgd2lsbCBiZVxuICAgICAqIHBlcnNpc3RlZCBpbiBgSW5kZXhlZERCYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBibG9ja051bSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NrIG51bWJlciBmb3IgdGhpcyB1cGRhdGUsIHN0b3JlZCBhcyBhIHN0cmluZyBzaW5jZSBpdCB3aWxsIGJlXG4gICAgICogcGVyc2lzdGVkIGluIGBJbmRleGVkREJgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGJsb2NrTnVtKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5ldyBibG9jayBoZWFkZXJzIGZvciB0aGlzIHN0YXRlIHVwZGF0ZSwgc2VyaWFsaXplZCBpbnRvIGEgZmxhdHRlbmVkIGJ5dGUgYXJyYXkuXG4gICAgICogQHJldHVybnMge0ZsYXR0ZW5lZFU4VmVjfVxuICAgICAqL1xuICAgIGdldCBmbGF0dGVuZWROZXdCbG9ja0hlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX2ZsYXR0ZW5lZE5ld0Jsb2NrSGVhZGVycyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGbGF0dGVuZWRVOFZlYy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5ldyBibG9jayBoZWFkZXJzIGZvciB0aGlzIHN0YXRlIHVwZGF0ZSwgc2VyaWFsaXplZCBpbnRvIGEgZmxhdHRlbmVkIGJ5dGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtGbGF0dGVuZWRVOFZlY30gYXJnMFxuICAgICAqL1xuICAgIHNldCBmbGF0dGVuZWROZXdCbG9ja0hlYWRlcnMoYXJnMCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJnMCwgRmxhdHRlbmVkVThWZWMpO1xuICAgICAgICB2YXIgcHRyMCA9IGFyZzAuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX2ZsYXR0ZW5lZE5ld0Jsb2NrSGVhZGVycyh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBibG9jayBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBoZWFkZXIgaW4gYGZsYXR0ZW5lZF9uZXdfYmxvY2tfaGVhZGVyc2AuXG4gICAgICogVGhpcyB2ZWMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgaGVhZGVycywgd2l0aCBlYWNoIGluZGV4XG4gICAgICogcmVwcmVzZW50aW5nIHRoZSBibG9jayBudW1iZXIgZm9yIHRoZSBoZWFkZXIgYXQgdGhhdCBzYW1lIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXQgbmV3QmxvY2tOdW1zKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9uZXdCbG9ja051bXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBibG9jayBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBoZWFkZXIgaW4gYGZsYXR0ZW5lZF9uZXdfYmxvY2tfaGVhZGVyc2AuXG4gICAgICogVGhpcyB2ZWMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgaGVhZGVycywgd2l0aCBlYWNoIGluZGV4XG4gICAgICogcmVwcmVzZW50aW5nIHRoZSBibG9jayBudW1iZXIgZm9yIHRoZSBoZWFkZXIgYXQgdGhhdCBzYW1lIGluZGV4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbmV3QmxvY2tOdW1zKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9uZXdCbG9ja051bXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0dGVuZWQgYnl0ZSBhcnJheSBjb250YWluaW5nIHBhcnRpYWwgYmxvY2tjaGFpbiBwZWFrcyB1c2VkIGZvciBtZXJrbGUgdHJlZVxuICAgICAqIHZlcmlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RmxhdHRlbmVkVThWZWN9XG4gICAgICovXG4gICAgZ2V0IGZsYXR0ZW5lZFBhcnRpYWxCbG9ja0NoYWluUGVha3MoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX2ZsYXR0ZW5lZFBhcnRpYWxCbG9ja0NoYWluUGVha3ModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmxhdHRlbmVkVThWZWMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5lZCBieXRlIGFycmF5IGNvbnRhaW5pbmcgcGFydGlhbCBibG9ja2NoYWluIHBlYWtzIHVzZWQgZm9yIG1lcmtsZSB0cmVlXG4gICAgICogdmVyaWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7RmxhdHRlbmVkVThWZWN9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgZmxhdHRlbmVkUGFydGlhbEJsb2NrQ2hhaW5QZWFrcyhhcmcwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhcmcwLCBGbGF0dGVuZWRVOFZlYyk7XG4gICAgICAgIHZhciBwdHIwID0gYXJnMC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfZmxhdHRlbmVkUGFydGlhbEJsb2NrQ2hhaW5QZWFrcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGJsb2NrIGluIHRoaXMgdXBkYXRlLCBzdG9yZXMgYSBib29sZWFuIChhcyB1OCkgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogdGhhdCBibG9jayBjb250YWlucyBub3RlcyByZWxldmFudCB0byB0aGlzIGNsaWVudC4gSW5kZXggaSBjb3JyZXNwb25kcyB0b1xuICAgICAqIHRoZSBpdGggYmxvY2ssIHdpdGggMSBtZWFuaW5nIHJlbGV2YW50IGFuZCAwIG1lYW5pbmcgbm90IHJlbGV2YW50LlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBibG9ja0hhc1JlbGV2YW50Tm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX2Jsb2NrSGFzUmVsZXZhbnROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGJsb2NrIGluIHRoaXMgdXBkYXRlLCBzdG9yZXMgYSBib29sZWFuIChhcyB1OCkgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogdGhhdCBibG9jayBjb250YWlucyBub3RlcyByZWxldmFudCB0byB0aGlzIGNsaWVudC4gSW5kZXggaSBjb3JyZXNwb25kcyB0b1xuICAgICAqIHRoZSBpdGggYmxvY2ssIHdpdGggMSBtZWFuaW5nIHJlbGV2YW50IGFuZCAwIG1lYW5pbmcgbm90IHJlbGV2YW50LlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBibG9ja0hhc1JlbGV2YW50Tm90ZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX2Jsb2NrSGFzUmVsZXZhbnROb3Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgSURzIGZvciBuZXcgYXV0aGVudGljYXRpb24gbm9kZXMgcmVxdWlyZWQgdG8gdmVyaWZ5IGJsb2NrIGhlYWRlcnMuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkTm9kZUlkcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZE5vZGVJZHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgSURzIGZvciBuZXcgYXV0aGVudGljYXRpb24gbm9kZXMgcmVxdWlyZWQgdG8gdmVyaWZ5IGJsb2NrIGhlYWRlcnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzZXJpYWxpemVkTm9kZUlkcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZE5vZGVJZHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWN0dWFsIGF1dGhlbnRpY2F0aW9uIG5vZGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHRoZSBJRHMgYWJvdmUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkTm9kZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWROb2RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjdHVhbCBhdXRoZW50aWNhdGlvbiBub2RlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgSURzIGFib3ZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2VyaWFsaXplZE5vZGVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkTm9kZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJRHMgb2Ygbm90ZSB0YWdzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2xpZW50J3MgbG9jYWwgc3RhdGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldCBjb21taXR0ZWROb3RlSWRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9jb21taXR0ZWROb3RlSWRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJRHMgb2Ygbm90ZSB0YWdzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2xpZW50J3MgbG9jYWwgc3RhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBjb21taXR0ZWROb3RlSWRzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9jb21taXR0ZWROb3RlSWRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5wdXQgbm90ZXMgZm9yIHRoaXMgc3RhdGUgdXBkYXRlIGluIHNlcmlhbGl6ZWQgZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7U2VyaWFsaXplZElucHV0Tm90ZURhdGFbXX1cbiAgICAgKi9cbiAgICBnZXQgc2VyaWFsaXplZElucHV0Tm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWRJbnB1dE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnB1dCBub3RlcyBmb3IgdGhpcyBzdGF0ZSB1cGRhdGUgaW4gc2VyaWFsaXplZCBmb3JtLlxuICAgICAqIEBwYXJhbSB7U2VyaWFsaXplZElucHV0Tm90ZURhdGFbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzZXJpYWxpemVkSW5wdXROb3RlcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZElucHV0Tm90ZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgbm90ZXMgY3JlYXRlZCBpbiB0aGlzIHN0YXRlIHVwZGF0ZSBpbiBzZXJpYWxpemVkIGZvcm0uXG4gICAgICogQHJldHVybnMge1NlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YVtdfVxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkT3V0cHV0Tm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWRPdXRwdXROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3V0cHV0IG5vdGVzIGNyZWF0ZWQgaW4gdGhpcyBzdGF0ZSB1cGRhdGUgaW4gc2VyaWFsaXplZCBmb3JtLlxuICAgICAqIEBwYXJhbSB7U2VyaWFsaXplZE91dHB1dE5vdGVEYXRhW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2VyaWFsaXplZE91dHB1dE5vdGVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkT3V0cHV0Tm90ZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NvdW50IHN0YXRlIHVwZGF0ZXMgaW5jbHVkZWQgaW4gdGhpcyBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtKc0FjY291bnRVcGRhdGVbXX1cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudFVwZGF0ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX2FjY291bnRVcGRhdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NvdW50IHN0YXRlIHVwZGF0ZXMgaW5jbHVkZWQgaW4gdGhpcyBzeW5jLlxuICAgICAqIEBwYXJhbSB7SnNBY2NvdW50VXBkYXRlW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYWNjb3VudFVwZGF0ZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX2FjY291bnRVcGRhdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNhY3Rpb24gZGF0YSBmb3IgdHJhbnNhY3Rpb25zIGluY2x1ZGVkIGluIHRoaXMgdXBkYXRlLlxuICAgICAqIEByZXR1cm5zIHtTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhW119XG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9uVXBkYXRlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfdHJhbnNhY3Rpb25VcGRhdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2FjdGlvbiBkYXRhIGZvciB0cmFuc2FjdGlvbnMgaW5jbHVkZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhW119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgdHJhbnNhY3Rpb25VcGRhdGVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV90cmFuc2FjdGlvblVwZGF0ZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSnNTdGF0ZVN5bmNVcGRhdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEpzU3RhdGVTeW5jVXBkYXRlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBKc1N0b3JhZ2VNYXBFbnRyeUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19qc3N0b3JhZ2VtYXBlbnRyeV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgYSBzdG9yYWdlIG1hcCBlbnRyeSBpbiBhbiBhY2NvdW50LlxuICovXG5jbGFzcyBKc1N0b3JhZ2VNYXBFbnRyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSnNTdG9yYWdlTWFwRW50cnkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSnNTdG9yYWdlTWFwRW50cnlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBKc1N0b3JhZ2VNYXBFbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSnNTdG9yYWdlTWFwRW50cnlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzc3RvcmFnZW1hcGVudHJ5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3Qgb2YgdGhlIHN0b3JhZ2UgbWFwIGVudHJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG9mIHRoZSBzdG9yYWdlIG1hcCBlbnRyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCByb290KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGtleSBvZiB0aGUgc3RvcmFnZSBtYXAgZW50cnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQga2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfa2V5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IG9mIHRoZSBzdG9yYWdlIG1hcCBlbnRyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBrZXkoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV9rZXkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0b3JhZ2UgbWFwIGVudHJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RvcmFnZSBtYXAgZW50cnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBKc1N0b3JhZ2VNYXBFbnRyeS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSnNTdG9yYWdlTWFwRW50cnkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEpzU3RvcmFnZVNsb3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfanNzdG9yYWdlc2xvdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgYSBzdG9yYWdlIHNsb3QgaW4gYW4gYWNjb3VudC5cbiAqL1xuY2xhc3MgSnNTdG9yYWdlU2xvdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSnNTdG9yYWdlU2xvdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBKc1N0b3JhZ2VTbG90RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgSnNTdG9yYWdlU2xvdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgICAgIHNsb3RJbmRleDogdGhpcy5zbG90SW5kZXgsXG4gICAgICAgICAgICBzbG90VmFsdWU6IHRoaXMuc2xvdFZhbHVlLFxuICAgICAgICAgICAgc2xvdFR5cGU6IHRoaXMuc2xvdFR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEpzU3RvcmFnZVNsb3RGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzc3RvcmFnZXNsb3RfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXRtZW50IG9mIHRoZSB3aG9sZSBhY2NvdW50IHN0b3JhZ2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjb21taXRtZW50KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXRtZW50IG9mIHRoZSB3aG9sZSBhY2NvdW50IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBjb21taXRtZW50KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBzdG9yYWdlIHNsb3QuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc2xvdEluZGV4KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VzbG90X3Nsb3RJbmRleCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc3RvcmFnZSBzbG90LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNsb3RJbmRleChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZXNsb3Rfc2xvdEluZGV4KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHN0b3JlZCBpbiB0aGUgc3RvcmFnZSBzbG90LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHNsb3RWYWx1ZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X2tleShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHN0b3JlZCBpbiB0aGUgc3RvcmFnZSBzbG90LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNsb3RWYWx1ZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X2tleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzdG9yYWdlIHNsb3QuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc2xvdFR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZXNsb3Rfc2xvdFR5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc3RvcmFnZSBzbG90LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNsb3RUeXBlKGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlc2xvdF9zbG90VHlwZSh0aGlzLl9fd2JnX3B0ciwgYXJnMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBKc1N0b3JhZ2VTbG90LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBKc1N0b3JhZ2VTbG90LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBKc1ZhdWx0QXNzZXRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfanN2YXVsdGFzc2V0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgc2VyaWFsaXplZCB2YXVsdCBhc3NldFxuICovXG5jbGFzcyBKc1ZhdWx0QXNzZXQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEpzVmF1bHRBc3NldC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBKc1ZhdWx0QXNzZXRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBKc1ZhdWx0QXNzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb290OiB0aGlzLnJvb3QsXG4gICAgICAgICAgICB2YXVsdEtleTogdGhpcy52YXVsdEtleSxcbiAgICAgICAgICAgIGZhdWNldElkUHJlZml4OiB0aGlzLmZhdWNldElkUHJlZml4LFxuICAgICAgICAgICAgYXNzZXQ6IHRoaXMuYXNzZXQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEpzVmF1bHRBc3NldEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanN2YXVsdGFzc2V0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSB2YXVsdCdzIGFzc2V0cy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIHZhdWx0J3MgYXNzZXRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHJvb3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmF1bHQga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYXNzZXQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdmF1bHRLZXkoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV9rZXkocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YXVsdCBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3NldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCB2YXVsdEtleShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X2tleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2V0J3MgZmF1Y2V0IElEIHByZWZpeC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmYXVjZXRJZFByZWZpeCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NldCdzIGZhdWNldCBJRCBwcmVmaXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgZmF1Y2V0SWRQcmVmaXgoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdvcmQgcmVwcmVzZW50aW5nIHRoZSBhc3NldC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBhc3NldCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hc3NldFZhdWx0Um9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV29yZCByZXByZXNlbnRpbmcgdGhlIGFzc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGFzc2V0KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2Fzc2V0VmF1bHRSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEpzVmF1bHRBc3NldC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSnNWYXVsdEFzc2V0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBMaWJyYXJ5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2xpYnJhcnlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTGlicmFyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTGlicmFyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBMaWJyYXJ5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIExpYnJhcnlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2xpYnJhcnlfZnJlZShwdHIsIDApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTGlicmFyeS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTGlicmFyeS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTWVya2xlUGF0aEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19tZXJrbGVwYXRoX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE1lcmtsZVBhdGgge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE1lcmtsZVBhdGgucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTWVya2xlUGF0aEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBNZXJrbGVQYXRoRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19tZXJrbGVwYXRoX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBkZXB0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZXJrbGVwYXRoX2RlcHRoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmRbXX1cbiAgICAgKi9cbiAgICBub2RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5tZXJrbGVwYXRoX25vZGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1dvcmR9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21wdXRlUm9vdChpbmRleCwgbm9kZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm9kZSwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWVya2xlcGF0aF9jb21wdXRlUm9vdCh0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIG5vZGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBpbmRleFxuICAgICAqIEBwYXJhbSB7V29yZH0gbm9kZVxuICAgICAqIEBwYXJhbSB7V29yZH0gcm9vdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZlcmlmeShpbmRleCwgbm9kZSwgcm9vdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm9kZSwgV29yZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyb290LCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZXJrbGVwYXRoX3ZlcmlmeSh0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIG5vZGUuX193YmdfcHRyLCByb290Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBNZXJrbGVQYXRoLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBNZXJrbGVQYXRoLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVBc3NldHN9IG5vdGVfYXNzZXRzXG4gICAgICogQHBhcmFtIHtOb3RlTWV0YWRhdGF9IG5vdGVfbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge05vdGVSZWNpcGllbnR9IG5vdGVfcmVjaXBpZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZV9hc3NldHMsIG5vdGVfbWV0YWRhdGEsIG5vdGVfcmVjaXBpZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2Fzc2V0cywgTm90ZUFzc2V0cyk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX21ldGFkYXRhLCBOb3RlTWV0YWRhdGEpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9yZWNpcGllbnQsIE5vdGVSZWNpcGllbnQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfbmV3KG5vdGVfYXNzZXRzLl9fd2JnX3B0ciwgbm90ZV9tZXRhZGF0YS5fX3diZ19wdHIsIG5vdGVfcmVjaXBpZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7Tm90ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBtZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX21ldGFkYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVSZWNpcGllbnR9XG4gICAgICovXG4gICAgcmVjaXBpZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfcmVjaXBpZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVSZWNpcGllbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlQXNzZXRzfVxuICAgICAqL1xuICAgIGFzc2V0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX2Fzc2V0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlQXNzZXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBzY3JpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9zY3JpcHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHNlbmRlclxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge05vdGVBc3NldHN9IGFzc2V0c1xuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7RmVsdH0gYXV4XG4gICAgICogQHJldHVybnMge05vdGV9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVAySUROb3RlKHNlbmRlciwgdGFyZ2V0LCBhc3NldHMsIG5vdGVfdHlwZSwgYXV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzZW5kZXIsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModGFyZ2V0LCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFzc2V0cywgTm90ZUFzc2V0cyk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXV4LCBGZWx0KTtcbiAgICAgICAgICAgIHdhc20ubm90ZV9jcmVhdGVQMklETm90ZShyZXRwdHIsIHNlbmRlci5fX3diZ19wdHIsIHRhcmdldC5fX3diZ19wdHIsIGFzc2V0cy5fX3diZ19wdHIsIG5vdGVfdHlwZSwgYXV4Ll9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBzZW5kZXJcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtOb3RlQXNzZXRzfSBhc3NldHNcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHJlY2xhaW1faGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB0aW1lbG9ja19oZWlnaHRcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge0ZlbHR9IGF1eFxuICAgICAqIEByZXR1cm5zIHtOb3RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQMklERU5vdGUoc2VuZGVyLCB0YXJnZXQsIGFzc2V0cywgcmVjbGFpbV9oZWlnaHQsIHRpbWVsb2NrX2hlaWdodCwgbm90ZV90eXBlLCBhdXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNlbmRlciwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0YXJnZXQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXNzZXRzLCBOb3RlQXNzZXRzKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhdXgsIEZlbHQpO1xuICAgICAgICAgICAgd2FzbS5ub3RlX2NyZWF0ZVAySURFTm90ZShyZXRwdHIsIHNlbmRlci5fX3diZ19wdHIsIHRhcmdldC5fX3diZ19wdHIsIGFzc2V0cy5fX3diZ19wdHIsIGlzTGlrZU5vbmUocmVjbGFpbV9oZWlnaHQpID8gMHgxMDAwMDAwMDEgOiAocmVjbGFpbV9oZWlnaHQpID4+PiAwLCBpc0xpa2VOb25lKHRpbWVsb2NrX2hlaWdodCkgPyAweDEwMDAwMDAwMSA6ICh0aW1lbG9ja19oZWlnaHQpID4+PiAwLCBub3RlX3R5cGUsIGF1eC5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUFuZEFyZ3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWFuZGFyZ3NfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUFuZEFyZ3Mge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVBbmRBcmdzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVBbmRBcmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgTm90ZUFuZEFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVBbmRBcmdzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlYW5kYXJnc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZX0gbm90ZVxuICAgICAqIEBwYXJhbSB7V29yZCB8IG51bGx9IFthcmdzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGUsIGFyZ3MpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGUsIE5vdGUpO1xuICAgICAgICB2YXIgcHRyMCA9IG5vdGUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGxldCBwdHIxID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGFyZ3MpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJncywgV29yZCk7XG4gICAgICAgICAgICBwdHIxID0gYXJncy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVhbmRhcmdzX25ldyhwdHIwLCBwdHIxKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVBbmRBcmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlQW5kQXJncy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUFuZEFyZ3MucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVBbmRBcmdzQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWFuZGFyZ3NhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlQW5kQXJnc0FycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUFuZEFyZ3NBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWFuZGFyZ3NhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUFuZEFyZ3NbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWFuZGFyZ3NhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlQW5kQXJnc0FycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge05vdGVBbmRBcmdzfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVhbmRhcmdzYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVBbmRBcmdzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Tm90ZUFuZEFyZ3N9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIE5vdGVBbmRBcmdzKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ubm90ZWFuZGFyZ3NhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUFuZEFyZ3N9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIE5vdGVBbmRBcmdzKTtcbiAgICAgICAgd2FzbS5ub3RlYW5kYXJnc2FycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWFuZGFyZ3NhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUFuZEFyZ3NBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUFuZEFyZ3NBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUFzc2V0c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlYXNzZXRzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVBc3NldHMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVBc3NldHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUFzc2V0c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlQXNzZXRzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlYXNzZXRzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5naWJsZUFzc2V0W10gfCBudWxsfSBbYXNzZXRzX2FycmF5XVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFzc2V0c19hcnJheSkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXNzZXRzX2FycmF5KSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhc3NldHNfYXJyYXksIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlYXNzZXRzX25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVBc3NldHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5naWJsZUFzc2V0fSBhc3NldFxuICAgICAqL1xuICAgIHB1c2goYXNzZXQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFzc2V0LCBGdW5naWJsZUFzc2V0KTtcbiAgICAgICAgd2FzbS5ub3RlYXNzZXRzX3B1c2godGhpcy5fX3diZ19wdHIsIGFzc2V0Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0W119XG4gICAgICovXG4gICAgZnVuZ2libGVBc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWFzc2V0c19mdW5naWJsZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVBc3NldHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVBc3NldHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVDb25zdW1hYmlsaXR5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVjb25zdW1hYmlsaXR5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVDb25zdW1hYmlsaXR5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlQ29uc3VtYWJpbGl0eS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlQ29uc3VtYWJpbGl0eUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE5vdGVDb25zdW1hYmlsaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlQ29uc3VtYWJpbGl0eUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWNvbnN1bWFiaWxpdHlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGFjY291bnRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlY29uc3VtYWJpbGl0eV9hY2NvdW50SWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGNvbnN1bWFibGVBZnRlckJsb2NrKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVjb25zdW1hYmlsaXR5X2NvbnN1bWFibGVBZnRlckJsb2NrKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMHgxMDAwMDAwMDEgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlQ29uc3VtYWJpbGl0eS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUNvbnN1bWFiaWxpdHkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVEZXRhaWxzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVkZXRhaWxzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVEZXRhaWxzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlRGV0YWlscy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlRGV0YWlsc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRGV0YWlsc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWRldGFpbHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVBc3NldHN9IG5vdGVfYXNzZXRzXG4gICAgICogQHBhcmFtIHtOb3RlUmVjaXBpZW50fSBub3RlX3JlY2lwaWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGVfYXNzZXRzLCBub3RlX3JlY2lwaWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9hc3NldHMsIE5vdGVBc3NldHMpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9yZWNpcGllbnQsIE5vdGVSZWNpcGllbnQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzX25ldyhub3RlX2Fzc2V0cy5fX3diZ19wdHIsIG5vdGVfcmVjaXBpZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlRGV0YWlsc0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVBc3NldHN9XG4gICAgICovXG4gICAgYXNzZXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzX2Fzc2V0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlQXNzZXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVJlY2lwaWVudH1cbiAgICAgKi9cbiAgICByZWNpcGllbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNfcmVjaXBpZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVSZWNpcGllbnQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRGV0YWlscy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZURldGFpbHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVEZXRhaWxzQW5kVGFnRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVkZXRhaWxzYW5kdGFnX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVEZXRhaWxzQW5kVGFnIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlRGV0YWlsc0FuZFRhZy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlRGV0YWlsc0FuZFRhZ0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE5vdGVEZXRhaWxzQW5kVGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRGV0YWlsc0FuZFRhZ0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWRldGFpbHNhbmR0YWdfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVEZXRhaWxzfSBub3RlX2RldGFpbHNcbiAgICAgKiBAcGFyYW0ge05vdGVUYWd9IHRhZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGVfZGV0YWlscywgdGFnKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2RldGFpbHMsIE5vdGVEZXRhaWxzKTtcbiAgICAgICAgdmFyIHB0cjAgPSBub3RlX2RldGFpbHMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0YWcsIE5vdGVUYWcpO1xuICAgICAgICB2YXIgcHRyMSA9IHRhZy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ19uZXcocHRyMCwgcHRyMSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlRGV0YWlsc0FuZFRhZ0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZURldGFpbHN9XG4gICAgICovXG4gICAgZ2V0IG5vdGVEZXRhaWxzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnX25vdGVEZXRhaWxzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVEZXRhaWxzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICBnZXQgdGFnKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnX3RhZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZURldGFpbHNBbmRUYWcucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVEZXRhaWxzQW5kVGFnLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVkZXRhaWxzYW5kdGFnYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZURldGFpbHNBbmRUYWdBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVkZXRhaWxzYW5kdGFnYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVEZXRhaWxzQW5kVGFnW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZURldGFpbHNBbmRUYWdBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOb3RlRGV0YWlsc0FuZFRhZ31cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlRGV0YWlsc0FuZFRhZy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge05vdGVEZXRhaWxzQW5kVGFnfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBOb3RlRGV0YWlsc0FuZFRhZyk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVEZXRhaWxzQW5kVGFnfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBOb3RlRGV0YWlsc0FuZFRhZyk7XG4gICAgICAgIHdhc20ubm90ZWRldGFpbHNhbmR0YWdhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVEZXRhaWxzQW5kVGFnQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVEZXRhaWxzQW5kVGFnQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVFeGVjdXRpb25IaW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVleGVjdXRpb25oaW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVFeGVjdXRpb25IaW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlRXhlY3V0aW9uSGludC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlRXhlY3V0aW9uSGludEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRXhlY3V0aW9uSGludEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWV4ZWN1dGlvbmhpbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbkhpbnR9XG4gICAgICovXG4gICAgc3RhdGljIG5vbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWV4ZWN1dGlvbmhpbnRfbm9uZSgpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbkhpbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uSGludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgYWx3YXlzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVleGVjdXRpb25oaW50X2Fsd2F5cygpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbkhpbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja19udW1cbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbkhpbnR9XG4gICAgICovXG4gICAgc3RhdGljIGFmdGVyQmxvY2soYmxvY2tfbnVtKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWV4ZWN1dGlvbmhpbnRfYWZ0ZXJCbG9jayhibG9ja19udW0pO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbkhpbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlcG9jaF9sZW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdF9sZW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvdF9vZmZzZXRcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbkhpbnR9XG4gICAgICovXG4gICAgc3RhdGljIG9uQmxvY2tTbG90KGVwb2NoX2xlbiwgc2xvdF9sZW4sIHNsb3Rfb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWV4ZWN1dGlvbmhpbnRfb25CbG9ja1Nsb3QoZXBvY2hfbGVuLCBzbG90X2xlbiwgc2xvdF9vZmZzZXQpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbkhpbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZFxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uSGludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBhcnRzKHRhZywgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVleGVjdXRpb25oaW50X2Zyb21QYXJ0cyh0YWcsIHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbkhpbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja19udW1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5CZUNvbnN1bWVkKGJsb2NrX251bSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVleGVjdXRpb25oaW50X2NhbkJlQ29uc3VtZWQodGhpcy5fX3diZ19wdHIsIGJsb2NrX251bSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRXhlY3V0aW9uSGludC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUV4ZWN1dGlvbkhpbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVFeGVjdXRpb25Nb2RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVleGVjdXRpb25tb2RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVFeGVjdXRpb25Nb2RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlRXhlY3V0aW9uTW9kZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlRXhlY3V0aW9uTW9kZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRXhlY3V0aW9uTW9kZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWV4ZWN1dGlvbm1vZGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbk1vZGV9XG4gICAgICovXG4gICAgc3RhdGljIG5ld0xvY2FsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV9uZXR3b3JrKCk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uTW9kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25Nb2RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdOZXR3b3JrKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV9wdWJsaWMoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25Nb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlZXhlY3V0aW9ubW9kZV90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVFeGVjdXRpb25Nb2RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRXhlY3V0aW9uTW9kZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUZpbGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWZpbGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIGEgbm90ZS5cbiAqL1xuY2xhc3MgTm90ZUZpbGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVGaWxlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVGaWxlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVGaWxlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZmlsZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBgTm90ZUZpbGVgJ3MgdHlwZXMuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBub3RlVHlwZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWZpbGVfbm90ZVR5cGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR1cm4gYSBub3RlZmlsZSBpbnRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlZmlsZV9zZXJpYWxpemUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHZhbGlkIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgYSBgTm90ZUZpbGVgLFxuICAgICAqIHJldHVybiBpdCBhcyBhIHN0cnVjdC5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge05vdGVGaWxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYnl0ZXMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ubm90ZWZpbGVfZGVzZXJpYWxpemUocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVGaWxlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SW5wdXROb3RlfSBub3RlXG4gICAgICogQHJldHVybnMge05vdGVGaWxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSW5wdXROb3RlKG5vdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGUsIElucHV0Tm90ZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWZpbGVfZnJvbUlucHV0Tm90ZShub3RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRmlsZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPdXRwdXROb3RlfSBub3RlXG4gICAgICogQHJldHVybnMge05vdGVGaWxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tT3V0cHV0Tm90ZShub3RlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlLCBPdXRwdXROb3RlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZmlsZV9mcm9tT3V0cHV0Tm90ZShub3RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRmlsZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRGV0YWlsc30gbm90ZV9kZXRhaWxzXG4gICAgICogQHJldHVybnMge05vdGVGaWxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTm90ZURldGFpbHMobm90ZV9kZXRhaWxzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2RldGFpbHMsIE5vdGVEZXRhaWxzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZmlsZV9mcm9tTm90ZURldGFpbHMobm90ZV9kZXRhaWxzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRmlsZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSWR9IG5vdGVfZGV0YWlsc1xuICAgICAqIEByZXR1cm5zIHtOb3RlRmlsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU5vdGVJZChub3RlX2RldGFpbHMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfZGV0YWlscywgTm90ZUlkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZmlsZV9mcm9tTm90ZUlkKG5vdGVfZGV0YWlscy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUZpbGUuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRmlsZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUZpbGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVGaWx0ZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWZpbHRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlRmlsdGVyIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUZpbHRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWZpbHRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUZpbHRlclR5cGVzfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge05vdGVJZFtdIHwgbnVsbH0gW25vdGVfaWRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGVfdHlwZSwgbm90ZV9pZHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG5vdGVfaWRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChub3RlX2lkcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVmaWx0ZXJfbmV3KG5vdGVfdHlwZSwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlRmlsdGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRmlsdGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRmlsdGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlSGVhZGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVoZWFkZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUhlYWRlciB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVIZWFkZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVoZWFkZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVoZWFkZXJfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZU1ldGFkYXRhfVxuICAgICAqL1xuICAgIG1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVoZWFkZXJfbWV0YWRhdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZU1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVoZWFkZXJfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUhlYWRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUhlYWRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUlkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVpZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlSWQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVJZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlSWRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBOb3RlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVJZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWlkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSByZWNpcGllbnRfZGlnZXN0XG4gICAgICogQHBhcmFtIHtXb3JkfSBhc3NldF9jb21taXRtZW50X2RpZ2VzdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlY2lwaWVudF9kaWdlc3QsIGFzc2V0X2NvbW1pdG1lbnRfZGlnZXN0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyZWNpcGllbnRfZGlnZXN0LCBXb3JkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFzc2V0X2NvbW1pdG1lbnRfZGlnZXN0LCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaWRfbmV3KHJlY2lwaWVudF9kaWdlc3QuX193YmdfcHRyLCBhc3NldF9jb21taXRtZW50X2RpZ2VzdC5fX3diZ19wdHIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUlkRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaGV4LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5ub3RlaWRfZnJvbUhleChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVpZF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVJZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUlkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlSWRBbmRBcmdzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVpZGFuZGFyZ3NfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUlkQW5kQXJncyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUlkQW5kQXJncy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlSWRBbmRBcmdzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgTm90ZUlkQW5kQXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUlkQW5kQXJnc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWlkYW5kYXJnc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkfSBub3RlX2lkXG4gICAgICogQHBhcmFtIHtXb3JkIHwgbnVsbH0gW2FyZ3NdXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZV9pZCwgYXJncykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9pZCwgTm90ZUlkKTtcbiAgICAgICAgdmFyIHB0cjAgPSBub3RlX2lkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBsZXQgcHRyMSA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShhcmdzKSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFyZ3MsIFdvcmQpO1xuICAgICAgICAgICAgcHRyMSA9IGFyZ3MuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaWRhbmRhcmdzX25ldyhwdHIwLCBwdHIxKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVJZEFuZEFyZ3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVJZEFuZEFyZ3MucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVJZEFuZEFyZ3MucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVJZEFuZEFyZ3NBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlaWRhbmRhcmdzYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUlkQW5kQXJnc0FycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUlkQW5kQXJnc0FycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlaWRhbmRhcmdzYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVJZEFuZEFyZ3NbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWlkYW5kYXJnc2FycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVJZEFuZEFyZ3NBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOb3RlSWRBbmRBcmdzfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVpZGFuZGFyZ3NhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZUlkQW5kQXJncy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge05vdGVJZEFuZEFyZ3N9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIE5vdGVJZEFuZEFyZ3MpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5ub3RlaWRhbmRhcmdzYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVJZEFuZEFyZ3N9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIE5vdGVJZEFuZEFyZ3MpO1xuICAgICAgICB3YXNtLm5vdGVpZGFuZGFyZ3NhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpZGFuZGFyZ3NhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUlkQW5kQXJnc0FycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlSWRBbmRBcmdzQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVJbmNsdXNpb25Qcm9vZkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlaW5jbHVzaW9ucHJvb2ZfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUluY2x1c2lvblByb29mIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlSW5jbHVzaW9uUHJvb2YucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUluY2x1c2lvblByb29mRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVJbmNsdXNpb25Qcm9vZkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWluY2x1c2lvbnByb29mX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVMb2NhdGlvbn1cbiAgICAgKi9cbiAgICBsb2NhdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaW5jbHVzaW9ucHJvb2ZfbG9jYXRpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUxvY2F0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWVya2xlUGF0aH1cbiAgICAgKi9cbiAgICBub3RlUGF0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaW5jbHVzaW9ucHJvb2Zfbm90ZVBhdGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTWVya2xlUGF0aC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVJbmNsdXNpb25Qcm9vZi5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUluY2x1c2lvblByb29mLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlSW5wdXRzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVpbnB1dHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUlucHV0cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUlucHV0cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlSW5wdXRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVJbnB1dHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVpbnB1dHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZlbHRBcnJheX0gZmVsdF9hcnJheVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlbHRfYXJyYXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZlbHRfYXJyYXksIEZlbHRBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWlucHV0c19uZXcoZmVsdF9hcnJheS5fX3diZ19wdHIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUlucHV0c0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIHZhbHVlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlaW5wdXRzX3ZhbHVlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVJbnB1dHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVJbnB1dHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVMb2NhdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlbG9jYXRpb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUxvY2F0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlTG9jYXRpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUxvY2F0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVMb2NhdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWxvY2F0aW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBibG9ja051bSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlbG9jYXRpb25fYmxvY2tOdW0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG5vZGVJbmRleEluQmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWxvY2F0aW9uX25vZGVJbmRleEluQmxvY2sodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUxvY2F0aW9uLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlTG9jYXRpb24ucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVNZXRhZGF0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlbWV0YWRhdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZU1ldGFkYXRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlTWV0YWRhdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZU1ldGFkYXRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVNZXRhZGF0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZW1ldGFkYXRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHNlbmRlclxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7Tm90ZVRhZ30gbm90ZV90YWdcbiAgICAgKiBAcGFyYW0ge05vdGVFeGVjdXRpb25IaW50fSBub3RlX2V4ZWN1dGlvbl9oaW50XG4gICAgICogQHBhcmFtIHtGZWx0IHwgbnVsbH0gW2F1eF1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZW5kZXIsIG5vdGVfdHlwZSwgbm90ZV90YWcsIG5vdGVfZXhlY3V0aW9uX2hpbnQsIGF1eCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VuZGVyLCBBY2NvdW50SWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV90YWcsIE5vdGVUYWcpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9leGVjdXRpb25faGludCwgTm90ZUV4ZWN1dGlvbkhpbnQpO1xuICAgICAgICBsZXQgcHRyMCA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShhdXgpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXV4LCBGZWx0KTtcbiAgICAgICAgICAgIHB0cjAgPSBhdXguX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlbWV0YWRhdGFfbmV3KHNlbmRlci5fX3diZ19wdHIsIG5vdGVfdHlwZSwgbm90ZV90YWcuX193YmdfcHRyLCBub3RlX2V4ZWN1dGlvbl9oaW50Ll9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlTWV0YWRhdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBzZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZW1ldGFkYXRhX3NlbmRlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIHRhZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ190YWcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVUeXBlfVxuICAgICAqL1xuICAgIG5vdGVUeXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVtZXRhZGF0YV9ub3RlVHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlTWV0YWRhdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVNZXRhZGF0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZVJlY2lwaWVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlcmVjaXBpZW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVSZWNpcGllbnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVSZWNpcGllbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZVJlY2lwaWVudEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE5vdGVSZWNpcGllbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVSZWNpcGllbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVyZWNpcGllbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHNlcmlhbF9udW1cbiAgICAgKiBAcGFyYW0ge05vdGVTY3JpcHR9IG5vdGVfc2NyaXB0XG4gICAgICogQHBhcmFtIHtOb3RlSW5wdXRzfSBpbnB1dHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxfbnVtLCBub3RlX3NjcmlwdCwgaW5wdXRzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzZXJpYWxfbnVtLCBXb3JkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfc2NyaXB0LCBOb3RlU2NyaXB0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGlucHV0cywgTm90ZUlucHV0cyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXJlY2lwaWVudF9uZXcoc2VyaWFsX251bS5fX3diZ19wdHIsIG5vdGVfc2NyaXB0Ll9fd2JnX3B0ciwgaW5wdXRzLl9fd2JnX3B0cik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlUmVjaXBpZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX3N0b3JhZ2VDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHNlcmlhbE51bSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIHNjcmlwdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlcmVjaXBpZW50X3NjcmlwdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlucHV0c31cbiAgICAgKi9cbiAgICBpbnB1dHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXJlY2lwaWVudF9pbnB1dHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlucHV0cy5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVSZWNpcGllbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVSZWNpcGllbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVSZWNpcGllbnRBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlcmVjaXBpZW50YXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZVJlY2lwaWVudEFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZVJlY2lwaWVudEFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlcmVjaXBpZW50YXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVSZWNpcGllbnRbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXJlY2lwaWVudGFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVSZWNpcGllbnRBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOb3RlUmVjaXBpZW50fVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVyZWNpcGllbnRhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZVJlY2lwaWVudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge05vdGVSZWNpcGllbnR9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIE5vdGVSZWNpcGllbnQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5ub3RlcmVjaXBpZW50YXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVSZWNpcGllbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIE5vdGVSZWNpcGllbnQpO1xuICAgICAgICB3YXNtLm5vdGVyZWNpcGllbnRhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVyZWNpcGllbnRhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZVJlY2lwaWVudEFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlUmVjaXBpZW50QXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVTY3JpcHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZXNjcmlwdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlU2NyaXB0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlU2NyaXB0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVTY3JpcHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZVNjcmlwdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZXNjcmlwdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50IHRoZSBNQVNUIHNvdXJjZSBmb3IgdGhpcyBzY3JpcHQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZXNjcmlwdF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVzY3JpcHRfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVzY3JpcHRfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgcDJpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3Rlc2NyaXB0X3AyaWQoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIHN0YXRpYyBwMmlkZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3Rlc2NyaXB0X3AyaWRlKCk7XG4gICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc3dhcCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3Rlc2NyaXB0X3N3YXAoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXNjcmlwdF9yb290KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlU2NyaXB0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlU2NyaXB0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlVGFnRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGV0YWdfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZVRhZyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZVRhZy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlVGFnRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVUYWdGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGV0YWdfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQWNjb3VudElkKGFjY291bnRfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXRhZ19mcm9tQWNjb3VudElkKGFjY291bnRfaWQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1c2VfY2FzZV9pZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkXG4gICAgICogQHBhcmFtIHtOb3RlRXhlY3V0aW9uTW9kZX0gZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgc3RhdGljIGZvclB1YmxpY1VzZUNhc2UodXNlX2Nhc2VfaWQsIHBheWxvYWQsIGV4ZWN1dGlvbikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZXhlY3V0aW9uLCBOb3RlRXhlY3V0aW9uTW9kZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXRhZ19mb3JQdWJsaWNVc2VDYXNlKHVzZV9jYXNlX2lkLCBwYXlsb2FkLCBleGVjdXRpb24uX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1c2VfY2FzZV9pZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkXG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgc3RhdGljIGZvckxvY2FsVXNlQ2FzZSh1c2VfY2FzZV9pZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGV0YWdfZm9yTG9jYWxVc2VDYXNlKHVzZV9jYXNlX2lkLCBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU2luZ2xlVGFyZ2V0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGV0YWdfaXNTaW5nbGVUYXJnZXQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbk1vZGV9XG4gICAgICovXG4gICAgZXhlY3V0aW9uTW9kZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RldGFnX2V4ZWN1dGlvbk1vZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbk1vZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYXNVMzIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXRhZ19hc1UzMih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlVGFnLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlVGFnLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBPdXRwdXROb3RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX291dHB1dG5vdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgT3V0cHV0Tm90ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT3V0cHV0Tm90ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBPdXRwdXROb3RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgT3V0cHV0Tm90ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgT3V0cHV0Tm90ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfb3V0cHV0bm90ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZX0gbm90ZVxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmdWxsKG5vdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGUsIE5vdGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfZnVsbChub3RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BhcnRpYWxOb3RlfSBwYXJ0aWFsX25vdGVcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFydGlhbChwYXJ0aWFsX25vdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHBhcnRpYWxfbm90ZSwgUGFydGlhbE5vdGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfcGFydGlhbChwYXJ0aWFsX25vdGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUhlYWRlcn0gbm90ZV9oZWFkZXJcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGVhZGVyKG5vdGVfaGVhZGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2hlYWRlciwgTm90ZUhlYWRlcik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9oZWFkZXIobm90ZV9oZWFkZXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlQXNzZXRzIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGFzc2V0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX2Fzc2V0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBOb3RlQXNzZXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICByZWNpcGllbnREaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9yZWNpcGllbnREaWdlc3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBtZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX21ldGFkYXRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGV9XG4gICAgICovXG4gICAgc2hyaW5rKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfc2hyaW5rKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGludG9GdWxsKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfaW50b0Z1bGwocHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBPdXRwdXROb3RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBPdXRwdXROb3RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBPdXRwdXROb3RlQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfb3V0cHV0bm90ZWFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE91dHB1dE5vdGVBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE91dHB1dE5vdGVBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfb3V0cHV0bm90ZWFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPdXRwdXROb3RlW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBPdXRwdXROb3RlQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZX1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5vdXRwdXRub3RlYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE91dHB1dE5vdGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtPdXRwdXROb3RlfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBPdXRwdXROb3RlKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ub3V0cHV0bm90ZWFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPdXRwdXROb3RlfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBPdXRwdXROb3RlKTtcbiAgICAgICAgd2FzbS5vdXRwdXRub3RlYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE91dHB1dE5vdGVBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gT3V0cHV0Tm90ZUFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBPdXRwdXROb3Rlc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19vdXRwdXRub3Rlc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBPdXRwdXROb3RlcyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT3V0cHV0Tm90ZXMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgT3V0cHV0Tm90ZXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBPdXRwdXROb3RlcykpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgT3V0cHV0Tm90ZXNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX291dHB1dG5vdGVzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtTm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZXNfbnVtTm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVzX2lzRW1wdHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZX1cbiAgICAgKi9cbiAgICBnZXROb3RlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZXNfZ2V0Tm90ZSh0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVbXX1cbiAgICAgKi9cbiAgICBub3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5vdXRwdXRub3Rlc19ub3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE91dHB1dE5vdGVzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBPdXRwdXROb3Rlcy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgT3V0cHV0Tm90ZXNBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19vdXRwdXRub3Rlc2FycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE91dHB1dE5vdGVzQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPdXRwdXROb3Rlc0FycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vdXRwdXRub3Rlc2FycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPdXRwdXROb3Rlc1tdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3Rlc2FycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE91dHB1dE5vdGVzQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZXN9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ub3V0cHV0bm90ZXNhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZXMuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtPdXRwdXROb3Rlc30gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgT3V0cHV0Tm90ZXMpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5vdXRwdXRub3Rlc2FycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPdXRwdXROb3Rlc30gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgT3V0cHV0Tm90ZXMpO1xuICAgICAgICB3YXNtLm91dHB1dG5vdGVzYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3Rlc2FycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBPdXRwdXROb3Rlc0FycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBPdXRwdXROb3Rlc0FycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBQYWNrYWdlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3BhY2thZ2VfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgUGFja2FnZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUGFja2FnZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBQYWNrYWdlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFBhY2thZ2VGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3BhY2thZ2VfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucGFja2FnZV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1BhY2thZ2V9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucGFja2FnZV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQYWNrYWdlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBQYWNrYWdlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBQYWNrYWdlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBQYXJ0aWFsTm90ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19wYXJ0aWFsbm90ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBQYXJ0aWFsTm90ZSB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFBhcnRpYWxOb3RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wYXJ0aWFsbm90ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucGFydGlhbG5vdGVfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZU1ldGFkYXRhfVxuICAgICAqL1xuICAgIG1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfbWV0YWRhdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZU1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICByZWNpcGllbnREaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUFzc2V0c31cbiAgICAgKi9cbiAgICBhc3NldHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucGFydGlhbG5vdGVfYXNzZXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVBc3NldHMuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBQYXJ0aWFsTm90ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gUGFydGlhbE5vdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFByb3ZlblRyYW5zYWN0aW9uRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Byb3ZlbnRyYW5zYWN0aW9uX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFdBU00gd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBbYFByb3ZlblRyYW5zYWN0aW9uYF0uXG4gKi9cbmNsYXNzIFByb3ZlblRyYW5zYWN0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShQcm92ZW5UcmFuc2FjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBQcm92ZW5UcmFuc2FjdGlvbkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQcm92ZW5UcmFuc2FjdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcHJvdmVudHJhbnNhY3Rpb25fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBwcm92ZW4gdHJhbnNhY3Rpb24gaW50byBieXRlcy5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25fc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGEgcHJvdmVuIHRyYW5zYWN0aW9uIGZyb20gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtQcm92ZW5UcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm92ZW5UcmFuc2FjdGlvbi5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBJRC5cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25JZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY2NvdW50IElEIHRoZSB0cmFuc2FjdGlvbiB3YXMgZXhlY3V0ZWQgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGFjY291bnRJZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9hY2NvdW50SWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWZlcmVuY2UgYmxvY2sgbnVtYmVyIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJlZkJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX3JlZkJsb2NrTnVtYmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgbnVtYmVyIGF0IHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBleHBpcmVzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZXhwaXJhdGlvbkJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX2V4cGlyYXRpb25CbG9ja051bWJlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbm90ZXMgY3JlYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3Rlc31cbiAgICAgKi9cbiAgICBvdXRwdXROb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9vdXRwdXROb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3Rlcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tbWl0bWVudCBvZiB0aGUgcmVmZXJlbmNlIGJsb2NrLlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHJlZkJsb2NrQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9yZWZCbG9ja0NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVsbGlmaWVycyBvZiB0aGUgY29uc3VtZWQgaW5wdXQgbm90ZXMuXG4gICAgICogQHJldHVybnMge1dvcmRbXX1cbiAgICAgKi9cbiAgICBudWxsaWZpZXJzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX251bGxpZmllcnMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBQcm92ZW5UcmFuc2FjdGlvbi5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gUHJvdmVuVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFB1YmxpY0tleUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19wdWJsaWNrZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgUHVibGljS2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShQdWJsaWNLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUHVibGljS2V5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFB1YmxpY0tleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcHVibGlja2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnB1YmxpY2tleV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1B1YmxpY0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wdWJsaWNrZXlfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhtZXNzYWdlLCBXb3JkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNpZ25hdHVyZSwgU2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wdWJsaWNrZXlfdmVyaWZ5KHRoaXMuX193YmdfcHRyLCBtZXNzYWdlLl9fd2JnX3B0ciwgc2lnbmF0dXJlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHRvQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wdWJsaWNrZXlfdG9Db21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7UHVibGljS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyByZWNvdmVyRnJvbShtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG1lc3NhZ2UsIFdvcmQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNpZ25hdHVyZSwgU2lnbmF0dXJlKTtcbiAgICAgICAgICAgIHdhc20ucHVibGlja2V5X3JlY292ZXJGcm9tKHJldHB0ciwgbWVzc2FnZS5fX3diZ19wdHIsIHNpZ25hdHVyZS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2lnbmluZ0lucHV0c30gc2lnbmluZ19pbnB1dHNcbiAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmVyaWZ5RGF0YShzaWduaW5nX2lucHV0cywgc2lnbmF0dXJlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduaW5nX2lucHV0cywgU2lnbmluZ0lucHV0cyk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduYXR1cmUsIFNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHVibGlja2V5X3ZlcmlmeURhdGEodGhpcy5fX3diZ19wdHIsIHNpZ25pbmdfaW5wdXRzLl9fd2JnX3B0ciwgc2lnbmF0dXJlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBQdWJsaWNLZXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFB1YmxpY0tleS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgUnBjQ2xpZW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3JwY2NsaWVudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBSUEMgQ2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIE1pZGVuIG5vZGVzIGRpcmVjdGx5LlxuICovXG5jbGFzcyBScGNDbGllbnQge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBScGNDbGllbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3JwY2NsaWVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUlBDIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRwb2ludCAtIEVuZHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIHtFbmRwb2ludH0gZW5kcG9pbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbmRwb2ludCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZW5kcG9pbnQsIEVuZHBvaW50KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZW5kcG9pbnQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnJwY2NsaWVudF9uZXcocmV0cHRyLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByMCA+Pj4gMDtcbiAgICAgICAgICAgIFJwY0NsaWVudEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBub3RlcyBieSB0aGVpciBJRHMgZnJvbSB0aGUgY29ubmVjdGVkIE1pZGVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm90ZV9pZHMgLSBBcnJheSBvZiBbYE5vdGVJZGBdIG9iamVjdHMgdG8gZmV0Y2hcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gIGRpZmZlcmVudCBkYXRhIGRlcGVuZGluZyBvbiB0aGUgbm90ZSB0eXBlOlxuICAgICAqIC0gUHJpdmF0ZSBub3RlczogUmV0dXJucyBvbmx5IGBub3RlX2lkYCBhbmQgYG1ldGFkYXRhYC4gVGhlIGBpbnB1dF9ub3RlYCBmaWVsZCB3aWxsIGJlXG4gICAgICogICBgbnVsbGAuXG4gICAgICogLSBQdWJsaWMgbm90ZXM6IFJldHVybnMgdGhlIGZ1bGwgYGlucHV0X25vdGVgIHdpdGggaW5jbHVzaW9uIHByb29mLCBhbG9uZ3NpZGUgbWV0YWRhdGEgYW5kXG4gICAgICogICBJRC5cbiAgICAgKiBAcGFyYW0ge05vdGVJZFtdfSBub3RlX2lkc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoZWROb3RlW10+fVxuICAgICAqL1xuICAgIGdldE5vdGVzQnlJZChub3RlX2lkcykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobm90ZV9pZHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJwY2NsaWVudF9nZXROb3Rlc0J5SWQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgbm90ZSBzY3JpcHQgYnkgaXRzIHJvb3QgaGFzaCBmcm9tIHRoZSBjb25uZWN0ZWQgTWlkZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBgc2NyaXB0X3Jvb3RgIFRoZSByb290IGhhc2ggb2YgdGhlIG5vdGUgc2NyaXB0IHRvIGZldGNoXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBgTm90ZVNjcmlwdGBcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHNjcmlwdF9yb290XG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm90ZVNjcmlwdD59XG4gICAgICovXG4gICAgZ2V0Tm90ZVNjcmlwdEJ5Um9vdChzY3JpcHRfcm9vdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2NyaXB0X3Jvb3QsIFdvcmQpO1xuICAgICAgICB2YXIgcHRyMCA9IHNjcmlwdF9yb290Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJwY2NsaWVudF9nZXROb3RlU2NyaXB0QnlSb290KHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFJwY0NsaWVudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gUnBjQ2xpZW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBScG8yNTZGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcnBvMjU2X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFJwbzI1NiB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJwbzI1NkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcnBvMjU2X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWx0QXJyYXl9IGZlbHRfYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaEVsZW1lbnRzKGZlbHRfYXJyYXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZlbHRfYXJyYXksIEZlbHRBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucnBvMjU2X2hhc2hFbGVtZW50cyhmZWx0X2FycmF5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgUnBvMjU2LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBScG8yNTYucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNjcmlwdEJ1aWxkZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2NyaXB0YnVpbGRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTY3JpcHRCdWlsZGVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTY3JpcHRCdWlsZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNjcmlwdEJ1aWxkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2NyaXB0QnVpbGRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2NyaXB0YnVpbGRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbW9kdWxlIHBhdGggKHNvbWV0aGluZyBsaWtlIGBteV9saWI6Om1vZHVsZWApIGFuZCBzb3VyY2UgY29kZSwgdGhpcyB3aWxsXG4gICAgICogc3RhdGljYWxseSBsaW5rIGl0IGZvciB1c2Ugd2l0aCBzY3JpcHRzIHRvIGJlIGJ1aWx0IHdpdGggdGhpcyBidWlsZGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVfcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVfY29kZVxuICAgICAqL1xuICAgIGxpbmtNb2R1bGUobW9kdWxlX3BhdGgsIG1vZHVsZV9jb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChtb2R1bGVfcGF0aCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChtb2R1bGVfY29kZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uc2NyaXB0YnVpbGRlcl9saW5rTW9kdWxlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpY2FsbHkgbGlua3MgdGhlIGdpdmVuIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBTdGF0aWMgbGlua2luZyBtZWFucyB0aGUgbGlicmFyeSBjb2RlIGlzIGNvcGllZCBpbnRvIHRoZSBzY3JpcHQgY29kZS5cbiAgICAgKiBVc2UgdGhpcyBmb3IgbW9zdCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGF2YWlsYWJsZSBvbi1jaGFpbi5cbiAgICAgKlxuICAgICAqIFJlY2VpdmVzIGFzIGFyZ3VtZW50IHRoZSBsaWJyYXJ5IHRvIGxpbmsuXG4gICAgICogQHBhcmFtIHtMaWJyYXJ5fSBsaWJyYXJ5XG4gICAgICovXG4gICAgbGlua1N0YXRpY0xpYnJhcnkobGlicmFyeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MobGlicmFyeSwgTGlicmFyeSk7XG4gICAgICAgICAgICB3YXNtLnNjcmlwdGJ1aWxkZXJfbGlua1N0YXRpY0xpYnJhcnkocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgbGlicmFyeS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGR5bmFtaWNhbGx5IGxpbmsgdGhlIFtgTGlicmFyeWBdIG9mIGEgZm9yZWlnbiBhY2NvdW50XG4gICAgICogdGhhdCBpcyBpbnZva2VkIHVzaW5nIGZvcmVpZ24gcHJvY2VkdXJlIGludm9jYXRpb24gKEZQSSkuIEl0cyBjb2RlIGlzIGF2YWlsYWJsZVxuICAgICAqIG9uLWNoYWluIGFuZCBzbyBpdCBkb2VzIG5vdCBoYXZlIHRvIGJlIGNvcGllZCBpbnRvIHRoZSBzY3JpcHQgY29kZS5cbiAgICAgKlxuICAgICAqIEZvciBhbGwgb3RoZXIgdXNlIGNhc2VzIG5vdCBpbnZvbHZpbmcgRlBJLCBsaW5rIHRoZSBsaWJyYXJ5IHN0YXRpY2FsbHkuXG4gICAgICogUmVjZWl2ZXMgYXMgYXJndW1lbnQgdGhlIGxpYnJhcnkgdG8gYmUgbGlua2VkLlxuICAgICAqIEBwYXJhbSB7TGlicmFyeX0gbGlicmFyeVxuICAgICAqL1xuICAgIGxpbmtEeW5hbWljTGlicmFyeShsaWJyYXJ5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhsaWJyYXJ5LCBMaWJyYXJ5KTtcbiAgICAgICAgICAgIHdhc20uc2NyaXB0YnVpbGRlcl9saW5rRHluYW1pY0xpYnJhcnkocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgbGlicmFyeS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgVHJhbnNhY3Rpb24gU2NyaXB0J3Mgc291cmNlIGNvZGUsIGNvbXBpbGVzIGl0IHdpdGggdGhlIGF2YWlsYWJsZVxuICAgICAqIG1vZHVsZXMgdW5kZXIgdGhpcyBidWlsZGVyLiBSZXR1cm5zIHRoZSBjb21waWxlZCBzY3JpcHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR4X3NjcmlwdFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblNjcmlwdH1cbiAgICAgKi9cbiAgICBjb21waWxlVHhTY3JpcHQodHhfc2NyaXB0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0eF9zY3JpcHQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNjcmlwdGJ1aWxkZXJfY29tcGlsZVR4U2NyaXB0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TY3JpcHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBOb3RlIFNjcmlwdCdzIHNvdXJjZSBjb2RlLCBjb21waWxlcyBpdCB3aXRoIHRoZSBhdmFpbGFibGVcbiAgICAgKiBtb2R1bGVzIHVuZGVyIHRoaXMgYnVpbGRlci4gUmV0dXJucyB0aGUgY29tcGlsZWQgc2NyaXB0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgY29tcGlsZU5vdGVTY3JpcHQocHJvZ3JhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uc2NyaXB0YnVpbGRlcl9jb21waWxlTm90ZVNjcmlwdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBMaWJyYXJ5IFBhdGgsIGFuZCBhIHNvdXJjZSBjb2RlLCB0dXJuIGl0IGludG8gYSBMaWJyYXJ5LlxuICAgICAqIEUuZy4gQSBwYXRoIGxpYnJhcnkgY2FuIGJlIGBtaWRlbjo6bXlfY29udHJhY3RgLiBXaGVuIHR1cm5lZCBpbnRvIGEgbGlicmFyeSxcbiAgICAgKiB0aGlzIGNhbiBiZSB1c2VkIGZyb20gYW5vdGhlciBzY3JpcHQgd2l0aCBhbiBpbXBvcnQgc3RhdGVtZW50LCBmb2xsb3dpbmcgdGhlXG4gICAgICogcHJldmlvdXMgZXhhbXBsZTogYHVzZS5taWRlbjo6bXlfY29udHJhY3QnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaWJyYXJ5X3BhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlX2NvZGVcbiAgICAgKiBAcmV0dXJucyB7TGlicmFyeX1cbiAgICAgKi9cbiAgICBidWlsZExpYnJhcnkobGlicmFyeV9wYXRoLCBzb3VyY2VfY29kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobGlicmFyeV9wYXRoLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHNvdXJjZV9jb2RlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5zY3JpcHRidWlsZGVyX2J1aWxkTGlicmFyeShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIExpYnJhcnkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNjcmlwdEJ1aWxkZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNjcmlwdEJ1aWxkZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNlY3JldEtleUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zZWNyZXRrZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2VjcmV0S2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTZWNyZXRLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2VjcmV0S2V5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNlY3JldEtleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2VjcmV0a2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlZWRdXG4gICAgICogQHJldHVybnMge1NlY3JldEtleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgcnBvRmFsY29uV2l0aFJORyhzZWVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShzZWVkKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5zZWNyZXRrZXlfcnBvRmFsY29uV2l0aFJORyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2VjcmV0S2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZWVkXVxuICAgICAqIEByZXR1cm5zIHtTZWNyZXRLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGVjZHNhV2l0aFJORyhzZWVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShzZWVkKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5zZWNyZXRrZXlfZWNkc2FXaXRoUk5HKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTZWNyZXRLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1B1YmxpY0tleX1cbiAgICAgKi9cbiAgICBwdWJsaWNLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2VjcmV0a2V5X3B1YmxpY0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBQdWJsaWNLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmV9XG4gICAgICovXG4gICAgc2lnbihtZXNzYWdlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhtZXNzYWdlLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZWNyZXRrZXlfc2lnbih0aGlzLl9fd2JnX3B0ciwgbWVzc2FnZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NpZ25pbmdJbnB1dHN9IHNpZ25pbmdfaW5wdXRzXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAgICAgKi9cbiAgICBzaWduRGF0YShzaWduaW5nX2lucHV0cykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2lnbmluZ19pbnB1dHMsIFNpZ25pbmdJbnB1dHMpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldGtleV9zaWduRGF0YSh0aGlzLl9fd2JnX3B0ciwgc2lnbmluZ19pbnB1dHMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldGtleV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1NlY3JldEtleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zZWNyZXRrZXlfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2VjcmV0S2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTZWNyZXRLZXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNlY3JldEtleS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2VyaWFsaXplZElucHV0Tm90ZURhdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2VyaWFsaXplZElucHV0Tm90ZURhdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgU2VyaWFsaXplZElucHV0Tm90ZURhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5vdGVJZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm90ZUlkKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG5vdGVBc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm90ZUFzc2V0cyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZUFzc2V0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBzZXJpYWxOdW1iZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3NlcmlhbE51bWJlcihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzZXJpYWxOdW1iZXIoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3NlcmlhbE51bWJlcih0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBpbnB1dHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2lucHV0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBpbnB1dHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2lucHV0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5vdGVTY3JpcHRSb290KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZVNjcmlwdFJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vdGVTY3JpcHRSb290KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZVNjcmlwdFJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgbm90ZVNjcmlwdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZVNjcmlwdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBub3RlU2NyaXB0KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlU2NyaXB0KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbnVsbGlmaWVyKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2NvZGVSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBudWxsaWZpZXIoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfY29kZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdGF0ZURpc2NyaW1pbmFudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfc3RhdGVEaXNjcmltaW5hbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdGF0ZURpc2NyaW1pbmFudChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3N0YXRlRGlzY3JpbWluYW50KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9zdGF0ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdGF0ZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfc3RhdGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudENvbW1pdG1lbnQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNyZWF0ZWRBdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50Q29tbWl0bWVudCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTZXJpYWxpemVkSW5wdXROb3RlRGF0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2VyaWFsaXplZElucHV0Tm90ZURhdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5vdGVJZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm90ZUlkKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG5vdGVBc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVBc3NldHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm90ZUFzc2V0cyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZUFzc2V0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHJlY2lwaWVudERpZ2VzdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCByZWNpcGllbnREaWdlc3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfaW5wdXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IG1ldGFkYXRhKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9pbnB1dHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBudWxsaWZpZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9udWxsaWZpZXIocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IG51bGxpZmllcihhcmcwKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfbnVsbGlmaWVyKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXhwZWN0ZWRIZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9leHBlY3RlZEhlaWdodCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGV4cGVjdGVkSGVpZ2h0KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX2V4cGVjdGVkSGVpZ2h0KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3RhdGVEaXNjcmltaW5hbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9zdGF0ZURpc2NyaW1pbmFudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0YXRlRGlzY3JpbWluYW50KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX3N0YXRlRGlzY3JpbWluYW50KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfc3RhdGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RhdGUoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9zdGF0ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgaWQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgZGV0YWlscygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBkZXRhaWxzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlQXNzZXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHNjcmlwdFJvb3QoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfc2NyaXB0Um9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBzY3JpcHRSb290KGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9zY3JpcHRSb290KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHR4U2NyaXB0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3R4U2NyaXB0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IHR4U2NyaXB0KGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV90eFNjcmlwdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJsb2NrTnVtKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGJsb2NrTnVtKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdGF0dXNWYXJpYW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3N0YXR1c1ZhcmlhbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdGF0dXNWYXJpYW50KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9zdGF0dXNWYXJpYW50KHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfaW5wdXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0YXR1cyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfaW5wdXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFNpZ25hdHVyZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zaWduYXR1cmVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2lnbmF0dXJlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaWduYXR1cmUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2lnbmF0dXJlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNpZ25hdHVyZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2lnbmF0dXJlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zaWduYXR1cmVfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgdG9QcmVwYXJlZFNpZ25hdHVyZShtZXNzYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhtZXNzYWdlLCBXb3JkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gbWVzc2FnZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uc2lnbmF0dXJlX3RvUHJlcGFyZWRTaWduYXR1cmUocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjIgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTaWduYXR1cmUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFNpZ25hdHVyZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2lnbmluZ0lucHV0c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zaWduaW5naW5wdXRzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNpZ25pbmdJbnB1dHMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNpZ25pbmdJbnB1dHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2lnbmluZ0lucHV0c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTaWduaW5nSW5wdXRzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zaWduaW5naW5wdXRzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblN1bW1hcnl9IHN1bW1hcnlcbiAgICAgKiBAcmV0dXJucyB7U2lnbmluZ0lucHV0c31cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3VHJhbnNhY3Rpb25TdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN1bW1hcnksIFRyYW5zYWN0aW9uU3VtbWFyeSk7XG4gICAgICAgIHZhciBwdHIwID0gc3VtbWFyeS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX25ld1RyYW5zYWN0aW9uU3VtbWFyeShwdHIwKTtcbiAgICAgICAgcmV0dXJuIFNpZ25pbmdJbnB1dHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmVsdFtdfSBmZWx0c1xuICAgICAqIEByZXR1cm5zIHtTaWduaW5nSW5wdXRzfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdBcmJpdHJhcnkoZmVsdHMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGZlbHRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX25ld0FyYml0cmFyeShwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIFNpZ25pbmdJbnB1dHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gd29yZFxuICAgICAqIEByZXR1cm5zIHtTaWduaW5nSW5wdXRzfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdCbGluZCh3b3JkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh3b3JkLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX25ld0JsaW5kKHdvcmQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFNpZ25pbmdJbnB1dHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN1bW1hcnl9XG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25TdW1tYXJ5UGF5bG9hZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zaWduaW5naW5wdXRzX3RyYW5zYWN0aW9uU3VtbWFyeVBheWxvYWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN1bW1hcnkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRBcnJheX1cbiAgICAgKi9cbiAgICBhcmJpdHJhcnlQYXlsb2FkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNpZ25pbmdpbnB1dHNfYXJiaXRyYXJ5UGF5bG9hZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZlbHRBcnJheS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBibGluZFBheWxvYWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2lnbmluZ2lucHV0c19ibGluZFBheWxvYWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTaWduaW5nSW5wdXRzVHlwZX1cbiAgICAgKi9cbiAgICBnZXQgdmFyaWFudFR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c192YXJpYW50VHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHRvQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX3RvQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdEFycmF5fVxuICAgICAqL1xuICAgIHRvRWxlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c190b0VsZW1lbnRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHRBcnJheS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtTaWduaW5nSW5wdXRzfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNpZ25pbmdpbnB1dHNfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2lnbmluZ0lucHV0cy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2lnbmluZ0lucHV0cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2lnbmluZ0lucHV0cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2xvdEFuZEtleXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2xvdGFuZGtleXNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2xvdEFuZEtleXMge1xuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFNsb3RBbmRLZXlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTbG90QW5kS2V5c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2xvdGFuZGtleXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RvcmFnZV9zbG90X2luZGV4XG4gICAgICogQHBhcmFtIHtXb3JkW119IHN0b3JhZ2VfbWFwX2tleXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlX3Nsb3RfaW5kZXgsIHN0b3JhZ2VfbWFwX2tleXMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKHN0b3JhZ2VfbWFwX2tleXMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNsb3RhbmRrZXlzX25ldyhzdG9yYWdlX3Nsb3RfaW5kZXgsIHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgU2xvdEFuZEtleXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdG9yYWdlX3Nsb3RfaW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2xvdGFuZGtleXNfc3RvcmFnZV9zbG90X2luZGV4KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmRbXX1cbiAgICAgKi9cbiAgICBzdG9yYWdlX21hcF9rZXlzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNsb3RhbmRrZXlzX3N0b3JhZ2VfbWFwX2tleXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTbG90QW5kS2V5cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2xvdEFuZEtleXMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFN0b3JhZ2VNYXBGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc3RvcmFnZW1hcF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTdG9yYWdlTWFwIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU3RvcmFnZU1hcEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc3RvcmFnZW1hcF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VtYXBfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBTdG9yYWdlTWFwRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0ga2V5XG4gICAgICogQHBhcmFtIHtXb3JkfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGluc2VydChrZXksIHZhbHVlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhrZXksIFdvcmQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModmFsdWUsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VtYXBfaW5zZXJ0KHRoaXMuX193YmdfcHRyLCBrZXkuX193YmdfcHRyLCB2YWx1ZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFN0b3JhZ2VNYXAucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFN0b3JhZ2VNYXAucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFN0b3JhZ2VTbG90RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3N0b3JhZ2VzbG90X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFN0b3JhZ2VTbG90IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTdG9yYWdlU2xvdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTdG9yYWdlU2xvdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFN0b3JhZ2VTbG90KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTdG9yYWdlU2xvdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc3RvcmFnZXNsb3RfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0b3JhZ2VTbG90fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUodmFsdWUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHZhbHVlLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlc2xvdF9mcm9tVmFsdWUodmFsdWUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFN0b3JhZ2VTbG90Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RvcmFnZVNsb3R9XG4gICAgICovXG4gICAgc3RhdGljIGVtcHR5VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZXNsb3RfZW1wdHlWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gU3RvcmFnZVNsb3QuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RvcmFnZU1hcH0gc3RvcmFnZV9tYXBcbiAgICAgKiBAcmV0dXJucyB7U3RvcmFnZVNsb3R9XG4gICAgICovXG4gICAgc3RhdGljIG1hcChzdG9yYWdlX21hcCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmFnZV9tYXAsIFN0b3JhZ2VNYXApO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VzbG90X21hcChzdG9yYWdlX21hcC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU3RvcmFnZVNsb3QuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTdG9yYWdlU2xvdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU3RvcmFnZVNsb3QucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFN0b3JhZ2VTbG90QXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc3RvcmFnZXNsb3RhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTdG9yYWdlU2xvdEFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU3RvcmFnZVNsb3RBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc3RvcmFnZXNsb3RhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVNsb3RbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZXNsb3RhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBTdG9yYWdlU2xvdEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1N0b3JhZ2VTbG90fVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnN0b3JhZ2VzbG90YXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2VTbG90Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVNsb3R9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIFN0b3JhZ2VTbG90KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uc3RvcmFnZXNsb3RhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVNsb3R9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIFN0b3JhZ2VTbG90KTtcbiAgICAgICAgd2FzbS5zdG9yYWdlc2xvdGFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZXNsb3RhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU3RvcmFnZVNsb3RBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU3RvcmFnZVNsb3RBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU3luY1N1bW1hcnlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc3luY3N1bW1hcnlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU3luY1N1bW1hcnkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFN5bmNTdW1tYXJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFN5bmNTdW1tYXJ5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFN5bmNTdW1tYXJ5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zeW5jc3VtbWFyeV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmxvY2tOdW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3luY3N1bW1hcnlfYmxvY2tOdW0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkW119XG4gICAgICovXG4gICAgY29tbWl0dGVkTm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc3luY3N1bW1hcnlfY29tbWl0dGVkTm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWRbXX1cbiAgICAgKi9cbiAgICBjb25zdW1lZE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnN5bmNzdW1tYXJ5X2NvbnN1bWVkTm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWRbXX1cbiAgICAgKi9cbiAgICB1cGRhdGVkQWNjb3VudHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc3luY3N1bW1hcnlfdXBkYXRlZEFjY291bnRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25JZFtdfVxuICAgICAqL1xuICAgIGNvbW1pdHRlZFRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zeW5jc3VtbWFyeV9jb21taXR0ZWRUcmFuc2FjdGlvbnMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zeW5jc3VtbWFyeV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1N5bmNTdW1tYXJ5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnN5bmNzdW1tYXJ5X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN5bmNTdW1tYXJ5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTeW5jU3VtbWFyeS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU3luY1N1bW1hcnkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRlc3RVdGlsc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190ZXN0dXRpbHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVGVzdFV0aWxzIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVGVzdFV0aWxzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190ZXN0dXRpbHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVNb2NrQWNjb3VudElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRlc3R1dGlsc19jcmVhdGVNb2NrQWNjb3VudElkKCk7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVNb2NrU2VyaWFsaXplZFBhY2thZ2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udGVzdHV0aWxzX2NyZWF0ZU1vY2tTZXJpYWxpemVkUGFja2FnZSgpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVGVzdFV0aWxzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUZXN0VXRpbHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRva2VuU3ltYm9sRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Rva2Vuc3ltYm9sX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRva2VuU3ltYm9sIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUb2tlblN5bWJvbC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUb2tlblN5bWJvbEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUb2tlblN5bWJvbEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdG9rZW5zeW1ib2xfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3ltYm9sKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzeW1ib2wsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRva2Vuc3ltYm9sX25ldyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHIwID4+PiAwO1xuICAgICAgICAgICAgVG9rZW5TeW1ib2xGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRva2Vuc3ltYm9sX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IHB0cjE7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGxlbjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRva2VuU3ltYm9sLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUb2tlblN5bWJvbC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25BcmdzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uYXJnc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvbkFyZ3Mge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uQXJncy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvbkFyZ3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25BcmdzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbmFyZ3NfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TY3JpcHQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgdHhTY3JpcHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25hcmdzX3R4U2NyaXB0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFRyYW5zYWN0aW9uU2NyaXB0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVJZH0gbm90ZV9pZFxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldE5vdGVBcmdzKG5vdGVfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfaWQsIE5vdGVJZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25hcmdzX2dldE5vdGVBcmdzKHRoaXMuX193YmdfcHRyLCBub3RlX2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWR2aWNlSW5wdXRzfVxuICAgICAqL1xuICAgIGFkdmljZUlucHV0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmFyZ3NfYWR2aWNlSW5wdXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFkdmljZUlucHV0cy5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uQXJncy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25BcmdzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvbkZpbHRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbmZpbHRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvbkZpbHRlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25GaWx0ZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25GaWx0ZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25GaWx0ZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uZmlsdGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uRmlsdGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBhbGwoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25maWx0ZXJfYWxsKCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbkZpbHRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbklkW119IGlkc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkZpbHRlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaWRzKGlkcykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoaWRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmZpbHRlcl9pZHMocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbkZpbHRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uRmlsdGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmNvbW1pdHRlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmZpbHRlcl91bmNvbW1pdHRlZCgpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25GaWx0ZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja19udW1cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25GaWx0ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGV4cGlyZWRCZWZvcmUoYmxvY2tfbnVtKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25maWx0ZXJfZXhwaXJlZEJlZm9yZShibG9ja19udW0pO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25GaWx0ZXIuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25GaWx0ZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uSWRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25pZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvbklkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvbklkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uSWRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbklkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvbklkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbmlkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICBhc0VsZW1lbnRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uaWRfYXNFbGVtZW50cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgYXNCeXRlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbmlkX2FzQnl0ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvSGV4KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbmlkX3RvSGV4KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBpbm5lcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvbklkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvbklkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblByb3ZlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnByb3Zlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblByb3ZlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25Qcm92ZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25Qcm92ZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25Qcm92ZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucHJvdmVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUHJvdmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdMb2NhbFByb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnByb3Zlcl9uZXdMb2NhbFByb3ZlcigpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25Qcm92ZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblByb3Zlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3UmVtb3RlUHJvdmVyKGVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChlbmRwb2ludCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucHJvdmVyX25ld1JlbW90ZVByb3ZlcihwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUHJvdmVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25wcm92ZXJfc2VyaWFsaXplKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmVyX3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtlbmRwb2ludF1cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25Qcm92ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHByb3Zlcl90eXBlLCBlbmRwb2ludCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvdmVyX3R5cGUsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUoZW5kcG9pbnQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGVuZHBvaW50LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25wcm92ZXJfZGVzZXJpYWxpemUocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUHJvdmVyLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZW5kcG9pbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25wcm92ZXJfZW5kcG9pbnQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblByb3Zlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25Qcm92ZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uUmVjb3JkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVjb3JkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uUmVjb3JkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblJlY29yZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblJlY29yZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblJlY29yZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25yZWNvcmRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25JZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgYWNjb3VudElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX2FjY291bnRJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGluaXRBY2NvdW50U3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfaW5pdEFjY291bnRTdGF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBmaW5hbEFjY291bnRTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF9maW5hbEFjY291bnRTdGF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqL1xuICAgIGlucHV0Tm90ZU51bGxpZmllcnMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25yZWNvcmRfaW5wdXROb3RlTnVsbGlmaWVycyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVzfVxuICAgICAqL1xuICAgIG91dHB1dE5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX291dHB1dE5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJsb2NrTnVtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX2Jsb2NrTnVtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3RhdHVzfVxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uU3RhdHVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX3RyYW5zYWN0aW9uU3RhdHVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGNyZWF0aW9uVGltZXN0YW1wKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX2NyZWF0aW9uVGltZXN0YW1wKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25SZWNvcmQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uUmVjb3JkLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblJlcXVlc3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25yZXF1ZXN0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uUmVxdWVzdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25SZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVxdWVzdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblJlcXVlc3RGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVxdWVzdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3Rfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3R9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVtdfVxuICAgICAqL1xuICAgIGV4cGVjdGVkT3V0cHV0T3duTm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0X2V4cGVjdGVkT3V0cHV0T3duTm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVEZXRhaWxzQW5kVGFnW119XG4gICAgICovXG4gICAgZXhwZWN0ZWRGdXR1cmVOb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RfZXhwZWN0ZWRGdXR1cmVOb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBzY3JpcHRBcmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0X3NjcmlwdEFyZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBhdXRoQXJnKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdF9hdXRoQXJnKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblJlcXVlc3QucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uUmVxdWVzdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlQW5kQXJnc0FycmF5fSBub3Rlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhVbmF1dGhlbnRpY2F0ZWRJbnB1dE5vdGVzKG5vdGVzKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlcywgTm90ZUFuZEFyZ3NBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoVW5hdXRoZW50aWNhdGVkSW5wdXROb3RlcyhwdHIsIG5vdGVzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVJZEFuZEFyZ3NBcnJheX0gbm90ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoQXV0aGVudGljYXRlZElucHV0Tm90ZXMobm90ZXMpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVzLCBOb3RlSWRBbmRBcmdzQXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aEF1dGhlbnRpY2F0ZWRJbnB1dE5vdGVzKHB0ciwgbm90ZXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T3V0cHV0Tm90ZUFycmF5fSBub3Rlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhPd25PdXRwdXROb3Rlcyhub3Rlcykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZXMsIE91dHB1dE5vdGVBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoT3duT3V0cHV0Tm90ZXMocHRyLCBub3Rlcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblNjcmlwdH0gc2NyaXB0XG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEN1c3RvbVNjcmlwdChzY3JpcHQpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNjcmlwdCwgVHJhbnNhY3Rpb25TY3JpcHQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aEN1c3RvbVNjcmlwdChwdHIsIHNjcmlwdC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlUmVjaXBpZW50QXJyYXl9IHJlY2lwaWVudHNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoRXhwZWN0ZWRPdXRwdXRSZWNpcGllbnRzKHJlY2lwaWVudHMpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJlY2lwaWVudHMsIE5vdGVSZWNpcGllbnRBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoRXhwZWN0ZWRPdXRwdXRSZWNpcGllbnRzKHB0ciwgcmVjaXBpZW50cy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRGV0YWlsc0FuZFRhZ0FycmF5fSBub3RlX2RldGFpbHNfYW5kX3RhZ1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhFeHBlY3RlZEZ1dHVyZU5vdGVzKG5vdGVfZGV0YWlsc19hbmRfdGFnKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2RldGFpbHNfYW5kX3RhZywgTm90ZURldGFpbHNBbmRUYWdBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoRXhwZWN0ZWRGdXR1cmVOb3RlcyhwdHIsIG5vdGVfZGV0YWlsc19hbmRfdGFnLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FkdmljZU1hcH0gYWR2aWNlX21hcFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIGV4dGVuZEFkdmljZU1hcChhZHZpY2VfbWFwKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhZHZpY2VfbWFwLCBBZHZpY2VNYXApO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfZXh0ZW5kQWR2aWNlTWFwKHB0ciwgYWR2aWNlX21hcC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGb3JlaWduQWNjb3VudEFycmF5fSBmb3JlaWduX2FjY291bnRzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEZvcmVpZ25BY2NvdW50cyhmb3JlaWduX2FjY291bnRzKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmb3JlaWduX2FjY291bnRzLCBGb3JlaWduQWNjb3VudEFycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhGb3JlaWduQWNjb3VudHMocHRyLCBmb3JlaWduX2FjY291bnRzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHNjcmlwdF9hcmdcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoU2NyaXB0QXJnKHNjcmlwdF9hcmcpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNjcmlwdF9hcmcsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aFNjcmlwdEFyZyhwdHIsIHNjcmlwdF9hcmcuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gYXV0aF9hcmdcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoQXV0aEFyZyhhdXRoX2FyZykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXV0aF9hcmcsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aEF1dGhBcmcocHRyLCBhdXRoX2FyZy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdH1cbiAgICAgKi9cbiAgICBidWlsZCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX2J1aWxkKHB0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3QuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblJlc3VsdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlc3VsdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBXQVNNIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgW2BUcmFuc2FjdGlvblJlc3VsdGBdLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvblJlc3VsdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25SZXN1bHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXN1bHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXN1bHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVzdWx0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbklkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25faWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXhlY3V0ZWQgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge0V4ZWN1dGVkVHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgZXhlY3V0ZWRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlc3VsdF9leGVjdXRlZFRyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEV4ZWN1dGVkVHJhbnNhY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbm90ZXMgdGhhdCBhcmUgZXhwZWN0ZWQgdG8gYmUgY3JlYXRlZCBhcyBhIHJlc3VsdCBvZiBmb2xsb3ctdXAgZXhlY3V0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7Tm90ZURldGFpbHNBbmRUYWdbXX1cbiAgICAgKi9cbiAgICBmdXR1cmVOb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnJlc3VsdF9mdXR1cmVOb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0IGludG8gYnl0ZXMuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVzdWx0X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhIHRyYW5zYWN0aW9uIHJlc3VsdCBmcm9tIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXN1bHR9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25yZXN1bHRfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXN1bHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uUmVzdWx0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblJlc3VsdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25TY3JpcHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25zY3JpcHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25TY3JpcHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uU2NyaXB0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnNjcmlwdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXNjcmlwdF9yb290KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblNjcmlwdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25TY3JpcHQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHdvcmRcbiAgICAgKiBAcGFyYW0ge0ZlbHRBcnJheX0gZmVsdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3b3JkLCBmZWx0cykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mod29yZCwgV29yZCk7XG4gICAgICAgIHZhciBwdHIwID0gd29yZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZlbHRzLCBGZWx0QXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyX25ldyhwdHIwLCBmZWx0cy5fX3diZ19wdHIpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgd29yZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0QXJyYXl9XG4gICAgICovXG4gICAgZmVsdHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJfZmVsdHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdEFycmF5Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcn1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcmFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpci5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcik7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpcik7XG4gICAgICAgIHdhc20udHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVzYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uU3RhdHVzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc3RhdHVzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uU3RhdHVzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblN0YXR1cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblN0YXR1c0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblN0YXR1c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25zdGF0dXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdGF0dXN9XG4gICAgICovXG4gICAgc3RhdGljIHBlbmRpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfcGVuZGluZygpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja19udW1cbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gY29tbWl0X3RpbWVzdGFtcFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN0YXR1c31cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tbWl0dGVkKGJsb2NrX251bSwgY29tbWl0X3RpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2NvbW1pdHRlZChibG9ja19udW0sIGNvbW1pdF90aW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXVzZVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN0YXR1c31cbiAgICAgKi9cbiAgICBzdGF0aWMgZGlzY2FyZGVkKGNhdXNlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjYXVzZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2Rpc2NhcmRlZChwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1BlbmRpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfaXNQZW5kaW5nKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb21taXR0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfaXNDb21taXR0ZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Rpc2NhcmRlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19pc0Rpc2NhcmRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0QmxvY2tOdW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfZ2V0QmxvY2tOdW0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAweDEwMDAwMDAwMSA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2JpZ2ludCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRDb21taXRUaW1lc3RhbXAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdGF0dXNfZ2V0Q29tbWl0VGltZXN0YW1wKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0QmlnSW50NjQocmV0cHRyICsgOCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHIwID09PSAwID8gdW5kZWZpbmVkIDogQmlnSW50LmFzVWludE4oNjQsIHIyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uU3RhdHVzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblN0YXR1cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnN0b3JldXBkYXRlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblN0b3JlVXBkYXRlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnN0b3JldXBkYXRlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0V4ZWN1dGVkVHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgZXhlY3V0ZWRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX2V4ZWN1dGVkVHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRXhlY3V0ZWRUcmFuc2FjdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdWJtaXNzaW9uSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfc3VibWlzc2lvbkhlaWdodCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3Rlc31cbiAgICAgKi9cbiAgICBjcmVhdGVkTm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9jcmVhdGVkTm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50RGVsdGF9XG4gICAgICovXG4gICAgYWNjb3VudERlbHRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfYWNjb3VudERlbHRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnREZWx0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVEZXRhaWxzQW5kVGFnW119XG4gICAgICovXG4gICAgZnV0dXJlTm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9mdXR1cmVOb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN0b3JlVXBkYXRlfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25TdW1tYXJ5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc3VtbWFyeV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblN1bW1hcnkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uU3VtbWFyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblN1bW1hcnlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TdW1tYXJ5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnN1bW1hcnlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdW1tYXJ5X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdW1tYXJ5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3VtbWFyeV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN1bW1hcnkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnREZWx0YX1cbiAgICAgKi9cbiAgICBhY2NvdW50RGVsdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdW1tYXJ5X2FjY291bnREZWx0YShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnREZWx0YS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3Rlc31cbiAgICAgKi9cbiAgICBpbnB1dE5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3VtbWFyeV9pbnB1dE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSW5wdXROb3Rlcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZXN9XG4gICAgICovXG4gICAgb3V0cHV0Tm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdW1tYXJ5X291dHB1dE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZXMuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc2FsdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN1bW1hcnlfc2FsdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uU3VtbWFyeS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25TdW1tYXJ5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBXZWJDbGllbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfd2ViY2xpZW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFdlYkNsaWVudCB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFdlYkNsaWVudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfd2ViY2xpZW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudEhlYWRlcltdPn1cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0QWNjb3VudHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnQgfCB1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGdldEFjY291bnQoYWNjb3VudF9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0QWNjb3VudCh0aGlzLl9fd2JnX3B0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHB1Yl9rZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoU2VjcmV0S2V5Pn1cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50QXV0aEJ5UHViS2V5KHB1Yl9rZXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHB1Yl9rZXksIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRBY2NvdW50QXV0aEJ5UHViS2V5KHRoaXMuX193YmdfcHRyLCBwdWJfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgaW5zZXJ0QWNjb3VudEFkZHJlc3MoYWNjb3VudF9pZCwgYWRkcmVzcykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFkZHJlc3MsIEFkZHJlc3MpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9pbnNlcnRBY2NvdW50QWRkcmVzcyh0aGlzLl9fd2JnX3B0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIsIGFkZHJlc3MuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICByZW1vdmVBY2NvdW50QWRkcmVzcyhhY2NvdW50X2lkLCBhZGRyZXNzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWRkcmVzcywgQWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3JlbW92ZUFjY291bnRBZGRyZXNzKHRoaXMuX193YmdfcHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0ciwgYWRkcmVzcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbm90ZV9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBvcnRfdHlwZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGVGaWxlPn1cbiAgICAgKi9cbiAgICBleHBvcnROb3RlRmlsZShub3RlX2lkLCBleHBvcnRfdHlwZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobm90ZV9pZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoZXhwb3J0X3R5cGUsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZXhwb3J0Tm90ZUZpbGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGVudGlyZSB1bmRlcmx5aW5nIHdlYiBzdG9yZSBhbmQgcmV0dXJucyBpdCBhcyBhIGBKc1ZhbHVlYFxuICAgICAqXG4gICAgICogTWVhbnQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgZm9yY2VfaW1wb3J0X3N0b3JlYCBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGV4cG9ydFN0b3JlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9leHBvcnRTdG9yZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudEZpbGU+fVxuICAgICAqL1xuICAgIGV4cG9ydEFjY291bnRGaWxlKGFjY291bnRfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIHZhciBwdHIwID0gYWNjb3VudF9pZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZXhwb3J0QWNjb3VudEZpbGUodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRGaWxlfSBhY2NvdW50X2ZpbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGltcG9ydEFjY291bnRGaWxlKGFjY291bnRfZmlsZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9maWxlLCBBY2NvdW50RmlsZSk7XG4gICAgICAgIHZhciBwdHIwID0gYWNjb3VudF9maWxlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9pbXBvcnRBY2NvdW50RmlsZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5pdF9zZWVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdXRhYmxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1dGhfc2NoZW1lX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudD59XG4gICAgICovXG4gICAgaW1wb3J0UHVibGljQWNjb3VudEZyb21TZWVkKGluaXRfc2VlZCwgbXV0YWJsZSwgYXV0aF9zY2hlbWVfaWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGluaXRfc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ltcG9ydFB1YmxpY0FjY291bnRGcm9tU2VlZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgbXV0YWJsZSwgYXV0aF9zY2hlbWVfaWQpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgaW1wb3J0QWNjb3VudEJ5SWQoYWNjb3VudF9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfaW1wb3J0QWNjb3VudEJ5SWQodGhpcy5fX3diZ19wdHIsIGFjY291bnRfaWQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRmlsZX0gbm90ZV9maWxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm90ZUlkPn1cbiAgICAgKi9cbiAgICBpbXBvcnROb3RlRmlsZShub3RlX2ZpbGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfZmlsZSwgTm90ZUZpbGUpO1xuICAgICAgICB2YXIgcHRyMCA9IG5vdGVfZmlsZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfaW1wb3J0Tm90ZUZpbGUodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gc3RvcmVfZHVtcFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZm9yY2VJbXBvcnRTdG9yZShzdG9yZV9kdW1wKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ZvcmNlSW1wb3J0U3RvcmUodGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3Qoc3RvcmVfZHVtcCkpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsaWVudCB3aXRoIGEgbW9jayBSUEMgQVBJLiBVc2VmdWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHByb29mLW9mLWNvbmNlcHRcbiAgICAgKiBhcHBsaWNhdGlvbnMgYXMgaXQgdXNlcyBhIG1vY2sgY2hhaW4gdGhhdCBzaW11bGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGEgcmVhbCBub2RlLlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZWVkXVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZXJpYWxpemVkX21vY2tfY2hhaW5dXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlcmlhbGl6ZWRfbW9ja19ub3RlX3RyYW5zcG9ydF9ub2RlXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgY3JlYXRlTW9ja0NsaWVudChzZWVkLCBzZXJpYWxpemVkX21vY2tfY2hhaW4sIHNlcmlhbGl6ZWRfbW9ja19ub3RlX3RyYW5zcG9ydF9ub2RlKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShzZWVkKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShzZXJpYWxpemVkX21vY2tfY2hhaW4pID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlcmlhbGl6ZWRfbW9ja19jaGFpbiwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUoc2VyaWFsaXplZF9tb2NrX25vdGVfdHJhbnNwb3J0X25vZGUpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlcmlhbGl6ZWRfbW9ja19ub3RlX3RyYW5zcG9ydF9ub2RlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2NyZWF0ZU1vY2tDbGllbnQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbm5lciBzZXJpYWxpemVkIG1vY2sgY2hhaW4gaWYgaXQgZXhpc3RzLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZU1vY2tDaGFpbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfc2VyaWFsaXplTW9ja0NoYWluKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbm5lciBzZXJpYWxpemVkIG1vY2sgbm90ZSB0cmFuc3BvcnQgbm9kZSBpZiBpdCBleGlzdHMuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplTW9ja05vdGVUcmFuc3BvcnROb2RlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9zZXJpYWxpemVNb2NrTm90ZVRyYW5zcG9ydE5vZGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3ZlQmxvY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X3Byb3ZlQmxvY2socmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdXNlc01vY2tDaGFpbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfdXNlc01vY2tDaGFpbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudFN0b3JhZ2VNb2RlfSBzdG9yYWdlX21vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11dGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXV0aF9zY2hlbWVfaWRcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbaW5pdF9zZWVkXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnQ+fVxuICAgICAqL1xuICAgIG5ld1dhbGxldChzdG9yYWdlX21vZGUsIG11dGFibGUsIGF1dGhfc2NoZW1lX2lkLCBpbml0X3NlZWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JhZ2VfbW9kZSwgQWNjb3VudFN0b3JhZ2VNb2RlKTtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGluaXRfc2VlZCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoaW5pdF9zZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X25ld1dhbGxldCh0aGlzLl9fd2JnX3B0ciwgc3RvcmFnZV9tb2RlLl9fd2JnX3B0ciwgbXV0YWJsZSwgYXV0aF9zY2hlbWVfaWQsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRTdG9yYWdlTW9kZX0gc3RvcmFnZV9tb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBub25fZnVuZ2libGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5fc3ltYm9sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IG1heF9zdXBwbHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXV0aF9zY2hlbWVfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50Pn1cbiAgICAgKi9cbiAgICBuZXdGYXVjZXQoc3RvcmFnZV9tb2RlLCBub25fZnVuZ2libGUsIHRva2VuX3N5bWJvbCwgZGVjaW1hbHMsIG1heF9zdXBwbHksIGF1dGhfc2NoZW1lX2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yYWdlX21vZGUsIEFjY291bnRTdG9yYWdlTW9kZSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0b2tlbl9zeW1ib2wsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfbmV3RmF1Y2V0KHRoaXMuX193YmdfcHRyLCBzdG9yYWdlX21vZGUuX193YmdfcHRyLCBub25fZnVuZ2libGUsIHB0cjAsIGxlbjAsIGRlY2ltYWxzLCBtYXhfc3VwcGx5LCBhdXRoX3NjaGVtZV9pZCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudH0gYWNjb3VudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgbmV3QWNjb3VudChhY2NvdW50LCBvdmVyd3JpdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnQsIEFjY291bnQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9uZXdBY2NvdW50KHRoaXMuX193YmdfcHRyLCBhY2NvdW50Ll9fd2JnX3B0ciwgb3ZlcndyaXRlKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZWNyZXRLZXl9IHNlY3JldF9rZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhZGRBY2NvdW50U2VjcmV0S2V5VG9XZWJTdG9yZShzZWNyZXRfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzZWNyZXRfa2V5LCBTZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9hZGRBY2NvdW50U2VjcmV0S2V5VG9XZWJTdG9yZSh0aGlzLl9fd2JnX3B0ciwgc2VjcmV0X2tleS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHRyYW5zYWN0aW9uIHNwZWNpZmllZCBieSB0aGUgcmVxdWVzdCBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgYWNjb3VudCxcbiAgICAgKiBwcm92ZXMgaXQsIHN1Ym1pdHMgaXQgdG8gdGhlIG5ldHdvcmssIGFuZCB1cGRhdGVzIHRoZSBsb2NhbCBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0cmFuc2FjdGlvbiB1dGlsaXplcyBmb3JlaWduIGFjY291bnQgZGF0YSwgdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGUgY2xpZW50IGRvZXNuJ3RcbiAgICAgKiBoYXZlIHRoZSByZXF1aXJlZCBibG9jayBoZWFkZXIgaW4gdGhlIGxvY2FsIGRhdGFiYXNlLiBJbiB0aGVzZSBzY2VuYXJpb3MsIGEgc3luYyB0b1xuICAgICAqIHRoZSBjaGFpbiB0aXAgaXMgcGVyZm9ybWVkLCBhbmQgdGhlIHJlcXVpcmVkIGJsb2NrIGhlYWRlciBpcyByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVxdWVzdH0gdHJhbnNhY3Rpb25fcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uSWQ+fVxuICAgICAqL1xuICAgIHN1Ym1pdE5ld1RyYW5zYWN0aW9uKGFjY291bnRfaWQsIHRyYW5zYWN0aW9uX3JlcXVlc3QpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2FjdGlvbl9yZXF1ZXN0LCBUcmFuc2FjdGlvblJlcXVlc3QpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9zdWJtaXROZXdUcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIsIHRyYW5zYWN0aW9uX3JlcXVlc3QuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSB0cmFuc2FjdGlvbiBzcGVjaWZpZWQgYnkgdGhlIHJlcXVlc3QgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIGFjY291bnQgYnV0IGRvZXMgbm90XG4gICAgICogc3VibWl0IGl0IHRvIHRoZSBuZXR3b3JrIG5vciB1cGRhdGUgdGhlIGxvY2FsIGRhdGFiYXNlLiBUaGUgcmV0dXJuZWQgW2BUcmFuc2FjdGlvblJlc3VsdGBdXG4gICAgICogcmV0YWlucyB0aGUgZXhlY3V0aW9uIGFydGlmYWN0cyBuZWVkZWQgdG8gY29udGludWUgd2l0aCB0aGUgdHJhbnNhY3Rpb24gbGlmZWN5Y2xlLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zYWN0aW9uIHV0aWxpemVzIGZvcmVpZ24gYWNjb3VudCBkYXRhLCB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHRoZSBjbGllbnQgZG9lc24ndFxuICAgICAqIGhhdmUgdGhlIHJlcXVpcmVkIGJsb2NrIGhlYWRlciBpbiB0aGUgbG9jYWwgZGF0YWJhc2UuIEluIHRoZXNlIHNjZW5hcmlvcywgYSBzeW5jIHRvXG4gICAgICogdGhlIGNoYWluIHRpcCBpcyBwZXJmb3JtZWQsIGFuZCB0aGUgcmVxdWlyZWQgYmxvY2sgaGVhZGVyIGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZXF1ZXN0fSB0cmFuc2FjdGlvbl9yZXF1ZXN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25SZXN1bHQ+fVxuICAgICAqL1xuICAgIGV4ZWN1dGVUcmFuc2FjdGlvbihhY2NvdW50X2lkLCB0cmFuc2FjdGlvbl9yZXF1ZXN0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNhY3Rpb25fcmVxdWVzdCwgVHJhbnNhY3Rpb25SZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZXhlY3V0ZVRyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0ciwgdHJhbnNhY3Rpb25fcmVxdWVzdC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB0cmFuc2FjdGlvbiBwcm9vZiB1c2luZyBlaXRoZXIgdGhlIHByb3ZpZGVkIHByb3ZlciBvciB0aGUgY2xpZW50J3MgZGVmYXVsdFxuICAgICAqIHByb3ZlciBpZiBub25lIGlzIHN1cHBsaWVkLlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZXN1bHR9IHRyYW5zYWN0aW9uX3Jlc3VsdFxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Qcm92ZXIgfCBudWxsfSBbcHJvdmVyXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByb3ZlblRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICBwcm92ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uX3Jlc3VsdCwgcHJvdmVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2FjdGlvbl9yZXN1bHQsIFRyYW5zYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgbGV0IHB0cjAgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUocHJvdmVyKSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHByb3ZlciwgVHJhbnNhY3Rpb25Qcm92ZXIpO1xuICAgICAgICAgICAgcHRyMCA9IHByb3Zlci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9wcm92ZVRyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyLCB0cmFuc2FjdGlvbl9yZXN1bHQuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQcm92ZW5UcmFuc2FjdGlvbn0gcHJvdmVuX3RyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlc3VsdH0gdHJhbnNhY3Rpb25fcmVzdWx0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICAgKi9cbiAgICBzdWJtaXRQcm92ZW5UcmFuc2FjdGlvbihwcm92ZW5fdHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uX3Jlc3VsdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJvdmVuX3RyYW5zYWN0aW9uLCBQcm92ZW5UcmFuc2FjdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2FjdGlvbl9yZXN1bHQsIFRyYW5zYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfc3VibWl0UHJvdmVuVHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIsIHByb3Zlbl90cmFuc2FjdGlvbi5fX3diZ19wdHIsIHRyYW5zYWN0aW9uX3Jlc3VsdC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVzdWx0fSB0cmFuc2FjdGlvbl9yZXN1bHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VibWlzc2lvbl9oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblN0b3JlVXBkYXRlPn1cbiAgICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uX3Jlc3VsdCwgc3VibWlzc2lvbl9oZWlnaHQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zYWN0aW9uX3Jlc3VsdCwgVHJhbnNhY3Rpb25SZXN1bHQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9hcHBseVRyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyLCB0cmFuc2FjdGlvbl9yZXN1bHQuX193YmdfcHRyLCBzdWJtaXNzaW9uX2hlaWdodCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSB0YXJnZXRfYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBmYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gYW1vdW50XG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdH1cbiAgICAgKi9cbiAgICBuZXdNaW50VHJhbnNhY3Rpb25SZXF1ZXN0KHRhcmdldF9hY2NvdW50X2lkLCBmYXVjZXRfaWQsIG5vdGVfdHlwZSwgYW1vdW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0YXJnZXRfYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9uZXdNaW50VHJhbnNhY3Rpb25SZXF1ZXN0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHRhcmdldF9hY2NvdW50X2lkLl9fd2JnX3B0ciwgZmF1Y2V0X2lkLl9fd2JnX3B0ciwgbm90ZV90eXBlLCBhbW91bnQpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBzZW5kZXJfYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSB0YXJnZXRfYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBmYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge05vdGVUeXBlfSBub3RlX3R5cGVcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gYW1vdW50XG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbcmVjYWxsX2hlaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFt0aW1lbG9ja19oZWlnaHRdXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdH1cbiAgICAgKi9cbiAgICBuZXdTZW5kVHJhbnNhY3Rpb25SZXF1ZXN0KHNlbmRlcl9hY2NvdW50X2lkLCB0YXJnZXRfYWNjb3VudF9pZCwgZmF1Y2V0X2lkLCBub3RlX3R5cGUsIGFtb3VudCwgcmVjYWxsX2hlaWdodCwgdGltZWxvY2tfaGVpZ2h0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzZW5kZXJfYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0YXJnZXRfYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9uZXdTZW5kVHJhbnNhY3Rpb25SZXF1ZXN0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHNlbmRlcl9hY2NvdW50X2lkLl9fd2JnX3B0ciwgdGFyZ2V0X2FjY291bnRfaWQuX193YmdfcHRyLCBmYXVjZXRfaWQuX193YmdfcHRyLCBub3RlX3R5cGUsIGFtb3VudCwgaXNMaWtlTm9uZShyZWNhbGxfaGVpZ2h0KSA/IDB4MTAwMDAwMDAxIDogKHJlY2FsbF9oZWlnaHQpID4+PiAwLCBpc0xpa2VOb25lKHRpbWVsb2NrX2hlaWdodCkgPyAweDEwMDAwMDAwMSA6ICh0aW1lbG9ja19oZWlnaHQpID4+PiAwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsaXN0X29mX25vdGVfaWRzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdH1cbiAgICAgKi9cbiAgICBuZXdDb25zdW1lVHJhbnNhY3Rpb25SZXF1ZXN0KGxpc3Rfb2Zfbm90ZV9pZHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGxpc3Rfb2Zfbm90ZV9pZHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X25ld0NvbnN1bWVUcmFuc2FjdGlvblJlcXVlc3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3QuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHNlbmRlcl9hY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IG9mZmVyZWRfYXNzZXRfYW1vdW50XG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gcmVxdWVzdGVkX2Fzc2V0X2Ftb3VudFxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IHBheWJhY2tfbm90ZV90eXBlXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdH1cbiAgICAgKi9cbiAgICBuZXdTd2FwVHJhbnNhY3Rpb25SZXF1ZXN0KHNlbmRlcl9hY2NvdW50X2lkLCBvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZCwgb2ZmZXJlZF9hc3NldF9hbW91bnQsIHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWQsIHJlcXVlc3RlZF9hc3NldF9hbW91bnQsIG5vdGVfdHlwZSwgcGF5YmFja19ub3RlX3R5cGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNlbmRlcl9hY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9uZXdTd2FwVHJhbnNhY3Rpb25SZXF1ZXN0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHNlbmRlcl9hY2NvdW50X2lkLl9fd2JnX3B0ciwgb2ZmZXJlZF9hc3NldF9mYXVjZXRfaWQuX193YmdfcHRyLCBvZmZlcmVkX2Fzc2V0X2Ftb3VudCwgcmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZC5fX3diZ19wdHIsIHJlcXVlc3RlZF9hc3NldF9hbW91bnQsIG5vdGVfdHlwZSwgcGF5YmFja19ub3RlX3R5cGUpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBwcml2YXRlIG5vdGUgdmlhIHRoZSBub3RlIHRyYW5zcG9ydCBsYXllclxuICAgICAqIEBwYXJhbSB7Tm90ZX0gbm90ZVxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHNlbmRQcml2YXRlTm90ZShub3RlLCBhZGRyZXNzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlLCBOb3RlKTtcbiAgICAgICAgdmFyIHB0cjAgPSBub3RlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWRkcmVzcywgQWRkcmVzcyk7XG4gICAgICAgIHZhciBwdHIxID0gYWRkcmVzcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfc2VuZFByaXZhdGVOb3RlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBwdHIxKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggcHJpdmF0ZSBub3RlcyBmcm9tIHRoZSBub3RlIHRyYW5zcG9ydCBsYXllclxuICAgICAqXG4gICAgICogVXNlcyBhbiBpbnRlcm5hbCBwYWdpbmF0aW9uIG1lY2hhbmlzbSB0byBhdm9pZCBmZXRjaGluZyBkdXBsaWNhdGUgbm90ZXMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgZmV0Y2hQcml2YXRlTm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ZldGNoUHJpdmF0ZU5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIHByaXZhdGUgbm90ZXMgZnJvbSB0aGUgbm90ZSB0cmFuc3BvcnQgbGF5ZXJcbiAgICAgKlxuICAgICAqIEZldGNoZXMgYWxsIG5vdGVzIHN0b3JlZCBpbiB0aGUgdHJhbnNwb3J0IGxheWVyLCB3aXRoIG5vIHBhZ2luYXRpb24uXG4gICAgICogUHJlZmVyIHVzaW5nIFtgV2ViQ2xpZW50OjpmZXRjaF9wcml2YXRlX25vdGVzYF0gZm9yIGEgbW9yZSBlZmZpY2llbnQsIG9uLWdvaW5nLFxuICAgICAqIGZldGNoaW5nIG1lY2hhbmlzbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBmZXRjaEFsbFByaXZhdGVOb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZmV0Y2hBbGxQcml2YXRlTm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVGaWx0ZXJ9IGZpbHRlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPElucHV0Tm90ZVJlY29yZFtdPn1cbiAgICAgKi9cbiAgICBnZXRJbnB1dE5vdGVzKGZpbHRlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmlsdGVyLCBOb3RlRmlsdGVyKTtcbiAgICAgICAgdmFyIHB0cjAgPSBmaWx0ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldElucHV0Tm90ZXModGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbm90ZV9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPElucHV0Tm90ZVJlY29yZCB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgZ2V0SW5wdXROb3RlKG5vdGVfaWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG5vdGVfaWQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0SW5wdXROb3RlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRmlsdGVyfSBmaWx0ZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdldE91dHB1dE5vdGVzKGZpbHRlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmlsdGVyLCBOb3RlRmlsdGVyKTtcbiAgICAgICAgdmFyIHB0cjAgPSBmaWx0ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldE91dHB1dE5vdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5vdGVfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdldE91dHB1dE5vdGUobm90ZV9pZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobm90ZV9pZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRPdXRwdXROb3RlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWQgfCBudWxsfSBbYWNjb3VudF9pZF1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25zdW1hYmxlTm90ZVJlY29yZFtdPn1cbiAgICAgKi9cbiAgICBnZXRDb25zdW1hYmxlTm90ZXMoYWNjb3VudF9pZCkge1xuICAgICAgICBsZXQgcHRyMCA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShhY2NvdW50X2lkKSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBwdHIwID0gYWNjb3VudF9pZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRDb25zdW1hYmxlTm90ZXModGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNldHRpbmcgdmFsdWUgZm9yIGBrZXlgLCBvciBgTm9uZWAgaWYgaXQgaGFzbuKAmXQgYmVlbiBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueSB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgZ2V0U2V0dGluZyhrZXkpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGtleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRTZXR0aW5nKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHNldHRpbmcga2V5LXZhbHVlIGluIHRoZSBzdG9yZS4gSXQgY2FuIHRoZW4gYmUgcmV0cmlldmVkIHVzaW5nIGBnZXRfc2V0dGluZ2AuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHNldFNldHRpbmcoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoa2V5LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3NldFNldHRpbmcodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIGFkZEhlYXBPYmplY3QodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHNldHRpbmcga2V5LXZhbHVlIGZyb20gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICByZW1vdmVTZXR0aW5nKGtleSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoa2V5LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3JlbW92ZVNldHRpbmcodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgZXhpc3Rpbmcgc2V0dGluZyBrZXlzIGZyb20gdGhlIHN0b3JlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn1cbiAgICAgKi9cbiAgICBsaXN0U2V0dGluZ0tleXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2xpc3RTZXR0aW5nS2V5cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN5bmNTdW1tYXJ5Pn1cbiAgICAgKi9cbiAgICBzeW5jU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3N5bmNTdGF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgZ2V0U3luY0hlaWdodCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0U3luY0hlaWdodCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBvZmZlcmVkX2Fzc2V0X2Ftb3VudFxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSByZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IHJlcXVlc3RlZF9hc3NldF9hbW91bnRcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRTd2FwVGFnKG5vdGVfdHlwZSwgb2ZmZXJlZF9hc3NldF9mYXVjZXRfaWQsIG9mZmVyZWRfYXNzZXRfYW1vdW50LCByZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkLCByZXF1ZXN0ZWRfYXNzZXRfYW1vdW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfYnVpbGRTd2FwVGFnKHJldHB0ciwgbm90ZV90eXBlLCBvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZC5fX3diZ19wdHIsIG9mZmVyZWRfYXNzZXRfYW1vdW50LCByZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkLl9fd2JnX3B0ciwgcmVxdWVzdGVkX2Fzc2V0X2Ftb3VudCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhZGRUYWcodGFnKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0YWcsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfYWRkVGFnKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHJlbW92ZVRhZyh0YWcpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHRhZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9yZW1vdmVUYWcodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGxpc3RUYWdzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9saXN0VGFncyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25GaWx0ZXJ9IHRyYW5zYWN0aW9uX2ZpbHRlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uUmVjb3JkW10+fVxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbl9maWx0ZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zYWN0aW9uX2ZpbHRlciwgVHJhbnNhY3Rpb25GaWx0ZXIpO1xuICAgICAgICB2YXIgcHRyMCA9IHRyYW5zYWN0aW9uX2ZpbHRlci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0VHJhbnNhY3Rpb25zKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgV2ViQ2xpZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xpZW50IHdpdGggdGhlIGdpdmVuIG5vZGUgVVJMIGFuZCBvcHRpb25hbCBzZWVkLlxuICAgICAqIElmIGBub2RlX3VybGAgaXMgYE5vbmVgLCBpdCBkZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtub2RlX3VybF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtub2RlX25vdGVfdHJhbnNwb3J0X3VybF1cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VlZF1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGNyZWF0ZUNsaWVudChub2RlX3VybCwgbm9kZV9ub3RlX3RyYW5zcG9ydF91cmwsIHNlZWQpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG5vZGVfdXJsKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChub2RlX3VybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKG5vZGVfbm90ZV90cmFuc3BvcnRfdXJsKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChub2RlX25vdGVfdHJhbnNwb3J0X3VybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjIgPSBpc0xpa2VOb25lKHNlZWQpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfY3JlYXRlQ2xpZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gbm9kZSBVUkwsIG9wdGlvbmFsIHNlZWQsIGFuZCBleHRlcm5hbCBrZXlzdG9yZVxuICAgICAqIGNhbGxiYWNrcy4gSWYgYG5vZGVfdXJsYCBpcyBgTm9uZWAsIGl0IGRlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IGVuZHBvaW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW25vZGVfdXJsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW25vZGVfbm90ZV90cmFuc3BvcnRfdXJsXVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZWVkXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBudWxsfSBbZ2V0X2tleV9jYl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgbnVsbH0gW2luc2VydF9rZXlfY2JdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbiB8IG51bGx9IFtzaWduX2NiXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgY3JlYXRlQ2xpZW50V2l0aEV4dGVybmFsS2V5c3RvcmUobm9kZV91cmwsIG5vZGVfbm90ZV90cmFuc3BvcnRfdXJsLCBzZWVkLCBnZXRfa2V5X2NiLCBpbnNlcnRfa2V5X2NiLCBzaWduX2NiKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShub2RlX3VybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAobm9kZV91cmwsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShub2RlX25vdGVfdHJhbnNwb3J0X3VybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAobm9kZV9ub3RlX3RyYW5zcG9ydF91cmwsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShzZWVkKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChzZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2NyZWF0ZUNsaWVudFdpdGhFeHRlcm5hbEtleXN0b3JlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBpc0xpa2VOb25lKGdldF9rZXlfY2IpID8gMCA6IGFkZEhlYXBPYmplY3QoZ2V0X2tleV9jYiksIGlzTGlrZU5vbmUoaW5zZXJ0X2tleV9jYikgPyAwIDogYWRkSGVhcE9iamVjdChpbnNlcnRfa2V5X2NiKSwgaXNMaWtlTm9uZShzaWduX2NiKSA/IDAgOiBhZGRIZWFwT2JqZWN0KHNpZ25fY2IpKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1NjcmlwdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgY3JlYXRlU2NyaXB0QnVpbGRlcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfY3JlYXRlU2NyaXB0QnVpbGRlcihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNjcmlwdEJ1aWxkZXIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFdlYkNsaWVudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gV2ViQ2xpZW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBXb3JkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3dvcmRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgV29yZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoV29yZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBXb3JkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgV29yZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgV29yZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfd29yZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QmlnVWludDY0QXJyYXl9IHU2NF92ZWNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1NjRfdmVjKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk2NFRvV2FzbTAodTY0X3ZlYywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud29yZF9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBXb3JkRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXb3JkIGZyb20gYSBoZXggc3RyaW5nLlxuICAgICAqIEZhaWxzIGlmIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgbm90IGEgdmFsaWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgV29yZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChoZXgsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLndvcmRfZnJvbUhleChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZlbHRbXX0gZmVsdF92ZWNcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3RnJvbUZlbHRzKGZlbHRfdmVjKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChmZWx0X3ZlYywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud29yZF9uZXdGcm9tRmVsdHMocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvSGV4KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbmlkX3RvSGV4KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud29yZF9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ud29yZF9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCaWdVaW50NjRBcnJheX1cbiAgICAgKi9cbiAgICB0b1U2NHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ud29yZF90b1U2NHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU2NEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA4LCA4KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICB0b0ZlbHRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uaWRfYXNFbGVtZW50cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFdvcmQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFdvcmQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEVYUEVDVEVEX1JFU1BPTlNFX1RZUEVTID0gbmV3IFNldChbJ2Jhc2ljJywgJ2NvcnMnLCAnZGVmYXVsdCddKTtcblxuYXN5bmMgZnVuY3Rpb24gX193YmdfbG9hZChtb2R1bGUsIGltcG9ydHMpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZFJlc3BvbnNlID0gbW9kdWxlLm9rICYmIEVYUEVDVEVEX1JFU1BPTlNFX1RZUEVTLmhhcyhtb2R1bGUudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsaWRSZXNwb25zZSAmJiBtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9PSAnYXBwbGljYXRpb24vd2FzbScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nYCBmYWlsZWQgYmVjYXVzZSB5b3VyIHNlcnZlciBkb2VzIG5vdCBzZXJ2ZSBXYXNtIHdpdGggYGFwcGxpY2F0aW9uL3dhc21gIE1JTUUgdHlwZS4gRmFsbGluZyBiYWNrIHRvIGBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZWAgd2hpY2ggaXMgc2xvd2VyLiBPcmlnaW5hbCBlcnJvcjpcXG5cIiwgZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfX3diZ19nZXRfaW1wb3J0cygpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgaW1wb3J0cy53YmcgPSB7fTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19FcnJvcl9lODM5ODdmNjY1Y2Y1NTA0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfTnVtYmVyX2JiNDhjYTEyZjM5NWNkMDggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE51bWJlcihnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfU3RyaW5nXzhmMGViMzlhNGE0YzJmNjYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMSwgbGVuMSwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2JpZ2ludF9nZXRfYXNfaTY0X2YzZWJjNWE3NTUwMDBhZmQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2JpZ2ludCcgPyB2IDogdW5kZWZpbmVkO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRCaWdJbnQ2NChhcmcwICsgOCAqIDEsIGlzTGlrZU5vbmUocmV0KSA/IEJpZ0ludCgwKSA6IHJldCwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgIWlzTGlrZU5vbmUocmV0KSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2Jvb2xlYW5fZ2V0XzZkNWExZWU2NWJhYjVmNjggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2Jvb2xlYW4nID8gdiA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDB4RkZGRkZGIDogcmV0ID8gMSA6IDA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2RlYnVnX3N0cmluZ19kZjQ3ZmZiNWUzNWU2NzYzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBkZWJ1Z1N0cmluZyhnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMSwgbGVuMSwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2luX2JiOTMzYmQ5ZTFiM2JjMGYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSBpbiBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2lzX2JpZ2ludF9jYjMyMDcwN2RjZDM1ZjBiID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2lzX2Z1bmN0aW9uX2VlOGE2YzU4MzNjOTAzNzcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9pc19udWxsXzVlNjlmNzJlOTA2Y2M1N2MgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5faXNfb2JqZWN0X2M4MTgyNjFkMjFmMjgzYTQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5faXNfdW5kZWZpbmVkXzJkNDcyODYyYmQyOWE0NzggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9qc3ZhbF9lcV82YjEzYWI4MzQ3OGIxYzUwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXFfYjY2NGIzOGEyZjU4MjE0NyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fbnVtYmVyX2dldF9hMjBiZjliODUzNDE0NDlkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnbnVtYmVyJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0RmxvYXQ2NChhcmcwICsgOCAqIDEsIGlzTGlrZU5vbmUocmV0KSA/IDAgOiByZXQsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsICFpc0xpa2VOb25lKHJldCksIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9zdHJpbmdfZ2V0X2U0ZjA2YzkwNDg5YWQwMWIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdzdHJpbmcnID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUocmV0KSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMSwgbGVuMSwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX3Rocm93X2I4NTU0NDVmZjZhOTQyOTUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX3diZ19jYl91bnJlZl8yNDU0YTUzOWVhNTc5MGQ5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuX3diZ19jYl91bnJlZigpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWJvcnRfMjhhZDU1YzU4MjViMDA0ZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmFib3J0KGdldE9iamVjdChhcmcxKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hYm9ydF9lN2ViMDU5ZjcyZjllZDBjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuYWJvcnQoKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FjY291bnRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBY2NvdW50Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FjY291bnRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBY2NvdW50Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWNjb3VudGZpbGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBY2NvdW50RmlsZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hY2NvdW50aGVhZGVyX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQWNjb3VudEhlYWRlci5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hY2NvdW50aWRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBY2NvdW50SWQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWNjb3VudGlkX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQWNjb3VudElkLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWRkTm90ZVRhZ185NDhhYjRjYzdkM2Q3ODRiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAoYXJnMiAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdjI7XG4gICAgICAgIGlmIChhcmc0ICE9PSAwKSB7XG4gICAgICAgICAgICB2MiA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmc0LCBhcmc1KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNCwgYXJnNSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGFkZE5vdGVUYWcodjAsIHYxLCB2Mik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hcHBlbmRfYjU3N2ViM2ExNzdiYzBmYSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmFwcGVuZChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMiksIGdldFN0cmluZ0Zyb21XYXNtMChhcmczLCBhcmc0KSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FwcGx5U3RhdGVTeW5jXzY4NzQxNWQxYmNmNGRkOGEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFwcGx5U3RhdGVTeW5jKEpzU3RhdGVTeW5jVXBkYXRlLl9fd3JhcChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hdXRoc2VjcmV0a2V5X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQXV0aFNlY3JldEtleS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ib2R5XzU4NzU0MmIyZmQ4ZTA2YzAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ib2R5O1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2J1ZmZlcl9jY2M0NTIwYjM2ZDNjY2Y0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYnlvYlJlcXVlc3RfMjM0NGU2OTc1ZjI3NDU2ZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ5b2JSZXF1ZXN0O1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2J5dGVMZW5ndGhfYmNkNDJlNDAyNTI5OTc4OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ieXRlT2Zmc2V0X2NhM2E2Y2Y3OTQ0YjM2NGIgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ieXRlT2Zmc2V0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FsbF81MjU0NDBmNzJmYmZjMGVhID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfZTQ1ZDJjZjlmYzkyNWZjZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMiksIGdldE9iamVjdChhcmczKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfZTc2MmMzOWZhOGVhMzZiZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FuY2VsXzQ4YWI2ZjlkYzM2NmUzNjkgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhdGNoXzk0MzgzNmZhYTVkMjliZmIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYXRjaChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xlYXJUaW1lb3V0XzJlMmM0OTM5Mzg4Y2RmYmIgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGNsZWFyVGltZW91dCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Nsb3NlXzVhNmNhZWQzMjMxYjY4Y2QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jbG9zZSgpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jbG9zZV82OTU2ZGY4NDU0Nzg1NjFhID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuY2xvc2UoKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY29uc3VtYWJsZW5vdGVyZWNvcmRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBDb25zdW1hYmxlTm90ZVJlY29yZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19kb25lXzIwNDJhYTI2NzBmYjFkYjEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kb25lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZW5xdWV1ZV83YjE4YTY1MGFlYzc3ODk4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuZW5xdWV1ZShnZXRPYmplY3QoYXJnMSkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19leHBvcnRTdG9yZV8xM2I1Mjc0YjQ1MzY3MjY5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGV4cG9ydFN0b3JlKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mZWx0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRmVsdC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mZWx0X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRmVsdC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZldGNoXzUzZWVmN2RmN2I0MzlhNDkgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGZldGNoKGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZldGNoXzg3MjU4NjVmZjQ3ZTdmY2MgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5mZXRjaChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mZXRjaGVkbm90ZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZldGNoZWROb3RlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZvcmNlSW1wb3J0U3RvcmVfZTRmMTQzN2Q2YjRjZmYwZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZm9yY2VJbXBvcnRTdG9yZSh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZvcmVpZ25hY2NvdW50X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRm9yZWlnbkFjY291bnQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mdW5naWJsZWFzc2V0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRnVuZ2libGVBc3NldC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mdW5naWJsZWFzc2V0X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRnVuZ2libGVBc3NldC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Z1bmdpYmxlYXNzZXRkZWx0YWl0ZW1fbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGdW5naWJsZUFzc2V0RGVsdGFJdGVtLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRBZGRyZXNzZXNfNTdkY2FmMDQ0MDNmZmZmNiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50QWRkcmVzc2VzKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudEF1dGhCeVB1YktleV9hOTkyNjhhMGM1ZTc4MWZjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRBdXRoQnlQdWJLZXkoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50Q29kZV8yNTVjNDc4ODAwMjc2MDRmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRDb2RlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudEhlYWRlckJ5Q29tbWl0bWVudF8yNDU3YjM4MTI3OGFjZDlkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRIZWFkZXJCeUNvbW1pdG1lbnQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50SGVhZGVyXzNlM2MwZmQxNmNlNzgwNDYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudEhlYWRlcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRJZHNfMWRjM2NjOWJlYjAwZGFjNCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50SWRzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50U3RvcmFnZU1hcHNfNTJkMzkwZjU5ZDM5ODcwYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudFN0b3JhZ2VNYXBzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRTdG9yYWdlX2U3ZTMxNGQzYThjNjgxODggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudFN0b3JhZ2UoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50VmF1bHRBc3NldHNfMDU4YWE3YTNlODVmOWQ3ZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50VmF1bHRBc3NldHMoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBbGxBY2NvdW50SGVhZGVyc18yMWFlNThmYmQ3NGJjMjA3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldEFsbEFjY291bnRIZWFkZXJzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRCbG9ja0hlYWRlcnNfZmZiZTYyOTQxOWU0OWYyNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0QmxvY2tIZWFkZXJzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEZvcmVpZ25BY2NvdW50Q29kZV84NGY4MWE5ZmIyNjRiMmE4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRGb3JlaWduQWNjb3VudENvZGUodjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0SW5wdXROb3Rlc0Zyb21JZHNfYTQ4MTRmZjNlZTY4MzhmNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0SW5wdXROb3Rlc0Zyb21JZHModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0SW5wdXROb3Rlc0Zyb21OdWxsaWZpZXJzX2IxMjUxOTI1MjFjYjI3MDcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldElucHV0Tm90ZXNGcm9tTnVsbGlmaWVycyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRJbnB1dE5vdGVzXzllN2RhYWIzZTExYWFkYTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRJbnB1dE5vdGVzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldE5vdGVTY3JpcHRfOGRiNGE4N2YxZGFhNTczMiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXROb3RlU2NyaXB0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0Tm90ZVRhZ3NfNDQ1NjcyZmJkYTc2MTdjYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXROb3RlVGFncygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0T3V0cHV0Tm90ZXNGcm9tSWRzX2E5Zjk1ZWVlNWFlYTExMWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE91dHB1dE5vdGVzRnJvbUlkcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRPdXRwdXROb3Rlc0Zyb21OdWxsaWZpZXJzXzE1NzA4NDE5MjA5ZjAwMTcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE91dHB1dE5vdGVzRnJvbU51bGxpZmllcnModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0T3V0cHV0Tm90ZXNfN2U5MDM0Yjc4NDVkODU0NyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE91dHB1dE5vdGVzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFBhcnRpYWxCbG9ja2NoYWluTm9kZXNBbGxfZjdiOTlkYTRlY2MyY2Y2NyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzQWxsKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzXzRiNTlmM2NmM2Q2Nzg4NWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFBhcnRpYWxCbG9ja2NoYWluTm9kZXModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UGFydGlhbEJsb2NrY2hhaW5QZWFrc0J5QmxvY2tOdW1fYzM2ODM5NTRjZjg3MjYwMSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRQYXJ0aWFsQmxvY2tjaGFpblBlYWtzQnlCbG9ja051bShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJhbmRvbVZhbHVlc18xYzYxZmFjMTE0MDVmZmRjID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFJlYWRlcl80OGUwMDc0OWZlM2Y2MDg5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFNldHRpbmdfMzBkNDg3ZTI2ZWQzZWNmZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRTZXR0aW5nKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0U3luY0hlaWdodF9mN2M0ZmYwMzJkNmU4NzE5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFN5bmNIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRpbWVfMTQ3NzZiZmI0OGExYmZmOSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRyYWNrZWRCbG9ja0hlYWRlcnNfMGU5MjJhZjA1NDEwOTgxYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRUcmFja2VkQmxvY2tIZWFkZXJzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRUcmFuc2FjdGlvbnNfNzUxMTgyMmVkN2RmNGEwNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRUcmFuc2FjdGlvbnMoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRVbnNwZW50SW5wdXROb3RlTnVsbGlmaWVyc19hNTNlZTE4ODdiMzA1MTIyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFVuc3BlbnRJbnB1dE5vdGVOdWxsaWZpZXJzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfN2JlZDAxNmYxODVhZGQ4MSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0X2RvbmVfYTA0NjNhZjQzYTFmYzc2NCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmRvbmU7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAweEZGRkZGRiA6IHJldCA/IDEgOiAwO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0X2VmY2I0NDlmNThlYzI3YzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3QuZ2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0X3ZhbHVlXzVjZTk2YzlmODFjZTczOTggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF93aXRoX3JlZl9rZXlfMWRjMzYxYmQxMDA1M2JmZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApW2dldE9iamVjdChhcmcxKV07XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRwcm9jZWR1cmVzcmVzdWx0aXRlbV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEdldFByb2NlZHVyZXNSZXN1bHRJdGVtLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2hhc183ODdmYWZjOTgwYzNjY2RiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LmhhcyhnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2hlYWRlcnNfYjg3ZDdlYWJhNjFjMzI3OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnB1dG5vdGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBJbnB1dE5vdGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5wdXRub3RlcmVjb3JkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSW5wdXROb3RlUmVjb3JkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc2VydEFjY291bnRBZGRyZXNzXzgxOWE3YWJiNTdkNWM1MGUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gaW5zZXJ0QWNjb3VudEFkZHJlc3MoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zZXJ0QWNjb3VudEF1dGhfODhmZGYxYWU5Y2ZlMDE1NSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSBhcmcyO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSBhcmczO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gaW5zZXJ0QWNjb3VudEF1dGgoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMiwgYXJnMykpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnNlcnRCbG9ja0hlYWRlcl81ZTRjMzlhNjRhYmE5NDVkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNikge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIHZhciB2MiA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnNCwgYXJnNSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzQsIGFyZzUgKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGluc2VydEJsb2NrSGVhZGVyKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEsIHYyLCBhcmc2ICE9PSAwKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnNlcnRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzXzUxMzljYzk3MDJmZjBhOTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGluc2VydFBhcnRpYWxCbG9ja2NoYWluTm9kZXModjAsIHYxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc2VydFNldHRpbmdfMWUyZmEwZGU1MjRmMjc4MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBpbnNlcnRTZXR0aW5nKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc2VydFRyYW5zYWN0aW9uU2NyaXB0XzhlNWI2ZDJiY2M3MGM4MjYgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChhcmcyICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBpbnNlcnRUcmFuc2FjdGlvblNjcmlwdCh2MCwgdjEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl83MGJlYjExODljYTYzYjM4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc3RhbmNlb2ZfUHJvbWlzZV8wMDFmZGQ0MmFmYTFiN2VmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgUHJvbWlzZTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5XzIwYzhlNzMwMDJmN2FmOTggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pc0FycmF5Xzk2ZTBhZjk4OTFkMDk0NWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFycmF5LmlzQXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzU2FmZUludGVnZXJfZDIxNmVkYTc5MTFkZGUzNiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTnVtYmVyLmlzU2FmZUludGVnZXIoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2l0ZXJhdG9yX2U1ODIyNjk1MzI3YTNjMzkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanNhY2NvdW50dXBkYXRlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNBY2NvdW50VXBkYXRlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzYWNjb3VudHVwZGF0ZV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzQWNjb3VudFVwZGF0ZS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzc3RvcmFnZW1hcGVudHJ5X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNTdG9yYWdlTWFwRW50cnkuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanNzdG9yYWdlbWFwZW50cnlfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc1N0b3JhZ2VNYXBFbnRyeS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzc3RvcmFnZXNsb3RfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc1N0b3JhZ2VTbG90Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzc3RvcmFnZXNsb3RfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc1N0b3JhZ2VTbG90Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanN2YXVsdGFzc2V0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNWYXVsdEFzc2V0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2pzdmF1bHRhc3NldF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzVmF1bHRBc3NldC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xlbmd0aF82OWJjYTNjYjY0ZmM4NzQ4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoX2NkZDIxNWUxMGQ5ZGQ1MDcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19saXN0U2V0dGluZ0tleXNfNjk0MGJlMDFjMjdhOGUwOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBsaXN0U2V0dGluZ0tleXMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xvY2tBY2NvdW50XzE3ZTYzMDczMzUzNDNlYWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gbG9ja0FjY291bnQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMF9mOTc0MDY4NmQ3MzkwMjVjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMWFjYzBiNmVlYTg5ZDA0MCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfMjUzMTc3M2RhYzM4ZWJiMyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18zYzNkODQ5MDQ2Njg4YTY2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHN0YXRlMCA9IHthOiBhcmcwLCBiOiBhcmcxfTtcbiAgICAgICAgICAgIHZhciBjYjAgPSAoYXJnMCwgYXJnMSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBzdGF0ZTAuYTtcbiAgICAgICAgICAgICAgICBzdGF0ZTAuYSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV8zNjc3KGEsIHN0YXRlMC5iLCBhcmcwLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTAuYSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKGNiMCk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RhdGUwLmEgPSBzdGF0ZTAuYiA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld181YTc5YmUzYWI1M2I4YWE1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzllZGY5ODM4YTJkZWYzOWMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2E3NDQyYjRiMTljMWEzNTYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2UxN2Q5ZjQzMTA1YjA4YmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfZnJvbV9zbGljZV85MmY0ZDc4Y2EyODJhMmQyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld19ub19hcmdzX2VlOThlZWU1Mjc1MDAwYTQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBGdW5jdGlvbihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X3dpdGhfYnl0ZV9vZmZzZXRfYW5kX2xlbmd0aF80NmUzZTZhNWU5ZjllODliID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCksIGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X3dpdGhfc3RyX2FuZF9pbml0XzBhZTc3MjhiNmVjMzY3YjEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBSZXF1ZXN0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV4dF8wMjA4MTBlMGFlOGViY2IwID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubmV4dCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXh0XzJjODI2ZmU1ZGZlYzZiNmEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5uZXh0O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWFuZGFyZ3NfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlQW5kQXJncy5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVjb25zdW1hYmlsaXR5X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUNvbnN1bWFiaWxpdHkuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWNvbnN1bWFiaWxpdHlfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlQ29uc3VtYWJpbGl0eS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVkZXRhaWxzYW5kdGFnX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZURldGFpbHNBbmRUYWcuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWRldGFpbHNhbmR0YWdfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlRGV0YWlsc0FuZFRhZy5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVmaWxlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUZpbGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWlkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUlkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVpZF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVJZC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVpZGFuZGFyZ3NfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlSWRBbmRBcmdzLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZXJlY2lwaWVudF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVSZWNpcGllbnQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3Rlc2NyaXB0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZVNjcmlwdC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vcGVuRGF0YWJhc2VfZjI0MmNkNzgyZDMwMDkxNiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBvcGVuRGF0YWJhc2UoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX291dHB1dG5vdGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPdXRwdXROb3RlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX291dHB1dG5vdGVfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPdXRwdXROb3RlLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3V0cHV0bm90ZXNfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBPdXRwdXROb3Rlcy5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Byb3RvdHlwZXNldGNhbGxfMmE2NjIwYjY5MjI2OTRiMiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Byb3ZlbnRyYW5zYWN0aW9uX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUHJvdmVuVHJhbnNhY3Rpb24uX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJ1bmVJcnJlbGV2YW50QmxvY2tzX2NlNTE3NGI4NWNiZDgzZmEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gcHJ1bmVJcnJlbGV2YW50QmxvY2tzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19xdWV1ZU1pY3JvdGFza18zNGQ2OTJjMjVjNDdkMDViID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucXVldWVNaWNyb3Rhc2s7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19xdWV1ZU1pY3JvdGFza185ZDc2Y2FjYjIwYzg0ZDU4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhnZXRPYmplY3QoYXJnMCkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVhZF80OGYxNTkzZGY1NDJmOTY4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkucmVhZCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVsZWFzZUxvY2tfNWQwYjVhNjg4ODdiODkxZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJlbGVhc2VMb2NrKCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZW1vdmVBY2NvdW50QWRkcmVzc185NGI0NTFmZDU0NzZiNjcyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gcmVtb3ZlQWNjb3VudEFkZHJlc3ModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVtb3ZlTm90ZVRhZ181NTBiMDM4NTE2N2YyZGNmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgbGV0IHYxO1xuICAgICAgICBpZiAoYXJnMiAhPT0gMCkge1xuICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdjI7XG4gICAgICAgIGlmIChhcmc0ICE9PSAwKSB7XG4gICAgICAgICAgICB2MiA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmc0LCBhcmc1KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNCwgYXJnNSAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlbW92ZU5vdGVUYWcodjAsIHYxLCB2Mik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZW1vdmVTZXR0aW5nXzlmNTljYmZiZTk1ZjQ4NDMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gcmVtb3ZlU2V0dGluZyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Jlc29sdmVfY2FmOTdjMzBiODNmNzA1MyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXNwb25kXzBmNGRiZjUzODZmNWM3M2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yZXNwb25kKGFyZzEgPj4+IDApO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2VyaWFsaXplZElucHV0Tm90ZURhdGEuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRUaW1lb3V0XzkyOWM5N2E3YzBmMjNkMzYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHNldFRpbWVvdXQoZ2V0T2JqZWN0KGFyZzApLCBhcmcxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF84YjM0MmQ4Y2Q5ZDJhMDJjID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzMsIGFyZzQpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzllNjUxNmRmN2I3ZDBmMTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxLCBhcmcyKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYm9keV8zYzM2NTk4OTc1M2Q2MWY0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuYm9keSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9jMjEzYzg3MTg1OWQ2NTAwID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF0gPSB0YWtlT2JqZWN0KGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2MyYWJiZWJlOGI5ZWJlZTEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3Quc2V0KGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfY2FjaGVfMmY5ZGViMTliOTJiODFlMyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNhY2hlID0gX193YmluZGdlbl9lbnVtX1JlcXVlc3RDYWNoZVthcmcxXTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9jcmVkZW50aWFsc19mNjIxY2QyZDg1YzBjMjI4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuY3JlZGVudGlhbHMgPSBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdENyZWRlbnRpYWxzW2FyZzFdO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2hlYWRlcnNfNjkyNmRhMjM4Y2QzMmVlNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmhlYWRlcnMgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfaW50ZWdyaXR5XzYyYTQ2ZmM3OTI4MzJmNDEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5pbnRlZ3JpdHkgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfbWV0aG9kX2MwMmQ4Y2JiZTIwNGFjMmQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5tZXRob2QgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfbW9kZV81MmVmNzNjZmE3OTYzOWNiID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkubW9kZSA9IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0TW9kZVthcmcxXTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9yZWRpcmVjdF9kZjAyODU0OTZlYzQ1ZmY4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmVkaXJlY3QgPSBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdFJlZGlyZWN0W2FyZzFdO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X3JlZmVycmVyX2VjOWNmOGE4YTMxNWQ1MGMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yZWZlcnJlciA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9yZWZlcnJlcl9wb2xpY3lfOTljMWYyOTliNGUzNzQ0NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJlZmVycmVyUG9saWN5ID0gX193YmluZGdlbl9lbnVtX1JlZmVycmVyUG9saWN5W2FyZzFdO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X3NpZ25hbF9kZGEyY2Y3Y2NiNmJlZTBmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuc2lnbmFsID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2lnbmFsXzRkYjVhYTA1NWJmOWViOWEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zaWduYWw7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zbG90YW5ka2V5c191bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNsb3RBbmRLZXlzLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF84OWUxZDlhYzZhMWIyNTBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGdsb2JhbDtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfR0xPQkFMX1RISVNfOGI1MzBmMzI2YTllNDhhYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZ2xvYmFsVGhpcztcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfU0VMRl82ZmRmNGI2NDcxMGNjOTFiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBzZWxmO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9XSU5ET1dfYjQ1YmZjNWEzN2Y2Y2ZhMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdHVzX2RlN2VlZDVhN2E1YmZkNWQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdGF0dXM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdG9yYWdlc2xvdF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN0b3JhZ2VTbG90Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3luY3N1bW1hcnlfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTeW5jU3VtbWFyeS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190aGVuXzRmNDZmNjU0NGU2YjRhMjggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190aGVuXzcwZDA1Y2Y3ODBhMThkNzcgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50aGVuKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RvU3RyaW5nXzdkYTdjOGRiZWM3OGZjYjggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdHJhbnNhY3Rpb25pZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uSWQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdHJhbnNhY3Rpb25pZF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uSWQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbnJlY29yZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uUmVjb3JkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9ucmVzdWx0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gVHJhbnNhY3Rpb25SZXN1bHQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpci5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9uc3RvcmV1cGRhdGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2FjdGlvblN0b3JlVXBkYXRlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3VuZG9BY2NvdW50U3RhdGVzX2ZlOWRhMzgyOTM3MDM2YmQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHVuZG9BY2NvdW50U3RhdGVzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydEFjY291bnRDb2RlX2M5M2U5MTExYjJjNzMyNzQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0QWNjb3VudENvZGUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0QWNjb3VudFJlY29yZF84ODg0M2VlNmE3MWNjOGIzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNywgYXJnOCwgYXJnOSwgYXJnMTAsIGFyZzExLCBhcmcxMiwgYXJnMTMsIGFyZzE0KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICBsZXQgZGVmZXJyZWQ0XzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDRfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkNV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQ1XzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IGFyZzI7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IGFyZzM7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IGFyZzQ7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGFyZzU7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IGFyZzY7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMSA9IGFyZzc7XG4gICAgICAgICAgICBkZWZlcnJlZDRfMCA9IGFyZzg7XG4gICAgICAgICAgICBkZWZlcnJlZDRfMSA9IGFyZzk7XG4gICAgICAgICAgICBkZWZlcnJlZDVfMCA9IGFyZzExO1xuICAgICAgICAgICAgZGVmZXJyZWQ1XzEgPSBhcmcxMjtcbiAgICAgICAgICAgIGxldCB2NjtcbiAgICAgICAgICAgIGlmIChhcmcxMyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHY2ID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxMywgYXJnMTQpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMTMsIGFyZzE0ICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRBY2NvdW50UmVjb3JkKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzIsIGFyZzMpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNCwgYXJnNSksIGdldFN0cmluZ0Zyb21XYXNtMChhcmc2LCBhcmc3KSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzgsIGFyZzkpLCBhcmcxMCAhPT0gMCwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzExLCBhcmcxMiksIHY2KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDNfMCwgZGVmZXJyZWQzXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQ0XzAsIGRlZmVycmVkNF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkNV8wLCBkZWZlcnJlZDVfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydEFjY291bnRTdG9yYWdlXzcxYWVhOTgzZDhlNDUyNTMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHVwc2VydEFjY291bnRTdG9yYWdlKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydEZvcmVpZ25BY2NvdW50Q29kZV9hMmZmZGQwZGViODdjMDYzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IGFyZzQ7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGFyZzU7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRGb3JlaWduQWNjb3VudENvZGUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzQsIGFyZzUpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0SW5wdXROb3RlXzc3MzM3MDJjNDhlMmFlMTcgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3LCBhcmc4LCBhcmc5LCBhcmcxMCwgYXJnMTEsIGFyZzEyLCBhcmcxMywgYXJnMTQsIGFyZzE1LCBhcmcxNiwgYXJnMTcsIGFyZzE4KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQ0XzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDRfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkNl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQ2XzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDdfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkN18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgdmFyIHYyID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmc0LCBhcmc1KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNCwgYXJnNSAqIDEsIDEpO1xuICAgICAgICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmc2LCBhcmc3KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNiwgYXJnNyAqIDEsIDEpO1xuICAgICAgICAgICAgZGVmZXJyZWQ0XzAgPSBhcmc4O1xuICAgICAgICAgICAgZGVmZXJyZWQ0XzEgPSBhcmc5O1xuICAgICAgICAgICAgdmFyIHY1ID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcxMCwgYXJnMTEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcxMCwgYXJnMTEgKiAxLCAxKTtcbiAgICAgICAgICAgIGRlZmVycmVkNl8wID0gYXJnMTI7XG4gICAgICAgICAgICBkZWZlcnJlZDZfMSA9IGFyZzEzO1xuICAgICAgICAgICAgZGVmZXJyZWQ3XzAgPSBhcmcxNDtcbiAgICAgICAgICAgIGRlZmVycmVkN18xID0gYXJnMTU7XG4gICAgICAgICAgICB2YXIgdjggPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzE3LCBhcmcxOCkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzE3LCBhcmcxOCAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0SW5wdXROb3RlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEsIHYyLCB2MywgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzgsIGFyZzkpLCB2NSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEyLCBhcmcxMyksIGdldFN0cmluZ0Zyb21XYXNtMChhcmcxNCwgYXJnMTUpLCBhcmcxNiwgdjgpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDRfMCwgZGVmZXJyZWQ0XzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQ2XzAsIGRlZmVycmVkNl8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkN18wLCBkZWZlcnJlZDdfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydE5vdGVTY3JpcHRfM2M1NjlhNjczZWZmMjFjOSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnROb3RlU2NyaXB0KGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydE91dHB1dE5vdGVfMWE5YzZiODBiYzNiMjk3OSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcsIGFyZzgsIGFyZzksIGFyZzEwLCBhcmcxMSwgYXJnMTIsIGFyZzEzKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gYXJnNDtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gYXJnNTtcbiAgICAgICAgICAgIHZhciB2MyA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnNiwgYXJnNykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzYsIGFyZzcgKiAxLCAxKTtcbiAgICAgICAgICAgIGxldCB2NDtcbiAgICAgICAgICAgIGlmIChhcmc4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnOCwgYXJnOSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc4LCBhcmc5ICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjUgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEyLCBhcmcxMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzEyLCBhcmcxMyAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0T3V0cHV0Tm90ZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNCwgYXJnNSksIHYzLCB2NCwgYXJnMTAgPj4+IDAsIGFyZzExLCB2NSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydFN0b3JhZ2VNYXBFbnRyaWVzXzU3ZGE3MzRjYmVlNDQ4YmYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHVwc2VydFN0b3JhZ2VNYXBFbnRyaWVzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydFRyYW5zYWN0aW9uUmVjb3JkX2U0YThiMDVmMWIzNzE0ZWEgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3LCBhcmc4LCBhcmc5LCBhcmcxMCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IGFyZzQ7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGFyZzU7XG4gICAgICAgICAgICB2YXIgdjMgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzcsIGFyZzgpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc3LCBhcmc4ICogMSwgMSk7XG4gICAgICAgICAgICBsZXQgdjQ7XG4gICAgICAgICAgICBpZiAoYXJnOSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHY0ID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmc5LCBhcmcxMCkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc5LCBhcmcxMCAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0VHJhbnNhY3Rpb25SZWNvcmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzQsIGFyZzUpLCBhcmc2LCB2MywgdjQpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRWYXVsdEFzc2V0c19jZTU0OWVkZTQ0NTdkZjZlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRWYXVsdEFzc2V0cyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192YWx1ZV82OTI2MjczMDk4MTRiYjhjID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmFsdWU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192aWV3X2Y2YzE1YWM5ZmVkNjNiYmQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52aWV3O1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3dvcmRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBXb3JkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3dvcmRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBXb3JkLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzFmZjMwYzg5ZjhjMTNkNGIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKE5hbWVkRXh0ZXJucmVmKFwiVHJhbnNhY3Rpb25SZWNvcmRcIikpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzIyNDFiNmFmNGM0YjI5NDEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgUmVmKFN0cmluZykgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzI1YTBhODQ0NDM3ZDBlOTIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKE5hbWVkRXh0ZXJucmVmKFwic3RyaW5nXCIpKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF8yOThkZmQ5OTk5OGYxYmJmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihOYW1lZEV4dGVybnJlZihcIkNvbnN1bWFibGVOb3RlUmVjb3JkXCIpKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF8zMTg2MTQ0ZjMwMTRhNmU5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihOYW1lZEV4dGVybnJlZihcIkZldGNoZWROb3RlXCIpKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF8zNTZhNjQ5Yzc2ZWEzZDRhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYENsb3N1cmUoQ2xvc3VyZSB7IGR0b3JfaWR4OiA1MTYsIGZ1bmN0aW9uOiBGdW5jdGlvbiB7IGFyZ3VtZW50czogW10sIHNoaW1faWR4OiA1MTcsIHJldDogVW5pdCwgaW5uZXJfcmV0OiBTb21lKFVuaXQpIH0sIG11dGFibGU6IHRydWUgfSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgd2FzbS5fX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTMwOCwgX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzMDkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzQ2MjVjNTc3YWIyZWM5ZWUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVTY0IC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IEJpZ0ludC5hc1VpbnROKDY0LCBhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF82MTE4MGNmMmRhNTU4MGRjID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihOYW1lZEV4dGVybnJlZihcIkFjY291bnRIZWFkZXJcIikpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0Xzc3YmMzZTkyNzQ1ZTlhMzUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihVOCkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfYTBjOWM5Nzk5Mzg1MTY3MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoTmFtZWRFeHRlcm5yZWYoXCJJbnB1dE5vdGVSZWNvcmRcIikpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0X2M4ODczODcxNjYzODI5ZGQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgQ2xvc3VyZShDbG9zdXJlIHsgZHRvcl9pZHg6IDUxNiwgZnVuY3Rpb246IEZ1bmN0aW9uIHsgYXJndW1lbnRzOiBbRXh0ZXJucmVmXSwgc2hpbV9pZHg6IDUyMSwgcmV0OiBVbml0LCBpbm5lcl9yZXQ6IFNvbWUoVW5pdCkgfSwgbXV0YWJsZTogdHJ1ZSB9KSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCB3YXNtLl9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85MzA4LCBfX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTM3NSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfZDZjZDE5YjgxNTYwZmQ2ZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBGNjQgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHRha2VPYmplY3QoYXJnMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbXBvcnRzO1xufVxuXG5mdW5jdGlvbiBfX3diZ19maW5hbGl6ZV9pbml0KGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgICBfX3diZ19pbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gICAgY2FjaGVkQmlnVWludDY0QXJyYXlNZW1vcnkwID0gbnVsbDtcbiAgICBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBudWxsO1xuICAgIGNhY2hlZFVpbnQzMkFycmF5TWVtb3J5MCA9IG51bGw7XG4gICAgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5cblxuICAgIHJldHVybiB3YXNtO1xufVxuXG5mdW5jdGlvbiBpbml0U3luYyhtb2R1bGUpIHtcbiAgICBpZiAod2FzbSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gd2FzbTtcblxuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgKHttb2R1bGV9ID0gbW9kdWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndXNpbmcgZGVwcmVjYXRlZCBwYXJhbWV0ZXJzIGZvciBgaW5pdFN5bmMoKWA7IHBhc3MgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgaWYgKCEobW9kdWxlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSkge1xuICAgICAgICBtb2R1bGUgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG1vZHVsZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBfX3diZ19maW5hbGl6ZV9pbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfX3diZ19pbml0KG1vZHVsZV9vcl9wYXRoKSB7XG4gICAgaWYgKHdhc20gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHdhc207XG5cblxuICAgIGlmICh0eXBlb2YgbW9kdWxlX29yX3BhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX29yX3BhdGgpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAoe21vZHVsZV9vcl9wYXRofSA9IG1vZHVsZV9vcl9wYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndXNpbmcgZGVwcmVjYXRlZCBwYXJhbWV0ZXJzIGZvciB0aGUgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb247IHBhc3MgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgY29uc3QgaW1wb3J0cyA9IF9fd2JnX2dldF9pbXBvcnRzKCk7XG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZV9vcl9wYXRoID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlX29yX3BhdGggaW5zdGFuY2VvZiBSZXF1ZXN0KSB8fCAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGVfb3JfcGF0aCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgbW9kdWxlX29yX3BhdGggPSBmZXRjaChtb2R1bGVfb3JfcGF0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBfX3diZ19sb2FkKGF3YWl0IG1vZHVsZV9vcl9wYXRoLCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBfX3diZ19maW5hbGl6ZV9pbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5jb25zdCBtb2R1bGUgPSBuZXcgVVJMKFwiYXNzZXRzL21pZGVuX2NsaWVudF93ZWIud2FzbVwiLCBpbXBvcnQubWV0YS51cmwpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBfX3diZ19pbml0KHsgbW9kdWxlX29yX3BhdGg6IG1vZHVsZSB9KTtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWNjb3VudEFycmF5LCBBY2NvdW50QnVpbGRlciwgQWNjb3VudEJ1aWxkZXJSZXN1bHQsIEFjY291bnRDb2RlLCBBY2NvdW50Q29tcG9uZW50LCBBY2NvdW50RGVsdGEsIEFjY291bnRGaWxlLCBBY2NvdW50SGVhZGVyLCBBY2NvdW50SWQsIEFjY291bnRJZEFycmF5LCBBY2NvdW50SW50ZXJmYWNlLCBBY2NvdW50U3RvcmFnZSwgQWNjb3VudFN0b3JhZ2VEZWx0YSwgQWNjb3VudFN0b3JhZ2VNb2RlLCBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cywgQWNjb3VudFR5cGUsIEFjY291bnRWYXVsdERlbHRhLCBBZGRyZXNzLCBBZHZpY2VJbnB1dHMsIEFkdmljZU1hcCwgQXNzZXRWYXVsdCwgQXV0aFNlY3JldEtleSwgQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudCwgQmxvY2tIZWFkZXIsIENvbnN1bWFibGVOb3RlUmVjb3JkLCBFbmRwb2ludCwgRXhlY3V0ZWRUcmFuc2FjdGlvbiwgRmVsdCwgRmVsdEFycmF5LCBGZXRjaGVkTm90ZSwgRmxhdHRlbmVkVThWZWMsIEZvcmVpZ25BY2NvdW50LCBGb3JlaWduQWNjb3VudEFycmF5LCBGdW5naWJsZUFzc2V0LCBGdW5naWJsZUFzc2V0RGVsdGEsIEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW0sIEdldFByb2NlZHVyZXNSZXN1bHRJdGVtLCBJbnB1dE5vdGUsIElucHV0Tm90ZVJlY29yZCwgSW5wdXROb3RlU3RhdGUsIElucHV0Tm90ZXMsIEludG9VbmRlcmx5aW5nQnl0ZVNvdXJjZSwgSW50b1VuZGVybHlpbmdTaW5rLCBJbnRvVW5kZXJseWluZ1NvdXJjZSwgSnNBY2NvdW50VXBkYXRlLCBKc1N0YXRlU3luY1VwZGF0ZSwgSnNTdG9yYWdlTWFwRW50cnksIEpzU3RvcmFnZVNsb3QsIEpzVmF1bHRBc3NldCwgTGlicmFyeSwgTWVya2xlUGF0aCwgTmV0d29ya0lkLCBOb3RlLCBOb3RlQW5kQXJncywgTm90ZUFuZEFyZ3NBcnJheSwgTm90ZUFzc2V0cywgTm90ZUNvbnN1bWFiaWxpdHksIE5vdGVEZXRhaWxzLCBOb3RlRGV0YWlsc0FuZFRhZywgTm90ZURldGFpbHNBbmRUYWdBcnJheSwgTm90ZUV4ZWN1dGlvbkhpbnQsIE5vdGVFeGVjdXRpb25Nb2RlLCBOb3RlRmlsZSwgTm90ZUZpbHRlciwgTm90ZUZpbHRlclR5cGVzLCBOb3RlSGVhZGVyLCBOb3RlSWQsIE5vdGVJZEFuZEFyZ3MsIE5vdGVJZEFuZEFyZ3NBcnJheSwgTm90ZUluY2x1c2lvblByb29mLCBOb3RlSW5wdXRzLCBOb3RlTG9jYXRpb24sIE5vdGVNZXRhZGF0YSwgTm90ZVJlY2lwaWVudCwgTm90ZVJlY2lwaWVudEFycmF5LCBOb3RlU2NyaXB0LCBOb3RlVGFnLCBOb3RlVHlwZSwgT3V0cHV0Tm90ZSwgT3V0cHV0Tm90ZUFycmF5LCBPdXRwdXROb3RlcywgT3V0cHV0Tm90ZXNBcnJheSwgUGFja2FnZSwgUGFydGlhbE5vdGUsIFByb3ZlblRyYW5zYWN0aW9uLCBQdWJsaWNLZXksIFJwY0NsaWVudCwgUnBvMjU2LCBTY3JpcHRCdWlsZGVyLCBTZWNyZXRLZXksIFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhLCBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEsIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGEsIFNpZ25hdHVyZSwgU2lnbmluZ0lucHV0cywgU2lnbmluZ0lucHV0c1R5cGUsIFNsb3RBbmRLZXlzLCBTdG9yYWdlTWFwLCBTdG9yYWdlU2xvdCwgU3RvcmFnZVNsb3RBcnJheSwgU3luY1N1bW1hcnksIFRlc3RVdGlscywgVG9rZW5TeW1ib2wsIFRyYW5zYWN0aW9uQXJncywgVHJhbnNhY3Rpb25GaWx0ZXIsIFRyYW5zYWN0aW9uSWQsIFRyYW5zYWN0aW9uUHJvdmVyLCBUcmFuc2FjdGlvblJlY29yZCwgVHJhbnNhY3Rpb25SZXF1ZXN0LCBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLCBUcmFuc2FjdGlvblJlc3VsdCwgVHJhbnNhY3Rpb25TY3JpcHQsIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyLCBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5LCBUcmFuc2FjdGlvblN0YXR1cywgVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZSwgVHJhbnNhY3Rpb25TdW1tYXJ5LCBXZWJDbGllbnQsIFdvcmQsIGluaXRTeW5jIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXJnby1hY2JkOGFjNS1hY2JkOGFjNS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/assets/miden_client_web.wasm":
/*!**************************************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/workers/assets/miden_client_web.wasm ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/miden_client_web.1c58f26d.wasm";

/***/ }),

/***/ "(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/web-client-methods-worker.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/workers/web-client-methods-worker.js ***!
  \**************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n// This is a documented workaround that should avoid issues with Vite projects\n// https://github.com/wasm-tool/rollup-plugin-rust?tab=readme-ov-file#usage-with-vite\n// Also, this effectively disables SSR.\nasync function loadWasm() {\n  let wasmModule;\n  if (true) {\n    wasmModule = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@demox-labs\").then(__webpack_require__.bind(__webpack_require__, /*! ./Cargo-acbd8ac5-acbd8ac5.js */ \"(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js\"));\n  }\n  return wasmModule;\n}\n\nconst WorkerAction = Object.freeze({\n  INIT: \"init\",\n  CALL_METHOD: \"callMethod\",\n});\n\nconst MethodName = Object.freeze({\n  CREATE_CLIENT: \"createClient\",\n  NEW_WALLET: \"newWallet\",\n  NEW_FAUCET: \"newFaucet\",\n  EXECUTE_TRANSACTION: \"executeTransaction\",\n  PROVE_TRANSACTION: \"proveTransaction\",\n  SUBMIT_NEW_TRANSACTION: \"submitNewTransaction\",\n  SUBMIT_NEW_TRANSACTION_MOCK: \"submitNewTransactionMock\",\n  SYNC_STATE: \"syncState\",\n  SYNC_STATE_MOCK: \"syncStateMock\",\n});\n\nconst wasm = await loadWasm();\n\n/**\n * Worker for executing WebClient methods in a separate thread.\n *\n * This worker offloads computationally heavy tasks from the main thread by handling\n * WebClient operations asynchronously. It imports the WASM module and instantiates a\n * WASM WebClient, then listens for messages from the main thread to perform one of two actions:\n *\n * 1. **Initialization (init):**\n *    - The worker receives an \"init\" message along with user parameters (RPC URL and seed).\n *    - It instantiates the WASM WebClient and calls its createClient method.\n *    - Once initialization is complete, the worker sends a `{ ready: true }` message back to signal\n *      that it is fully initialized.\n *\n * 2. **Method Invocation (callMethod):**\n *    - The worker receives a \"callMethod\" message with a specific method name and arguments.\n *    - It uses a mapping (defined in `methodHandlers`) to route the call to the corresponding WASM WebClient method.\n *    - Complex data is serialized before being sent and deserialized upon return.\n *    - The result (or any error) is then posted back to the main thread.\n *\n * The worker uses a message queue to process incoming messages sequentially, ensuring that only one message\n * is handled at a time.\n *\n * Additionally, the worker immediately sends a `{ loaded: true }` message upon script load. This informs the main\n * thread that the worker script is loaded and ready to receive the \"init\" message.\n *\n * Supported actions (defined in `WorkerAction`):\n *   - \"init\"       : Initialize the WASM WebClient with provided parameters.\n *   - \"callMethod\" : Invoke a designated method on the WASM WebClient.\n *\n * Supported method names are defined in the `MethodName` constant.\n */\n\n// Global state variables.\nlet wasmWebClient = null;\nlet wasmSeed = null; // Seed for the WASM WebClient, if needed.\nlet ready = false; // Indicates if the worker is fully initialized.\nlet messageQueue = []; // Queue for sequential processing.\nlet processing = false; // Flag to ensure one message is processed at a time.\n\n// Define a mapping from method names to handler functions.\nconst methodHandlers = {\n  [MethodName.NEW_WALLET]: async (args) => {\n    const [walletStorageModeStr, mutable, authSchemeId, seed] = args;\n    const walletStorageMode =\n      wasm.AccountStorageMode.tryFromStr(walletStorageModeStr);\n    const wallet = await wasmWebClient.newWallet(\n      walletStorageMode,\n      mutable,\n      authSchemeId,\n      seed\n    );\n    const serializedWallet = wallet.serialize();\n    return serializedWallet.buffer;\n  },\n  [MethodName.NEW_FAUCET]: async (args) => {\n    const [\n      faucetStorageModeStr,\n      nonFungible,\n      tokenSymbol,\n      decimals,\n      maxSupplyStr,\n      authSchemeId,\n    ] = args;\n    const faucetStorageMode =\n      wasm.AccountStorageMode.tryFromStr(faucetStorageModeStr);\n    const maxSupply = BigInt(maxSupplyStr);\n    const faucet = await wasmWebClient.newFaucet(\n      faucetStorageMode,\n      nonFungible,\n      tokenSymbol,\n      decimals,\n      maxSupply,\n      authSchemeId\n    );\n    const serializedFaucet = faucet.serialize();\n    return serializedFaucet.buffer;\n  },\n  [MethodName.SYNC_STATE]: async () => {\n    const syncSummary = await wasmWebClient.syncState();\n    const serializedSyncSummary = syncSummary.serialize();\n    return serializedSyncSummary.buffer;\n  },\n  [MethodName.EXECUTE_TRANSACTION]: async (args) => {\n    const [accountIdHex, serializedTransactionRequest] = args;\n    const accountId = wasm.AccountId.fromHex(accountIdHex);\n    const transactionRequestBytes = new Uint8Array(\n      serializedTransactionRequest\n    );\n    const transactionRequest = wasm.TransactionRequest.deserialize(\n      transactionRequestBytes\n    );\n    const result = await wasmWebClient.executeTransaction(\n      accountId,\n      transactionRequest\n    );\n    const serializedResult = result.serialize();\n    return serializedResult.buffer;\n  },\n  [MethodName.PROVE_TRANSACTION]: async (args) => {\n    const [serializedTransactionResult, proverPayload] = args;\n    const transactionResultBytes = new Uint8Array(serializedTransactionResult);\n    const transactionResult = wasm.TransactionResult.deserialize(\n      transactionResultBytes\n    );\n\n    let prover;\n    if (proverPayload) {\n      if (proverPayload === \"local\") {\n        prover = wasm.TransactionProver.newLocalProver();\n      } else if (proverPayload.startsWith(\"remote:\")) {\n        const endpoint = proverPayload.slice(\"remote:\".length);\n        if (!endpoint) {\n          throw new Error(\"Remote prover requires an endpoint\");\n        }\n        prover = wasm.TransactionProver.newRemoteProver(endpoint);\n      } else {\n        throw new Error(\"Invalid prover tag received in worker\");\n      }\n    }\n\n    const proven = await wasmWebClient.proveTransaction(\n      transactionResult,\n      prover\n    );\n    const serializedProven = proven.serialize();\n    return serializedProven.buffer;\n  },\n  [MethodName.SUBMIT_NEW_TRANSACTION]: async (args) => {\n    const [accountIdHex, serializedTransactionRequest] = args;\n    const accountId = wasm.AccountId.fromHex(accountIdHex);\n    const transactionRequestBytes = new Uint8Array(\n      serializedTransactionRequest\n    );\n    const transactionRequest = wasm.TransactionRequest.deserialize(\n      transactionRequestBytes\n    );\n\n    const result = await wasmWebClient.executeTransaction(\n      accountId,\n      transactionRequest\n    );\n\n    const transactionId = result.id().toHex();\n\n    const proven = await wasmWebClient.proveTransaction(result);\n    const submissionHeight = await wasmWebClient.submitProvenTransaction(\n      proven,\n      result\n    );\n    const transactionUpdate = await wasmWebClient.applyTransaction(\n      result,\n      submissionHeight\n    );\n\n    return {\n      transactionId,\n      submissionHeight,\n      serializedTransactionResult: result.serialize().buffer,\n      serializedTransactionUpdate: transactionUpdate.serialize().buffer,\n    };\n  },\n};\n\n// Add mock methods to the handler mapping.\nmethodHandlers[MethodName.SYNC_STATE_MOCK] = async (args) => {\n  let [serializedMockChain, serializedMockNoteTransportNode] = args;\n  serializedMockChain = new Uint8Array(serializedMockChain);\n  serializedMockNoteTransportNode = serializedMockNoteTransportNode\n    ? new Uint8Array(serializedMockNoteTransportNode)\n    : null;\n  await wasmWebClient.createMockClient(\n    wasmSeed,\n    serializedMockChain,\n    serializedMockNoteTransportNode\n  );\n\n  return await methodHandlers[MethodName.SYNC_STATE]();\n};\n\nmethodHandlers[MethodName.SUBMIT_NEW_TRANSACTION_MOCK] = async (args) => {\n  let serializedMockNoteTransportNode = args.pop();\n  let serializedMockChain = args.pop();\n  serializedMockChain = new Uint8Array(serializedMockChain);\n  serializedMockNoteTransportNode = serializedMockNoteTransportNode\n    ? new Uint8Array(serializedMockNoteTransportNode)\n    : null;\n\n  wasmWebClient = new wasm.WebClient();\n  await wasmWebClient.createMockClient(\n    wasmSeed,\n    serializedMockChain,\n    serializedMockNoteTransportNode\n  );\n\n  const result = await methodHandlers[MethodName.SUBMIT_NEW_TRANSACTION](args);\n\n  return {\n    transactionId: result.transactionId,\n    submissionHeight: result.submissionHeight,\n    serializedTransactionResult: result.serializedTransactionResult,\n    serializedTransactionUpdate: result.serializedTransactionUpdate,\n    serializedMockChain: wasmWebClient.serializeMockChain().buffer,\n    serializedMockNoteTransportNode:\n      wasmWebClient.serializeMockNoteTransportNode().buffer,\n  };\n};\n\n/**\n * Process a single message event.\n */\nasync function processMessage(event) {\n  const { action, args, methodName, requestId } = event.data;\n  try {\n    if (action === WorkerAction.INIT) {\n      const [rpcUrl, noteTransportUrl, seed] = args;\n      // Initialize the WASM WebClient.\n      wasmWebClient = new wasm.WebClient();\n      await wasmWebClient.createClient(rpcUrl, noteTransportUrl, seed);\n\n      wasmSeed = seed;\n      ready = true;\n      // Signal that the worker is fully initialized.\n      self.postMessage({ ready: true });\n      return;\n    } else if (action === WorkerAction.CALL_METHOD) {\n      if (!ready) {\n        throw new Error(\"Worker is not ready. Please initialize first.\");\n      }\n      if (!wasmWebClient) {\n        throw new Error(\"WebClient not initialized in worker.\");\n      }\n      // Look up the handler from the mapping.\n      const handler = methodHandlers[methodName];\n      if (!handler) {\n        throw new Error(`Unsupported method: ${methodName}`);\n      }\n      const result = await handler(args);\n      self.postMessage({ requestId, result });\n      return;\n    } else {\n      throw new Error(`Unsupported action: ${action}`);\n    }\n  } catch (error) {\n    console.error(`WORKER: Error occurred - ${error}`);\n    self.postMessage({ requestId, error: error });\n  }\n}\n\n/**\n * Process messages one at a time from the messageQueue.\n */\nasync function processQueue() {\n  if (processing || messageQueue.length === 0) return;\n  processing = true;\n  const event = messageQueue.shift();\n  try {\n    await processMessage(event);\n  } finally {\n    processing = false;\n    processQueue(); // Process next message in queue.\n  }\n}\n\n// Enqueue incoming messages and process them sequentially.\nself.onmessage = (event) => {\n  messageQueue.push(event);\n  processQueue();\n};\n\n// Immediately signal that the worker script has loaded.\n// This tells the main thread that the file is fully loaded before sending the \"init\" message.\nself.postMessage({ loaded: true });\n//# sourceMappingURL=web-client-methods-worker.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRlbW94LWxhYnMvbWlkZW4tc2RrL2Rpc3Qvd29ya2Vycy93ZWItY2xpZW50LW1ldGhvZHMtd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBNkQ7QUFDbkUsdUJBQXVCLGdQQUFzQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBLE1BQU07QUFDTiw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBLElBQUk7QUFDSiw4Q0FBOEMsTUFBTTtBQUNwRCx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcY3JhYmRhby1hZ2VudFxcbWlkZW4td2ViLXR1dG9yaWFsc1xcbm9kZV9tb2R1bGVzXFxAZGVtb3gtbGFic1xcbWlkZW4tc2RrXFxkaXN0XFx3b3JrZXJzXFx3ZWItY2xpZW50LW1ldGhvZHMtd29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgaXMgYSBkb2N1bWVudGVkIHdvcmthcm91bmQgdGhhdCBzaG91bGQgYXZvaWQgaXNzdWVzIHdpdGggVml0ZSBwcm9qZWN0c1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dhc20tdG9vbC9yb2xsdXAtcGx1Z2luLXJ1c3Q/dGFiPXJlYWRtZS1vdi1maWxlI3VzYWdlLXdpdGgtdml0ZVxuLy8gQWxzbywgdGhpcyBlZmZlY3RpdmVseSBkaXNhYmxlcyBTU1IuXG5hc3luYyBmdW5jdGlvbiBsb2FkV2FzbSgpIHtcbiAgbGV0IHdhc21Nb2R1bGU7XG4gIGlmICghaW1wb3J0Lm1ldGEuZW52IHx8IChpbXBvcnQubWV0YS5lbnYgJiYgIWltcG9ydC5tZXRhLmVudi5TU1IpKSB7XG4gICAgd2FzbU1vZHVsZSA9IGF3YWl0IGltcG9ydCgnLi9DYXJnby1hY2JkOGFjNS1hY2JkOGFjNS5qcycpO1xuICB9XG4gIHJldHVybiB3YXNtTW9kdWxlO1xufVxuXG5jb25zdCBXb3JrZXJBY3Rpb24gPSBPYmplY3QuZnJlZXplKHtcbiAgSU5JVDogXCJpbml0XCIsXG4gIENBTExfTUVUSE9EOiBcImNhbGxNZXRob2RcIixcbn0pO1xuXG5jb25zdCBNZXRob2ROYW1lID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENSRUFURV9DTElFTlQ6IFwiY3JlYXRlQ2xpZW50XCIsXG4gIE5FV19XQUxMRVQ6IFwibmV3V2FsbGV0XCIsXG4gIE5FV19GQVVDRVQ6IFwibmV3RmF1Y2V0XCIsXG4gIEVYRUNVVEVfVFJBTlNBQ1RJT046IFwiZXhlY3V0ZVRyYW5zYWN0aW9uXCIsXG4gIFBST1ZFX1RSQU5TQUNUSU9OOiBcInByb3ZlVHJhbnNhY3Rpb25cIixcbiAgU1VCTUlUX05FV19UUkFOU0FDVElPTjogXCJzdWJtaXROZXdUcmFuc2FjdGlvblwiLFxuICBTVUJNSVRfTkVXX1RSQU5TQUNUSU9OX01PQ0s6IFwic3VibWl0TmV3VHJhbnNhY3Rpb25Nb2NrXCIsXG4gIFNZTkNfU1RBVEU6IFwic3luY1N0YXRlXCIsXG4gIFNZTkNfU1RBVEVfTU9DSzogXCJzeW5jU3RhdGVNb2NrXCIsXG59KTtcblxuY29uc3Qgd2FzbSA9IGF3YWl0IGxvYWRXYXNtKCk7XG5cbi8qKlxuICogV29ya2VyIGZvciBleGVjdXRpbmcgV2ViQ2xpZW50IG1ldGhvZHMgaW4gYSBzZXBhcmF0ZSB0aHJlYWQuXG4gKlxuICogVGhpcyB3b3JrZXIgb2ZmbG9hZHMgY29tcHV0YXRpb25hbGx5IGhlYXZ5IHRhc2tzIGZyb20gdGhlIG1haW4gdGhyZWFkIGJ5IGhhbmRsaW5nXG4gKiBXZWJDbGllbnQgb3BlcmF0aW9ucyBhc3luY2hyb25vdXNseS4gSXQgaW1wb3J0cyB0aGUgV0FTTSBtb2R1bGUgYW5kIGluc3RhbnRpYXRlcyBhXG4gKiBXQVNNIFdlYkNsaWVudCwgdGhlbiBsaXN0ZW5zIGZvciBtZXNzYWdlcyBmcm9tIHRoZSBtYWluIHRocmVhZCB0byBwZXJmb3JtIG9uZSBvZiB0d28gYWN0aW9uczpcbiAqXG4gKiAxLiAqKkluaXRpYWxpemF0aW9uIChpbml0KToqKlxuICogICAgLSBUaGUgd29ya2VyIHJlY2VpdmVzIGFuIFwiaW5pdFwiIG1lc3NhZ2UgYWxvbmcgd2l0aCB1c2VyIHBhcmFtZXRlcnMgKFJQQyBVUkwgYW5kIHNlZWQpLlxuICogICAgLSBJdCBpbnN0YW50aWF0ZXMgdGhlIFdBU00gV2ViQ2xpZW50IGFuZCBjYWxscyBpdHMgY3JlYXRlQ2xpZW50IG1ldGhvZC5cbiAqICAgIC0gT25jZSBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZSwgdGhlIHdvcmtlciBzZW5kcyBhIGB7IHJlYWR5OiB0cnVlIH1gIG1lc3NhZ2UgYmFjayB0byBzaWduYWxcbiAqICAgICAgdGhhdCBpdCBpcyBmdWxseSBpbml0aWFsaXplZC5cbiAqXG4gKiAyLiAqKk1ldGhvZCBJbnZvY2F0aW9uIChjYWxsTWV0aG9kKToqKlxuICogICAgLSBUaGUgd29ya2VyIHJlY2VpdmVzIGEgXCJjYWxsTWV0aG9kXCIgbWVzc2FnZSB3aXRoIGEgc3BlY2lmaWMgbWV0aG9kIG5hbWUgYW5kIGFyZ3VtZW50cy5cbiAqICAgIC0gSXQgdXNlcyBhIG1hcHBpbmcgKGRlZmluZWQgaW4gYG1ldGhvZEhhbmRsZXJzYCkgdG8gcm91dGUgdGhlIGNhbGwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgV0FTTSBXZWJDbGllbnQgbWV0aG9kLlxuICogICAgLSBDb21wbGV4IGRhdGEgaXMgc2VyaWFsaXplZCBiZWZvcmUgYmVpbmcgc2VudCBhbmQgZGVzZXJpYWxpemVkIHVwb24gcmV0dXJuLlxuICogICAgLSBUaGUgcmVzdWx0IChvciBhbnkgZXJyb3IpIGlzIHRoZW4gcG9zdGVkIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqIFRoZSB3b3JrZXIgdXNlcyBhIG1lc3NhZ2UgcXVldWUgdG8gcHJvY2VzcyBpbmNvbWluZyBtZXNzYWdlcyBzZXF1ZW50aWFsbHksIGVuc3VyaW5nIHRoYXQgb25seSBvbmUgbWVzc2FnZVxuICogaXMgaGFuZGxlZCBhdCBhIHRpbWUuXG4gKlxuICogQWRkaXRpb25hbGx5LCB0aGUgd29ya2VyIGltbWVkaWF0ZWx5IHNlbmRzIGEgYHsgbG9hZGVkOiB0cnVlIH1gIG1lc3NhZ2UgdXBvbiBzY3JpcHQgbG9hZC4gVGhpcyBpbmZvcm1zIHRoZSBtYWluXG4gKiB0aHJlYWQgdGhhdCB0aGUgd29ya2VyIHNjcmlwdCBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHJlY2VpdmUgdGhlIFwiaW5pdFwiIG1lc3NhZ2UuXG4gKlxuICogU3VwcG9ydGVkIGFjdGlvbnMgKGRlZmluZWQgaW4gYFdvcmtlckFjdGlvbmApOlxuICogICAtIFwiaW5pdFwiICAgICAgIDogSW5pdGlhbGl6ZSB0aGUgV0FTTSBXZWJDbGllbnQgd2l0aCBwcm92aWRlZCBwYXJhbWV0ZXJzLlxuICogICAtIFwiY2FsbE1ldGhvZFwiIDogSW52b2tlIGEgZGVzaWduYXRlZCBtZXRob2Qgb24gdGhlIFdBU00gV2ViQ2xpZW50LlxuICpcbiAqIFN1cHBvcnRlZCBtZXRob2QgbmFtZXMgYXJlIGRlZmluZWQgaW4gdGhlIGBNZXRob2ROYW1lYCBjb25zdGFudC5cbiAqL1xuXG4vLyBHbG9iYWwgc3RhdGUgdmFyaWFibGVzLlxubGV0IHdhc21XZWJDbGllbnQgPSBudWxsO1xubGV0IHdhc21TZWVkID0gbnVsbDsgLy8gU2VlZCBmb3IgdGhlIFdBU00gV2ViQ2xpZW50LCBpZiBuZWVkZWQuXG5sZXQgcmVhZHkgPSBmYWxzZTsgLy8gSW5kaWNhdGVzIGlmIHRoZSB3b3JrZXIgaXMgZnVsbHkgaW5pdGlhbGl6ZWQuXG5sZXQgbWVzc2FnZVF1ZXVlID0gW107IC8vIFF1ZXVlIGZvciBzZXF1ZW50aWFsIHByb2Nlc3NpbmcuXG5sZXQgcHJvY2Vzc2luZyA9IGZhbHNlOyAvLyBGbGFnIHRvIGVuc3VyZSBvbmUgbWVzc2FnZSBpcyBwcm9jZXNzZWQgYXQgYSB0aW1lLlxuXG4vLyBEZWZpbmUgYSBtYXBwaW5nIGZyb20gbWV0aG9kIG5hbWVzIHRvIGhhbmRsZXIgZnVuY3Rpb25zLlxuY29uc3QgbWV0aG9kSGFuZGxlcnMgPSB7XG4gIFtNZXRob2ROYW1lLk5FV19XQUxMRVRdOiBhc3luYyAoYXJncykgPT4ge1xuICAgIGNvbnN0IFt3YWxsZXRTdG9yYWdlTW9kZVN0ciwgbXV0YWJsZSwgYXV0aFNjaGVtZUlkLCBzZWVkXSA9IGFyZ3M7XG4gICAgY29uc3Qgd2FsbGV0U3RvcmFnZU1vZGUgPVxuICAgICAgd2FzbS5BY2NvdW50U3RvcmFnZU1vZGUudHJ5RnJvbVN0cih3YWxsZXRTdG9yYWdlTW9kZVN0cik7XG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgd2FzbVdlYkNsaWVudC5uZXdXYWxsZXQoXG4gICAgICB3YWxsZXRTdG9yYWdlTW9kZSxcbiAgICAgIG11dGFibGUsXG4gICAgICBhdXRoU2NoZW1lSWQsXG4gICAgICBzZWVkXG4gICAgKTtcbiAgICBjb25zdCBzZXJpYWxpemVkV2FsbGV0ID0gd2FsbGV0LnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBzZXJpYWxpemVkV2FsbGV0LmJ1ZmZlcjtcbiAgfSxcbiAgW01ldGhvZE5hbWUuTkVXX0ZBVUNFVF06IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgY29uc3QgW1xuICAgICAgZmF1Y2V0U3RvcmFnZU1vZGVTdHIsXG4gICAgICBub25GdW5naWJsZSxcbiAgICAgIHRva2VuU3ltYm9sLFxuICAgICAgZGVjaW1hbHMsXG4gICAgICBtYXhTdXBwbHlTdHIsXG4gICAgICBhdXRoU2NoZW1lSWQsXG4gICAgXSA9IGFyZ3M7XG4gICAgY29uc3QgZmF1Y2V0U3RvcmFnZU1vZGUgPVxuICAgICAgd2FzbS5BY2NvdW50U3RvcmFnZU1vZGUudHJ5RnJvbVN0cihmYXVjZXRTdG9yYWdlTW9kZVN0cik7XG4gICAgY29uc3QgbWF4U3VwcGx5ID0gQmlnSW50KG1heFN1cHBseVN0cik7XG4gICAgY29uc3QgZmF1Y2V0ID0gYXdhaXQgd2FzbVdlYkNsaWVudC5uZXdGYXVjZXQoXG4gICAgICBmYXVjZXRTdG9yYWdlTW9kZSxcbiAgICAgIG5vbkZ1bmdpYmxlLFxuICAgICAgdG9rZW5TeW1ib2wsXG4gICAgICBkZWNpbWFscyxcbiAgICAgIG1heFN1cHBseSxcbiAgICAgIGF1dGhTY2hlbWVJZFxuICAgICk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEZhdWNldCA9IGZhdWNldC5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZEZhdWNldC5idWZmZXI7XG4gIH0sXG4gIFtNZXRob2ROYW1lLlNZTkNfU1RBVEVdOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3luY1N1bW1hcnkgPSBhd2FpdCB3YXNtV2ViQ2xpZW50LnN5bmNTdGF0ZSgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTeW5jU3VtbWFyeSA9IHN5bmNTdW1tYXJ5LnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBzZXJpYWxpemVkU3luY1N1bW1hcnkuYnVmZmVyO1xuICB9LFxuICBbTWV0aG9kTmFtZS5FWEVDVVRFX1RSQU5TQUNUSU9OXTogYXN5bmMgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBbYWNjb3VudElkSGV4LCBzZXJpYWxpemVkVHJhbnNhY3Rpb25SZXF1ZXN0XSA9IGFyZ3M7XG4gICAgY29uc3QgYWNjb3VudElkID0gd2FzbS5BY2NvdW50SWQuZnJvbUhleChhY2NvdW50SWRIZXgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb25SZXF1ZXN0XG4gICAgKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB3YXNtLlRyYW5zYWN0aW9uUmVxdWVzdC5kZXNlcmlhbGl6ZShcbiAgICAgIHRyYW5zYWN0aW9uUmVxdWVzdEJ5dGVzXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3YXNtV2ViQ2xpZW50LmV4ZWN1dGVUcmFuc2FjdGlvbihcbiAgICAgIGFjY291bnRJZCxcbiAgICAgIHRyYW5zYWN0aW9uUmVxdWVzdFxuICAgICk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlc3VsdCA9IHJlc3VsdC5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZFJlc3VsdC5idWZmZXI7XG4gIH0sXG4gIFtNZXRob2ROYW1lLlBST1ZFX1RSQU5TQUNUSU9OXTogYXN5bmMgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBbc2VyaWFsaXplZFRyYW5zYWN0aW9uUmVzdWx0LCBwcm92ZXJQYXlsb2FkXSA9IGFyZ3M7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZXN1bHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlc3VsdCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZXN1bHQgPSB3YXNtLlRyYW5zYWN0aW9uUmVzdWx0LmRlc2VyaWFsaXplKFxuICAgICAgdHJhbnNhY3Rpb25SZXN1bHRCeXRlc1xuICAgICk7XG5cbiAgICBsZXQgcHJvdmVyO1xuICAgIGlmIChwcm92ZXJQYXlsb2FkKSB7XG4gICAgICBpZiAocHJvdmVyUGF5bG9hZCA9PT0gXCJsb2NhbFwiKSB7XG4gICAgICAgIHByb3ZlciA9IHdhc20uVHJhbnNhY3Rpb25Qcm92ZXIubmV3TG9jYWxQcm92ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvdmVyUGF5bG9hZC5zdGFydHNXaXRoKFwicmVtb3RlOlwiKSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHByb3ZlclBheWxvYWQuc2xpY2UoXCJyZW1vdGU6XCIubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSBwcm92ZXIgcmVxdWlyZXMgYW4gZW5kcG9pbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmVyID0gd2FzbS5UcmFuc2FjdGlvblByb3Zlci5uZXdSZW1vdGVQcm92ZXIoZW5kcG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm92ZXIgdGFnIHJlY2VpdmVkIGluIHdvcmtlclwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm92ZW4gPSBhd2FpdCB3YXNtV2ViQ2xpZW50LnByb3ZlVHJhbnNhY3Rpb24oXG4gICAgICB0cmFuc2FjdGlvblJlc3VsdCxcbiAgICAgIHByb3ZlclxuICAgICk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFByb3ZlbiA9IHByb3Zlbi5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZFByb3Zlbi5idWZmZXI7XG4gIH0sXG4gIFtNZXRob2ROYW1lLlNVQk1JVF9ORVdfVFJBTlNBQ1RJT05dOiBhc3luYyAoYXJncykgPT4ge1xuICAgIGNvbnN0IFthY2NvdW50SWRIZXgsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlcXVlc3RdID0gYXJncztcbiAgICBjb25zdCBhY2NvdW50SWQgPSB3YXNtLkFjY291bnRJZC5mcm9tSGV4KGFjY291bnRJZEhleCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZXF1ZXN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheShcbiAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlcXVlc3RcbiAgICApO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdCA9IHdhc20uVHJhbnNhY3Rpb25SZXF1ZXN0LmRlc2VyaWFsaXplKFxuICAgICAgdHJhbnNhY3Rpb25SZXF1ZXN0Qnl0ZXNcbiAgICApO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2FzbVdlYkNsaWVudC5leGVjdXRlVHJhbnNhY3Rpb24oXG4gICAgICBhY2NvdW50SWQsXG4gICAgICB0cmFuc2FjdGlvblJlcXVlc3RcbiAgICApO1xuXG4gICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHJlc3VsdC5pZCgpLnRvSGV4KCk7XG5cbiAgICBjb25zdCBwcm92ZW4gPSBhd2FpdCB3YXNtV2ViQ2xpZW50LnByb3ZlVHJhbnNhY3Rpb24ocmVzdWx0KTtcbiAgICBjb25zdCBzdWJtaXNzaW9uSGVpZ2h0ID0gYXdhaXQgd2FzbVdlYkNsaWVudC5zdWJtaXRQcm92ZW5UcmFuc2FjdGlvbihcbiAgICAgIHByb3ZlbixcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25VcGRhdGUgPSBhd2FpdCB3YXNtV2ViQ2xpZW50LmFwcGx5VHJhbnNhY3Rpb24oXG4gICAgICByZXN1bHQsXG4gICAgICBzdWJtaXNzaW9uSGVpZ2h0XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbklkLFxuICAgICAgc3VibWlzc2lvbkhlaWdodCxcbiAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblJlc3VsdDogcmVzdWx0LnNlcmlhbGl6ZSgpLmJ1ZmZlcixcbiAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvblVwZGF0ZTogdHJhbnNhY3Rpb25VcGRhdGUuc2VyaWFsaXplKCkuYnVmZmVyLFxuICAgIH07XG4gIH0sXG59O1xuXG4vLyBBZGQgbW9jayBtZXRob2RzIHRvIHRoZSBoYW5kbGVyIG1hcHBpbmcuXG5tZXRob2RIYW5kbGVyc1tNZXRob2ROYW1lLlNZTkNfU1RBVEVfTU9DS10gPSBhc3luYyAoYXJncykgPT4ge1xuICBsZXQgW3NlcmlhbGl6ZWRNb2NrQ2hhaW4sIHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGVdID0gYXJncztcbiAgc2VyaWFsaXplZE1vY2tDaGFpbiA9IG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRNb2NrQ2hhaW4pO1xuICBzZXJpYWxpemVkTW9ja05vdGVUcmFuc3BvcnROb2RlID0gc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZVxuICAgID8gbmV3IFVpbnQ4QXJyYXkoc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZSlcbiAgICA6IG51bGw7XG4gIGF3YWl0IHdhc21XZWJDbGllbnQuY3JlYXRlTW9ja0NsaWVudChcbiAgICB3YXNtU2VlZCxcbiAgICBzZXJpYWxpemVkTW9ja0NoYWluLFxuICAgIHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGVcbiAgKTtcblxuICByZXR1cm4gYXdhaXQgbWV0aG9kSGFuZGxlcnNbTWV0aG9kTmFtZS5TWU5DX1NUQVRFXSgpO1xufTtcblxubWV0aG9kSGFuZGxlcnNbTWV0aG9kTmFtZS5TVUJNSVRfTkVXX1RSQU5TQUNUSU9OX01PQ0tdID0gYXN5bmMgKGFyZ3MpID0+IHtcbiAgbGV0IHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGUgPSBhcmdzLnBvcCgpO1xuICBsZXQgc2VyaWFsaXplZE1vY2tDaGFpbiA9IGFyZ3MucG9wKCk7XG4gIHNlcmlhbGl6ZWRNb2NrQ2hhaW4gPSBuZXcgVWludDhBcnJheShzZXJpYWxpemVkTW9ja0NoYWluKTtcbiAgc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZSA9IHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGVcbiAgICA/IG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGUpXG4gICAgOiBudWxsO1xuXG4gIHdhc21XZWJDbGllbnQgPSBuZXcgd2FzbS5XZWJDbGllbnQoKTtcbiAgYXdhaXQgd2FzbVdlYkNsaWVudC5jcmVhdGVNb2NrQ2xpZW50KFxuICAgIHdhc21TZWVkLFxuICAgIHNlcmlhbGl6ZWRNb2NrQ2hhaW4sXG4gICAgc2VyaWFsaXplZE1vY2tOb3RlVHJhbnNwb3J0Tm9kZVxuICApO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1ldGhvZEhhbmRsZXJzW01ldGhvZE5hbWUuU1VCTUlUX05FV19UUkFOU0FDVElPTl0oYXJncyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0cmFuc2FjdGlvbklkOiByZXN1bHQudHJhbnNhY3Rpb25JZCxcbiAgICBzdWJtaXNzaW9uSGVpZ2h0OiByZXN1bHQuc3VibWlzc2lvbkhlaWdodCxcbiAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb25SZXN1bHQ6IHJlc3VsdC5zZXJpYWxpemVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uVXBkYXRlOiByZXN1bHQuc2VyaWFsaXplZFRyYW5zYWN0aW9uVXBkYXRlLFxuICAgIHNlcmlhbGl6ZWRNb2NrQ2hhaW46IHdhc21XZWJDbGllbnQuc2VyaWFsaXplTW9ja0NoYWluKCkuYnVmZmVyLFxuICAgIHNlcmlhbGl6ZWRNb2NrTm90ZVRyYW5zcG9ydE5vZGU6XG4gICAgICB3YXNtV2ViQ2xpZW50LnNlcmlhbGl6ZU1vY2tOb3RlVHJhbnNwb3J0Tm9kZSgpLmJ1ZmZlcixcbiAgfTtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIHNpbmdsZSBtZXNzYWdlIGV2ZW50LlxuICovXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShldmVudCkge1xuICBjb25zdCB7IGFjdGlvbiwgYXJncywgbWV0aG9kTmFtZSwgcmVxdWVzdElkIH0gPSBldmVudC5kYXRhO1xuICB0cnkge1xuICAgIGlmIChhY3Rpb24gPT09IFdvcmtlckFjdGlvbi5JTklUKSB7XG4gICAgICBjb25zdCBbcnBjVXJsLCBub3RlVHJhbnNwb3J0VXJsLCBzZWVkXSA9IGFyZ3M7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBXQVNNIFdlYkNsaWVudC5cbiAgICAgIHdhc21XZWJDbGllbnQgPSBuZXcgd2FzbS5XZWJDbGllbnQoKTtcbiAgICAgIGF3YWl0IHdhc21XZWJDbGllbnQuY3JlYXRlQ2xpZW50KHJwY1VybCwgbm90ZVRyYW5zcG9ydFVybCwgc2VlZCk7XG5cbiAgICAgIHdhc21TZWVkID0gc2VlZDtcbiAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgIC8vIFNpZ25hbCB0aGF0IHRoZSB3b3JrZXIgaXMgZnVsbHkgaW5pdGlhbGl6ZWQuXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgcmVhZHk6IHRydWUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFdvcmtlckFjdGlvbi5DQUxMX01FVEhPRCkge1xuICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgaXMgbm90IHJlYWR5LiBQbGVhc2UgaW5pdGlhbGl6ZSBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIXdhc21XZWJDbGllbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViQ2xpZW50IG5vdCBpbml0aWFsaXplZCBpbiB3b3JrZXIuXCIpO1xuICAgICAgfVxuICAgICAgLy8gTG9vayB1cCB0aGUgaGFuZGxlciBmcm9tIHRoZSBtYXBwaW5nLlxuICAgICAgY29uc3QgaGFuZGxlciA9IG1ldGhvZEhhbmRsZXJzW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWV0aG9kOiAke21ldGhvZE5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGFyZ3MpO1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHJlcXVlc3RJZCwgcmVzdWx0IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGlvbjogJHthY3Rpb259YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFdPUktFUjogRXJyb3Igb2NjdXJyZWQgLSAke2Vycm9yfWApO1xuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyByZXF1ZXN0SWQsIGVycm9yOiBlcnJvciB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2Nlc3MgbWVzc2FnZXMgb25lIGF0IGEgdGltZSBmcm9tIHRoZSBtZXNzYWdlUXVldWUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgaWYgKHByb2Nlc3NpbmcgfHwgbWVzc2FnZVF1ZXVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBwcm9jZXNzaW5nID0gdHJ1ZTtcbiAgY29uc3QgZXZlbnQgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9jZXNzTWVzc2FnZShldmVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgcHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHByb2Nlc3NRdWV1ZSgpOyAvLyBQcm9jZXNzIG5leHQgbWVzc2FnZSBpbiBxdWV1ZS5cbiAgfVxufVxuXG4vLyBFbnF1ZXVlIGluY29taW5nIG1lc3NhZ2VzIGFuZCBwcm9jZXNzIHRoZW0gc2VxdWVudGlhbGx5Llxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgbWVzc2FnZVF1ZXVlLnB1c2goZXZlbnQpO1xuICBwcm9jZXNzUXVldWUoKTtcbn07XG5cbi8vIEltbWVkaWF0ZWx5IHNpZ25hbCB0aGF0IHRoZSB3b3JrZXIgc2NyaXB0IGhhcyBsb2FkZWQuXG4vLyBUaGlzIHRlbGxzIHRoZSBtYWluIHRocmVhZCB0aGF0IHRoZSBmaWxlIGlzIGZ1bGx5IGxvYWRlZCBiZWZvcmUgc2VuZGluZyB0aGUgXCJpbml0XCIgbWVzc2FnZS5cbnNlbGYucG9zdE1lc3NhZ2UoeyBsb2FkZWQ6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWItY2xpZW50LW1ldGhvZHMtd29ya2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@demox-labs/miden-sdk/dist/workers/web-client-methods-worker.js\n");

/***/ })

};
;