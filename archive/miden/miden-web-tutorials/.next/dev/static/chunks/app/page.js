/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_1_createWalletAndFaucet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/1_createWalletAndFaucet */ \"(app-pages-browser)/./lib/1_createWalletAndFaucet.ts\");\n/* harmony import */ var _lib_2_mintConsumeTransfer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/2_mintConsumeTransfer */ \"(app-pages-browser)/./lib/2_mintConsumeTransfer.ts\");\n/* harmony import */ var _lib_3_incrementCounterContract__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/3_incrementCounterContract */ \"(app-pages-browser)/./lib/3_incrementCounterContract.ts\");\n/* harmony import */ var _lib_4_unauthenticatedNoteTransfer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/4_unauthenticatedNoteTransfer */ \"(app-pages-browser)/./lib/4_unauthenticatedNoteTransfer.ts\");\n/* harmony import */ var _lib_5_foreignProcedureInvocation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/5_foreignProcedureInvocation */ \"(app-pages-browser)/./lib/5_foreignProcedureInvocation.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst tutorials = [\n    {\n        label: 'Tutorial 1: Create Wallet & Deploy Faucet',\n        fn: _lib_1_createWalletAndFaucet__WEBPACK_IMPORTED_MODULE_2__.createWalletAndFaucet,\n        color: '#e65100'\n    },\n    {\n        label: 'Tutorial 2: Mint, Consume & Transfer Tokens',\n        fn: _lib_2_mintConsumeTransfer__WEBPACK_IMPORTED_MODULE_3__.mintConsumeTransfer,\n        color: '#ef6c00'\n    },\n    {\n        label: 'Tutorial 3: Increment Counter Contract',\n        fn: _lib_3_incrementCounterContract__WEBPACK_IMPORTED_MODULE_4__.incrementCounterContract,\n        color: '#f57c00'\n    },\n    {\n        label: 'Tutorial 4: Unauthenticated Note Transfers',\n        fn: _lib_4_unauthenticatedNoteTransfer__WEBPACK_IMPORTED_MODULE_5__.unauthenticatedNoteTransfer,\n        color: '#fb8c00'\n    },\n    {\n        label: 'Tutorial 5: Foreign Procedure Invocation',\n        fn: _lib_5_foreignProcedureInvocation__WEBPACK_IMPORTED_MODULE_6__.foreignProcedureInvocation,\n        color: '#ffa726'\n    }\n];\nfunction Home() {\n    _s();\n    const [running, setRunning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const run = async (idx)=>{\n        setRunning(idx);\n        try {\n            await tutorials[idx].fn();\n        } catch (err) {\n            console.error('Tutorial error:', err);\n        }\n        setRunning(null);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        style: {\n            minHeight: '100vh',\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            justifyContent: 'center',\n            background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',\n            color: '#fff',\n            padding: '2rem'\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                style: {\n                    fontSize: '2.5rem',\n                    marginBottom: '0.5rem'\n                },\n                children: \"Miden Contract Tutorials\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\crabdao-agent\\\\miden-web-tutorials\\\\app\\\\page.tsx\",\n                lineNumber: 41,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    color: '#aaa',\n                    marginBottom: '2rem'\n                },\n                children: \"Open browser console (F12) to see logs. Run tutorials in order.\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\crabdao-agent\\\\miden-web-tutorials\\\\app\\\\page.tsx\",\n                lineNumber: 42,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: 'flex',\n                    flexDirection: 'column',\n                    gap: '1rem',\n                    maxWidth: '500px',\n                    width: '100%'\n                },\n                children: tutorials.map((t, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>run(i),\n                        disabled: running !== null,\n                        style: {\n                            padding: '1rem 1.5rem',\n                            fontSize: '1.1rem',\n                            cursor: running !== null ? 'wait' : 'pointer',\n                            background: 'transparent',\n                            border: `2px solid ${t.color}`,\n                            color: '#fff',\n                            borderRadius: '12px',\n                            transition: 'all 0.2s',\n                            opacity: running !== null && running !== i ? 0.4 : 1\n                        },\n                        children: running === i ? 'Running... (check console)' : t.label\n                    }, i, false, {\n                        fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\crabdao-agent\\\\miden-web-tutorials\\\\app\\\\page.tsx\",\n                        lineNumber: 48,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\crabdao-agent\\\\miden-web-tutorials\\\\app\\\\page.tsx\",\n                lineNumber: 46,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    color: '#666',\n                    marginTop: '2rem',\n                    fontSize: '0.85rem'\n                },\n                children: \"Powered by @demox-labs/miden-sdk | Testnet RPC: rpc.testnet.miden.io\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\crabdao-agent\\\\miden-web-tutorials\\\\app\\\\page.tsx\",\n                lineNumber: 69,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\DELL\\\\Desktop\\\\crabdao-agent\\\\miden-web-tutorials\\\\app\\\\page.tsx\",\n        lineNumber: 31,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"bwZ08dQ6D7RDV+JwK0Xuk+IkVCI=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUNpQztBQUNzQztBQUNKO0FBQ1U7QUFDTTtBQUNGO0FBRWpGLE1BQU1NLFlBQVk7SUFDaEI7UUFBRUMsT0FBTztRQUE2Q0MsSUFBSVAsK0VBQXFCQTtRQUFFUSxPQUFPO0lBQVU7SUFDbEc7UUFBRUYsT0FBTztRQUErQ0MsSUFBSU4sMkVBQW1CQTtRQUFFTyxPQUFPO0lBQVU7SUFDbEc7UUFBRUYsT0FBTztRQUEwQ0MsSUFBSUwscUZBQXdCQTtRQUFFTSxPQUFPO0lBQVU7SUFDbEc7UUFBRUYsT0FBTztRQUE4Q0MsSUFBSUosMkZBQTJCQTtRQUFFSyxPQUFPO0lBQVU7SUFDekc7UUFBRUYsT0FBTztRQUE0Q0MsSUFBSUgseUZBQTBCQTtRQUFFSSxPQUFPO0lBQVU7Q0FDdkc7QUFFYyxTQUFTQzs7SUFDdEIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdaLCtDQUFRQSxDQUFnQjtJQUV0RCxNQUFNYSxNQUFNLE9BQU9DO1FBQ2pCRixXQUFXRTtRQUNYLElBQUk7WUFDRixNQUFNUixTQUFTLENBQUNRLElBQUksQ0FBQ04sRUFBRTtRQUN6QixFQUFFLE9BQU9PLEtBQUs7WUFDWkMsUUFBUUMsS0FBSyxDQUFDLG1CQUFtQkY7UUFDbkM7UUFDQUgsV0FBVztJQUNiO0lBRUEscUJBQ0UsOERBQUNNO1FBQUtDLE9BQU87WUFDWEMsV0FBVztZQUNYQyxTQUFTO1lBQ1RDLGVBQWU7WUFDZkMsWUFBWTtZQUNaQyxnQkFBZ0I7WUFDaEJDLFlBQVk7WUFDWmhCLE9BQU87WUFDUGlCLFNBQVM7UUFDWDs7MEJBQ0UsOERBQUNDO2dCQUFHUixPQUFPO29CQUFFUyxVQUFVO29CQUFVQyxjQUFjO2dCQUFTOzBCQUFHOzs7Ozs7MEJBQzNELDhEQUFDQztnQkFBRVgsT0FBTztvQkFBRVYsT0FBTztvQkFBUW9CLGNBQWM7Z0JBQU87MEJBQUc7Ozs7OzswQkFJbkQsOERBQUNFO2dCQUFJWixPQUFPO29CQUFFRSxTQUFTO29CQUFRQyxlQUFlO29CQUFVVSxLQUFLO29CQUFRQyxVQUFVO29CQUFTQyxPQUFPO2dCQUFPOzBCQUNuRzVCLFVBQVU2QixHQUFHLENBQUMsQ0FBQ0MsR0FBR0Msa0JBQ2pCLDhEQUFDQzt3QkFFQ0MsU0FBUyxJQUFNMUIsSUFBSXdCO3dCQUNuQkcsVUFBVTdCLFlBQVk7d0JBQ3RCUSxPQUFPOzRCQUNMTyxTQUFTOzRCQUNURSxVQUFVOzRCQUNWYSxRQUFROUIsWUFBWSxPQUFPLFNBQVM7NEJBQ3BDYyxZQUFZOzRCQUNaaUIsUUFBUSxDQUFDLFVBQVUsRUFBRU4sRUFBRTNCLEtBQUssRUFBRTs0QkFDOUJBLE9BQU87NEJBQ1BrQyxjQUFjOzRCQUNkQyxZQUFZOzRCQUNaQyxTQUFTbEMsWUFBWSxRQUFRQSxZQUFZMEIsSUFBSSxNQUFNO3dCQUNyRDtrQ0FFQzFCLFlBQVkwQixJQUFJLCtCQUErQkQsRUFBRTdCLEtBQUs7dUJBZmxEOEI7Ozs7Ozs7Ozs7MEJBb0JYLDhEQUFDUDtnQkFBRVgsT0FBTztvQkFBRVYsT0FBTztvQkFBUXFDLFdBQVc7b0JBQVFsQixVQUFVO2dCQUFVOzBCQUFHOzs7Ozs7Ozs7Ozs7QUFLM0U7R0F6RHdCbEI7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcY3JhYmRhby1hZ2VudFxcbWlkZW4td2ViLXR1dG9yaWFsc1xcYXBwXFxwYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVdhbGxldEFuZEZhdWNldCB9IGZyb20gJy4uL2xpYi8xX2NyZWF0ZVdhbGxldEFuZEZhdWNldCc7XG5pbXBvcnQgeyBtaW50Q29uc3VtZVRyYW5zZmVyIH0gZnJvbSAnLi4vbGliLzJfbWludENvbnN1bWVUcmFuc2Zlcic7XG5pbXBvcnQgeyBpbmNyZW1lbnRDb3VudGVyQ29udHJhY3QgfSBmcm9tICcuLi9saWIvM19pbmNyZW1lbnRDb3VudGVyQ29udHJhY3QnO1xuaW1wb3J0IHsgdW5hdXRoZW50aWNhdGVkTm90ZVRyYW5zZmVyIH0gZnJvbSAnLi4vbGliLzRfdW5hdXRoZW50aWNhdGVkTm90ZVRyYW5zZmVyJztcbmltcG9ydCB7IGZvcmVpZ25Qcm9jZWR1cmVJbnZvY2F0aW9uIH0gZnJvbSAnLi4vbGliLzVfZm9yZWlnblByb2NlZHVyZUludm9jYXRpb24nO1xuXG5jb25zdCB0dXRvcmlhbHMgPSBbXG4gIHsgbGFiZWw6ICdUdXRvcmlhbCAxOiBDcmVhdGUgV2FsbGV0ICYgRGVwbG95IEZhdWNldCcsIGZuOiBjcmVhdGVXYWxsZXRBbmRGYXVjZXQsIGNvbG9yOiAnI2U2NTEwMCcgfSxcbiAgeyBsYWJlbDogJ1R1dG9yaWFsIDI6IE1pbnQsIENvbnN1bWUgJiBUcmFuc2ZlciBUb2tlbnMnLCBmbjogbWludENvbnN1bWVUcmFuc2ZlciwgY29sb3I6ICcjZWY2YzAwJyB9LFxuICB7IGxhYmVsOiAnVHV0b3JpYWwgMzogSW5jcmVtZW50IENvdW50ZXIgQ29udHJhY3QnLCBmbjogaW5jcmVtZW50Q291bnRlckNvbnRyYWN0LCBjb2xvcjogJyNmNTdjMDAnIH0sXG4gIHsgbGFiZWw6ICdUdXRvcmlhbCA0OiBVbmF1dGhlbnRpY2F0ZWQgTm90ZSBUcmFuc2ZlcnMnLCBmbjogdW5hdXRoZW50aWNhdGVkTm90ZVRyYW5zZmVyLCBjb2xvcjogJyNmYjhjMDAnIH0sXG4gIHsgbGFiZWw6ICdUdXRvcmlhbCA1OiBGb3JlaWduIFByb2NlZHVyZSBJbnZvY2F0aW9uJywgZm46IGZvcmVpZ25Qcm9jZWR1cmVJbnZvY2F0aW9uLCBjb2xvcjogJyNmZmE3MjYnIH0sXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICBjb25zdCBbcnVubmluZywgc2V0UnVubmluZ10gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBydW4gPSBhc3luYyAoaWR4OiBudW1iZXIpID0+IHtcbiAgICBzZXRSdW5uaW5nKGlkeCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHR1dG9yaWFsc1tpZHhdLmZuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUdXRvcmlhbCBlcnJvcjonLCBlcnIpO1xuICAgIH1cbiAgICBzZXRSdW5uaW5nKG51bGwpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPG1haW4gc3R5bGU9e3tcbiAgICAgIG1pbkhlaWdodDogJzEwMHZoJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICBiYWNrZ3JvdW5kOiAnbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzFhMWEyZSAwJSwgIzE2MjEzZSA1MCUsICMwZjM0NjAgMTAwJSknLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIHBhZGRpbmc6ICcycmVtJyxcbiAgICB9fT5cbiAgICAgIDxoMSBzdHlsZT17eyBmb250U2l6ZTogJzIuNXJlbScsIG1hcmdpbkJvdHRvbTogJzAuNXJlbScgfX0+TWlkZW4gQ29udHJhY3QgVHV0b3JpYWxzPC9oMT5cbiAgICAgIDxwIHN0eWxlPXt7IGNvbG9yOiAnI2FhYScsIG1hcmdpbkJvdHRvbTogJzJyZW0nIH19PlxuICAgICAgICBPcGVuIGJyb3dzZXIgY29uc29sZSAoRjEyKSB0byBzZWUgbG9ncy4gUnVuIHR1dG9yaWFscyBpbiBvcmRlci5cbiAgICAgIDwvcD5cblxuICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLCBnYXA6ICcxcmVtJywgbWF4V2lkdGg6ICc1MDBweCcsIHdpZHRoOiAnMTAwJScgfX0+XG4gICAgICAgIHt0dXRvcmlhbHMubWFwKCh0LCBpKSA9PiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gcnVuKGkpfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e3J1bm5pbmcgIT09IG51bGx9XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwYWRkaW5nOiAnMXJlbSAxLjVyZW0nLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzEuMXJlbScsXG4gICAgICAgICAgICAgIGN1cnNvcjogcnVubmluZyAhPT0gbnVsbCA/ICd3YWl0JyA6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgYm9yZGVyOiBgMnB4IHNvbGlkICR7dC5jb2xvcn1gLFxuICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwLjJzJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogcnVubmluZyAhPT0gbnVsbCAmJiBydW5uaW5nICE9PSBpID8gMC40IDogMSxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3J1bm5pbmcgPT09IGkgPyAnUnVubmluZy4uLiAoY2hlY2sgY29uc29sZSknIDogdC5sYWJlbH1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cblxuICAgICAgPHAgc3R5bGU9e3sgY29sb3I6ICcjNjY2JywgbWFyZ2luVG9wOiAnMnJlbScsIGZvbnRTaXplOiAnMC44NXJlbScgfX0+XG4gICAgICAgIFBvd2VyZWQgYnkgQGRlbW94LWxhYnMvbWlkZW4tc2RrIHwgVGVzdG5ldCBSUEM6IHJwYy50ZXN0bmV0Lm1pZGVuLmlvXG4gICAgICA8L3A+XG4gICAgPC9tYWluPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiY3JlYXRlV2FsbGV0QW5kRmF1Y2V0IiwibWludENvbnN1bWVUcmFuc2ZlciIsImluY3JlbWVudENvdW50ZXJDb250cmFjdCIsInVuYXV0aGVudGljYXRlZE5vdGVUcmFuc2ZlciIsImZvcmVpZ25Qcm9jZWR1cmVJbnZvY2F0aW9uIiwidHV0b3JpYWxzIiwibGFiZWwiLCJmbiIsImNvbG9yIiwiSG9tZSIsInJ1bm5pbmciLCJzZXRSdW5uaW5nIiwicnVuIiwiaWR4IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwibWFpbiIsInN0eWxlIiwibWluSGVpZ2h0IiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJiYWNrZ3JvdW5kIiwicGFkZGluZyIsImgxIiwiZm9udFNpemUiLCJtYXJnaW5Cb3R0b20iLCJwIiwiZGl2IiwiZ2FwIiwibWF4V2lkdGgiLCJ3aWR0aCIsIm1hcCIsInQiLCJpIiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwiY3Vyc29yIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwidHJhbnNpdGlvbiIsIm9wYWNpdHkiLCJtYXJnaW5Ub3AiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/1_createWalletAndFaucet.ts":
/*!****************************************!*\
  !*** ./lib/1_createWalletAndFaucet.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWalletAndFaucet: () => (/* binding */ createWalletAndFaucet)\n/* harmony export */ });\n// Tutorial 1: Create a Wallet Account & Deploy a Fungible Faucet\n//\n// CONCEPTS:\n// - Public vs private accounts (public = state visible on-chain)\n// - Accounts = smart contracts in Miden (native account abstraction)\n// - Faucets = special accounts that can mint new tokens\n//\n// WHAT HAPPENS:\n// 1. Connect to Miden testnet via WebClient\n// 2. Create a public wallet for \"Alice\"\n// 3. Deploy a faucet that can mint \"MID\" tokens\nasync function createWalletAndFaucet() {\n    if (false) {}\n    const { WebClient, AccountStorageMode } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_demox-labs_miden-sdk_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @demox-labs/miden-sdk */ \"(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/index.js\"));\n    // --- Connect to testnet ---\n    const client = await WebClient.createClient('https://rpc.testnet.miden.io');\n    const state = await client.syncState();\n    console.log('Latest block number:', state.blockNum());\n    // --- Create Alice's wallet ---\n    // AccountStorageMode.public() = account state visible on-chain\n    // true = mutable (code can be upgraded)\n    // 0 = RPO Falcon 512 auth scheme\n    console.log('Creating wallet for Alice...');\n    const alice = await client.newWallet(AccountStorageMode.public(), true, 0);\n    console.log('Alice Account ID:', alice.id().toString());\n    // --- Deploy a fungible faucet ---\n    // This creates a token factory that can mint \"MID\" tokens\n    // Parameters: storage mode, immutable, symbol, decimals, max supply, auth scheme\n    console.log('Deploying faucet...');\n    const faucet = await client.newFaucet(AccountStorageMode.public(), false, 'MID', 8, BigInt(1000000), 0);\n    console.log('Faucet Account ID:', faucet.id().toString());\n    console.log('\\n=== Tutorial 1 Complete ===');\n    console.log('You now have:');\n    console.log('  - A wallet (Alice) that can hold tokens');\n    console.log('  - A faucet that can mint MID tokens');\n    console.log('Next: Run Tutorial 2 to mint and transfer tokens.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi8xX2NyZWF0ZVdhbGxldEFuZEZhdWNldC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWlFO0FBQ2pFLEVBQUU7QUFDRixZQUFZO0FBQ1osaUVBQWlFO0FBQ2pFLHFFQUFxRTtBQUNyRSx3REFBd0Q7QUFDeEQsRUFBRTtBQUNGLGdCQUFnQjtBQUNoQiw0Q0FBNEM7QUFDNUMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUV6QyxlQUFlQTtJQUNwQixJQUFJLEtBQTZCLEVBQUUsRUFHbEM7SUFFRCxNQUFNLEVBQUVHLFNBQVMsRUFBRUMsa0JBQWtCLEVBQUUsR0FBRyxNQUFNLHNRQUErQjtJQUUvRSw2QkFBNkI7SUFDN0IsTUFBTUMsU0FBUyxNQUFNRixVQUFVRyxZQUFZLENBQUM7SUFDNUMsTUFBTUMsUUFBUSxNQUFNRixPQUFPRyxTQUFTO0lBQ3BDUCxRQUFRUSxHQUFHLENBQUMsd0JBQXdCRixNQUFNRyxRQUFRO0lBRWxELGdDQUFnQztJQUNoQywrREFBK0Q7SUFDL0Qsd0NBQXdDO0lBQ3hDLGlDQUFpQztJQUNqQ1QsUUFBUVEsR0FBRyxDQUFDO0lBQ1osTUFBTUUsUUFBUSxNQUFNTixPQUFPTyxTQUFTLENBQUNSLG1CQUFtQlMsTUFBTSxJQUFJLE1BQU07SUFDeEVaLFFBQVFRLEdBQUcsQ0FBQyxxQkFBcUJFLE1BQU1HLEVBQUUsR0FBR0MsUUFBUTtJQUVwRCxtQ0FBbUM7SUFDbkMsMERBQTBEO0lBQzFELGlGQUFpRjtJQUNqRmQsUUFBUVEsR0FBRyxDQUFDO0lBQ1osTUFBTU8sU0FBUyxNQUFNWCxPQUFPWSxTQUFTLENBQ25DYixtQkFBbUJTLE1BQU0sSUFDekIsT0FDQSxPQUNBLEdBQ0FLLE9BQU8sVUFDUDtJQUVGakIsUUFBUVEsR0FBRyxDQUFDLHNCQUFzQk8sT0FBT0YsRUFBRSxHQUFHQyxRQUFRO0lBRXREZCxRQUFRUSxHQUFHLENBQUM7SUFDWlIsUUFBUVEsR0FBRyxDQUFDO0lBQ1pSLFFBQVFRLEdBQUcsQ0FBQztJQUNaUixRQUFRUSxHQUFHLENBQUM7SUFDWlIsUUFBUVEsR0FBRyxDQUFDO0FBQ2QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcY3JhYmRhby1hZ2VudFxcbWlkZW4td2ViLXR1dG9yaWFsc1xcbGliXFwxX2NyZWF0ZVdhbGxldEFuZEZhdWNldC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUdXRvcmlhbCAxOiBDcmVhdGUgYSBXYWxsZXQgQWNjb3VudCAmIERlcGxveSBhIEZ1bmdpYmxlIEZhdWNldFxuLy9cbi8vIENPTkNFUFRTOlxuLy8gLSBQdWJsaWMgdnMgcHJpdmF0ZSBhY2NvdW50cyAocHVibGljID0gc3RhdGUgdmlzaWJsZSBvbi1jaGFpbilcbi8vIC0gQWNjb3VudHMgPSBzbWFydCBjb250cmFjdHMgaW4gTWlkZW4gKG5hdGl2ZSBhY2NvdW50IGFic3RyYWN0aW9uKVxuLy8gLSBGYXVjZXRzID0gc3BlY2lhbCBhY2NvdW50cyB0aGF0IGNhbiBtaW50IG5ldyB0b2tlbnNcbi8vXG4vLyBXSEFUIEhBUFBFTlM6XG4vLyAxLiBDb25uZWN0IHRvIE1pZGVuIHRlc3RuZXQgdmlhIFdlYkNsaWVudFxuLy8gMi4gQ3JlYXRlIGEgcHVibGljIHdhbGxldCBmb3IgXCJBbGljZVwiXG4vLyAzLiBEZXBsb3kgYSBmYXVjZXQgdGhhdCBjYW4gbWludCBcIk1JRFwiIHRva2Vuc1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2FsbGV0QW5kRmF1Y2V0KCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ1RoaXMgbXVzdCBydW4gaW4gdGhlIGJyb3dzZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IFdlYkNsaWVudCwgQWNjb3VudFN0b3JhZ2VNb2RlIH0gPSBhd2FpdCBpbXBvcnQoJ0BkZW1veC1sYWJzL21pZGVuLXNkaycpO1xuXG4gIC8vIC0tLSBDb25uZWN0IHRvIHRlc3RuZXQgLS0tXG4gIGNvbnN0IGNsaWVudCA9IGF3YWl0IFdlYkNsaWVudC5jcmVhdGVDbGllbnQoJ2h0dHBzOi8vcnBjLnRlc3RuZXQubWlkZW4uaW8nKTtcbiAgY29uc3Qgc3RhdGUgPSBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG4gIGNvbnNvbGUubG9nKCdMYXRlc3QgYmxvY2sgbnVtYmVyOicsIHN0YXRlLmJsb2NrTnVtKCkpO1xuXG4gIC8vIC0tLSBDcmVhdGUgQWxpY2UncyB3YWxsZXQgLS0tXG4gIC8vIEFjY291bnRTdG9yYWdlTW9kZS5wdWJsaWMoKSA9IGFjY291bnQgc3RhdGUgdmlzaWJsZSBvbi1jaGFpblxuICAvLyB0cnVlID0gbXV0YWJsZSAoY29kZSBjYW4gYmUgdXBncmFkZWQpXG4gIC8vIDAgPSBSUE8gRmFsY29uIDUxMiBhdXRoIHNjaGVtZVxuICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgd2FsbGV0IGZvciBBbGljZS4uLicpO1xuICBjb25zdCBhbGljZSA9IGF3YWl0IGNsaWVudC5uZXdXYWxsZXQoQWNjb3VudFN0b3JhZ2VNb2RlLnB1YmxpYygpLCB0cnVlLCAwKTtcbiAgY29uc29sZS5sb2coJ0FsaWNlIEFjY291bnQgSUQ6JywgYWxpY2UuaWQoKS50b1N0cmluZygpKTtcblxuICAvLyAtLS0gRGVwbG95IGEgZnVuZ2libGUgZmF1Y2V0IC0tLVxuICAvLyBUaGlzIGNyZWF0ZXMgYSB0b2tlbiBmYWN0b3J5IHRoYXQgY2FuIG1pbnQgXCJNSURcIiB0b2tlbnNcbiAgLy8gUGFyYW1ldGVyczogc3RvcmFnZSBtb2RlLCBpbW11dGFibGUsIHN5bWJvbCwgZGVjaW1hbHMsIG1heCBzdXBwbHksIGF1dGggc2NoZW1lXG4gIGNvbnNvbGUubG9nKCdEZXBsb3lpbmcgZmF1Y2V0Li4uJyk7XG4gIGNvbnN0IGZhdWNldCA9IGF3YWl0IGNsaWVudC5uZXdGYXVjZXQoXG4gICAgQWNjb3VudFN0b3JhZ2VNb2RlLnB1YmxpYygpLCAvLyBwdWJsaWMgc28gYW55b25lIGNhbiB2ZXJpZnkgbWludGluZ1xuICAgIGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1tdXRhYmxlIOKAlCBydWxlcyBjYW4ndCBjaGFuZ2VcbiAgICAnTUlEJywgICAgICAgICAgICAgICAgICAgICAgIC8vIHRva2VuIHN5bWJvbFxuICAgIDgsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbHMgKDEgTUlEID0gMTAwLDAwMCwwMDAgYmFzZSB1bml0cylcbiAgICBCaWdJbnQoMV8wMDBfMDAwKSwgICAgICAgICAgIC8vIG1heCBzdXBwbHlcbiAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJQTyBGYWxjb24gNTEyXG4gICk7XG4gIGNvbnNvbGUubG9nKCdGYXVjZXQgQWNjb3VudCBJRDonLCBmYXVjZXQuaWQoKS50b1N0cmluZygpKTtcblxuICBjb25zb2xlLmxvZygnXFxuPT09IFR1dG9yaWFsIDEgQ29tcGxldGUgPT09Jyk7XG4gIGNvbnNvbGUubG9nKCdZb3Ugbm93IGhhdmU6Jyk7XG4gIGNvbnNvbGUubG9nKCcgIC0gQSB3YWxsZXQgKEFsaWNlKSB0aGF0IGNhbiBob2xkIHRva2VucycpO1xuICBjb25zb2xlLmxvZygnICAtIEEgZmF1Y2V0IHRoYXQgY2FuIG1pbnQgTUlEIHRva2VucycpO1xuICBjb25zb2xlLmxvZygnTmV4dDogUnVuIFR1dG9yaWFsIDIgdG8gbWludCBhbmQgdHJhbnNmZXIgdG9rZW5zLicpO1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVdhbGxldEFuZEZhdWNldCIsImNvbnNvbGUiLCJ3YXJuIiwiV2ViQ2xpZW50IiwiQWNjb3VudFN0b3JhZ2VNb2RlIiwiY2xpZW50IiwiY3JlYXRlQ2xpZW50Iiwic3RhdGUiLCJzeW5jU3RhdGUiLCJsb2ciLCJibG9ja051bSIsImFsaWNlIiwibmV3V2FsbGV0IiwicHVibGljIiwiaWQiLCJ0b1N0cmluZyIsImZhdWNldCIsIm5ld0ZhdWNldCIsIkJpZ0ludCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/1_createWalletAndFaucet.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/2_mintConsumeTransfer.ts":
/*!**************************************!*\
  !*** ./lib/2_mintConsumeTransfer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mintConsumeTransfer: () => (/* binding */ mintConsumeTransfer)\n/* harmony export */ });\n// Tutorial 2: Mint Tokens, Consume Notes, Transfer to Another Account\n//\n// CONCEPTS:\n// - Minting creates a \"note\" (like a cashier's check) — NOT directly in your wallet\n// - You must CONSUME a note to add tokens to your balance\n// - P2ID (Pay-to-ID) notes lock tokens to a specific recipient\n//\n// FLOW:\n// 1. Create Alice wallet + faucet\n// 2. Mint 1000 MID to Alice (creates a note)\n// 3. Alice consumes the note (tokens enter her wallet)\n// 4. Alice sends 100 MID to Bob via P2ID note\nasync function mintConsumeTransfer() {\n    if (false) {}\n    const { WebClient, AccountStorageMode, NoteType, Address } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_demox-labs_miden-sdk_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @demox-labs/miden-sdk */ \"(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/index.js\"));\n    const client = await WebClient.createClient('https://rpc.testnet.miden.io');\n    const state = await client.syncState();\n    console.log('Latest block number:', state.blockNum());\n    // Step 1: Create Alice + faucet\n    console.log('\\n[Step 1] Creating Alice wallet and faucet...');\n    const alice = await client.newWallet(AccountStorageMode.public(), true, 0);\n    console.log('Alice ID:', alice.id().toString());\n    const faucet = await client.newFaucet(AccountStorageMode.public(), false, 'MID', 8, BigInt(1000000), 0);\n    console.log('Faucet ID:', faucet.id().toString());\n    await client.syncState();\n    // Step 2: Mint 1000 MID to Alice\n    // This creates a PUBLIC note containing 1000 tokens addressed to Alice\n    console.log('\\n[Step 2] Minting 1000 MID to Alice...');\n    const mintTxRequest = client.newMintTransactionRequest(alice.id(), faucet.id(), NoteType.Public, BigInt(1000));\n    await client.submitNewTransaction(faucet.id(), mintTxRequest);\n    // Wait for the note to be committed in a block\n    console.log('Waiting 12s for block confirmation...');\n    await new Promise((r)=>setTimeout(r, 12000));\n    await client.syncState();\n    // Step 3: Consume the note — move tokens into Alice's wallet\n    console.log('\\n[Step 3] Finding and consuming notes...');\n    const consumableNotes = await client.getConsumableNotes(alice.id());\n    console.log(`Found ${consumableNotes.length} consumable note(s)`);\n    const noteIds = consumableNotes.map((n)=>n.inputNoteRecord().id().toString());\n    const consumeTxRequest = client.newConsumeTransactionRequest(noteIds);\n    await client.submitNewTransaction(alice.id(), consumeTxRequest);\n    await client.syncState();\n    console.log('Notes consumed! Tokens are now in Alice\\'s wallet.');\n    // Step 4: Send 100 MID to Bob\n    // This creates a P2ID note locked to Bob's account\n    console.log('\\n[Step 4] Sending 100 MID to Bob...');\n    const bob = await client.newWallet(AccountStorageMode.public(), true, 0);\n    console.log('Bob ID:', bob.id().toString());\n    const sendTxRequest = client.newSendTransactionRequest(alice.id(), bob.id(), faucet.id(), NoteType.Public, BigInt(100));\n    await client.submitNewTransaction(alice.id(), sendTxRequest);\n    console.log('100 MID sent to Bob!');\n    console.log('\\n=== Tutorial 2 Complete ===');\n    console.log('You learned:');\n    console.log('  - Minting creates notes, not direct balance changes');\n    console.log('  - Consuming a note adds tokens to your wallet');\n    console.log('  - P2ID notes are how you transfer tokens');\n    console.log('Next: Run Tutorial 3 to interact with a smart contract.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi8yX21pbnRDb25zdW1lVHJhbnNmZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0YsWUFBWTtBQUNaLG9GQUFvRjtBQUNwRiwwREFBMEQ7QUFDMUQsK0RBQStEO0FBQy9ELEVBQUU7QUFDRixRQUFRO0FBQ1Isa0NBQWtDO0FBQ2xDLDZDQUE2QztBQUM3Qyx1REFBdUQ7QUFDdkQsOENBQThDO0FBRXZDLGVBQWVBO0lBQ3BCLElBQUksS0FBNkIsRUFBRSxFQUdsQztJQUVELE1BQU0sRUFBRUcsU0FBUyxFQUFFQyxrQkFBa0IsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUUsR0FBRyxNQUFNLHNRQUNqRTtJQUdGLE1BQU1DLFNBQVMsTUFBTUosVUFBVUssWUFBWSxDQUFDO0lBQzVDLE1BQU1DLFFBQVEsTUFBTUYsT0FBT0csU0FBUztJQUNwQ1QsUUFBUVUsR0FBRyxDQUFDLHdCQUF3QkYsTUFBTUcsUUFBUTtJQUVsRCxnQ0FBZ0M7SUFDaENYLFFBQVFVLEdBQUcsQ0FBQztJQUNaLE1BQU1FLFFBQVEsTUFBTU4sT0FBT08sU0FBUyxDQUFDVixtQkFBbUJXLE1BQU0sSUFBSSxNQUFNO0lBQ3hFZCxRQUFRVSxHQUFHLENBQUMsYUFBYUUsTUFBTUcsRUFBRSxHQUFHQyxRQUFRO0lBRTVDLE1BQU1DLFNBQVMsTUFBTVgsT0FBT1ksU0FBUyxDQUNuQ2YsbUJBQW1CVyxNQUFNLElBQUksT0FBTyxPQUFPLEdBQUdLLE9BQU8sVUFBWTtJQUVuRW5CLFFBQVFVLEdBQUcsQ0FBQyxjQUFjTyxPQUFPRixFQUFFLEdBQUdDLFFBQVE7SUFFOUMsTUFBTVYsT0FBT0csU0FBUztJQUV0QixpQ0FBaUM7SUFDakMsdUVBQXVFO0lBQ3ZFVCxRQUFRVSxHQUFHLENBQUM7SUFDWixNQUFNVSxnQkFBZ0JkLE9BQU9lLHlCQUF5QixDQUNwRFQsTUFBTUcsRUFBRSxJQUNSRSxPQUFPRixFQUFFLElBQ1RYLFNBQVNrQixNQUFNLEVBQ2ZILE9BQU87SUFFVCxNQUFNYixPQUFPaUIsb0JBQW9CLENBQUNOLE9BQU9GLEVBQUUsSUFBSUs7SUFFL0MsK0NBQStDO0lBQy9DcEIsUUFBUVUsR0FBRyxDQUFDO0lBQ1osTUFBTSxJQUFJYyxRQUFRLENBQUNDLElBQU1DLFdBQVdELEdBQUc7SUFDdkMsTUFBTW5CLE9BQU9HLFNBQVM7SUFFdEIsNkRBQTZEO0lBQzdEVCxRQUFRVSxHQUFHLENBQUM7SUFDWixNQUFNaUIsa0JBQWtCLE1BQU1yQixPQUFPc0Isa0JBQWtCLENBQUNoQixNQUFNRyxFQUFFO0lBQ2hFZixRQUFRVSxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUVpQixnQkFBZ0JFLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQztJQUVoRSxNQUFNQyxVQUFVSCxnQkFBZ0JJLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxlQUFlLEdBQUdsQixFQUFFLEdBQUdDLFFBQVE7SUFDNUUsTUFBTWtCLG1CQUFtQjVCLE9BQU82Qiw0QkFBNEIsQ0FBQ0w7SUFDN0QsTUFBTXhCLE9BQU9pQixvQkFBb0IsQ0FBQ1gsTUFBTUcsRUFBRSxJQUFJbUI7SUFDOUMsTUFBTTVCLE9BQU9HLFNBQVM7SUFDdEJULFFBQVFVLEdBQUcsQ0FBQztJQUVaLDhCQUE4QjtJQUM5QixtREFBbUQ7SUFDbkRWLFFBQVFVLEdBQUcsQ0FBQztJQUNaLE1BQU0wQixNQUFNLE1BQU05QixPQUFPTyxTQUFTLENBQUNWLG1CQUFtQlcsTUFBTSxJQUFJLE1BQU07SUFDdEVkLFFBQVFVLEdBQUcsQ0FBQyxXQUFXMEIsSUFBSXJCLEVBQUUsR0FBR0MsUUFBUTtJQUV4QyxNQUFNcUIsZ0JBQWdCL0IsT0FBT2dDLHlCQUF5QixDQUNwRDFCLE1BQU1HLEVBQUUsSUFDUnFCLElBQUlyQixFQUFFLElBQ05FLE9BQU9GLEVBQUUsSUFDVFgsU0FBU2tCLE1BQU0sRUFDZkgsT0FBTztJQUVULE1BQU1iLE9BQU9pQixvQkFBb0IsQ0FBQ1gsTUFBTUcsRUFBRSxJQUFJc0I7SUFDOUNyQyxRQUFRVSxHQUFHLENBQUM7SUFFWlYsUUFBUVUsR0FBRyxDQUFDO0lBQ1pWLFFBQVFVLEdBQUcsQ0FBQztJQUNaVixRQUFRVSxHQUFHLENBQUM7SUFDWlYsUUFBUVUsR0FBRyxDQUFDO0lBQ1pWLFFBQVFVLEdBQUcsQ0FBQztJQUNaVixRQUFRVSxHQUFHLENBQUM7QUFDZCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxERUxMXFxEZXNrdG9wXFxjcmFiZGFvLWFnZW50XFxtaWRlbi13ZWItdHV0b3JpYWxzXFxsaWJcXDJfbWludENvbnN1bWVUcmFuc2Zlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUdXRvcmlhbCAyOiBNaW50IFRva2VucywgQ29uc3VtZSBOb3RlcywgVHJhbnNmZXIgdG8gQW5vdGhlciBBY2NvdW50XG4vL1xuLy8gQ09OQ0VQVFM6XG4vLyAtIE1pbnRpbmcgY3JlYXRlcyBhIFwibm90ZVwiIChsaWtlIGEgY2FzaGllcidzIGNoZWNrKSDigJQgTk9UIGRpcmVjdGx5IGluIHlvdXIgd2FsbGV0XG4vLyAtIFlvdSBtdXN0IENPTlNVTUUgYSBub3RlIHRvIGFkZCB0b2tlbnMgdG8geW91ciBiYWxhbmNlXG4vLyAtIFAySUQgKFBheS10by1JRCkgbm90ZXMgbG9jayB0b2tlbnMgdG8gYSBzcGVjaWZpYyByZWNpcGllbnRcbi8vXG4vLyBGTE9XOlxuLy8gMS4gQ3JlYXRlIEFsaWNlIHdhbGxldCArIGZhdWNldFxuLy8gMi4gTWludCAxMDAwIE1JRCB0byBBbGljZSAoY3JlYXRlcyBhIG5vdGUpXG4vLyAzLiBBbGljZSBjb25zdW1lcyB0aGUgbm90ZSAodG9rZW5zIGVudGVyIGhlciB3YWxsZXQpXG4vLyA0LiBBbGljZSBzZW5kcyAxMDAgTUlEIHRvIEJvYiB2aWEgUDJJRCBub3RlXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaW50Q29uc3VtZVRyYW5zZmVyKCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ1RoaXMgbXVzdCBydW4gaW4gdGhlIGJyb3dzZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7IFdlYkNsaWVudCwgQWNjb3VudFN0b3JhZ2VNb2RlLCBOb3RlVHlwZSwgQWRkcmVzcyB9ID0gYXdhaXQgaW1wb3J0KFxuICAgICdAZGVtb3gtbGFicy9taWRlbi1zZGsnXG4gICk7XG5cbiAgY29uc3QgY2xpZW50ID0gYXdhaXQgV2ViQ2xpZW50LmNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9ycGMudGVzdG5ldC5taWRlbi5pbycpO1xuICBjb25zdCBzdGF0ZSA9IGF3YWl0IGNsaWVudC5zeW5jU3RhdGUoKTtcbiAgY29uc29sZS5sb2coJ0xhdGVzdCBibG9jayBudW1iZXI6Jywgc3RhdGUuYmxvY2tOdW0oKSk7XG5cbiAgLy8gU3RlcCAxOiBDcmVhdGUgQWxpY2UgKyBmYXVjZXRcbiAgY29uc29sZS5sb2coJ1xcbltTdGVwIDFdIENyZWF0aW5nIEFsaWNlIHdhbGxldCBhbmQgZmF1Y2V0Li4uJyk7XG4gIGNvbnN0IGFsaWNlID0gYXdhaXQgY2xpZW50Lm5ld1dhbGxldChBY2NvdW50U3RvcmFnZU1vZGUucHVibGljKCksIHRydWUsIDApO1xuICBjb25zb2xlLmxvZygnQWxpY2UgSUQ6JywgYWxpY2UuaWQoKS50b1N0cmluZygpKTtcblxuICBjb25zdCBmYXVjZXQgPSBhd2FpdCBjbGllbnQubmV3RmF1Y2V0KFxuICAgIEFjY291bnRTdG9yYWdlTW9kZS5wdWJsaWMoKSwgZmFsc2UsICdNSUQnLCA4LCBCaWdJbnQoMV8wMDBfMDAwKSwgMCxcbiAgKTtcbiAgY29uc29sZS5sb2coJ0ZhdWNldCBJRDonLCBmYXVjZXQuaWQoKS50b1N0cmluZygpKTtcblxuICBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG5cbiAgLy8gU3RlcCAyOiBNaW50IDEwMDAgTUlEIHRvIEFsaWNlXG4gIC8vIFRoaXMgY3JlYXRlcyBhIFBVQkxJQyBub3RlIGNvbnRhaW5pbmcgMTAwMCB0b2tlbnMgYWRkcmVzc2VkIHRvIEFsaWNlXG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCAyXSBNaW50aW5nIDEwMDAgTUlEIHRvIEFsaWNlLi4uJyk7XG4gIGNvbnN0IG1pbnRUeFJlcXVlc3QgPSBjbGllbnQubmV3TWludFRyYW5zYWN0aW9uUmVxdWVzdChcbiAgICBhbGljZS5pZCgpLCAgICAgICAvLyByZWNpcGllbnRcbiAgICBmYXVjZXQuaWQoKSwgICAgICAvLyBtaW50ZXJcbiAgICBOb3RlVHlwZS5QdWJsaWMsICAvLyB2aXNpYmxlIG9uLWNoYWluXG4gICAgQmlnSW50KDEwMDApLCAgICAgLy8gYW1vdW50XG4gICk7XG4gIGF3YWl0IGNsaWVudC5zdWJtaXROZXdUcmFuc2FjdGlvbihmYXVjZXQuaWQoKSwgbWludFR4UmVxdWVzdCk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIG5vdGUgdG8gYmUgY29tbWl0dGVkIGluIGEgYmxvY2tcbiAgY29uc29sZS5sb2coJ1dhaXRpbmcgMTJzIGZvciBibG9jayBjb25maXJtYXRpb24uLi4nKTtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMTIwMDApKTtcbiAgYXdhaXQgY2xpZW50LnN5bmNTdGF0ZSgpO1xuXG4gIC8vIFN0ZXAgMzogQ29uc3VtZSB0aGUgbm90ZSDigJQgbW92ZSB0b2tlbnMgaW50byBBbGljZSdzIHdhbGxldFxuICBjb25zb2xlLmxvZygnXFxuW1N0ZXAgM10gRmluZGluZyBhbmQgY29uc3VtaW5nIG5vdGVzLi4uJyk7XG4gIGNvbnN0IGNvbnN1bWFibGVOb3RlcyA9IGF3YWl0IGNsaWVudC5nZXRDb25zdW1hYmxlTm90ZXMoYWxpY2UuaWQoKSk7XG4gIGNvbnNvbGUubG9nKGBGb3VuZCAke2NvbnN1bWFibGVOb3Rlcy5sZW5ndGh9IGNvbnN1bWFibGUgbm90ZShzKWApO1xuXG4gIGNvbnN0IG5vdGVJZHMgPSBjb25zdW1hYmxlTm90ZXMubWFwKChuKSA9PiBuLmlucHV0Tm90ZVJlY29yZCgpLmlkKCkudG9TdHJpbmcoKSk7XG4gIGNvbnN0IGNvbnN1bWVUeFJlcXVlc3QgPSBjbGllbnQubmV3Q29uc3VtZVRyYW5zYWN0aW9uUmVxdWVzdChub3RlSWRzKTtcbiAgYXdhaXQgY2xpZW50LnN1Ym1pdE5ld1RyYW5zYWN0aW9uKGFsaWNlLmlkKCksIGNvbnN1bWVUeFJlcXVlc3QpO1xuICBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG4gIGNvbnNvbGUubG9nKCdOb3RlcyBjb25zdW1lZCEgVG9rZW5zIGFyZSBub3cgaW4gQWxpY2VcXCdzIHdhbGxldC4nKTtcblxuICAvLyBTdGVwIDQ6IFNlbmQgMTAwIE1JRCB0byBCb2JcbiAgLy8gVGhpcyBjcmVhdGVzIGEgUDJJRCBub3RlIGxvY2tlZCB0byBCb2IncyBhY2NvdW50XG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCA0XSBTZW5kaW5nIDEwMCBNSUQgdG8gQm9iLi4uJyk7XG4gIGNvbnN0IGJvYiA9IGF3YWl0IGNsaWVudC5uZXdXYWxsZXQoQWNjb3VudFN0b3JhZ2VNb2RlLnB1YmxpYygpLCB0cnVlLCAwKTtcbiAgY29uc29sZS5sb2coJ0JvYiBJRDonLCBib2IuaWQoKS50b1N0cmluZygpKTtcblxuICBjb25zdCBzZW5kVHhSZXF1ZXN0ID0gY2xpZW50Lm5ld1NlbmRUcmFuc2FjdGlvblJlcXVlc3QoXG4gICAgYWxpY2UuaWQoKSwgICAgICAgLy8gc2VuZGVyXG4gICAgYm9iLmlkKCksICAgICAgICAgLy8gcmVjaXBpZW50XG4gICAgZmF1Y2V0LmlkKCksICAgICAgLy8gd2hpY2ggdG9rZW5cbiAgICBOb3RlVHlwZS5QdWJsaWMsICAvLyBwdWJsaWMgbm90ZVxuICAgIEJpZ0ludCgxMDApLCAgICAgIC8vIGFtb3VudFxuICApO1xuICBhd2FpdCBjbGllbnQuc3VibWl0TmV3VHJhbnNhY3Rpb24oYWxpY2UuaWQoKSwgc2VuZFR4UmVxdWVzdCk7XG4gIGNvbnNvbGUubG9nKCcxMDAgTUlEIHNlbnQgdG8gQm9iIScpO1xuXG4gIGNvbnNvbGUubG9nKCdcXG49PT0gVHV0b3JpYWwgMiBDb21wbGV0ZSA9PT0nKTtcbiAgY29uc29sZS5sb2coJ1lvdSBsZWFybmVkOicpO1xuICBjb25zb2xlLmxvZygnICAtIE1pbnRpbmcgY3JlYXRlcyBub3Rlcywgbm90IGRpcmVjdCBiYWxhbmNlIGNoYW5nZXMnKTtcbiAgY29uc29sZS5sb2coJyAgLSBDb25zdW1pbmcgYSBub3RlIGFkZHMgdG9rZW5zIHRvIHlvdXIgd2FsbGV0Jyk7XG4gIGNvbnNvbGUubG9nKCcgIC0gUDJJRCBub3RlcyBhcmUgaG93IHlvdSB0cmFuc2ZlciB0b2tlbnMnKTtcbiAgY29uc29sZS5sb2coJ05leHQ6IFJ1biBUdXRvcmlhbCAzIHRvIGludGVyYWN0IHdpdGggYSBzbWFydCBjb250cmFjdC4nKTtcbn1cbiJdLCJuYW1lcyI6WyJtaW50Q29uc3VtZVRyYW5zZmVyIiwiY29uc29sZSIsIndhcm4iLCJXZWJDbGllbnQiLCJBY2NvdW50U3RvcmFnZU1vZGUiLCJOb3RlVHlwZSIsIkFkZHJlc3MiLCJjbGllbnQiLCJjcmVhdGVDbGllbnQiLCJzdGF0ZSIsInN5bmNTdGF0ZSIsImxvZyIsImJsb2NrTnVtIiwiYWxpY2UiLCJuZXdXYWxsZXQiLCJwdWJsaWMiLCJpZCIsInRvU3RyaW5nIiwiZmF1Y2V0IiwibmV3RmF1Y2V0IiwiQmlnSW50IiwibWludFR4UmVxdWVzdCIsIm5ld01pbnRUcmFuc2FjdGlvblJlcXVlc3QiLCJQdWJsaWMiLCJzdWJtaXROZXdUcmFuc2FjdGlvbiIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsImNvbnN1bWFibGVOb3RlcyIsImdldENvbnN1bWFibGVOb3RlcyIsImxlbmd0aCIsIm5vdGVJZHMiLCJtYXAiLCJuIiwiaW5wdXROb3RlUmVjb3JkIiwiY29uc3VtZVR4UmVxdWVzdCIsIm5ld0NvbnN1bWVUcmFuc2FjdGlvblJlcXVlc3QiLCJib2IiLCJzZW5kVHhSZXF1ZXN0IiwibmV3U2VuZFRyYW5zYWN0aW9uUmVxdWVzdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/2_mintConsumeTransfer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/3_incrementCounterContract.ts":
/*!*******************************************!*\
  !*** ./lib/3_incrementCounterContract.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   incrementCounterContract: () => (/* binding */ incrementCounterContract)\n/* harmony export */ });\n// Tutorial 3: Increment a Counter Smart Contract\n//\n// CONCEPTS:\n// - Smart contracts in Miden are accounts with custom MASM code\n// - Transaction scripts call procedures on contracts\n// - The counter contract stores a count in storage slot 0\n//\n// MASM CONTRACT (counter):\n//   get_count   — reads slot 0 and returns the value\n//   increment   — reads slot 0, adds 1, writes back\n//\n// FLOW:\n// 1. Import the existing counter contract from testnet\n// 2. Build a transaction script that calls increment_count\n// 3. Execute, prove, and submit the transaction\n// 4. Read the updated count\nasync function incrementCounterContract() {\n    if (false) {}\n    const { Address, AccountBuilder, AccountComponent, AccountStorageMode, AccountType, SecretKey, StorageMap, StorageSlot, TransactionRequestBuilder, WebClient } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_demox-labs_miden-sdk_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @demox-labs/miden-sdk */ \"(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/index.js\"));\n    const client = await WebClient.createClient('https://rpc.testnet.miden.io');\n    console.log('Current block:', (await client.syncState()).blockNum());\n    // -----------------------------------------------------------------------\n    // The Counter Contract — written in Miden Assembly (MASM)\n    // -----------------------------------------------------------------------\n    // This is the actual smart contract code. Let's walk through it:\n    const counterContractCode = `\n  use.miden::active_account   # read state of the account being executed against\n  use.miden::native_account   # write state (set_item)\n  use.std::sys                # system utilities\n\n  const.COUNTER_SLOT=0        # storage slot index where we keep the count\n\n  #! get_count: Read the counter value from storage\n  #! Stack input:  []\n  #! Stack output: [count]\n  export.get_count\n      push.COUNTER_SLOT          # push slot index 0 onto stack\n      # => [0]\n\n      exec.active_account::get_item  # read the word at slot 0\n      # => [value3, value2, value1, value0]\n      # A \"word\" is 4 field elements. Our count is in value0.\n\n      movdn.4 dropw              # keep only the first element\n      # => [count]\n  end\n\n  #! increment_count: Read count, add 1, write back\n  #! Stack input:  []\n  #! Stack output: []\n  export.increment_count\n      push.COUNTER_SLOT          # push slot index\n      # => [0]\n\n      exec.active_account::get_item  # read current value\n      # => [value3, value2, value1, count]\n\n      add.1                      # count + 1\n      # => [value3, value2, value1, count+1]\n\n      debug.stack                # print stack (visible in debug mode)\n\n      push.COUNTER_SLOT          # where to write\n      # => [0, value3, value2, value1, count+1]\n\n      exec.native_account::set_item  # write the updated word\n      # => [OLD_VALUE]\n\n      dropw                      # clean up\n      # => []\n  end\n`;\n    // -----------------------------------------------------------------------\n    // Step 1: Import the counter contract that's already deployed on testnet\n    // -----------------------------------------------------------------------\n    console.log('\\n[Step 1] Importing counter contract from testnet...');\n    const counterContractId = Address.fromBech32('mtst1arjemrxne8lj5qz4mg9c8mtyxg954483').accountId();\n    let counterAccount = await client.getAccount(counterContractId);\n    if (!counterAccount) {\n        await client.importAccountById(counterContractId);\n        await client.syncState();\n        counterAccount = await client.getAccount(counterContractId);\n        if (!counterAccount) throw new Error('Counter contract not found');\n    }\n    console.log('Counter contract loaded. Current storage slot 0:', counterAccount.storage().getItem(0)?.toHex());\n    // -----------------------------------------------------------------------\n    // Step 2: Build an account that can call the counter contract\n    // -----------------------------------------------------------------------\n    console.log('\\n[Step 2] Creating caller account...');\n    const builder = client.createScriptBuilder();\n    const storageMap = new StorageMap();\n    const storageSlotMap = StorageSlot.map(storageMap);\n    const component = AccountComponent.compile(counterContractCode, builder, [\n        storageSlotMap\n    ]).withSupportsAllTypes();\n    const walletSeed = new Uint8Array(32);\n    crypto.getRandomValues(walletSeed);\n    const secretKey = SecretKey.rpoFalconWithRNG(walletSeed);\n    const authComponent = AccountComponent.createAuthComponent(secretKey);\n    const result = new AccountBuilder(walletSeed).accountType(AccountType.RegularAccountImmutableCode).storageMode(AccountStorageMode.public()).withAuthComponent(authComponent).withComponent(component).build();\n    await client.addAccountSecretKeyToWebStore(secretKey);\n    await client.newAccount(result.account, false);\n    await client.syncState();\n    console.log('Caller account:', result.account.id().toString());\n    // -----------------------------------------------------------------------\n    // Step 3: Build the transaction script\n    // -----------------------------------------------------------------------\n    // This script tells the VM: \"call increment_count on the counter contract\"\n    console.log('\\n[Step 3] Building and executing transaction script...');\n    const accountCodeLib = builder.buildLibrary('external_contract::counter_contract', counterContractCode);\n    builder.linkDynamicLibrary(accountCodeLib);\n    const txScriptCode = `\nuse.external_contract::counter_contract\nbegin\n    call.counter_contract::increment_count\nend\n`;\n    const txScript = builder.compileTxScript(txScriptCode);\n    const txRequest = new TransactionRequestBuilder().withCustomScript(txScript).build();\n    // -----------------------------------------------------------------------\n    // Step 4: Execute, prove, submit\n    // -----------------------------------------------------------------------\n    await client.submitNewTransaction(counterAccount.id(), txRequest);\n    await client.syncState();\n    // -----------------------------------------------------------------------\n    // Step 5: Read the updated count\n    // -----------------------------------------------------------------------\n    const updated = await client.getAccount(counterAccount.id());\n    const countHex = updated?.storage().getItem(0);\n    if (countHex) {\n        const counterValue = Number(BigInt('0x' + countHex.toHex().slice(-16).match(/../g).reverse().join('')));\n        console.log('\\nCounter value after increment:', counterValue);\n    }\n    console.log('\\n=== Tutorial 3 Complete ===');\n    console.log('You learned:');\n    console.log('  - MASM smart contracts store state in numbered slots');\n    console.log('  - get_item / set_item read and write storage');\n    console.log('  - Transaction scripts call procedures on contracts');\n    console.log('  - The counter incremented on the live testnet!');\n    console.log('Next: Run Tutorial 4 for unauthenticated note transfers.');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi8zX2luY3JlbWVudENvdW50ZXJDb250cmFjdC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaURBQWlEO0FBQ2pELEVBQUU7QUFDRixZQUFZO0FBQ1osZ0VBQWdFO0FBQ2hFLHFEQUFxRDtBQUNyRCwwREFBMEQ7QUFDMUQsRUFBRTtBQUNGLDJCQUEyQjtBQUMzQixxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BELEVBQUU7QUFDRixRQUFRO0FBQ1IsdURBQXVEO0FBQ3ZELDJEQUEyRDtBQUMzRCxnREFBZ0Q7QUFDaEQsNEJBQTRCO0FBRXJCLGVBQWVBO0lBQ3BCLElBQUksS0FBNkIsRUFBRSxFQUdsQztJQUVELE1BQU0sRUFDSkcsT0FBTyxFQUNQQyxjQUFjLEVBQ2RDLGdCQUFnQixFQUNoQkMsa0JBQWtCLEVBQ2xCQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLHlCQUF5QixFQUN6QkMsU0FBUyxFQUNWLEdBQUcsTUFBTSxzUUFBK0I7SUFFekMsTUFBTUMsU0FBUyxNQUFNRCxVQUFVRSxZQUFZLENBQUM7SUFDNUNiLFFBQVFjLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNRixPQUFPRyxTQUFTLEVBQUMsRUFBR0MsUUFBUTtJQUVqRSwwRUFBMEU7SUFDMUUsMERBQTBEO0lBQzFELDBFQUEwRTtJQUMxRSxpRUFBaUU7SUFFakUsTUFBTUMsc0JBQXNCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Qy9CLENBQUM7SUFFQywwRUFBMEU7SUFDMUUseUVBQXlFO0lBQ3pFLDBFQUEwRTtJQUMxRWpCLFFBQVFjLEdBQUcsQ0FBQztJQUNaLE1BQU1JLG9CQUFvQmhCLFFBQVFpQixVQUFVLENBQzFDLHlDQUNBQyxTQUFTO0lBRVgsSUFBSUMsaUJBQWlCLE1BQU1ULE9BQU9VLFVBQVUsQ0FBQ0o7SUFDN0MsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDbkIs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dG9yaWFsc1xcbGliXFwzX2luY3JlbWVudENvdW50ZXJDb250cmFjdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUdXRvcmlhbCAzOiBJbmNyZW1lbnQgYSBDb3VudGVyIFNtYXJ0IENvbnRyYWN0XG4vL1xuLy8gQ09OQ0VQVFM6XG4vLyAtIFNtYXJ0IGNvbnRyYWN0cyBpbiBNaWRlbiBhcmUgYWNjb3VudHMgd2l0aCBjdXN0b20gTUFTTSBjb2RlXG4vLyAtIFRyYW5zYWN0aW9uIHNjcmlwdHMgY2FsbCBwcm9jZWR1cmVzIG9uIGNvbnRyYWN0c1xuLy8gLSBUaGUgY291bnRlciBjb250cmFjdCBzdG9yZXMgYSBjb3VudCBpbiBzdG9yYWdlIHNsb3QgMFxuLy9cbi8vIE1BU00gQ09OVFJBQ1QgKGNvdW50ZXIpOlxuLy8gICBnZXRfY291bnQgICDigJQgcmVhZHMgc2xvdCAwIGFuZCByZXR1cm5zIHRoZSB2YWx1ZVxuLy8gICBpbmNyZW1lbnQgICDigJQgcmVhZHMgc2xvdCAwLCBhZGRzIDEsIHdyaXRlcyBiYWNrXG4vL1xuLy8gRkxPVzpcbi8vIDEuIEltcG9ydCB0aGUgZXhpc3RpbmcgY291bnRlciBjb250cmFjdCBmcm9tIHRlc3RuZXRcbi8vIDIuIEJ1aWxkIGEgdHJhbnNhY3Rpb24gc2NyaXB0IHRoYXQgY2FsbHMgaW5jcmVtZW50X2NvdW50XG4vLyAzLiBFeGVjdXRlLCBwcm92ZSwgYW5kIHN1Ym1pdCB0aGUgdHJhbnNhY3Rpb25cbi8vIDQuIFJlYWQgdGhlIHVwZGF0ZWQgY291bnRcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlbWVudENvdW50ZXJDb250cmFjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdUaGlzIG11c3QgcnVuIGluIHRoZSBicm93c2VyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIEFkZHJlc3MsXG4gICAgQWNjb3VudEJ1aWxkZXIsXG4gICAgQWNjb3VudENvbXBvbmVudCxcbiAgICBBY2NvdW50U3RvcmFnZU1vZGUsXG4gICAgQWNjb3VudFR5cGUsXG4gICAgU2VjcmV0S2V5LFxuICAgIFN0b3JhZ2VNYXAsXG4gICAgU3RvcmFnZVNsb3QsXG4gICAgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcixcbiAgICBXZWJDbGllbnQsXG4gIH0gPSBhd2FpdCBpbXBvcnQoJ0BkZW1veC1sYWJzL21pZGVuLXNkaycpO1xuXG4gIGNvbnN0IGNsaWVudCA9IGF3YWl0IFdlYkNsaWVudC5jcmVhdGVDbGllbnQoJ2h0dHBzOi8vcnBjLnRlc3RuZXQubWlkZW4uaW8nKTtcbiAgY29uc29sZS5sb2coJ0N1cnJlbnQgYmxvY2s6JywgKGF3YWl0IGNsaWVudC5zeW5jU3RhdGUoKSkuYmxvY2tOdW0oKSk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGhlIENvdW50ZXIgQ29udHJhY3Qg4oCUIHdyaXR0ZW4gaW4gTWlkZW4gQXNzZW1ibHkgKE1BU00pXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRoaXMgaXMgdGhlIGFjdHVhbCBzbWFydCBjb250cmFjdCBjb2RlLiBMZXQncyB3YWxrIHRocm91Z2ggaXQ6XG5cbiAgY29uc3QgY291bnRlckNvbnRyYWN0Q29kZSA9IGBcbiAgdXNlLm1pZGVuOjphY3RpdmVfYWNjb3VudCAgICMgcmVhZCBzdGF0ZSBvZiB0aGUgYWNjb3VudCBiZWluZyBleGVjdXRlZCBhZ2FpbnN0XG4gIHVzZS5taWRlbjo6bmF0aXZlX2FjY291bnQgICAjIHdyaXRlIHN0YXRlIChzZXRfaXRlbSlcbiAgdXNlLnN0ZDo6c3lzICAgICAgICAgICAgICAgICMgc3lzdGVtIHV0aWxpdGllc1xuXG4gIGNvbnN0LkNPVU5URVJfU0xPVD0wICAgICAgICAjIHN0b3JhZ2Ugc2xvdCBpbmRleCB3aGVyZSB3ZSBrZWVwIHRoZSBjb3VudFxuXG4gICMhIGdldF9jb3VudDogUmVhZCB0aGUgY291bnRlciB2YWx1ZSBmcm9tIHN0b3JhZ2VcbiAgIyEgU3RhY2sgaW5wdXQ6ICBbXVxuICAjISBTdGFjayBvdXRwdXQ6IFtjb3VudF1cbiAgZXhwb3J0LmdldF9jb3VudFxuICAgICAgcHVzaC5DT1VOVEVSX1NMT1QgICAgICAgICAgIyBwdXNoIHNsb3QgaW5kZXggMCBvbnRvIHN0YWNrXG4gICAgICAjID0+IFswXVxuXG4gICAgICBleGVjLmFjdGl2ZV9hY2NvdW50OjpnZXRfaXRlbSAgIyByZWFkIHRoZSB3b3JkIGF0IHNsb3QgMFxuICAgICAgIyA9PiBbdmFsdWUzLCB2YWx1ZTIsIHZhbHVlMSwgdmFsdWUwXVxuICAgICAgIyBBIFwid29yZFwiIGlzIDQgZmllbGQgZWxlbWVudHMuIE91ciBjb3VudCBpcyBpbiB2YWx1ZTAuXG5cbiAgICAgIG1vdmRuLjQgZHJvcHcgICAgICAgICAgICAgICMga2VlcCBvbmx5IHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAjID0+IFtjb3VudF1cbiAgZW5kXG5cbiAgIyEgaW5jcmVtZW50X2NvdW50OiBSZWFkIGNvdW50LCBhZGQgMSwgd3JpdGUgYmFja1xuICAjISBTdGFjayBpbnB1dDogIFtdXG4gICMhIFN0YWNrIG91dHB1dDogW11cbiAgZXhwb3J0LmluY3JlbWVudF9jb3VudFxuICAgICAgcHVzaC5DT1VOVEVSX1NMT1QgICAgICAgICAgIyBwdXNoIHNsb3QgaW5kZXhcbiAgICAgICMgPT4gWzBdXG5cbiAgICAgIGV4ZWMuYWN0aXZlX2FjY291bnQ6OmdldF9pdGVtICAjIHJlYWQgY3VycmVudCB2YWx1ZVxuICAgICAgIyA9PiBbdmFsdWUzLCB2YWx1ZTIsIHZhbHVlMSwgY291bnRdXG5cbiAgICAgIGFkZC4xICAgICAgICAgICAgICAgICAgICAgICMgY291bnQgKyAxXG4gICAgICAjID0+IFt2YWx1ZTMsIHZhbHVlMiwgdmFsdWUxLCBjb3VudCsxXVxuXG4gICAgICBkZWJ1Zy5zdGFjayAgICAgICAgICAgICAgICAjIHByaW50IHN0YWNrICh2aXNpYmxlIGluIGRlYnVnIG1vZGUpXG5cbiAgICAgIHB1c2guQ09VTlRFUl9TTE9UICAgICAgICAgICMgd2hlcmUgdG8gd3JpdGVcbiAgICAgICMgPT4gWzAsIHZhbHVlMywgdmFsdWUyLCB2YWx1ZTEsIGNvdW50KzFdXG5cbiAgICAgIGV4ZWMubmF0aXZlX2FjY291bnQ6OnNldF9pdGVtICAjIHdyaXRlIHRoZSB1cGRhdGVkIHdvcmRcbiAgICAgICMgPT4gW09MRF9WQUxVRV1cblxuICAgICAgZHJvcHcgICAgICAgICAgICAgICAgICAgICAgIyBjbGVhbiB1cFxuICAgICAgIyA9PiBbXVxuICBlbmRcbmA7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3RlcCAxOiBJbXBvcnQgdGhlIGNvdW50ZXIgY29udHJhY3QgdGhhdCdzIGFscmVhZHkgZGVwbG95ZWQgb24gdGVzdG5ldFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zb2xlLmxvZygnXFxuW1N0ZXAgMV0gSW1wb3J0aW5nIGNvdW50ZXIgY29udHJhY3QgZnJvbSB0ZXN0bmV0Li4uJyk7XG4gIGNvbnN0IGNvdW50ZXJDb250cmFjdElkID0gQWRkcmVzcy5mcm9tQmVjaDMyKFxuICAgICdtdHN0MWFyamVtcnhuZThsajVxejRtZzljOG10eXhnOTU0NDgzJyxcbiAgKS5hY2NvdW50SWQoKTtcblxuICBsZXQgY291bnRlckFjY291bnQgPSBhd2FpdCBjbGllbnQuZ2V0QWNjb3VudChjb3VudGVyQ29udHJhY3RJZCk7XG4gIGlmICghY291bnRlckFjY291bnQpIHtcbiAgICBhd2FpdCBjbGllbnQuaW1wb3J0QWNjb3VudEJ5SWQoY291bnRlckNvbnRyYWN0SWQpO1xuICAgIGF3YWl0IGNsaWVudC5zeW5jU3RhdGUoKTtcbiAgICBjb3VudGVyQWNjb3VudCA9IGF3YWl0IGNsaWVudC5nZXRBY2NvdW50KGNvdW50ZXJDb250cmFjdElkKTtcbiAgICBpZiAoIWNvdW50ZXJBY2NvdW50KSB0aHJvdyBuZXcgRXJyb3IoJ0NvdW50ZXIgY29udHJhY3Qgbm90IGZvdW5kJyk7XG4gIH1cbiAgY29uc29sZS5sb2coJ0NvdW50ZXIgY29udHJhY3QgbG9hZGVkLiBDdXJyZW50IHN0b3JhZ2Ugc2xvdCAwOicsXG4gICAgY291bnRlckFjY291bnQuc3RvcmFnZSgpLmdldEl0ZW0oMCk/LnRvSGV4KCkpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0ZXAgMjogQnVpbGQgYW4gYWNjb3VudCB0aGF0IGNhbiBjYWxsIHRoZSBjb3VudGVyIGNvbnRyYWN0XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCAyXSBDcmVhdGluZyBjYWxsZXIgYWNjb3VudC4uLicpO1xuICBjb25zdCBidWlsZGVyID0gY2xpZW50LmNyZWF0ZVNjcmlwdEJ1aWxkZXIoKTtcbiAgY29uc3Qgc3RvcmFnZU1hcCA9IG5ldyBTdG9yYWdlTWFwKCk7XG4gIGNvbnN0IHN0b3JhZ2VTbG90TWFwID0gU3RvcmFnZVNsb3QubWFwKHN0b3JhZ2VNYXApO1xuXG4gIGNvbnN0IGNvbXBvbmVudCA9IEFjY291bnRDb21wb25lbnQuY29tcGlsZShcbiAgICBjb3VudGVyQ29udHJhY3RDb2RlLCBidWlsZGVyLCBbc3RvcmFnZVNsb3RNYXBdLFxuICApLndpdGhTdXBwb3J0c0FsbFR5cGVzKCk7XG5cbiAgY29uc3Qgd2FsbGV0U2VlZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh3YWxsZXRTZWVkKTtcbiAgY29uc3Qgc2VjcmV0S2V5ID0gU2VjcmV0S2V5LnJwb0ZhbGNvbldpdGhSTkcod2FsbGV0U2VlZCk7XG4gIGNvbnN0IGF1dGhDb21wb25lbnQgPSBBY2NvdW50Q29tcG9uZW50LmNyZWF0ZUF1dGhDb21wb25lbnQoc2VjcmV0S2V5KTtcblxuICBjb25zdCByZXN1bHQgPSBuZXcgQWNjb3VudEJ1aWxkZXIod2FsbGV0U2VlZClcbiAgICAuYWNjb3VudFR5cGUoQWNjb3VudFR5cGUuUmVndWxhckFjY291bnRJbW11dGFibGVDb2RlKVxuICAgIC5zdG9yYWdlTW9kZShBY2NvdW50U3RvcmFnZU1vZGUucHVibGljKCkpXG4gICAgLndpdGhBdXRoQ29tcG9uZW50KGF1dGhDb21wb25lbnQpXG4gICAgLndpdGhDb21wb25lbnQoY29tcG9uZW50KVxuICAgIC5idWlsZCgpO1xuXG4gIGF3YWl0IGNsaWVudC5hZGRBY2NvdW50U2VjcmV0S2V5VG9XZWJTdG9yZShzZWNyZXRLZXkpO1xuICBhd2FpdCBjbGllbnQubmV3QWNjb3VudChyZXN1bHQuYWNjb3VudCwgZmFsc2UpO1xuICBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG4gIGNvbnNvbGUubG9nKCdDYWxsZXIgYWNjb3VudDonLCByZXN1bHQuYWNjb3VudC5pZCgpLnRvU3RyaW5nKCkpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0ZXAgMzogQnVpbGQgdGhlIHRyYW5zYWN0aW9uIHNjcmlwdFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGlzIHNjcmlwdCB0ZWxscyB0aGUgVk06IFwiY2FsbCBpbmNyZW1lbnRfY291bnQgb24gdGhlIGNvdW50ZXIgY29udHJhY3RcIlxuICBjb25zb2xlLmxvZygnXFxuW1N0ZXAgM10gQnVpbGRpbmcgYW5kIGV4ZWN1dGluZyB0cmFuc2FjdGlvbiBzY3JpcHQuLi4nKTtcblxuICBjb25zdCBhY2NvdW50Q29kZUxpYiA9IGJ1aWxkZXIuYnVpbGRMaWJyYXJ5KFxuICAgICdleHRlcm5hbF9jb250cmFjdDo6Y291bnRlcl9jb250cmFjdCcsXG4gICAgY291bnRlckNvbnRyYWN0Q29kZSxcbiAgKTtcbiAgYnVpbGRlci5saW5rRHluYW1pY0xpYnJhcnkoYWNjb3VudENvZGVMaWIpO1xuXG4gIGNvbnN0IHR4U2NyaXB0Q29kZSA9IGBcbnVzZS5leHRlcm5hbF9jb250cmFjdDo6Y291bnRlcl9jb250cmFjdFxuYmVnaW5cbiAgICBjYWxsLmNvdW50ZXJfY29udHJhY3Q6OmluY3JlbWVudF9jb3VudFxuZW5kXG5gO1xuXG4gIGNvbnN0IHR4U2NyaXB0ID0gYnVpbGRlci5jb21waWxlVHhTY3JpcHQodHhTY3JpcHRDb2RlKTtcbiAgY29uc3QgdHhSZXF1ZXN0ID0gbmV3IFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIoKVxuICAgIC53aXRoQ3VzdG9tU2NyaXB0KHR4U2NyaXB0KVxuICAgIC5idWlsZCgpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0ZXAgNDogRXhlY3V0ZSwgcHJvdmUsIHN1Ym1pdFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhd2FpdCBjbGllbnQuc3VibWl0TmV3VHJhbnNhY3Rpb24oY291bnRlckFjY291bnQuaWQoKSwgdHhSZXF1ZXN0KTtcbiAgYXdhaXQgY2xpZW50LnN5bmNTdGF0ZSgpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0ZXAgNTogUmVhZCB0aGUgdXBkYXRlZCBjb3VudFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zdCB1cGRhdGVkID0gYXdhaXQgY2xpZW50LmdldEFjY291bnQoY291bnRlckFjY291bnQuaWQoKSk7XG4gIGNvbnN0IGNvdW50SGV4ID0gdXBkYXRlZD8uc3RvcmFnZSgpLmdldEl0ZW0oMCk7XG5cbiAgaWYgKGNvdW50SGV4KSB7XG4gICAgY29uc3QgY291bnRlclZhbHVlID0gTnVtYmVyKFxuICAgICAgQmlnSW50KCcweCcgKyBjb3VudEhleC50b0hleCgpLnNsaWNlKC0xNikubWF0Y2goLy4uL2cpIS5yZXZlcnNlKCkuam9pbignJykpLFxuICAgICk7XG4gICAgY29uc29sZS5sb2coJ1xcbkNvdW50ZXIgdmFsdWUgYWZ0ZXIgaW5jcmVtZW50OicsIGNvdW50ZXJWYWx1ZSk7XG4gIH1cblxuICBjb25zb2xlLmxvZygnXFxuPT09IFR1dG9yaWFsIDMgQ29tcGxldGUgPT09Jyk7XG4gIGNvbnNvbGUubG9nKCdZb3UgbGVhcm5lZDonKTtcbiAgY29uc29sZS5sb2coJyAgLSBNQVNNIHNtYXJ0IGNvbnRyYWN0cyBzdG9yZSBzdGF0ZSBpbiBudW1iZXJlZCBzbG90cycpO1xuICBjb25zb2xlLmxvZygnICAtIGdldF9pdGVtIC8gc2V0X2l0ZW0gcmVhZCBhbmQgd3JpdGUgc3RvcmFnZScpO1xuICBjb25zb2xlLmxvZygnICAtIFRyYW5zYWN0aW9uIHNjcmlwdHMgY2FsbCBwcm9jZWR1cmVzIG9uIGNvbnRyYWN0cycpO1xuICBjb25zb2xlLmxvZygnICAtIFRoZSBjb3VudGVyIGluY3JlbWVudGVkIG9uIHRoZSBsaXZlIHRlc3RuZXQhJyk7XG4gIGNvbnNvbGUubG9nKCdOZXh0OiBSdW4gVHV0b3JpYWwgNCBmb3IgdW5hdXRoZW50aWNhdGVkIG5vdGUgdHJhbnNmZXJzLicpO1xufVxuIl0sIm5hbWVzIjpbImluY3JlbWVudENvdW50ZXJDb250cmFjdCIsImNvbnNvbGUiLCJ3YXJuIiwiQWRkcmVzcyIsIkFjY291bnRCdWlsZGVyIiwiQWNjb3VudENvbXBvbmVudCIsIkFjY291bnRTdG9yYWdlTW9kZSIsIkFjY291bnRUeXBlIiwiU2VjcmV0S2V5IiwiU3RvcmFnZU1hcCIsIlN0b3JhZ2VTbG90IiwiVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlciIsIldlYkNsaWVudCIsImNsaWVudCIsImNyZWF0ZUNsaWVudCIsImxvZyIsInN5bmNTdGF0ZSIsImJsb2NrTnVtIiwiY291bnRlckNvbnRyYWN0Q29kZSIsImNvdW50ZXJDb250cmFjdElkIiwiZnJvbUJlY2gzMiIsImFjY291bnRJZCIsImNvdW50ZXJBY2NvdW50IiwiZ2V0QWNjb3VudCIsImltcG9ydEFjY291bnRCeUlkIiwiRXJyb3IiLCJzdG9yYWdlIiwiZ2V0SXRlbSIsInRvSGV4IiwiYnVpbGRlciIsImNyZWF0ZVNjcmlwdEJ1aWxkZXIiLCJzdG9yYWdlTWFwIiwic3RvcmFnZVNsb3RNYXAiLCJtYXAiLCJjb21wb25lbnQiLCJjb21waWxlIiwid2l0aFN1cHBvcnRzQWxsVHlwZXMiLCJ3YWxsZXRTZWVkIiwiVWludDhBcnJheSIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInNlY3JldEtleSIsInJwb0ZhbGNvbldpdGhSTkciLCJhdXRoQ29tcG9uZW50IiwiY3JlYXRlQXV0aENvbXBvbmVudCIsInJlc3VsdCIsImFjY291bnRUeXBlIiwiUmVndWxhckFjY291bnRJbW11dGFibGVDb2RlIiwic3RvcmFnZU1vZGUiLCJwdWJsaWMiLCJ3aXRoQXV0aENvbXBvbmVudCIsIndpdGhDb21wb25lbnQiLCJidWlsZCIsImFkZEFjY291bnRTZWNyZXRLZXlUb1dlYlN0b3JlIiwibmV3QWNjb3VudCIsImFjY291bnQiLCJpZCIsInRvU3RyaW5nIiwiYWNjb3VudENvZGVMaWIiLCJidWlsZExpYnJhcnkiLCJsaW5rRHluYW1pY0xpYnJhcnkiLCJ0eFNjcmlwdENvZGUiLCJ0eFNjcmlwdCIsImNvbXBpbGVUeFNjcmlwdCIsInR4UmVxdWVzdCIsIndpdGhDdXN0b21TY3JpcHQiLCJzdWJtaXROZXdUcmFuc2FjdGlvbiIsInVwZGF0ZWQiLCJjb3VudEhleCIsImNvdW50ZXJWYWx1ZSIsIk51bWJlciIsIkJpZ0ludCIsInNsaWNlIiwibWF0Y2giLCJyZXZlcnNlIiwiam9pbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/3_incrementCounterContract.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/4_unauthenticatedNoteTransfer.ts":
/*!**********************************************!*\
  !*** ./lib/4_unauthenticatedNoteTransfer.ts ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unauthenticatedNoteTransfer: () => (/* binding */ unauthenticatedNoteTransfer)\n/* harmony export */ });\n// Tutorial 4: Unauthenticated Note Transfer Chain\n//\n// CONCEPTS:\n// - Unauthenticated notes can be created AND consumed in the same block\n// - This enables faster-than-blocktime settlement\n// - Uses delegated proving (offloads ZK proof generation to a remote server)\n// - Great for: order books, payment channels, micropayments\n//\n// FLOW:\n// Alice -> Wallet1 -> Wallet2 -> Wallet3 -> Wallet4 -> Wallet5\n// Each hop creates a P2ID note and immediately consumes it\nasync function unauthenticatedNoteTransfer() {\n    if (false) {}\n    const { WebClient, AccountStorageMode, NoteType, TransactionProver, Note, NoteAssets, MidenArrays, Felt, FungibleAsset, NoteAndArgsArray, NoteAndArgs, TransactionRequestBuilder, OutputNote } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_demox-labs_miden-sdk_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @demox-labs/miden-sdk */ \"(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/index.js\"));\n    // --- Setup with delegated prover ---\n    // Delegated proving = offload ZK proof generation to a fast server\n    // Trustless: the prover can't steal funds, but sees transaction details\n    const client = await WebClient.createClient('https://rpc.testnet.miden.io');\n    const prover = TransactionProver.newRemoteProver('https://tx-prover.testnet.miden.io');\n    console.log('Latest block:', (await client.syncState()).blockNum());\n    // --- Create accounts ---\n    console.log('\\n[Step 1] Creating Alice + 5 wallets...');\n    const alice = await client.newWallet(AccountStorageMode.public(), true, 0);\n    console.log('Alice:', alice.id().toString());\n    const wallets = [];\n    for(let i = 0; i < 5; i++){\n        const w = await client.newWallet(AccountStorageMode.public(), true, 0);\n        wallets.push(w);\n        console.log(`Wallet ${i + 1}:`, w.id().toString());\n    }\n    // --- Create faucet and fund Alice ---\n    console.log('\\n[Step 2] Creating faucet + minting to Alice...');\n    const faucet = await client.newFaucet(AccountStorageMode.public(), false, 'MID', 8, BigInt(1000000), 0);\n    console.log('Faucet:', faucet.id().toString());\n    // Mint using delegated prover (faster in browser)\n    {\n        const txResult = await client.executeTransaction(faucet.id(), client.newMintTransactionRequest(alice.id(), faucet.id(), NoteType.Public, BigInt(10000)));\n        const proven = await client.proveTransaction(txResult, prover);\n        const height = await client.submitProvenTransaction(proven, txResult);\n        await client.applyTransaction(txResult, height);\n    }\n    console.log('Waiting 7s for settlement...');\n    await new Promise((r)=>setTimeout(r, 7000));\n    await client.syncState();\n    // Consume minted notes\n    console.log('\\n[Step 3] Consuming minted notes...');\n    const noteIds = (await client.getConsumableNotes(alice.id())).map((rec)=>rec.inputNoteRecord().id().toString());\n    {\n        const txResult = await client.executeTransaction(alice.id(), client.newConsumeTransactionRequest(noteIds));\n        const proven = await client.proveTransaction(txResult, prover);\n        const height = await client.submitProvenTransaction(proven, txResult);\n        await client.applyTransaction(txResult, height);\n        await client.syncState();\n    }\n    // --- Transfer chain with unauthenticated notes ---\n    // Each iteration: create P2ID note from sender, immediately consume on receiver\n    // No waiting for block confirmation between create and consume!\n    console.log('\\n[Step 4] Unauthenticated transfer chain...');\n    console.log('Alice -> W1 -> W2 -> W3 -> W4 -> W5\\n');\n    const startTime = Date.now();\n    for(let i = 0; i < wallets.length; i++){\n        const sender = i === 0 ? alice : wallets[i - 1];\n        const receiver = wallets[i];\n        console.log(`--- Hop ${i + 1}: ${sender.id().toString().slice(0, 10)} -> ${receiver.id().toString().slice(0, 10)} ---`);\n        // Build a P2ID note with 50 MID\n        const assets = new NoteAssets([\n            new FungibleAsset(faucet.id(), BigInt(50))\n        ]);\n        const p2idNote = Note.createP2IDNote(sender.id(), receiver.id(), assets, NoteType.Public, new Felt(BigInt(0)));\n        // Create the note (sender's transaction)\n        console.log('  Creating note...');\n        {\n            const txResult = await client.executeTransaction(sender.id(), new TransactionRequestBuilder().withOwnOutputNotes(new MidenArrays.OutputNoteArray([\n                OutputNote.full(p2idNote)\n            ])).build());\n            const proven = await client.proveTransaction(txResult, prover);\n            const height = await client.submitProvenTransaction(proven, txResult);\n            await client.applyTransaction(txResult, height);\n        }\n        // Consume the note AS UNAUTHENTICATED (no block wait!)\n        // This is the key difference — withUnauthenticatedInputNotes\n        console.log('  Consuming (unauthenticated)...');\n        {\n            const consumeRequest = new TransactionRequestBuilder().withUnauthenticatedInputNotes(new NoteAndArgsArray([\n                new NoteAndArgs(p2idNote, null)\n            ])).build();\n            const txResult = await client.executeTransaction(receiver.id(), consumeRequest);\n            const proven = await client.proveTransaction(txResult, prover);\n            const height = await client.submitProvenTransaction(proven, txResult);\n            const execResult = await client.applyTransaction(txResult, height);\n            const txId = execResult.executedTransaction().id().toHex().toString();\n            console.log(`  TX: https://testnet.midenscan.com/tx/${txId}`);\n        }\n    }\n    const elapsed = Date.now() - startTime;\n    console.log(`\\nTotal chain time: ${elapsed}ms (${wallets.length} hops)`);\n    console.log('\\n=== Tutorial 4 Complete ===');\n    console.log('You learned:');\n    console.log('  - Unauthenticated notes skip block confirmation');\n    console.log('  - Create + consume in same batch = sub-blocktime settlement');\n    console.log('  - Delegated proving speeds up browser-based ZK proofs');\n    console.log('  - This pattern enables DEX order books and payment channels');\n    console.log('Next: Run Tutorial 5 for cross-contract calls (FPI).');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi80X3VuYXV0aGVudGljYXRlZE5vdGVUcmFuc2Zlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixZQUFZO0FBQ1osd0VBQXdFO0FBQ3hFLGtEQUFrRDtBQUNsRCw2RUFBNkU7QUFDN0UsNERBQTREO0FBQzVELEVBQUU7QUFDRixRQUFRO0FBQ1IsK0RBQStEO0FBQy9ELDJEQUEyRDtBQUVwRCxlQUFlQTtJQUNwQixJQUFJLEtBQTZCLEVBQUUsRUFHbEM7SUFFRCxNQUFNLEVBQ0pHLFNBQVMsRUFDVEMsa0JBQWtCLEVBQ2xCQyxRQUFRLEVBQ1JDLGlCQUFpQixFQUNqQkMsSUFBSSxFQUNKQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsSUFBSSxFQUNKQyxhQUFhLEVBQ2JDLGdCQUFnQixFQUNoQkMsV0FBVyxFQUNYQyx5QkFBeUIsRUFDekJDLFVBQVUsRUFDWCxHQUFHLE1BQU0sc1FBQStCO0lBRXpDLHNDQUFzQztJQUN0QyxtRUFBbUU7SUFDbkUsd0VBQXdFO0lBQ3hFLE1BQU1DLFNBQVMsTUFBTWIsVUFBVWMsWUFBWSxDQUFDO0lBQzVDLE1BQU1DLFNBQVNaLGtCQUFrQmEsZUFBZSxDQUM5QztJQUVGbEIsUUFBUW1CLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNSixPQUFPSyxTQUFTLEVBQUMsRUFBR0MsUUFBUTtJQUVoRSwwQkFBMEI7SUFDMUJyQixRQUFRbUIsR0FBRyxDQUFDO0lBQ1osTUFBTUcsUUFBUSxNQUFNUCxPQUFPUSxTQUFTLENBQUNwQixtQkFBbUJxQixNQUFNLElBQUksTUFBTTtJQUN4RXhCLFFBQVFtQixHQUFHLENBQUMsVUFBVUcsTUFBTUcsRUFBRSxHQUFHQyxRQUFRO0lBRXpDLE1BQU1DLFVBQVUsRUFBRTtJQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQzFCLE1BQU1DLElBQUksTUFBTWQsT0FBT1EsU0FBUyxDQUFDcEIs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UW1CLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFcUQsUUFBUSxJQUFJLEVBQUU3QyxRQUFRNEIsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUV2RXZELFFBQVFtQixHQUFHLENBQUM7SUFDWm5CLFFBQVFtQixHQUFHLENBQUM7SUFDWm5CLFFBQVFtQixHQUFHLENBQUM7SUFDWm5CLFFBQVFtQixHQUFHLENBQUM7SUFDWm5CLFFBQVFtQixHQUFHLENBQUM7SUFDWm5CLFFBQVFtQixHQUFHLENBQUM7SUFDWm5CLFFBQVFtQixHQUFHLENBQUM7QUFDZCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxERUxMXFxEZXNrdG9wXFxjcmFiZGFvLWFnZW50XFxtaWRlbi13ZWItdHV0b3JpYWxzXFxsaWJcXDRfdW5hdXRoZW50aWNhdGVkTm90ZVRyYW5zZmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFR1dG9yaWFsIDQ6IFVuYXV0aGVudGljYXRlZCBOb3RlIFRyYW5zZmVyIENoYWluXG4vL1xuLy8gQ09OQ0VQVFM6XG4vLyAtIFVuYXV0aGVudGljYXRlZCBub3RlcyBjYW4gYmUgY3JlYXRlZCBBTkQgY29uc3VtZWQgaW4gdGhlIHNhbWUgYmxvY2tcbi8vIC0gVGhpcyBlbmFibGVzIGZhc3Rlci10aGFuLWJsb2NrdGltZSBzZXR0bGVtZW50XG4vLyAtIFVzZXMgZGVsZWdhdGVkIHByb3ZpbmcgKG9mZmxvYWRzIFpLIHByb29mIGdlbmVyYXRpb24gdG8gYSByZW1vdGUgc2VydmVyKVxuLy8gLSBHcmVhdCBmb3I6IG9yZGVyIGJvb2tzLCBwYXltZW50IGNoYW5uZWxzLCBtaWNyb3BheW1lbnRzXG4vL1xuLy8gRkxPVzpcbi8vIEFsaWNlIC0+IFdhbGxldDEgLT4gV2FsbGV0MiAtPiBXYWxsZXQzIC0+IFdhbGxldDQgLT4gV2FsbGV0NVxuLy8gRWFjaCBob3AgY3JlYXRlcyBhIFAySUQgbm90ZSBhbmQgaW1tZWRpYXRlbHkgY29uc3VtZXMgaXRcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuYXV0aGVudGljYXRlZE5vdGVUcmFuc2ZlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdUaGlzIG11c3QgcnVuIGluIHRoZSBicm93c2VyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIFdlYkNsaWVudCxcbiAgICBBY2NvdW50U3RvcmFnZU1vZGUsXG4gICAgTm90ZVR5cGUsXG4gICAgVHJhbnNhY3Rpb25Qcm92ZXIsXG4gICAgTm90ZSxcbiAgICBOb3RlQXNzZXRzLFxuICAgIE1pZGVuQXJyYXlzLFxuICAgIEZlbHQsXG4gICAgRnVuZ2libGVBc3NldCxcbiAgICBOb3RlQW5kQXJnc0FycmF5LFxuICAgIE5vdGVBbmRBcmdzLFxuICAgIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIsXG4gICAgT3V0cHV0Tm90ZSxcbiAgfSA9IGF3YWl0IGltcG9ydCgnQGRlbW94LWxhYnMvbWlkZW4tc2RrJyk7XG5cbiAgLy8gLS0tIFNldHVwIHdpdGggZGVsZWdhdGVkIHByb3ZlciAtLS1cbiAgLy8gRGVsZWdhdGVkIHByb3ZpbmcgPSBvZmZsb2FkIFpLIHByb29mIGdlbmVyYXRpb24gdG8gYSBmYXN0IHNlcnZlclxuICAvLyBUcnVzdGxlc3M6IHRoZSBwcm92ZXIgY2FuJ3Qgc3RlYWwgZnVuZHMsIGJ1dCBzZWVzIHRyYW5zYWN0aW9uIGRldGFpbHNcbiAgY29uc3QgY2xpZW50ID0gYXdhaXQgV2ViQ2xpZW50LmNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9ycGMudGVzdG5ldC5taWRlbi5pbycpO1xuICBjb25zdCBwcm92ZXIgPSBUcmFuc2FjdGlvblByb3Zlci5uZXdSZW1vdGVQcm92ZXIoXG4gICAgJ2h0dHBzOi8vdHgtcHJvdmVyLnRlc3RuZXQubWlkZW4uaW8nLFxuICApO1xuICBjb25zb2xlLmxvZygnTGF0ZXN0IGJsb2NrOicsIChhd2FpdCBjbGllbnQuc3luY1N0YXRlKCkpLmJsb2NrTnVtKCkpO1xuXG4gIC8vIC0tLSBDcmVhdGUgYWNjb3VudHMgLS0tXG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCAxXSBDcmVhdGluZyBBbGljZSArIDUgd2FsbGV0cy4uLicpO1xuICBjb25zdCBhbGljZSA9IGF3YWl0IGNsaWVudC5uZXdXYWxsZXQoQWNjb3VudFN0b3JhZ2VNb2RlLnB1YmxpYygpLCB0cnVlLCAwKTtcbiAgY29uc29sZS5sb2coJ0FsaWNlOicsIGFsaWNlLmlkKCkudG9TdHJpbmcoKSk7XG5cbiAgY29uc3Qgd2FsbGV0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIGNvbnN0IHcgPSBhd2FpdCBjbGllbnQubmV3V2FsbGV0KEFjY291bnRTdG9yYWdlTW9kZS5wdWJsaWMoKSwgdHJ1ZSwgMCk7XG4gICAgd2FsbGV0cy5wdXNoKHcpO1xuICAgIGNvbnNvbGUubG9nKGBXYWxsZXQgJHtpICsgMX06YCwgdy5pZCgpLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLy8gLS0tIENyZWF0ZSBmYXVjZXQgYW5kIGZ1bmQgQWxpY2UgLS0tXG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCAyXSBDcmVhdGluZyBmYXVjZXQgKyBtaW50aW5nIHRvIEFsaWNlLi4uJyk7XG4gIGNvbnN0IGZhdWNldCA9IGF3YWl0IGNsaWVudC5uZXdGYXVjZXQoXG4gICAgQWNjb3VudFN0b3JhZ2VNb2RlLnB1YmxpYygpLCBmYWxzZSwgJ01JRCcsIDgsIEJpZ0ludCgxXzAwMF8wMDApLCAwLFxuICApO1xuICBjb25zb2xlLmxvZygnRmF1Y2V0OicsIGZhdWNldC5pZCgpLnRvU3RyaW5nKCkpO1xuXG4gIC8vIE1pbnQgdXNpbmcgZGVsZWdhdGVkIHByb3ZlciAoZmFzdGVyIGluIGJyb3dzZXIpXG4gIHtcbiAgICBjb25zdCB0eFJlc3VsdCA9IGF3YWl0IGNsaWVudC5leGVjdXRlVHJhbnNhY3Rpb24oXG4gICAgICBmYXVjZXQuaWQoKSxcbiAgICAgIGNsaWVudC5uZXdNaW50VHJhbnNhY3Rpb25SZXF1ZXN0KFxuICAgICAgICBhbGljZS5pZCgpLCBmYXVjZXQuaWQoKSwgTm90ZVR5cGUuUHVibGljLCBCaWdJbnQoMTBfMDAwKSxcbiAgICAgICksXG4gICAgKTtcbiAgICBjb25zdCBwcm92ZW4gPSBhd2FpdCBjbGllbnQucHJvdmVUcmFuc2FjdGlvbih0eFJlc3VsdCwgcHJvdmVyKTtcbiAgICBjb25zdCBoZWlnaHQgPSBhd2FpdCBjbGllbnQuc3VibWl0UHJvdmVuVHJhbnNhY3Rpb24ocHJvdmVuLCB0eFJlc3VsdCk7XG4gICAgYXdhaXQgY2xpZW50LmFwcGx5VHJhbnNhY3Rpb24odHhSZXN1bHQsIGhlaWdodCk7XG4gIH1cblxuICBjb25zb2xlLmxvZygnV2FpdGluZyA3cyBmb3Igc2V0dGxlbWVudC4uLicpO1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCA3MDAwKSk7XG4gIGF3YWl0IGNsaWVudC5zeW5jU3RhdGUoKTtcblxuICAvLyBDb25zdW1lIG1pbnRlZCBub3Rlc1xuICBjb25zb2xlLmxvZygnXFxuW1N0ZXAgM10gQ29uc3VtaW5nIG1pbnRlZCBub3Rlcy4uLicpO1xuICBjb25zdCBub3RlSWRzID0gKGF3YWl0IGNsaWVudC5nZXRDb25zdW1hYmxlTm90ZXMoYWxpY2UuaWQoKSkpLm1hcCgocmVjKSA9PlxuICAgIHJlYy5pbnB1dE5vdGVSZWNvcmQoKS5pZCgpLnRvU3RyaW5nKCksXG4gICk7XG4gIHtcbiAgICBjb25zdCB0eFJlc3VsdCA9IGF3YWl0IGNsaWVudC5leGVjdXRlVHJhbnNhY3Rpb24oXG4gICAgICBhbGljZS5pZCgpLFxuICAgICAgY2xpZW50Lm5ld0NvbnN1bWVUcmFuc2FjdGlvblJlcXVlc3Qobm90ZUlkcyksXG4gICAgKTtcbiAgICBjb25zdCBwcm92ZW4gPSBhd2FpdCBjbGllbnQucHJvdmVUcmFuc2FjdGlvbih0eFJlc3VsdCwgcHJvdmVyKTtcbiAgICBjb25zdCBoZWlnaHQgPSBhd2FpdCBjbGllbnQuc3VibWl0UHJvdmVuVHJhbnNhY3Rpb24ocHJvdmVuLCB0eFJlc3VsdCk7XG4gICAgYXdhaXQgY2xpZW50LmFwcGx5VHJhbnNhY3Rpb24odHhSZXN1bHQsIGhlaWdodCk7XG4gICAgYXdhaXQgY2xpZW50LnN5bmNTdGF0ZSgpO1xuICB9XG5cbiAgLy8gLS0tIFRyYW5zZmVyIGNoYWluIHdpdGggdW5hdXRoZW50aWNhdGVkIG5vdGVzIC0tLVxuICAvLyBFYWNoIGl0ZXJhdGlvbjogY3JlYXRlIFAySUQgbm90ZSBmcm9tIHNlbmRlciwgaW1tZWRpYXRlbHkgY29uc3VtZSBvbiByZWNlaXZlclxuICAvLyBObyB3YWl0aW5nIGZvciBibG9jayBjb25maXJtYXRpb24gYmV0d2VlbiBjcmVhdGUgYW5kIGNvbnN1bWUhXG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCA0XSBVbmF1dGhlbnRpY2F0ZWQgdHJhbnNmZXIgY2hhaW4uLi4nKTtcbiAgY29uc29sZS5sb2coJ0FsaWNlIC0+IFcxIC0+IFcyIC0+IFczIC0+IFc0IC0+IFc1XFxuJyk7XG5cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHdhbGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZW5kZXIgPSBpID09PSAwID8gYWxpY2UgOiB3YWxsZXRzW2kgLSAxXTtcbiAgICBjb25zdCByZWNlaXZlciA9IHdhbGxldHNbaV07XG4gICAgY29uc29sZS5sb2coYC0tLSBIb3AgJHtpICsgMX06ICR7c2VuZGVyLmlkKCkudG9TdHJpbmcoKS5zbGljZSgwLCAxMCl9IC0+ICR7cmVjZWl2ZXIuaWQoKS50b1N0cmluZygpLnNsaWNlKDAsIDEwKX0gLS0tYCk7XG5cbiAgICAvLyBCdWlsZCBhIFAySUQgbm90ZSB3aXRoIDUwIE1JRFxuICAgIGNvbnN0IGFzc2V0cyA9IG5ldyBOb3RlQXNzZXRzKFtuZXcgRnVuZ2libGVBc3NldChmYXVjZXQuaWQoKSwgQmlnSW50KDUwKSldKTtcbiAgICBjb25zdCBwMmlkTm90ZSA9IE5vdGUuY3JlYXRlUDJJRE5vdGUoXG4gICAgICBzZW5kZXIuaWQoKSwgcmVjZWl2ZXIuaWQoKSwgYXNzZXRzLCBOb3RlVHlwZS5QdWJsaWMsIG5ldyBGZWx0KEJpZ0ludCgwKSksXG4gICAgKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgbm90ZSAoc2VuZGVyJ3MgdHJhbnNhY3Rpb24pXG4gICAgY29uc29sZS5sb2coJyAgQ3JlYXRpbmcgbm90ZS4uLicpO1xuICAgIHtcbiAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgY2xpZW50LmV4ZWN1dGVUcmFuc2FjdGlvbihcbiAgICAgICAgc2VuZGVyLmlkKCksXG4gICAgICAgIG5ldyBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyKClcbiAgICAgICAgICAud2l0aE93bk91dHB1dE5vdGVzKG5ldyBNaWRlbkFycmF5cy5PdXRwdXROb3RlQXJyYXkoW091dHB1dE5vdGUuZnVsbChwMmlkTm90ZSldKSlcbiAgICAgICAgICAuYnVpbGQoKSxcbiAgICAgICk7XG4gICAgICBjb25zdCBwcm92ZW4gPSBhd2FpdCBjbGllbnQucHJvdmVUcmFuc2FjdGlvbih0eFJlc3VsdCwgcHJvdmVyKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGF3YWl0IGNsaWVudC5zdWJtaXRQcm92ZW5UcmFuc2FjdGlvbihwcm92ZW4sIHR4UmVzdWx0KTtcbiAgICAgIGF3YWl0IGNsaWVudC5hcHBseVRyYW5zYWN0aW9uKHR4UmVzdWx0LCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgdGhlIG5vdGUgQVMgVU5BVVRIRU5USUNBVEVEIChubyBibG9jayB3YWl0ISlcbiAgICAvLyBUaGlzIGlzIHRoZSBrZXkgZGlmZmVyZW5jZSDigJQgd2l0aFVuYXV0aGVudGljYXRlZElucHV0Tm90ZXNcbiAgICBjb25zb2xlLmxvZygnICBDb25zdW1pbmcgKHVuYXV0aGVudGljYXRlZCkuLi4nKTtcbiAgICB7XG4gICAgICBjb25zdCBjb25zdW1lUmVxdWVzdCA9IG5ldyBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyKClcbiAgICAgICAgLndpdGhVbmF1dGhlbnRpY2F0ZWRJbnB1dE5vdGVzKFxuICAgICAgICAgIG5ldyBOb3RlQW5kQXJnc0FycmF5KFtuZXcgTm90ZUFuZEFyZ3MocDJpZE5vdGUsIG51bGwpXSksXG4gICAgICAgIClcbiAgICAgICAgLmJ1aWxkKCk7XG5cbiAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgY2xpZW50LmV4ZWN1dGVUcmFuc2FjdGlvbihyZWNlaXZlci5pZCgpLCBjb25zdW1lUmVxdWVzdCk7XG4gICAgICBjb25zdCBwcm92ZW4gPSBhd2FpdCBjbGllbnQucHJvdmVUcmFuc2FjdGlvbih0eFJlc3VsdCwgcHJvdmVyKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGF3YWl0IGNsaWVudC5zdWJtaXRQcm92ZW5UcmFuc2FjdGlvbihwcm92ZW4sIHR4UmVzdWx0KTtcbiAgICAgIGNvbnN0IGV4ZWNSZXN1bHQgPSBhd2FpdCBjbGllbnQuYXBwbHlUcmFuc2FjdGlvbih0eFJlc3VsdCwgaGVpZ2h0KTtcblxuICAgICAgY29uc3QgdHhJZCA9IGV4ZWNSZXN1bHQuZXhlY3V0ZWRUcmFuc2FjdGlvbigpLmlkKCkudG9IZXgoKS50b1N0cmluZygpO1xuICAgICAgY29uc29sZS5sb2coYCAgVFg6IGh0dHBzOi8vdGVzdG5ldC5taWRlbnNjYW4uY29tL3R4LyR7dHhJZH1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgY29uc29sZS5sb2coYFxcblRvdGFsIGNoYWluIHRpbWU6ICR7ZWxhcHNlZH1tcyAoJHt3YWxsZXRzLmxlbmd0aH0gaG9wcylgKTtcblxuICBjb25zb2xlLmxvZygnXFxuPT09IFR1dG9yaWFsIDQgQ29tcGxldGUgPT09Jyk7XG4gIGNvbnNvbGUubG9nKCdZb3UgbGVhcm5lZDonKTtcbiAgY29uc29sZS5sb2coJyAgLSBVbmF1dGhlbnRpY2F0ZWQgbm90ZXMgc2tpcCBibG9jayBjb25maXJtYXRpb24nKTtcbiAgY29uc29sZS5sb2coJyAgLSBDcmVhdGUgKyBjb25zdW1lIGluIHNhbWUgYmF0Y2ggPSBzdWItYmxvY2t0aW1lIHNldHRsZW1lbnQnKTtcbiAgY29uc29sZS5sb2coJyAgLSBEZWxlZ2F0ZWQgcHJvdmluZyBzcGVlZHMgdXAgYnJvd3Nlci1iYXNlZCBaSyBwcm9vZnMnKTtcbiAgY29uc29sZS5sb2coJyAgLSBUaGlzIHBhdHRlcm4gZW5hYmxlcyBERVggb3JkZXIgYm9va3MgYW5kIHBheW1lbnQgY2hhbm5lbHMnKTtcbiAgY29uc29sZS5sb2coJ05leHQ6IFJ1biBUdXRvcmlhbCA1IGZvciBjcm9zcy1jb250cmFjdCBjYWxscyAoRlBJKS4nKTtcbn1cbiJdLCJuYW1lcyI6WyJ1bmF1dGhlbnRpY2F0ZWROb3RlVHJhbnNmZXIiLCJjb25zb2xlIiwid2FybiIsIldlYkNsaWVudCIsIkFjY291bnRTdG9yYWdlTW9kZSIsIk5vdGVUeXBlIiwiVHJhbnNhY3Rpb25Qcm92ZXIiLCJOb3RlIiwiTm90ZUFzc2V0cyIsIk1pZGVuQXJyYXlzIiwiRmVsdCIsIkZ1bmdpYmxlQXNzZXQiLCJOb3RlQW5kQXJnc0FycmF5IiwiTm90ZUFuZEFyZ3MiLCJUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyIiwiT3V0cHV0Tm90ZSIsImNsaWVudCIsImNyZWF0ZUNsaWVudCIsInByb3ZlciIsIm5ld1JlbW90ZVByb3ZlciIsImxvZyIsInN5bmNTdGF0ZSIsImJsb2NrTnVtIiwiYWxpY2UiLCJuZXdXYWxsZXQiLCJwdWJsaWMiLCJpZCIsInRvU3RyaW5nIiwid2FsbGV0cyIsImkiLCJ3IiwicHVzaCIsImZhdWNldCIsIm5ld0ZhdWNldCIsIkJpZ0ludCIsInR4UmVzdWx0IiwiZXhlY3V0ZVRyYW5zYWN0aW9uIiwibmV3TWludFRyYW5zYWN0aW9uUmVxdWVzdCIsIlB1YmxpYyIsInByb3ZlbiIsInByb3ZlVHJhbnNhY3Rpb24iLCJoZWlnaHQiLCJzdWJtaXRQcm92ZW5UcmFuc2FjdGlvbiIsImFwcGx5VHJhbnNhY3Rpb24iLCJQcm9taXNlIiwiciIsInNldFRpbWVvdXQiLCJub3RlSWRzIiwiZ2V0Q29uc3VtYWJsZU5vdGVzIiwibWFwIiwicmVjIiwiaW5wdXROb3RlUmVjb3JkIiwibmV3Q29uc3VtZVRyYW5zYWN0aW9uUmVxdWVzdCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJsZW5ndGgiLCJzZW5kZXIiLCJyZWNlaXZlciIsInNsaWNlIiwiYXNzZXRzIiwicDJpZE5vdGUiLCJjcmVhdGVQMklETm90ZSIsIndpdGhPd25PdXRwdXROb3RlcyIsIk91dHB1dE5vdGVBcnJheSIsImZ1bGwiLCJidWlsZCIsImNvbnN1bWVSZXF1ZXN0Iiwid2l0aFVuYXV0aGVudGljYXRlZElucHV0Tm90ZXMiLCJleGVjUmVzdWx0IiwidHhJZCIsImV4ZWN1dGVkVHJhbnNhY3Rpb24iLCJ0b0hleCIsImVsYXBzZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/4_unauthenticatedNoteTransfer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/5_foreignProcedureInvocation.ts":
/*!*********************************************!*\
  !*** ./lib/5_foreignProcedureInvocation.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   foreignProcedureInvocation: () => (/* binding */ foreignProcedureInvocation)\n/* harmony export */ });\n// Tutorial 5: Foreign Procedure Invocation (FPI)\n//\n// CONCEPTS:\n// - FPI = one contract reading state from another contract (read-only cross-contract call)\n// - Like Solidity's view/pure external calls, but with ZK proofs\n// - Core primitive for price oracles, composable DeFi, etc.\n//\n// WHAT WE BUILD:\n// - A \"count reader\" contract that reads from the counter contract via FPI\n// - The reader calls get_count on the counter, then saves the result to its own storage\n//\n//   [Count Reader Contract] --FPI--> [Counter Contract]\n//         copy_count()       reads    get_count()\n//         saves to slot 0             returns count from slot 0\nasync function foreignProcedureInvocation() {\n    if (false) {}\n    const { AccountBuilder, AccountComponent, Address, AccountType, MidenArrays, SecretKey, StorageSlot, TransactionRequestBuilder, ForeignAccount, AccountStorageRequirements, WebClient, AccountStorageMode } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_demox-labs_miden-sdk_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @demox-labs/miden-sdk */ \"(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/index.js\"));\n    const client = await WebClient.createClient('https://rpc.testnet.miden.io');\n    console.log('Current block:', (await client.syncState()).blockNum());\n    // -----------------------------------------------------------------------\n    // Step 1: The Count Reader Contract (MASM)\n    // -----------------------------------------------------------------------\n    // This contract has one procedure: copy_count\n    // It expects the stack to contain:\n    //   [account_id_prefix, account_id_suffix, get_count_proc_hash]\n    // It calls tx::execute_foreign_procedure to read another contract's state\n    // Then writes the result to its own storage slot 0\n    console.log('\\n[Step 1] Creating count reader contract...');\n    const countReaderCode = `\n    use.miden::active_account\n    use.miden::native_account\n    use.miden::tx                    # <-- tx module has execute_foreign_procedure\n    use.std::sys\n\n    # Stack input: [account_id_prefix, account_id_suffix, get_count_proc_hash]\n    export.copy_count\n        exec.tx::execute_foreign_procedure\n        # => [count]\n        # The VM calls get_count on the foreign account and returns the result!\n\n        push.0\n        # => [slot_index, count]\n\n        debug.stack\n\n        exec.native_account::set_item dropw\n        # => []  (saved count to our slot 0)\n\n        exec.sys::truncate_stack\n    end\n`;\n    const builder = client.createScriptBuilder();\n    const readerComponent = AccountComponent.compile(countReaderCode, builder, [\n        StorageSlot.emptyValue()\n    ]).withSupportsAllTypes();\n    const walletSeed = new Uint8Array(32);\n    crypto.getRandomValues(walletSeed);\n    const secretKey = SecretKey.rpoFalconWithRNG(walletSeed);\n    const authComponent = AccountComponent.createAuthComponent(secretKey);\n    const readerContract = new AccountBuilder(walletSeed).accountType(AccountType.RegularAccountImmutableCode).storageMode(AccountStorageMode.public()).withAuthComponent(authComponent).withComponent(readerComponent).build();\n    await client.addAccountSecretKeyToWebStore(secretKey);\n    await client.syncState();\n    await client.newAccount(readerContract.account, false);\n    console.log('Count reader ID:', readerContract.account.id().toString());\n    // -----------------------------------------------------------------------\n    // Step 2: Import the counter contract from testnet\n    // -----------------------------------------------------------------------\n    console.log('\\n[Step 2] Importing counter contract...');\n    const counterContractId = Address.fromBech32('mtst1arjemrxne8lj5qz4mg9c8mtyxg954483').accountId();\n    let counterAccount = await client.getAccount(counterContractId);\n    if (!counterAccount) {\n        await client.importAccountById(counterContractId);\n        await client.syncState();\n        counterAccount = await client.getAccount(counterContractId);\n        if (!counterAccount) throw new Error('Counter contract not found');\n    }\n    console.log('Counter storage slot 0:', counterAccount.storage().getItem(0)?.toHex());\n    // -----------------------------------------------------------------------\n    // Step 3: Get the procedure hash for get_count\n    // -----------------------------------------------------------------------\n    // We need the hash of get_count so we can tell execute_foreign_procedure\n    // which procedure to call on the counter contract\n    const counterContractCode = `\n    use.miden::active_account\n    use.miden::native_account\n    use.std::sys\n\n    const.COUNTER_SLOT=0\n\n    export.get_count\n        push.COUNTER_SLOT\n        exec.active_account::get_item\n        movdn.4 dropw\n    end\n\n    export.increment_count\n        push.COUNTER_SLOT\n        exec.active_account::get_item\n        add.1\n        debug.stack\n        push.COUNTER_SLOT\n        exec.native_account::set_item\n        dropw\n    end\n`;\n    const counterComponent = AccountComponent.compile(counterContractCode, builder, [\n        StorageSlot.emptyValue()\n    ]).withSupportsAllTypes();\n    const getCountProcHash = counterComponent.getProcedureHash('get_count');\n    console.log('\\n[Step 3] get_count procedure hash:', getCountProcHash);\n    // -----------------------------------------------------------------------\n    // Step 4: Build the FPI transaction script\n    // -----------------------------------------------------------------------\n    // This script pushes the procedure hash and target account ID onto the stack,\n    // then calls copy_count on our reader contract\n    console.log('\\n[Step 4] Building FPI transaction...');\n    const readerLib = builder.buildLibrary('external_contract::count_reader_contract', countReaderCode);\n    builder.linkDynamicLibrary(readerLib);\n    const fpiScriptCode = `\n    use.external_contract::count_reader_contract\n    use.std::sys\n\n    begin\n        push.${getCountProcHash}\n        # => [GET_COUNT_HASH]\n\n        push.${counterAccount.id().suffix()}\n        # => [account_id_suffix, GET_COUNT_HASH]\n\n        push.${counterAccount.id().prefix()}\n        # => [account_id_prefix, account_id_suffix, GET_COUNT_HASH]\n\n        call.count_reader_contract::copy_count\n        # => []\n\n        exec.sys::truncate_stack\n    end\n`;\n    const txScript = builder.compileTxScript(fpiScriptCode);\n    // Declare the counter contract as a \"foreign account\" in our transaction\n    const storageRequirements = new AccountStorageRequirements();\n    const foreignAccount = ForeignAccount.public(counterContractId, storageRequirements);\n    const txRequest = new TransactionRequestBuilder().withCustomScript(txScript).withForeignAccounts(new MidenArrays.ForeignAccountArray([\n        foreignAccount\n    ])).build();\n    // -----------------------------------------------------------------------\n    // Step 5: Execute and verify\n    // -----------------------------------------------------------------------\n    const txId = await client.submitNewTransaction(readerContract.account.id(), txRequest);\n    console.log('TX on MidenScan: https://testnet.midenscan.com/tx/' + txId.toHex());\n    await client.syncState();\n    // Read both contracts' storage to verify the copy\n    const updatedCounter = await client.getAccount(counterAccount.id());\n    const updatedReader = await client.getAccount(readerContract.account.id());\n    console.log('\\nCounter contract slot 0:', updatedCounter?.storage().getItem(0)?.toHex());\n    console.log('Reader contract slot 0: ', updatedReader?.storage().getItem(0)?.toHex());\n    const readerStorage = updatedReader?.storage().getItem(0);\n    if (readerStorage) {\n        const countValue = Number(BigInt('0x' + readerStorage.toHex().slice(-16).match(/../g).reverse().join('')));\n        console.log('\\nCount copied via FPI:', countValue);\n    }\n    console.log('\\n=== Tutorial 5 Complete ===');\n    console.log('You learned:');\n    console.log('  - FPI lets contracts read state from other contracts');\n    console.log('  - tx::execute_foreign_procedure is the MASM call');\n    console.log('  - You need the procedure hash + target account ID');\n    console.log('  - ForeignAccount must be declared in the transaction request');\n    console.log('  - This is how oracles and composable DeFi work on Miden!');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi81X2ZvcmVpZ25Qcm9jZWR1cmVJbnZvY2F0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLFlBQVk7QUFDWiwyRkFBMkY7QUFDM0YsaUVBQWlFO0FBQ2pFLDREQUE0RDtBQUM1RCxFQUFFO0FBQ0YsaUJBQWlCO0FBQ2pCLDJFQUEyRTtBQUMzRSx3RkFBd0Y7QUFDeEYsRUFBRTtBQUNGLHdEQUF3RDtBQUN4RCxrREFBa0Q7QUFDbEQsZ0VBQWdFO0FBRXpELGVBQWVBO0lBQ3BCLElBQUksS0FBNkIsRUFBRSxFQUdsQztJQUVELE1BQU0sRUFDSkcsY0FBYyxFQUNkQyxnQkFBZ0IsRUFDaEJDLE9BQU8sRUFDUEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyx5QkFBeUIsRUFDekJDLGNBQWMsRUFDZEMsMEJBQTBCLEVBQzFCQyxTQUFTLEVBQ1RDLGtCQUFrQixFQUNuQixHQUFHLE1BQU0sc1FBQStCO0lBRXpDLE1BQU1DLFNBQVMsTUFBTUYsVUFBVUcsWUFBWSxDQUFDO0lBQzVDZixRQUFRZ0IsR0FBRyxDQUFDLGtCQUFrQixDQUFDLE1BQU1GLE9BQU9HLFNBQVMsRUFBQyxFQUFHQyxRQUFRO0lBRWpFLDBFQUEwRTtJQUMxRSwyQ0FBMkM7SUFDM0MsMEVBQTBFO0lBQzFFLDhDQUE4QztJQUM5QyxtQ0FBbUM7SUFDbkMsZ0VBQWdFO0lBQ2hFLDBFQUEwRTtJQUMxRSxtREFBbUQ7SUFFbkRsQixRQUFRZ0IsR0FBRyxDQUFDO0lBRVosTUFBTUcsa0JBQWtCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQjNCLENBQUM7SUFFQyxNQUFNQyxVQUFVTixPQUFPTyxtQkFBbUI7SUFDMUMsTUFBTUMsa0JBQWtCbkIsaUJBQWlCb0IsT0FBTyxDQUM5Q0osaUJBQWlCQyxTQUFTO1FBQUNaLFlBQVlnQixVQUFVO0tBQUcsRUFDcERDLG9CQUFvQjtJQUV0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LFFBQVFnQixHQUFHLENBQUMsdURBQXVEMkQsS0FBS25CLEtBQUs7SUFFN0UsTUFBTTFDLE9BQU9HLFNBQVM7SUFFdEIsa0RBQWtEO0lBQ2xELE1BQU00RCxpQkFBaUIsTUFBTS9ELE9BQU9xQyxVQUFVLENBQUNELGVBQWVMLEVBQUU7SUFDaEUsTUFBTWlDLGdCQUFnQixNQUFNaEUsT0FBT3FDLFVBQVUsQ0FBQ2pCLGVBQWVVLE9BQU8sQ0FBQ0MsRUFBRTtJQUV2RTdDLFFBQVFnQixHQUFHLENBQUMsOEJBQThCNkQsZ0JBQWdCdkIsVUFBVUMsUUFBUSxJQUFJQztJQUNoRnhELFFBQVFnQixHQUFHLENBQUMsNEJBQTRCOEQsZUFBZXhCLFVBQVVDLFFBQVEsSUFBSUM7SUFFN0UsTUFBTXVCLGdCQUFnQkQsZUFBZXhCLFVBQVVDLFFBQVE7SUFDdkQsSUFBSXdCLGVBQWU7UUFDakIsTUFBTUMsYUFBYUMsT0FDakJDLE9BQU8sT0FBT0gsY0FBY3ZCLEtBQUssR0FBRzJCLEtBQUssQ0FBQyxDQUFDLElBQUlDLEtBQUssQ0FBQyxPQUFRQyxPQUFPLEdBQUdDLElBQUksQ0FBQztRQUU5RXRGLFFBQVFnQixHQUFHLENBQUMsMkJBQTJCZ0U7SUFDekM7SUFFQWhGLFFBQVFnQixHQUFHLENBQUM7SUFDWmhCLFFBQVFnQixHQUFHLENBQUM7SUFDWmhCLFFBQVFnQixHQUFHLENBQUM7SUFDWmhCLFFBQVFnQixHQUFHLENBQUM7SUFDWmhCLFFBQVFnQixHQUFHLENBQUM7SUFDWmhCLFFBQVFnQixHQUFHLENBQUM7SUFDWmhCLFFBQVFnQixHQUFHLENBQUM7QUFDZCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxERUxMXFxEZXNrdG9wXFxjcmFiZGFvLWFnZW50XFxtaWRlbi13ZWItdHV0b3JpYWxzXFxsaWJcXDVfZm9yZWlnblByb2NlZHVyZUludm9jYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVHV0b3JpYWwgNTogRm9yZWlnbiBQcm9jZWR1cmUgSW52b2NhdGlvbiAoRlBJKVxuLy9cbi8vIENPTkNFUFRTOlxuLy8gLSBGUEkgPSBvbmUgY29udHJhY3QgcmVhZGluZyBzdGF0ZSBmcm9tIGFub3RoZXIgY29udHJhY3QgKHJlYWQtb25seSBjcm9zcy1jb250cmFjdCBjYWxsKVxuLy8gLSBMaWtlIFNvbGlkaXR5J3Mgdmlldy9wdXJlIGV4dGVybmFsIGNhbGxzLCBidXQgd2l0aCBaSyBwcm9vZnNcbi8vIC0gQ29yZSBwcmltaXRpdmUgZm9yIHByaWNlIG9yYWNsZXMsIGNvbXBvc2FibGUgRGVGaSwgZXRjLlxuLy9cbi8vIFdIQVQgV0UgQlVJTEQ6XG4vLyAtIEEgXCJjb3VudCByZWFkZXJcIiBjb250cmFjdCB0aGF0IHJlYWRzIGZyb20gdGhlIGNvdW50ZXIgY29udHJhY3QgdmlhIEZQSVxuLy8gLSBUaGUgcmVhZGVyIGNhbGxzIGdldF9jb3VudCBvbiB0aGUgY291bnRlciwgdGhlbiBzYXZlcyB0aGUgcmVzdWx0IHRvIGl0cyBvd24gc3RvcmFnZVxuLy9cbi8vICAgW0NvdW50IFJlYWRlciBDb250cmFjdF0gLS1GUEktLT4gW0NvdW50ZXIgQ29udHJhY3RdXG4vLyAgICAgICAgIGNvcHlfY291bnQoKSAgICAgICByZWFkcyAgICBnZXRfY291bnQoKVxuLy8gICAgICAgICBzYXZlcyB0byBzbG90IDAgICAgICAgICAgICAgcmV0dXJucyBjb3VudCBmcm9tIHNsb3QgMFxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9yZWlnblByb2NlZHVyZUludm9jYXRpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUud2FybignVGhpcyBtdXN0IHJ1biBpbiB0aGUgYnJvd3NlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBBY2NvdW50QnVpbGRlcixcbiAgICBBY2NvdW50Q29tcG9uZW50LFxuICAgIEFkZHJlc3MsXG4gICAgQWNjb3VudFR5cGUsXG4gICAgTWlkZW5BcnJheXMsXG4gICAgU2VjcmV0S2V5LFxuICAgIFN0b3JhZ2VTbG90LFxuICAgIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIsXG4gICAgRm9yZWlnbkFjY291bnQsXG4gICAgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMsXG4gICAgV2ViQ2xpZW50LFxuICAgIEFjY291bnRTdG9yYWdlTW9kZSxcbiAgfSA9IGF3YWl0IGltcG9ydCgnQGRlbW94LWxhYnMvbWlkZW4tc2RrJyk7XG5cbiAgY29uc3QgY2xpZW50ID0gYXdhaXQgV2ViQ2xpZW50LmNyZWF0ZUNsaWVudCgnaHR0cHM6Ly9ycGMudGVzdG5ldC5taWRlbi5pbycpO1xuICBjb25zb2xlLmxvZygnQ3VycmVudCBibG9jazonLCAoYXdhaXQgY2xpZW50LnN5bmNTdGF0ZSgpKS5ibG9ja051bSgpKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdGVwIDE6IFRoZSBDb3VudCBSZWFkZXIgQ29udHJhY3QgKE1BU00pXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRoaXMgY29udHJhY3QgaGFzIG9uZSBwcm9jZWR1cmU6IGNvcHlfY291bnRcbiAgLy8gSXQgZXhwZWN0cyB0aGUgc3RhY2sgdG8gY29udGFpbjpcbiAgLy8gICBbYWNjb3VudF9pZF9wcmVmaXgsIGFjY291bnRfaWRfc3VmZml4LCBnZXRfY291bnRfcHJvY19oYXNoXVxuICAvLyBJdCBjYWxscyB0eDo6ZXhlY3V0ZV9mb3JlaWduX3Byb2NlZHVyZSB0byByZWFkIGFub3RoZXIgY29udHJhY3QncyBzdGF0ZVxuICAvLyBUaGVuIHdyaXRlcyB0aGUgcmVzdWx0IHRvIGl0cyBvd24gc3RvcmFnZSBzbG90IDBcblxuICBjb25zb2xlLmxvZygnXFxuW1N0ZXAgMV0gQ3JlYXRpbmcgY291bnQgcmVhZGVyIGNvbnRyYWN0Li4uJyk7XG5cbiAgY29uc3QgY291bnRSZWFkZXJDb2RlID0gYFxuICAgIHVzZS5taWRlbjo6YWN0aXZlX2FjY291bnRcbiAgICB1c2UubWlkZW46Om5hdGl2ZV9hY2NvdW50XG4gICAgdXNlLm1pZGVuOjp0eCAgICAgICAgICAgICAgICAgICAgIyA8LS0gdHggbW9kdWxlIGhhcyBleGVjdXRlX2ZvcmVpZ25fcHJvY2VkdXJlXG4gICAgdXNlLnN0ZDo6c3lzXG5cbiAgICAjIFN0YWNrIGlucHV0OiBbYWNjb3VudF9pZF9wcmVmaXgsIGFjY291bnRfaWRfc3VmZml4LCBnZXRfY291bnRfcHJvY19oYXNoXVxuICAgIGV4cG9ydC5jb3B5X2NvdW50XG4gICAgICAgIGV4ZWMudHg6OmV4ZWN1dGVfZm9yZWlnbl9wcm9jZWR1cmVcbiAgICAgICAgIyA9PiBbY291bnRdXG4gICAgICAgICMgVGhlIFZNIGNhbGxzIGdldF9jb3VudCBvbiB0aGUgZm9yZWlnbiBhY2NvdW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHQhXG5cbiAgICAgICAgcHVzaC4wXG4gICAgICAgICMgPT4gW3Nsb3RfaW5kZXgsIGNvdW50XVxuXG4gICAgICAgIGRlYnVnLnN0YWNrXG5cbiAgICAgICAgZXhlYy5uYXRpdmVfYWNjb3VudDo6c2V0X2l0ZW0gZHJvcHdcbiAgICAgICAgIyA9PiBbXSAgKHNhdmVkIGNvdW50IHRvIG91ciBzbG90IDApXG5cbiAgICAgICAgZXhlYy5zeXM6OnRydW5jYXRlX3N0YWNrXG4gICAgZW5kXG5gO1xuXG4gIGNvbnN0IGJ1aWxkZXIgPSBjbGllbnQuY3JlYXRlU2NyaXB0QnVpbGRlcigpO1xuICBjb25zdCByZWFkZXJDb21wb25lbnQgPSBBY2NvdW50Q29tcG9uZW50LmNvbXBpbGUoXG4gICAgY291bnRSZWFkZXJDb2RlLCBidWlsZGVyLCBbU3RvcmFnZVNsb3QuZW1wdHlWYWx1ZSgpXSxcbiAgKS53aXRoU3VwcG9ydHNBbGxUeXBlcygpO1xuXG4gIGNvbnN0IHdhbGxldFNlZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMod2FsbGV0U2VlZCk7XG4gIGNvbnN0IHNlY3JldEtleSA9IFNlY3JldEtleS5ycG9GYWxjb25XaXRoUk5HKHdhbGxldFNlZWQpO1xuICBjb25zdCBhdXRoQ29tcG9uZW50ID0gQWNjb3VudENvbXBvbmVudC5jcmVhdGVBdXRoQ29tcG9uZW50KHNlY3JldEtleSk7XG5cbiAgY29uc3QgcmVhZGVyQ29udHJhY3QgPSBuZXcgQWNjb3VudEJ1aWxkZXIod2FsbGV0U2VlZClcbiAgICAuYWNjb3VudFR5cGUoQWNjb3VudFR5cGUuUmVndWxhckFjY291bnRJbW11dGFibGVDb2RlKVxuICAgIC5zdG9yYWdlTW9kZShBY2NvdW50U3RvcmFnZU1vZGUucHVibGljKCkpXG4gICAgLndpdGhBdXRoQ29tcG9uZW50KGF1dGhDb21wb25lbnQpXG4gICAgLndpdGhDb21wb25lbnQocmVhZGVyQ29tcG9uZW50KVxuICAgIC5idWlsZCgpO1xuXG4gIGF3YWl0IGNsaWVudC5hZGRBY2NvdW50U2VjcmV0S2V5VG9XZWJTdG9yZShzZWNyZXRLZXkpO1xuICBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG4gIGF3YWl0IGNsaWVudC5uZXdBY2NvdW50KHJlYWRlckNvbnRyYWN0LmFjY291bnQsIGZhbHNlKTtcbiAgY29uc29sZS5sb2coJ0NvdW50IHJlYWRlciBJRDonLCByZWFkZXJDb250cmFjdC5hY2NvdW50LmlkKCkudG9TdHJpbmcoKSk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3RlcCAyOiBJbXBvcnQgdGhlIGNvdW50ZXIgY29udHJhY3QgZnJvbSB0ZXN0bmV0XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCAyXSBJbXBvcnRpbmcgY291bnRlciBjb250cmFjdC4uLicpO1xuICBjb25zdCBjb3VudGVyQ29udHJhY3RJZCA9IEFkZHJlc3MuZnJvbUJlY2gzMihcbiAgICAnbXRzdDFhcmplbXJ4bmU4bGo1cXo0bWc5YzhtdHl4Zzk1NDQ4MycsXG4gICkuYWNjb3VudElkKCk7XG5cbiAgbGV0IGNvdW50ZXJBY2NvdW50ID0gYXdhaXQgY2xpZW50LmdldEFjY291bnQoY291bnRlckNvbnRyYWN0SWQpO1xuICBpZiAoIWNvdW50ZXJBY2NvdW50KSB7XG4gICAgYXdhaXQgY2xpZW50LmltcG9ydEFjY291bnRCeUlkKGNvdW50ZXJDb250cmFjdElkKTtcbiAgICBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG4gICAgY291bnRlckFjY291bnQgPSBhd2FpdCBjbGllbnQuZ2V0QWNjb3VudChjb3VudGVyQ29udHJhY3RJZCk7XG4gICAgaWYgKCFjb3VudGVyQWNjb3VudCkgdGhyb3cgbmV3IEVycm9yKCdDb3VudGVyIGNvbnRyYWN0IG5vdCBmb3VuZCcpO1xuICB9XG4gIGNvbnNvbGUubG9nKCdDb3VudGVyIHN0b3JhZ2Ugc2xvdCAwOicsIGNvdW50ZXJBY2NvdW50LnN0b3JhZ2UoKS5nZXRJdGVtKDApPy50b0hleCgpKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdGVwIDM6IEdldCB0aGUgcHJvY2VkdXJlIGhhc2ggZm9yIGdldF9jb3VudFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBXZSBuZWVkIHRoZSBoYXNoIG9mIGdldF9jb3VudCBzbyB3ZSBjYW4gdGVsbCBleGVjdXRlX2ZvcmVpZ25fcHJvY2VkdXJlXG4gIC8vIHdoaWNoIHByb2NlZHVyZSB0byBjYWxsIG9uIHRoZSBjb3VudGVyIGNvbnRyYWN0XG5cbiAgY29uc3QgY291bnRlckNvbnRyYWN0Q29kZSA9IGBcbiAgICB1c2UubWlkZW46OmFjdGl2ZV9hY2NvdW50XG4gICAgdXNlLm1pZGVuOjpuYXRpdmVfYWNjb3VudFxuICAgIHVzZS5zdGQ6OnN5c1xuXG4gICAgY29uc3QuQ09VTlRFUl9TTE9UPTBcblxuICAgIGV4cG9ydC5nZXRfY291bnRcbiAgICAgICAgcHVzaC5DT1VOVEVSX1NMT1RcbiAgICAgICAgZXhlYy5hY3RpdmVfYWNjb3VudDo6Z2V0X2l0ZW1cbiAgICAgICAgbW92ZG4uNCBkcm9wd1xuICAgIGVuZFxuXG4gICAgZXhwb3J0LmluY3JlbWVudF9jb3VudFxuICAgICAgICBwdXNoLkNPVU5URVJfU0xPVFxuICAgICAgICBleGVjLmFjdGl2ZV9hY2NvdW50OjpnZXRfaXRlbVxuICAgICAgICBhZGQuMVxuICAgICAgICBkZWJ1Zy5zdGFja1xuICAgICAgICBwdXNoLkNPVU5URVJfU0xPVFxuICAgICAgICBleGVjLm5hdGl2ZV9hY2NvdW50OjpzZXRfaXRlbVxuICAgICAgICBkcm9wd1xuICAgIGVuZFxuYDtcblxuICBjb25zdCBjb3VudGVyQ29tcG9uZW50ID0gQWNjb3VudENvbXBvbmVudC5jb21waWxlKFxuICAgIGNvdW50ZXJDb250cmFjdENvZGUsIGJ1aWxkZXIsIFtTdG9yYWdlU2xvdC5lbXB0eVZhbHVlKCldLFxuICApLndpdGhTdXBwb3J0c0FsbFR5cGVzKCk7XG5cbiAgY29uc3QgZ2V0Q291bnRQcm9jSGFzaCA9IGNvdW50ZXJDb21wb25lbnQuZ2V0UHJvY2VkdXJlSGFzaCgnZ2V0X2NvdW50Jyk7XG4gIGNvbnNvbGUubG9nKCdcXG5bU3RlcCAzXSBnZXRfY291bnQgcHJvY2VkdXJlIGhhc2g6JywgZ2V0Q291bnRQcm9jSGFzaCk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3RlcCA0OiBCdWlsZCB0aGUgRlBJIHRyYW5zYWN0aW9uIHNjcmlwdFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGlzIHNjcmlwdCBwdXNoZXMgdGhlIHByb2NlZHVyZSBoYXNoIGFuZCB0YXJnZXQgYWNjb3VudCBJRCBvbnRvIHRoZSBzdGFjayxcbiAgLy8gdGhlbiBjYWxscyBjb3B5X2NvdW50IG9uIG91ciByZWFkZXIgY29udHJhY3RcblxuICBjb25zb2xlLmxvZygnXFxuW1N0ZXAgNF0gQnVpbGRpbmcgRlBJIHRyYW5zYWN0aW9uLi4uJyk7XG5cbiAgY29uc3QgcmVhZGVyTGliID0gYnVpbGRlci5idWlsZExpYnJhcnkoXG4gICAgJ2V4dGVybmFsX2NvbnRyYWN0Ojpjb3VudF9yZWFkZXJfY29udHJhY3QnLFxuICAgIGNvdW50UmVhZGVyQ29kZSxcbiAgKTtcbiAgYnVpbGRlci5saW5rRHluYW1pY0xpYnJhcnkocmVhZGVyTGliKTtcblxuICBjb25zdCBmcGlTY3JpcHRDb2RlID0gYFxuICAgIHVzZS5leHRlcm5hbF9jb250cmFjdDo6Y291bnRfcmVhZGVyX2NvbnRyYWN0XG4gICAgdXNlLnN0ZDo6c3lzXG5cbiAgICBiZWdpblxuICAgICAgICBwdXNoLiR7Z2V0Q291bnRQcm9jSGFzaH1cbiAgICAgICAgIyA9PiBbR0VUX0NPVU5UX0hBU0hdXG5cbiAgICAgICAgcHVzaC4ke2NvdW50ZXJBY2NvdW50LmlkKCkuc3VmZml4KCl9XG4gICAgICAgICMgPT4gW2FjY291bnRfaWRfc3VmZml4LCBHRVRfQ09VTlRfSEFTSF1cblxuICAgICAgICBwdXNoLiR7Y291bnRlckFjY291bnQuaWQoKS5wcmVmaXgoKX1cbiAgICAgICAgIyA9PiBbYWNjb3VudF9pZF9wcmVmaXgsIGFjY291bnRfaWRfc3VmZml4LCBHRVRfQ09VTlRfSEFTSF1cblxuICAgICAgICBjYWxsLmNvdW50X3JlYWRlcl9jb250cmFjdDo6Y29weV9jb3VudFxuICAgICAgICAjID0+IFtdXG5cbiAgICAgICAgZXhlYy5zeXM6OnRydW5jYXRlX3N0YWNrXG4gICAgZW5kXG5gO1xuXG4gIGNvbnN0IHR4U2NyaXB0ID0gYnVpbGRlci5jb21waWxlVHhTY3JpcHQoZnBpU2NyaXB0Q29kZSk7XG5cbiAgLy8gRGVjbGFyZSB0aGUgY291bnRlciBjb250cmFjdCBhcyBhIFwiZm9yZWlnbiBhY2NvdW50XCIgaW4gb3VyIHRyYW5zYWN0aW9uXG4gIGNvbnN0IHN0b3JhZ2VSZXF1aXJlbWVudHMgPSBuZXcgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMoKTtcbiAgY29uc3QgZm9yZWlnbkFjY291bnQgPSBGb3JlaWduQWNjb3VudC5wdWJsaWMoY291bnRlckNvbnRyYWN0SWQsIHN0b3JhZ2VSZXF1aXJlbWVudHMpO1xuXG4gIGNvbnN0IHR4UmVxdWVzdCA9IG5ldyBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyKClcbiAgICAud2l0aEN1c3RvbVNjcmlwdCh0eFNjcmlwdClcbiAgICAud2l0aEZvcmVpZ25BY2NvdW50cyhuZXcgTWlkZW5BcnJheXMuRm9yZWlnbkFjY291bnRBcnJheShbZm9yZWlnbkFjY291bnRdKSlcbiAgICAuYnVpbGQoKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdGVwIDU6IEV4ZWN1dGUgYW5kIHZlcmlmeVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25zdCB0eElkID0gYXdhaXQgY2xpZW50LnN1Ym1pdE5ld1RyYW5zYWN0aW9uKFxuICAgIHJlYWRlckNvbnRyYWN0LmFjY291bnQuaWQoKSwgdHhSZXF1ZXN0LFxuICApO1xuICBjb25zb2xlLmxvZygnVFggb24gTWlkZW5TY2FuOiBodHRwczovL3Rlc3RuZXQubWlkZW5zY2FuLmNvbS90eC8nICsgdHhJZC50b0hleCgpKTtcblxuICBhd2FpdCBjbGllbnQuc3luY1N0YXRlKCk7XG5cbiAgLy8gUmVhZCBib3RoIGNvbnRyYWN0cycgc3RvcmFnZSB0byB2ZXJpZnkgdGhlIGNvcHlcbiAgY29uc3QgdXBkYXRlZENvdW50ZXIgPSBhd2FpdCBjbGllbnQuZ2V0QWNjb3VudChjb3VudGVyQWNjb3VudC5pZCgpKTtcbiAgY29uc3QgdXBkYXRlZFJlYWRlciA9IGF3YWl0IGNsaWVudC5nZXRBY2NvdW50KHJlYWRlckNvbnRyYWN0LmFjY291bnQuaWQoKSk7XG5cbiAgY29uc29sZS5sb2coJ1xcbkNvdW50ZXIgY29udHJhY3Qgc2xvdCAwOicsIHVwZGF0ZWRDb3VudGVyPy5zdG9yYWdlKCkuZ2V0SXRlbSgwKT8udG9IZXgoKSk7XG4gIGNvbnNvbGUubG9nKCdSZWFkZXIgY29udHJhY3Qgc2xvdCAwOiAnLCB1cGRhdGVkUmVhZGVyPy5zdG9yYWdlKCkuZ2V0SXRlbSgwKT8udG9IZXgoKSk7XG5cbiAgY29uc3QgcmVhZGVyU3RvcmFnZSA9IHVwZGF0ZWRSZWFkZXI/LnN0b3JhZ2UoKS5nZXRJdGVtKDApO1xuICBpZiAocmVhZGVyU3RvcmFnZSkge1xuICAgIGNvbnN0IGNvdW50VmFsdWUgPSBOdW1iZXIoXG4gICAgICBCaWdJbnQoJzB4JyArIHJlYWRlclN0b3JhZ2UudG9IZXgoKS5zbGljZSgtMTYpLm1hdGNoKC8uLi9nKSEucmV2ZXJzZSgpLmpvaW4oJycpKSxcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKCdcXG5Db3VudCBjb3BpZWQgdmlhIEZQSTonLCBjb3VudFZhbHVlKTtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCdcXG49PT0gVHV0b3JpYWwgNSBDb21wbGV0ZSA9PT0nKTtcbiAgY29uc29sZS5sb2coJ1lvdSBsZWFybmVkOicpO1xuICBjb25zb2xlLmxvZygnICAtIEZQSSBsZXRzIGNvbnRyYWN0cyByZWFkIHN0YXRlIGZyb20gb3RoZXIgY29udHJhY3RzJyk7XG4gIGNvbnNvbGUubG9nKCcgIC0gdHg6OmV4ZWN1dGVfZm9yZWlnbl9wcm9jZWR1cmUgaXMgdGhlIE1BU00gY2FsbCcpO1xuICBjb25zb2xlLmxvZygnICAtIFlvdSBuZWVkIHRoZSBwcm9jZWR1cmUgaGFzaCArIHRhcmdldCBhY2NvdW50IElEJyk7XG4gIGNvbnNvbGUubG9nKCcgIC0gRm9yZWlnbkFjY291bnQgbXVzdCBiZSBkZWNsYXJlZCBpbiB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdCcpO1xuICBjb25zb2xlLmxvZygnICAtIFRoaXMgaXMgaG93IG9yYWNsZXMgYW5kIGNvbXBvc2FibGUgRGVGaSB3b3JrIG9uIE1pZGVuIScpO1xufVxuIl0sIm5hbWVzIjpbImZvcmVpZ25Qcm9jZWR1cmVJbnZvY2F0aW9uIiwiY29uc29sZSIsIndhcm4iLCJBY2NvdW50QnVpbGRlciIsIkFjY291bnRDb21wb25lbnQiLCJBZGRyZXNzIiwiQWNjb3VudFR5cGUiLCJNaWRlbkFycmF5cyIsIlNlY3JldEtleSIsIlN0b3JhZ2VTbG90IiwiVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlciIsIkZvcmVpZ25BY2NvdW50IiwiQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMiLCJXZWJDbGllbnQiLCJBY2NvdW50U3RvcmFnZU1vZGUiLCJjbGllbnQiLCJjcmVhdGVDbGllbnQiLCJsb2ciLCJzeW5jU3RhdGUiLCJibG9ja051bSIsImNvdW50UmVhZGVyQ29kZSIsImJ1aWxkZXIiLCJjcmVhdGVTY3JpcHRCdWlsZGVyIiwicmVhZGVyQ29tcG9uZW50IiwiY29tcGlsZSIsImVtcHR5VmFsdWUiLCJ3aXRoU3VwcG9ydHNBbGxUeXBlcyIsIndhbGxldFNlZWQiLCJVaW50OEFycmF5IiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwic2VjcmV0S2V5IiwicnBvRmFsY29uV2l0aFJORyIsImF1dGhDb21wb25lbnQiLCJjcmVhdGVBdXRoQ29tcG9uZW50IiwicmVhZGVyQ29udHJhY3QiLCJhY2NvdW50VHlwZSIsIlJlZ3VsYXJBY2NvdW50SW1tdXRhYmxlQ29kZSIsInN0b3JhZ2VNb2RlIiwicHVibGljIiwid2l0aEF1dGhDb21wb25lbnQiLCJ3aXRoQ29tcG9uZW50IiwiYnVpbGQiLCJhZGRBY2NvdW50U2VjcmV0S2V5VG9XZWJTdG9yZSIsIm5ld0FjY291bnQiLCJhY2NvdW50IiwiaWQiLCJ0b1N0cmluZyIsImNvdW50ZXJDb250cmFjdElkIiwiZnJvbUJlY2gzMiIsImFjY291bnRJZCIsImNvdW50ZXJBY2NvdW50IiwiZ2V0QWNjb3VudCIsImltcG9ydEFjY291bnRCeUlkIiwiRXJyb3IiLCJzdG9yYWdlIiwiZ2V0SXRlbSIsInRvSGV4IiwiY291bnRlckNvbnRyYWN0Q29kZSIsImNvdW50ZXJDb21wb25lbnQiLCJnZXRDb3VudFByb2NIYXNoIiwiZ2V0UHJvY2VkdXJlSGFzaCIsInJlYWRlckxpYiIsImJ1aWxkTGlicmFyeSIsImxpbmtEeW5hbWljTGlicmFyeSIsImZwaVNjcmlwdENvZGUiLCJzdWZmaXgiLCJwcmVmaXgiLCJ0eFNjcmlwdCIsImNvbXBpbGVUeFNjcmlwdCIsInN0b3JhZ2VSZXF1aXJlbWVudHMiLCJmb3JlaWduQWNjb3VudCIsInR4UmVxdWVzdCIsIndpdGhDdXN0b21TY3JpcHQiLCJ3aXRoRm9yZWlnbkFjY291bnRzIiwiRm9yZWlnbkFjY291bnRBcnJheSIsInR4SWQiLCJzdWJtaXROZXdUcmFuc2FjdGlvbiIsInVwZGF0ZWRDb3VudGVyIiwidXBkYXRlZFJlYWRlciIsInJlYWRlclN0b3JhZ2UiLCJjb3VudFZhbHVlIiwiTnVtYmVyIiwiQmlnSW50Iiwic2xpY2UiLCJtYXRjaCIsInJldmVyc2UiLCJqb2luIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/5_foreignProcedureInvocation.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CDELL%5C%5CDesktop%5C%5Ccrabdao-agent%5C%5Cmiden-web-tutorials%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CDELL%5C%5CDesktop%5C%5Ccrabdao-agent%5C%5Cmiden-web-tutorials%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDREVMTCU1QyU1Q0Rlc2t0b3AlNUMlNUNjcmFiZGFvLWFnZW50JTVDJTVDbWlkZW4td2ViLXR1dG9yaWFscyU1QyU1Q2FwcCU1QyU1Q3BhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsc0pBQWdIIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxERUxMXFxcXERlc2t0b3BcXFxcY3JhYmRhby1hZ2VudFxcXFxtaWRlbi13ZWItdHV0b3JpYWxzXFxcXGFwcFxcXFxwYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CDELL%5C%5CDesktop%5C%5Ccrabdao-agent%5C%5Cmiden-web-tutorials%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n        case REACT_VIEW_TRANSITION_TYPE:\n          return \"ViewTransition\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      isValidElement(node)\n        ? node._store && (node._store.validated = 1)\n        : \"object\" === typeof node &&\n          null !== node &&\n          node.$$typeof === REACT_LAZY_TYPE &&\n          (\"fulfilled\" === node._payload.status\n            ? isValidElement(node._payload.value) &&\n              node._payload.value._store &&\n              (node._payload.value._store.validated = 1)\n            : node._store && (node._store.validated = 1));\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      if (trackActualOwner) {\n        var previousStackTraceLimit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 10;\n        var debugStackDEV = Error(\"react-stack-top-frame\");\n        Error.stackTraceLimit = previousStackTraceLimit;\n      } else debugStackDEV = unknownOwnerDebugStack;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        debugStackDEV,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNHQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXERFTExcXERlc2t0b3BcXGNyYWJkYW8tYWdlbnRcXG1pZGVuLXdlYi10dXRvcmlhbHNcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0XFxjanNcXHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiVmlld1RyYW5zaXRpb25cIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcHJvcHMsIG93bmVyLCBkZWJ1Z1N0YWNrLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIHZhciByZWZQcm9wID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHJlZlByb3AgPyByZWZQcm9wIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIGlzVmFsaWRFbGVtZW50KG5vZGUpXG4gICAgICAgID8gbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpXG4gICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgKFwiZnVsZmlsbGVkXCIgPT09IG5vZGUuX3BheWxvYWQuc3RhdHVzXG4gICAgICAgICAgICA/IGlzVmFsaWRFbGVtZW50KG5vZGUuX3BheWxvYWQudmFsdWUpICYmXG4gICAgICAgICAgICAgIG5vZGUuX3BheWxvYWQudmFsdWUuX3N0b3JlICYmXG4gICAgICAgICAgICAgIChub2RlLl9wYXlsb2FkLnZhbHVlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKVxuICAgICAgICAgICAgOiBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvYmplY3QgJiZcbiAgICAgICAgbnVsbCAhPT0gb2JqZWN0ICYmXG4gICAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qudmlld190cmFuc2l0aW9uXCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIHJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZTogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdC5yZWFjdF9zdGFja19ib3R0b21fZnJhbWUuYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICBpZiAodHJhY2tBY3R1YWxPd25lcikge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDEwO1xuICAgICAgICB2YXIgZGVidWdTdGFja0RFViA9IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBwcmV2aW91c1N0YWNrVHJhY2VMaW1pdDtcbiAgICAgIH0gZWxzZSBkZWJ1Z1N0YWNrREVWID0gdW5rbm93bk93bmVyRGVidWdTdGFjaztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICBkZWJ1Z1N0YWNrREVWLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcY3JhYmRhby1hZ2VudFxcbWlkZW4td2ViLXR1dG9yaWFsc1xcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGpzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CDELL%5C%5CDesktop%5C%5Ccrabdao-agent%5C%5Cmiden-web-tutorials%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);