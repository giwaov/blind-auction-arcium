"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_demox-labs_miden-sdk_dist_workers_Cargo-acbd8ac5-acbd8ac5_js"],{

/***/ "(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js ***!
  \************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountArray: () => (/* binding */ AccountArray),\n/* harmony export */   AccountBuilder: () => (/* binding */ AccountBuilder),\n/* harmony export */   AccountBuilderResult: () => (/* binding */ AccountBuilderResult),\n/* harmony export */   AccountCode: () => (/* binding */ AccountCode),\n/* harmony export */   AccountComponent: () => (/* binding */ AccountComponent),\n/* harmony export */   AccountDelta: () => (/* binding */ AccountDelta),\n/* harmony export */   AccountFile: () => (/* binding */ AccountFile),\n/* harmony export */   AccountHeader: () => (/* binding */ AccountHeader),\n/* harmony export */   AccountId: () => (/* binding */ AccountId),\n/* harmony export */   AccountIdArray: () => (/* binding */ AccountIdArray),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   AccountStorage: () => (/* binding */ AccountStorage),\n/* harmony export */   AccountStorageDelta: () => (/* binding */ AccountStorageDelta),\n/* harmony export */   AccountStorageMode: () => (/* binding */ AccountStorageMode),\n/* harmony export */   AccountStorageRequirements: () => (/* binding */ AccountStorageRequirements),\n/* harmony export */   AccountType: () => (/* binding */ AccountType),\n/* harmony export */   AccountVaultDelta: () => (/* binding */ AccountVaultDelta),\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   AdviceInputs: () => (/* binding */ AdviceInputs),\n/* harmony export */   AdviceMap: () => (/* binding */ AdviceMap),\n/* harmony export */   AssetVault: () => (/* binding */ AssetVault),\n/* harmony export */   AuthSecretKey: () => (/* binding */ AuthSecretKey),\n/* harmony export */   BasicFungibleFaucetComponent: () => (/* binding */ BasicFungibleFaucetComponent),\n/* harmony export */   BlockHeader: () => (/* binding */ BlockHeader),\n/* harmony export */   ConsumableNoteRecord: () => (/* binding */ ConsumableNoteRecord),\n/* harmony export */   Endpoint: () => (/* binding */ Endpoint),\n/* harmony export */   ExecutedTransaction: () => (/* binding */ ExecutedTransaction),\n/* harmony export */   Felt: () => (/* binding */ Felt),\n/* harmony export */   FeltArray: () => (/* binding */ FeltArray),\n/* harmony export */   FetchedNote: () => (/* binding */ FetchedNote),\n/* harmony export */   FlattenedU8Vec: () => (/* binding */ FlattenedU8Vec),\n/* harmony export */   ForeignAccount: () => (/* binding */ ForeignAccount),\n/* harmony export */   ForeignAccountArray: () => (/* binding */ ForeignAccountArray),\n/* harmony export */   FungibleAsset: () => (/* binding */ FungibleAsset),\n/* harmony export */   FungibleAssetDelta: () => (/* binding */ FungibleAssetDelta),\n/* harmony export */   FungibleAssetDeltaItem: () => (/* binding */ FungibleAssetDeltaItem),\n/* harmony export */   GetProceduresResultItem: () => (/* binding */ GetProceduresResultItem),\n/* harmony export */   InputNote: () => (/* binding */ InputNote),\n/* harmony export */   InputNoteRecord: () => (/* binding */ InputNoteRecord),\n/* harmony export */   InputNoteState: () => (/* binding */ InputNoteState),\n/* harmony export */   InputNotes: () => (/* binding */ InputNotes),\n/* harmony export */   IntoUnderlyingByteSource: () => (/* binding */ IntoUnderlyingByteSource),\n/* harmony export */   IntoUnderlyingSink: () => (/* binding */ IntoUnderlyingSink),\n/* harmony export */   IntoUnderlyingSource: () => (/* binding */ IntoUnderlyingSource),\n/* harmony export */   JsAccountUpdate: () => (/* binding */ JsAccountUpdate),\n/* harmony export */   JsStateSyncUpdate: () => (/* binding */ JsStateSyncUpdate),\n/* harmony export */   JsStorageMapEntry: () => (/* binding */ JsStorageMapEntry),\n/* harmony export */   JsStorageSlot: () => (/* binding */ JsStorageSlot),\n/* harmony export */   JsVaultAsset: () => (/* binding */ JsVaultAsset),\n/* harmony export */   Library: () => (/* binding */ Library),\n/* harmony export */   MerklePath: () => (/* binding */ MerklePath),\n/* harmony export */   NetworkId: () => (/* binding */ NetworkId),\n/* harmony export */   Note: () => (/* binding */ Note),\n/* harmony export */   NoteAndArgs: () => (/* binding */ NoteAndArgs),\n/* harmony export */   NoteAndArgsArray: () => (/* binding */ NoteAndArgsArray),\n/* harmony export */   NoteAssets: () => (/* binding */ NoteAssets),\n/* harmony export */   NoteConsumability: () => (/* binding */ NoteConsumability),\n/* harmony export */   NoteDetails: () => (/* binding */ NoteDetails),\n/* harmony export */   NoteDetailsAndTag: () => (/* binding */ NoteDetailsAndTag),\n/* harmony export */   NoteDetailsAndTagArray: () => (/* binding */ NoteDetailsAndTagArray),\n/* harmony export */   NoteExecutionHint: () => (/* binding */ NoteExecutionHint),\n/* harmony export */   NoteExecutionMode: () => (/* binding */ NoteExecutionMode),\n/* harmony export */   NoteFile: () => (/* binding */ NoteFile),\n/* harmony export */   NoteFilter: () => (/* binding */ NoteFilter),\n/* harmony export */   NoteFilterTypes: () => (/* binding */ NoteFilterTypes),\n/* harmony export */   NoteHeader: () => (/* binding */ NoteHeader),\n/* harmony export */   NoteId: () => (/* binding */ NoteId),\n/* harmony export */   NoteIdAndArgs: () => (/* binding */ NoteIdAndArgs),\n/* harmony export */   NoteIdAndArgsArray: () => (/* binding */ NoteIdAndArgsArray),\n/* harmony export */   NoteInclusionProof: () => (/* binding */ NoteInclusionProof),\n/* harmony export */   NoteInputs: () => (/* binding */ NoteInputs),\n/* harmony export */   NoteLocation: () => (/* binding */ NoteLocation),\n/* harmony export */   NoteMetadata: () => (/* binding */ NoteMetadata),\n/* harmony export */   NoteRecipient: () => (/* binding */ NoteRecipient),\n/* harmony export */   NoteRecipientArray: () => (/* binding */ NoteRecipientArray),\n/* harmony export */   NoteScript: () => (/* binding */ NoteScript),\n/* harmony export */   NoteTag: () => (/* binding */ NoteTag),\n/* harmony export */   NoteType: () => (/* binding */ NoteType),\n/* harmony export */   OutputNote: () => (/* binding */ OutputNote),\n/* harmony export */   OutputNoteArray: () => (/* binding */ OutputNoteArray),\n/* harmony export */   OutputNotes: () => (/* binding */ OutputNotes),\n/* harmony export */   OutputNotesArray: () => (/* binding */ OutputNotesArray),\n/* harmony export */   Package: () => (/* binding */ Package),\n/* harmony export */   PartialNote: () => (/* binding */ PartialNote),\n/* harmony export */   ProvenTransaction: () => (/* binding */ ProvenTransaction),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   RpcClient: () => (/* binding */ RpcClient),\n/* harmony export */   Rpo256: () => (/* binding */ Rpo256),\n/* harmony export */   ScriptBuilder: () => (/* binding */ ScriptBuilder),\n/* harmony export */   SecretKey: () => (/* binding */ SecretKey),\n/* harmony export */   SerializedInputNoteData: () => (/* binding */ SerializedInputNoteData),\n/* harmony export */   SerializedOutputNoteData: () => (/* binding */ SerializedOutputNoteData),\n/* harmony export */   SerializedTransactionData: () => (/* binding */ SerializedTransactionData),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   SigningInputs: () => (/* binding */ SigningInputs),\n/* harmony export */   SigningInputsType: () => (/* binding */ SigningInputsType),\n/* harmony export */   SlotAndKeys: () => (/* binding */ SlotAndKeys),\n/* harmony export */   StorageMap: () => (/* binding */ StorageMap),\n/* harmony export */   StorageSlot: () => (/* binding */ StorageSlot),\n/* harmony export */   StorageSlotArray: () => (/* binding */ StorageSlotArray),\n/* harmony export */   SyncSummary: () => (/* binding */ SyncSummary),\n/* harmony export */   TestUtils: () => (/* binding */ TestUtils),\n/* harmony export */   TokenSymbol: () => (/* binding */ TokenSymbol),\n/* harmony export */   TransactionArgs: () => (/* binding */ TransactionArgs),\n/* harmony export */   TransactionFilter: () => (/* binding */ TransactionFilter),\n/* harmony export */   TransactionId: () => (/* binding */ TransactionId),\n/* harmony export */   TransactionProver: () => (/* binding */ TransactionProver),\n/* harmony export */   TransactionRecord: () => (/* binding */ TransactionRecord),\n/* harmony export */   TransactionRequest: () => (/* binding */ TransactionRequest),\n/* harmony export */   TransactionRequestBuilder: () => (/* binding */ TransactionRequestBuilder),\n/* harmony export */   TransactionResult: () => (/* binding */ TransactionResult),\n/* harmony export */   TransactionScript: () => (/* binding */ TransactionScript),\n/* harmony export */   TransactionScriptInputPair: () => (/* binding */ TransactionScriptInputPair),\n/* harmony export */   TransactionScriptInputPairArray: () => (/* binding */ TransactionScriptInputPairArray),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionStoreUpdate: () => (/* binding */ TransactionStoreUpdate),\n/* harmony export */   TransactionSummary: () => (/* binding */ TransactionSummary),\n/* harmony export */   WebClient: () => (/* binding */ WebClient),\n/* harmony export */   Word: () => (/* binding */ Word),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar dexie = {exports: {}};\n\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.0.8, Wed Jul 10 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n\n(function (module, exports) {\n\t(function (global, factory) {\n\t    module.exports = factory() ;\n\t})(commonjsGlobal, (function () {\n\t    /*! *****************************************************************************\n\t    Copyright (c) Microsoft Corporation.\n\t    Permission to use, copy, modify, and/or distribute this software for any\n\t    purpose with or without fee is hereby granted.\n\t    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n\t    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n\t    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n\t    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n\t    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n\t    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n\t    PERFORMANCE OF THIS SOFTWARE.\n\t    ***************************************************************************** */\n\t    var extendStatics = function(d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    function __extends(d, b) {\n\t        if (typeof b !== \"function\" && b !== null)\n\t            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    }\n\t    var __assign = function() {\n\t        __assign = Object.assign || function __assign(t) {\n\t            for (var s, i = 1, n = arguments.length; i < n; i++) {\n\t                s = arguments[i];\n\t                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n\t            }\n\t            return t;\n\t        };\n\t        return __assign.apply(this, arguments);\n\t    };\n\t    function __spreadArray(to, from, pack) {\n\t        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n\t            if (ar || !(i in from)) {\n\t                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n\t                ar[i] = from[i];\n\t            }\n\t        }\n\t        return to.concat(ar || Array.prototype.slice.call(from));\n\t    }\n\n\t    var _global = typeof globalThis !== 'undefined' ? globalThis :\n\t        typeof self !== 'undefined' ? self :\n\t            typeof window !== 'undefined' ? window :\n\t                commonjsGlobal;\n\n\t    var keys = Object.keys;\n\t    var isArray = Array.isArray;\n\t    if (typeof Promise !== 'undefined' && !_global.Promise) {\n\t        _global.Promise = Promise;\n\t    }\n\t    function extend(obj, extension) {\n\t        if (typeof extension !== 'object')\n\t            return obj;\n\t        keys(extension).forEach(function (key) {\n\t            obj[key] = extension[key];\n\t        });\n\t        return obj;\n\t    }\n\t    var getProto = Object.getPrototypeOf;\n\t    var _hasOwn = {}.hasOwnProperty;\n\t    function hasOwn(obj, prop) {\n\t        return _hasOwn.call(obj, prop);\n\t    }\n\t    function props(proto, extension) {\n\t        if (typeof extension === 'function')\n\t            extension = extension(getProto(proto));\n\t        (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n\t            setProp(proto, key, extension[key]);\n\t        });\n\t    }\n\t    var defineProperty = Object.defineProperty;\n\t    function setProp(obj, prop, functionOrGetSet, options) {\n\t        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n\t            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n\t            { value: functionOrGetSet, configurable: true, writable: true }, options));\n\t    }\n\t    function derive(Child) {\n\t        return {\n\t            from: function (Parent) {\n\t                Child.prototype = Object.create(Parent.prototype);\n\t                setProp(Child.prototype, \"constructor\", Child);\n\t                return {\n\t                    extend: props.bind(null, Child.prototype)\n\t                };\n\t            }\n\t        };\n\t    }\n\t    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\t    function getPropertyDescriptor(obj, prop) {\n\t        var pd = getOwnPropertyDescriptor(obj, prop);\n\t        var proto;\n\t        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n\t    }\n\t    var _slice = [].slice;\n\t    function slice(args, start, end) {\n\t        return _slice.call(args, start, end);\n\t    }\n\t    function override(origFunc, overridedFactory) {\n\t        return overridedFactory(origFunc);\n\t    }\n\t    function assert(b) {\n\t        if (!b)\n\t            throw new Error(\"Assertion Failed\");\n\t    }\n\t    function asap$1(fn) {\n\t        if (_global.setImmediate)\n\t            setImmediate(fn);\n\t        else\n\t            setTimeout(fn, 0);\n\t    }\n\t    function arrayToObject(array, extractor) {\n\t        return array.reduce(function (result, item, i) {\n\t            var nameAndValue = extractor(item, i);\n\t            if (nameAndValue)\n\t                result[nameAndValue[0]] = nameAndValue[1];\n\t            return result;\n\t        }, {});\n\t    }\n\t    function getByKeyPath(obj, keyPath) {\n\t        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n\t            return obj[keyPath];\n\t        if (!keyPath)\n\t            return obj;\n\t        if (typeof keyPath !== 'string') {\n\t            var rv = [];\n\t            for (var i = 0, l = keyPath.length; i < l; ++i) {\n\t                var val = getByKeyPath(obj, keyPath[i]);\n\t                rv.push(val);\n\t            }\n\t            return rv;\n\t        }\n\t        var period = keyPath.indexOf('.');\n\t        if (period !== -1) {\n\t            var innerObj = obj[keyPath.substr(0, period)];\n\t            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n\t        }\n\t        return undefined;\n\t    }\n\t    function setByKeyPath(obj, keyPath, value) {\n\t        if (!obj || keyPath === undefined)\n\t            return;\n\t        if ('isFrozen' in Object && Object.isFrozen(obj))\n\t            return;\n\t        if (typeof keyPath !== 'string' && 'length' in keyPath) {\n\t            assert(typeof value !== 'string' && 'length' in value);\n\t            for (var i = 0, l = keyPath.length; i < l; ++i) {\n\t                setByKeyPath(obj, keyPath[i], value[i]);\n\t            }\n\t        }\n\t        else {\n\t            var period = keyPath.indexOf('.');\n\t            if (period !== -1) {\n\t                var currentKeyPath = keyPath.substr(0, period);\n\t                var remainingKeyPath = keyPath.substr(period + 1);\n\t                if (remainingKeyPath === \"\")\n\t                    if (value === undefined) {\n\t                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n\t                            obj.splice(currentKeyPath, 1);\n\t                        else\n\t                            delete obj[currentKeyPath];\n\t                    }\n\t                    else\n\t                        obj[currentKeyPath] = value;\n\t                else {\n\t                    var innerObj = obj[currentKeyPath];\n\t                    if (!innerObj || !hasOwn(obj, currentKeyPath))\n\t                        innerObj = (obj[currentKeyPath] = {});\n\t                    setByKeyPath(innerObj, remainingKeyPath, value);\n\t                }\n\t            }\n\t            else {\n\t                if (value === undefined) {\n\t                    if (isArray(obj) && !isNaN(parseInt(keyPath)))\n\t                        obj.splice(keyPath, 1);\n\t                    else\n\t                        delete obj[keyPath];\n\t                }\n\t                else\n\t                    obj[keyPath] = value;\n\t            }\n\t        }\n\t    }\n\t    function delByKeyPath(obj, keyPath) {\n\t        if (typeof keyPath === 'string')\n\t            setByKeyPath(obj, keyPath, undefined);\n\t        else if ('length' in keyPath)\n\t            [].map.call(keyPath, function (kp) {\n\t                setByKeyPath(obj, kp, undefined);\n\t            });\n\t    }\n\t    function shallowClone(obj) {\n\t        var rv = {};\n\t        for (var m in obj) {\n\t            if (hasOwn(obj, m))\n\t                rv[m] = obj[m];\n\t        }\n\t        return rv;\n\t    }\n\t    var concat = [].concat;\n\t    function flatten(a) {\n\t        return concat.apply([], a);\n\t    }\n\t    var intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n\t        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\n\t    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));\n\t    function cloneSimpleObjectTree(o) {\n\t        var rv = {};\n\t        for (var k in o)\n\t            if (hasOwn(o, k)) {\n\t                var v = o[k];\n\t                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);\n\t            }\n\t        return rv;\n\t    }\n\t    function objectIsEmpty(o) {\n\t        for (var k in o)\n\t            if (hasOwn(o, k))\n\t                return false;\n\t        return true;\n\t    }\n\t    var circularRefs = null;\n\t    function deepClone(any) {\n\t        circularRefs = new WeakMap();\n\t        var rv = innerDeepClone(any);\n\t        circularRefs = null;\n\t        return rv;\n\t    }\n\t    function innerDeepClone(x) {\n\t        if (!x || typeof x !== 'object')\n\t            return x;\n\t        var rv = circularRefs.get(x);\n\t        if (rv)\n\t            return rv;\n\t        if (isArray(x)) {\n\t            rv = [];\n\t            circularRefs.set(x, rv);\n\t            for (var i = 0, l = x.length; i < l; ++i) {\n\t                rv.push(innerDeepClone(x[i]));\n\t            }\n\t        }\n\t        else if (intrinsicTypes.has(x.constructor)) {\n\t            rv = x;\n\t        }\n\t        else {\n\t            var proto = getProto(x);\n\t            rv = proto === Object.prototype ? {} : Object.create(proto);\n\t            circularRefs.set(x, rv);\n\t            for (var prop in x) {\n\t                if (hasOwn(x, prop)) {\n\t                    rv[prop] = innerDeepClone(x[prop]);\n\t                }\n\t            }\n\t        }\n\t        return rv;\n\t    }\n\t    var toString = {}.toString;\n\t    function toStringTag(o) {\n\t        return toString.call(o).slice(8, -1);\n\t    }\n\t    var iteratorSymbol = typeof Symbol !== 'undefined' ?\n\t        Symbol.iterator :\n\t        '@@iterator';\n\t    var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n\t        var i;\n\t        return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n\t    } : function () { return null; };\n\t    function delArrayItem(a, x) {\n\t        var i = a.indexOf(x);\n\t        if (i >= 0)\n\t            a.splice(i, 1);\n\t        return i >= 0;\n\t    }\n\t    var NO_CHAR_ARRAY = {};\n\t    function getArrayOf(arrayLike) {\n\t        var i, a, x, it;\n\t        if (arguments.length === 1) {\n\t            if (isArray(arrayLike))\n\t                return arrayLike.slice();\n\t            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n\t                return [arrayLike];\n\t            if ((it = getIteratorOf(arrayLike))) {\n\t                a = [];\n\t                while ((x = it.next()), !x.done)\n\t                    a.push(x.value);\n\t                return a;\n\t            }\n\t            if (arrayLike == null)\n\t                return [arrayLike];\n\t            i = arrayLike.length;\n\t            if (typeof i === 'number') {\n\t                a = new Array(i);\n\t                while (i--)\n\t                    a[i] = arrayLike[i];\n\t                return a;\n\t            }\n\t            return [arrayLike];\n\t        }\n\t        i = arguments.length;\n\t        a = new Array(i);\n\t        while (i--)\n\t            a[i] = arguments[i];\n\t        return a;\n\t    }\n\t    var isAsyncFunction = typeof Symbol !== 'undefined'\n\t        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n\t        : function () { return false; };\n\n\t    var dexieErrorNames = [\n\t        'Modify',\n\t        'Bulk',\n\t        'OpenFailed',\n\t        'VersionChange',\n\t        'Schema',\n\t        'Upgrade',\n\t        'InvalidTable',\n\t        'MissingAPI',\n\t        'NoSuchDatabase',\n\t        'InvalidArgument',\n\t        'SubTransaction',\n\t        'Unsupported',\n\t        'Internal',\n\t        'DatabaseClosed',\n\t        'PrematureCommit',\n\t        'ForeignAwait'\n\t    ];\n\t    var idbDomErrorNames = [\n\t        'Unknown',\n\t        'Constraint',\n\t        'Data',\n\t        'TransactionInactive',\n\t        'ReadOnly',\n\t        'Version',\n\t        'NotFound',\n\t        'InvalidState',\n\t        'InvalidAccess',\n\t        'Abort',\n\t        'Timeout',\n\t        'QuotaExceeded',\n\t        'Syntax',\n\t        'DataClone'\n\t    ];\n\t    var errorList = dexieErrorNames.concat(idbDomErrorNames);\n\t    var defaultTexts = {\n\t        VersionChanged: \"Database version changed by other database connection\",\n\t        DatabaseClosed: \"Database has been closed\",\n\t        Abort: \"Transaction aborted\",\n\t        TransactionInactive: \"Transaction has already completed or failed\",\n\t        MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n\t    };\n\t    function DexieError(name, msg) {\n\t        this.name = name;\n\t        this.message = msg;\n\t    }\n\t    derive(DexieError).from(Error).extend({\n\t        toString: function () { return this.name + \": \" + this.message; }\n\t    });\n\t    function getMultiErrorMessage(msg, failures) {\n\t        return msg + \". Errors: \" + Object.keys(failures)\n\t            .map(function (key) { return failures[key].toString(); })\n\t            .filter(function (v, i, s) { return s.indexOf(v) === i; })\n\t            .join('\\n');\n\t    }\n\t    function ModifyError(msg, failures, successCount, failedKeys) {\n\t        this.failures = failures;\n\t        this.failedKeys = failedKeys;\n\t        this.successCount = successCount;\n\t        this.message = getMultiErrorMessage(msg, failures);\n\t    }\n\t    derive(ModifyError).from(DexieError);\n\t    function BulkError(msg, failures) {\n\t        this.name = \"BulkError\";\n\t        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n\t        this.failuresByPos = failures;\n\t        this.message = getMultiErrorMessage(msg, this.failures);\n\t    }\n\t    derive(BulkError).from(DexieError);\n\t    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\n\t    var BaseException = DexieError;\n\t    var exceptions = errorList.reduce(function (obj, name) {\n\t        var fullName = name + \"Error\";\n\t        function DexieError(msgOrInner, inner) {\n\t            this.name = fullName;\n\t            if (!msgOrInner) {\n\t                this.message = defaultTexts[name] || fullName;\n\t                this.inner = null;\n\t            }\n\t            else if (typeof msgOrInner === 'string') {\n\t                this.message = \"\".concat(msgOrInner).concat(!inner ? '' : '\\n ' + inner);\n\t                this.inner = inner || null;\n\t            }\n\t            else if (typeof msgOrInner === 'object') {\n\t                this.message = \"\".concat(msgOrInner.name, \" \").concat(msgOrInner.message);\n\t                this.inner = msgOrInner;\n\t            }\n\t        }\n\t        derive(DexieError).from(BaseException);\n\t        obj[name] = DexieError;\n\t        return obj;\n\t    }, {});\n\t    exceptions.Syntax = SyntaxError;\n\t    exceptions.Type = TypeError;\n\t    exceptions.Range = RangeError;\n\t    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n\t        obj[name + \"Error\"] = exceptions[name];\n\t        return obj;\n\t    }, {});\n\t    function mapError(domError, message) {\n\t        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n\t            return domError;\n\t        var rv = new exceptionMap[domError.name](message || domError.message, domError);\n\t        if (\"stack\" in domError) {\n\t            setProp(rv, \"stack\", { get: function () {\n\t                    return this.inner.stack;\n\t                } });\n\t        }\n\t        return rv;\n\t    }\n\t    var fullNameExceptions = errorList.reduce(function (obj, name) {\n\t        if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n\t            obj[name + \"Error\"] = exceptions[name];\n\t        return obj;\n\t    }, {});\n\t    fullNameExceptions.ModifyError = ModifyError;\n\t    fullNameExceptions.DexieError = DexieError;\n\t    fullNameExceptions.BulkError = BulkError;\n\n\t    function nop() { }\n\t    function mirror(val) { return val; }\n\t    function pureFunctionChain(f1, f2) {\n\t        if (f1 == null || f1 === mirror)\n\t            return f2;\n\t        return function (val) {\n\t            return f2(f1(val));\n\t        };\n\t    }\n\t    function callBoth(on1, on2) {\n\t        return function () {\n\t            on1.apply(this, arguments);\n\t            on2.apply(this, arguments);\n\t        };\n\t    }\n\t    function hookCreatingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            var res = f1.apply(this, arguments);\n\t            if (res !== undefined)\n\t                arguments[0] = res;\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = null;\n\t            this.onerror = null;\n\t            var res2 = f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t            return res2 !== undefined ? res2 : res;\n\t        };\n\t    }\n\t    function hookDeletingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            f1.apply(this, arguments);\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = this.onerror = null;\n\t            f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t        };\n\t    }\n\t    function hookUpdatingChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function (modifications) {\n\t            var res = f1.apply(this, arguments);\n\t            extend(modifications, res);\n\t            var onsuccess = this.onsuccess,\n\t            onerror = this.onerror;\n\t            this.onsuccess = null;\n\t            this.onerror = null;\n\t            var res2 = f2.apply(this, arguments);\n\t            if (onsuccess)\n\t                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n\t            if (onerror)\n\t                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n\t            return res === undefined ?\n\t                (res2 === undefined ? undefined : res2) :\n\t                (extend(res, res2));\n\t        };\n\t    }\n\t    function reverseStoppableEventChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            if (f2.apply(this, arguments) === false)\n\t                return false;\n\t            return f1.apply(this, arguments);\n\t        };\n\t    }\n\t    function promisableChain(f1, f2) {\n\t        if (f1 === nop)\n\t            return f2;\n\t        return function () {\n\t            var res = f1.apply(this, arguments);\n\t            if (res && typeof res.then === 'function') {\n\t                var thiz = this, i = arguments.length, args = new Array(i);\n\t                while (i--)\n\t                    args[i] = arguments[i];\n\t                return res.then(function () {\n\t                    return f2.apply(thiz, args);\n\t                });\n\t            }\n\t            return f2.apply(this, arguments);\n\t        };\n\t    }\n\n\t    var debug = typeof location !== 'undefined' &&\n\t        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\t    function setDebug(value, filter) {\n\t        debug = value;\n\t    }\n\n\t    var INTERNAL = {};\n\t    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n\t        [] :\n\t        (function () {\n\t            var globalP = Promise.resolve();\n\t            if (typeof crypto === 'undefined' || !crypto.subtle)\n\t                return [globalP, getProto(globalP), globalP];\n\t            var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n\t            return [\n\t                nativeP,\n\t                getProto(nativeP),\n\t                globalP\n\t            ];\n\t        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n\t    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n\t    var patchGlobalPromise = !!resolvedGlobalPromise;\n\t    function schedulePhysicalTick() {\n\t        queueMicrotask(physicalTick);\n\t    }\n\t    var asap = function (callback, args) {\n\t        microtickQueue.push([callback, args]);\n\t        if (needsNewPhysicalTick) {\n\t            schedulePhysicalTick();\n\t            needsNewPhysicalTick = false;\n\t        }\n\t    };\n\t    var isOutsideMicroTick = true,\n\t    needsNewPhysicalTick = true,\n\t    unhandledErrors = [],\n\t    rejectingErrors = [],\n\t    rejectionMapper = mirror;\n\t    var globalPSD = {\n\t        id: 'global',\n\t        global: true,\n\t        ref: 0,\n\t        unhandleds: [],\n\t        onunhandled: nop,\n\t        pgp: false,\n\t        env: {},\n\t        finalize: nop\n\t    };\n\t    var PSD = globalPSD;\n\t    var microtickQueue = [];\n\t    var numScheduledCalls = 0;\n\t    var tickFinalizers = [];\n\t    function DexiePromise(fn) {\n\t        if (typeof this !== 'object')\n\t            throw new TypeError('Promises must be constructed via new');\n\t        this._listeners = [];\n\t        this._lib = false;\n\t        var psd = (this._PSD = PSD);\n\t        if (typeof fn !== 'function') {\n\t            if (fn !== INTERNAL)\n\t                throw new TypeError('Not a function');\n\t            this._state = arguments[1];\n\t            this._value = arguments[2];\n\t            if (this._state === false)\n\t                handleRejection(this, this._value);\n\t            return;\n\t        }\n\t        this._state = null;\n\t        this._value = null;\n\t        ++psd.ref;\n\t        executePromiseTask(this, fn);\n\t    }\n\t    var thenProp = {\n\t        get: function () {\n\t            var psd = PSD, microTaskId = totalEchoes;\n\t            function then(onFulfilled, onRejected) {\n\t                var _this = this;\n\t                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n\t                var cleanup = possibleAwait && !decrementExpectedAwaits();\n\t                var rv = new DexiePromise(function (resolve, reject) {\n\t                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n\t                });\n\t                if (this._consoleTask)\n\t                    rv._consoleTask = this._consoleTask;\n\t                return rv;\n\t            }\n\t            then.prototype = INTERNAL;\n\t            return then;\n\t        },\n\t        set: function (value) {\n\t            setProp(this, 'then', value && value.prototype === INTERNAL ?\n\t                thenProp :\n\t                {\n\t                    get: function () {\n\t                        return value;\n\t                    },\n\t                    set: thenProp.set\n\t                });\n\t        }\n\t    };\n\t    props(DexiePromise.prototype, {\n\t        then: thenProp,\n\t        _then: function (onFulfilled, onRejected) {\n\t            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n\t        },\n\t        catch: function (onRejected) {\n\t            if (arguments.length === 1)\n\t                return this.then(null, onRejected);\n\t            var type = arguments[0], handler = arguments[1];\n\t            return typeof type === 'function' ? this.then(null, function (err) {\n\t                return err instanceof type ? handler(err) : PromiseReject(err);\n\t            })\n\t                : this.then(null, function (err) {\n\t                    return err && err.name === type ? handler(err) : PromiseReject(err);\n\t                });\n\t        },\n\t        finally: function (onFinally) {\n\t            return this.then(function (value) {\n\t                return DexiePromise.resolve(onFinally()).then(function () { return value; });\n\t            }, function (err) {\n\t                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });\n\t            });\n\t        },\n\t        timeout: function (ms, msg) {\n\t            var _this = this;\n\t            return ms < Infinity ?\n\t                new DexiePromise(function (resolve, reject) {\n\t                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n\t                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n\t                }) : this;\n\t        }\n\t    });\n\t    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n\t        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n\t    globalPSD.env = snapShot();\n\t    function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n\t        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t        this.resolve = resolve;\n\t        this.reject = reject;\n\t        this.psd = zone;\n\t    }\n\t    props(DexiePromise, {\n\t        all: function () {\n\t            var values = getArrayOf.apply(null, arguments)\n\t                .map(onPossibleParallellAsync);\n\t            return new DexiePromise(function (resolve, reject) {\n\t                if (values.length === 0)\n\t                    resolve([]);\n\t                var remaining = values.length;\n\t                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n\t                    values[i] = x;\n\t                    if (!--remaining)\n\t                        resolve(values);\n\t                }, reject); });\n\t            });\n\t        },\n\t        resolve: function (value) {\n\t            if (value instanceof DexiePromise)\n\t                return value;\n\t            if (value && typeof value.then === 'function')\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    value.then(resolve, reject);\n\t                });\n\t            var rv = new DexiePromise(INTERNAL, true, value);\n\t            return rv;\n\t        },\n\t        reject: PromiseReject,\n\t        race: function () {\n\t            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t            return new DexiePromise(function (resolve, reject) {\n\t                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n\t            });\n\t        },\n\t        PSD: {\n\t            get: function () { return PSD; },\n\t            set: function (value) { return PSD = value; }\n\t        },\n\t        totalEchoes: { get: function () { return totalEchoes; } },\n\t        newPSD: newScope,\n\t        usePSD: usePSD,\n\t        scheduler: {\n\t            get: function () { return asap; },\n\t            set: function (value) { asap = value; }\n\t        },\n\t        rejectionMapper: {\n\t            get: function () { return rejectionMapper; },\n\t            set: function (value) { rejectionMapper = value; }\n\t        },\n\t        follow: function (fn, zoneProps) {\n\t            return new DexiePromise(function (resolve, reject) {\n\t                return newScope(function (resolve, reject) {\n\t                    var psd = PSD;\n\t                    psd.unhandleds = [];\n\t                    psd.onunhandled = reject;\n\t                    psd.finalize = callBoth(function () {\n\t                        var _this = this;\n\t                        run_at_end_of_this_or_next_physical_tick(function () {\n\t                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n\t                        });\n\t                    }, psd.finalize);\n\t                    fn();\n\t                }, zoneProps, resolve, reject);\n\t            });\n\t        }\n\t    });\n\t    if (NativePromise) {\n\t        if (NativePromise.allSettled)\n\t            setProp(DexiePromise, \"allSettled\", function () {\n\t                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t                return new DexiePromise(function (resolve) {\n\t                    if (possiblePromises.length === 0)\n\t                        resolve([]);\n\t                    var remaining = possiblePromises.length;\n\t                    var results = new Array(remaining);\n\t                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n\t                        .then(function () { return --remaining || resolve(results); }); });\n\t                });\n\t            });\n\t        if (NativePromise.any && typeof AggregateError !== 'undefined')\n\t            setProp(DexiePromise, \"any\", function () {\n\t                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    if (possiblePromises.length === 0)\n\t                        reject(new AggregateError([]));\n\t                    var remaining = possiblePromises.length;\n\t                    var failures = new Array(remaining);\n\t                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n\t                        failures[i] = failure;\n\t                        if (!--remaining)\n\t                            reject(new AggregateError(failures));\n\t                    }); });\n\t                });\n\t            });\n\t    }\n\t    function executePromiseTask(promise, fn) {\n\t        try {\n\t            fn(function (value) {\n\t                if (promise._state !== null)\n\t                    return;\n\t                if (value === promise)\n\t                    throw new TypeError('A promise cannot be resolved with itself.');\n\t                var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\t                if (value && typeof value.then === 'function') {\n\t                    executePromiseTask(promise, function (resolve, reject) {\n\t                        value instanceof DexiePromise ?\n\t                            value._then(resolve, reject) :\n\t                            value.then(resolve, reject);\n\t                    });\n\t                }\n\t                else {\n\t                    promise._state = true;\n\t                    promise._value = value;\n\t                    propagateAllListeners(promise);\n\t                }\n\t                if (shouldExecuteTick)\n\t                    endMicroTickScope();\n\t            }, handleRejection.bind(null, promise));\n\t        }\n\t        catch (ex) {\n\t            handleRejection(promise, ex);\n\t        }\n\t    }\n\t    function handleRejection(promise, reason) {\n\t        rejectingErrors.push(reason);\n\t        if (promise._state !== null)\n\t            return;\n\t        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\t        reason = rejectionMapper(reason);\n\t        promise._state = false;\n\t        promise._value = reason;\n\t        addPossiblyUnhandledError(promise);\n\t        propagateAllListeners(promise);\n\t        if (shouldExecuteTick)\n\t            endMicroTickScope();\n\t    }\n\t    function propagateAllListeners(promise) {\n\t        var listeners = promise._listeners;\n\t        promise._listeners = [];\n\t        for (var i = 0, len = listeners.length; i < len; ++i) {\n\t            propagateToListener(promise, listeners[i]);\n\t        }\n\t        var psd = promise._PSD;\n\t        --psd.ref || psd.finalize();\n\t        if (numScheduledCalls === 0) {\n\t            ++numScheduledCalls;\n\t            asap(function () {\n\t                if (--numScheduledCalls === 0)\n\t                    finalizePhysicalTick();\n\t            }, []);\n\t        }\n\t    }\n\t    function propagateToListener(promise, listener) {\n\t        if (promise._state === null) {\n\t            promise._listeners.push(listener);\n\t            return;\n\t        }\n\t        var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n\t        if (cb === null) {\n\t            return (promise._state ? listener.resolve : listener.reject)(promise._value);\n\t        }\n\t        ++listener.psd.ref;\n\t        ++numScheduledCalls;\n\t        asap(callListener, [cb, promise, listener]);\n\t    }\n\t    function callListener(cb, promise, listener) {\n\t        try {\n\t            var ret, value = promise._value;\n\t            if (!promise._state && rejectingErrors.length)\n\t                rejectingErrors = [];\n\t            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);\n\t            if (!promise._state && rejectingErrors.indexOf(value) === -1) {\n\t                markErrorAsHandled(promise);\n\t            }\n\t            listener.resolve(ret);\n\t        }\n\t        catch (e) {\n\t            listener.reject(e);\n\t        }\n\t        finally {\n\t            if (--numScheduledCalls === 0)\n\t                finalizePhysicalTick();\n\t            --listener.psd.ref || listener.psd.finalize();\n\t        }\n\t    }\n\t    function physicalTick() {\n\t        usePSD(globalPSD, function () {\n\t            beginMicroTickScope() && endMicroTickScope();\n\t        });\n\t    }\n\t    function beginMicroTickScope() {\n\t        var wasRootExec = isOutsideMicroTick;\n\t        isOutsideMicroTick = false;\n\t        needsNewPhysicalTick = false;\n\t        return wasRootExec;\n\t    }\n\t    function endMicroTickScope() {\n\t        var callbacks, i, l;\n\t        do {\n\t            while (microtickQueue.length > 0) {\n\t                callbacks = microtickQueue;\n\t                microtickQueue = [];\n\t                l = callbacks.length;\n\t                for (i = 0; i < l; ++i) {\n\t                    var item = callbacks[i];\n\t                    item[0].apply(null, item[1]);\n\t                }\n\t            }\n\t        } while (microtickQueue.length > 0);\n\t        isOutsideMicroTick = true;\n\t        needsNewPhysicalTick = true;\n\t    }\n\t    function finalizePhysicalTick() {\n\t        var unhandledErrs = unhandledErrors;\n\t        unhandledErrors = [];\n\t        unhandledErrs.forEach(function (p) {\n\t            p._PSD.onunhandled.call(null, p._value, p);\n\t        });\n\t        var finalizers = tickFinalizers.slice(0);\n\t        var i = finalizers.length;\n\t        while (i)\n\t            finalizers[--i]();\n\t    }\n\t    function run_at_end_of_this_or_next_physical_tick(fn) {\n\t        function finalizer() {\n\t            fn();\n\t            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n\t        }\n\t        tickFinalizers.push(finalizer);\n\t        ++numScheduledCalls;\n\t        asap(function () {\n\t            if (--numScheduledCalls === 0)\n\t                finalizePhysicalTick();\n\t        }, []);\n\t    }\n\t    function addPossiblyUnhandledError(promise) {\n\t        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n\t            unhandledErrors.push(promise);\n\t    }\n\t    function markErrorAsHandled(promise) {\n\t        var i = unhandledErrors.length;\n\t        while (i)\n\t            if (unhandledErrors[--i]._value === promise._value) {\n\t                unhandledErrors.splice(i, 1);\n\t                return;\n\t            }\n\t    }\n\t    function PromiseReject(reason) {\n\t        return new DexiePromise(INTERNAL, false, reason);\n\t    }\n\t    function wrap(fn, errorCatcher) {\n\t        var psd = PSD;\n\t        return function () {\n\t            var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n\t            try {\n\t                switchToZone(psd, true);\n\t                return fn.apply(this, arguments);\n\t            }\n\t            catch (e) {\n\t                errorCatcher && errorCatcher(e);\n\t            }\n\t            finally {\n\t                switchToZone(outerScope, false);\n\t                if (wasRootExec)\n\t                    endMicroTickScope();\n\t            }\n\t        };\n\t    }\n\t    var task = { awaits: 0, echoes: 0, id: 0 };\n\t    var taskCounter = 0;\n\t    var zoneStack = [];\n\t    var zoneEchoes = 0;\n\t    var totalEchoes = 0;\n\t    var zone_id_counter = 0;\n\t    function newScope(fn, props, a1, a2) {\n\t        var parent = PSD, psd = Object.create(parent);\n\t        psd.parent = parent;\n\t        psd.ref = 0;\n\t        psd.global = false;\n\t        psd.id = ++zone_id_counter;\n\t        globalPSD.env;\n\t        psd.env = patchGlobalPromise ? {\n\t            Promise: DexiePromise,\n\t            PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n\t            all: DexiePromise.all,\n\t            race: DexiePromise.race,\n\t            allSettled: DexiePromise.allSettled,\n\t            any: DexiePromise.any,\n\t            resolve: DexiePromise.resolve,\n\t            reject: DexiePromise.reject,\n\t        } : {};\n\t        if (props)\n\t            extend(psd, props);\n\t        ++parent.ref;\n\t        psd.finalize = function () {\n\t            --this.parent.ref || this.parent.finalize();\n\t        };\n\t        var rv = usePSD(psd, fn, a1, a2);\n\t        if (psd.ref === 0)\n\t            psd.finalize();\n\t        return rv;\n\t    }\n\t    function incrementExpectedAwaits() {\n\t        if (!task.id)\n\t            task.id = ++taskCounter;\n\t        ++task.awaits;\n\t        task.echoes += ZONE_ECHO_LIMIT;\n\t        return task.id;\n\t    }\n\t    function decrementExpectedAwaits() {\n\t        if (!task.awaits)\n\t            return false;\n\t        if (--task.awaits === 0)\n\t            task.id = 0;\n\t        task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n\t        return true;\n\t    }\n\t    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n\t        incrementExpectedAwaits = decrementExpectedAwaits = nop;\n\t    }\n\t    function onPossibleParallellAsync(possiblePromise) {\n\t        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n\t            incrementExpectedAwaits();\n\t            return possiblePromise.then(function (x) {\n\t                decrementExpectedAwaits();\n\t                return x;\n\t            }, function (e) {\n\t                decrementExpectedAwaits();\n\t                return rejection(e);\n\t            });\n\t        }\n\t        return possiblePromise;\n\t    }\n\t    function zoneEnterEcho(targetZone) {\n\t        ++totalEchoes;\n\t        if (!task.echoes || --task.echoes === 0) {\n\t            task.echoes = task.awaits = task.id = 0;\n\t        }\n\t        zoneStack.push(PSD);\n\t        switchToZone(targetZone, true);\n\t    }\n\t    function zoneLeaveEcho() {\n\t        var zone = zoneStack[zoneStack.length - 1];\n\t        zoneStack.pop();\n\t        switchToZone(zone, false);\n\t    }\n\t    function switchToZone(targetZone, bEnteringZone) {\n\t        var currentZone = PSD;\n\t        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n\t            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n\t        }\n\t        if (targetZone === PSD)\n\t            return;\n\t        PSD = targetZone;\n\t        if (currentZone === globalPSD)\n\t            globalPSD.env = snapShot();\n\t        if (patchGlobalPromise) {\n\t            var GlobalPromise = globalPSD.env.Promise;\n\t            var targetEnv = targetZone.env;\n\t            if (currentZone.global || targetZone.global) {\n\t                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n\t                GlobalPromise.all = targetEnv.all;\n\t                GlobalPromise.race = targetEnv.race;\n\t                GlobalPromise.resolve = targetEnv.resolve;\n\t                GlobalPromise.reject = targetEnv.reject;\n\t                if (targetEnv.allSettled)\n\t                    GlobalPromise.allSettled = targetEnv.allSettled;\n\t                if (targetEnv.any)\n\t                    GlobalPromise.any = targetEnv.any;\n\t            }\n\t        }\n\t    }\n\t    function snapShot() {\n\t        var GlobalPromise = _global.Promise;\n\t        return patchGlobalPromise ? {\n\t            Promise: GlobalPromise,\n\t            PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n\t            all: GlobalPromise.all,\n\t            race: GlobalPromise.race,\n\t            allSettled: GlobalPromise.allSettled,\n\t            any: GlobalPromise.any,\n\t            resolve: GlobalPromise.resolve,\n\t            reject: GlobalPromise.reject,\n\t        } : {};\n\t    }\n\t    function usePSD(psd, fn, a1, a2, a3) {\n\t        var outerScope = PSD;\n\t        try {\n\t            switchToZone(psd, true);\n\t            return fn(a1, a2, a3);\n\t        }\n\t        finally {\n\t            switchToZone(outerScope, false);\n\t        }\n\t    }\n\t    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n\t        return typeof fn !== 'function' ? fn : function () {\n\t            var outerZone = PSD;\n\t            if (possibleAwait)\n\t                incrementExpectedAwaits();\n\t            switchToZone(zone, true);\n\t            try {\n\t                return fn.apply(this, arguments);\n\t            }\n\t            finally {\n\t                switchToZone(outerZone, false);\n\t                if (cleanup)\n\t                    queueMicrotask(decrementExpectedAwaits);\n\t            }\n\t        };\n\t    }\n\t    function execInGlobalContext(cb) {\n\t        if (Promise === NativePromise && task.echoes === 0) {\n\t            if (zoneEchoes === 0) {\n\t                cb();\n\t            }\n\t            else {\n\t                enqueueNativeMicroTask(cb);\n\t            }\n\t        }\n\t        else {\n\t            setTimeout(cb, 0);\n\t        }\n\t    }\n\t    var rejection = DexiePromise.reject;\n\n\t    function tempTransaction(db, mode, storeNames, fn) {\n\t        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n\t            if (db._state.openComplete) {\n\t                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n\t            }\n\t            if (!db._state.isBeingOpened) {\n\t                if (!db._state.autoOpen)\n\t                    return rejection(new exceptions.DatabaseClosed());\n\t                db.open().catch(nop);\n\t            }\n\t            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n\t        }\n\t        else {\n\t            var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n\t            try {\n\t                trans.create();\n\t                db._state.PR1398_maxLoop = 3;\n\t            }\n\t            catch (ex) {\n\t                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n\t                    console.warn('Dexie: Need to reopen db');\n\t                    db.close({ disableAutoOpen: false });\n\t                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n\t                }\n\t                return rejection(ex);\n\t            }\n\t            return trans._promise(mode, function (resolve, reject) {\n\t                return newScope(function () {\n\t                    PSD.trans = trans;\n\t                    return fn(resolve, reject, trans);\n\t                });\n\t            }).then(function (result) {\n\t                if (mode === 'readwrite')\n\t                    try {\n\t                        trans.idbtrans.commit();\n\t                    }\n\t                    catch (_a) { }\n\t                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });\n\t            });\n\t        }\n\t    }\n\n\t    var DEXIE_VERSION = '4.0.8';\n\t    var maxString = String.fromCharCode(65535);\n\t    var minKey = -Infinity;\n\t    var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n\t    var STRING_EXPECTED = \"String expected.\";\n\t    var connections = [];\n\t    var DBNAMES_DB = '__dbnames';\n\t    var READONLY = 'readonly';\n\t    var READWRITE = 'readwrite';\n\n\t    function combine(filter1, filter2) {\n\t        return filter1 ?\n\t            filter2 ?\n\t                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n\t                filter1 :\n\t            filter2;\n\t    }\n\n\t    var AnyRange = {\n\t        type: 3 ,\n\t        lower: -Infinity,\n\t        lowerOpen: false,\n\t        upper: [[]],\n\t        upperOpen: false\n\t    };\n\n\t    function workaroundForUndefinedPrimKey(keyPath) {\n\t        return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n\t            ? function (obj) {\n\t                if (obj[keyPath] === undefined && (keyPath in obj)) {\n\t                    obj = deepClone(obj);\n\t                    delete obj[keyPath];\n\t                }\n\t                return obj;\n\t            }\n\t            : function (obj) { return obj; };\n\t    }\n\n\t    function Entity() {\n\t        throw exceptions.Type();\n\t    }\n\n\t    function cmp(a, b) {\n\t        try {\n\t            var ta = type(a);\n\t            var tb = type(b);\n\t            if (ta !== tb) {\n\t                if (ta === 'Array')\n\t                    return 1;\n\t                if (tb === 'Array')\n\t                    return -1;\n\t                if (ta === 'binary')\n\t                    return 1;\n\t                if (tb === 'binary')\n\t                    return -1;\n\t                if (ta === 'string')\n\t                    return 1;\n\t                if (tb === 'string')\n\t                    return -1;\n\t                if (ta === 'Date')\n\t                    return 1;\n\t                if (tb !== 'Date')\n\t                    return NaN;\n\t                return -1;\n\t            }\n\t            switch (ta) {\n\t                case 'number':\n\t                case 'Date':\n\t                case 'string':\n\t                    return a > b ? 1 : a < b ? -1 : 0;\n\t                case 'binary': {\n\t                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n\t                }\n\t                case 'Array':\n\t                    return compareArrays(a, b);\n\t            }\n\t        }\n\t        catch (_a) { }\n\t        return NaN;\n\t    }\n\t    function compareArrays(a, b) {\n\t        var al = a.length;\n\t        var bl = b.length;\n\t        var l = al < bl ? al : bl;\n\t        for (var i = 0; i < l; ++i) {\n\t            var res = cmp(a[i], b[i]);\n\t            if (res !== 0)\n\t                return res;\n\t        }\n\t        return al === bl ? 0 : al < bl ? -1 : 1;\n\t    }\n\t    function compareUint8Arrays(a, b) {\n\t        var al = a.length;\n\t        var bl = b.length;\n\t        var l = al < bl ? al : bl;\n\t        for (var i = 0; i < l; ++i) {\n\t            if (a[i] !== b[i])\n\t                return a[i] < b[i] ? -1 : 1;\n\t        }\n\t        return al === bl ? 0 : al < bl ? -1 : 1;\n\t    }\n\t    function type(x) {\n\t        var t = typeof x;\n\t        if (t !== 'object')\n\t            return t;\n\t        if (ArrayBuffer.isView(x))\n\t            return 'binary';\n\t        var tsTag = toStringTag(x);\n\t        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n\t    }\n\t    function getUint8Array(a) {\n\t        if (a instanceof Uint8Array)\n\t            return a;\n\t        if (ArrayBuffer.isView(a))\n\t            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n\t        return new Uint8Array(a);\n\t    }\n\n\t    var Table =  (function () {\n\t        function Table() {\n\t        }\n\t        Table.prototype._trans = function (mode, fn, writeLocked) {\n\t            var trans = this._tx || PSD.trans;\n\t            var tableName = this.name;\n\t            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask(\"Dexie: \".concat(mode === 'readonly' ? 'read' : 'write', \" \").concat(this.name));\n\t            function checkTableInTransaction(resolve, reject, trans) {\n\t                if (!trans.schema[tableName])\n\t                    throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n\t                return fn(trans.idbtrans, trans);\n\t            }\n\t            var wasRootExec = beginMicroTickScope();\n\t            try {\n\t                var p = trans && trans.db._novip === this.db._novip ?\n\t                    trans === PSD.trans ?\n\t                        trans._promise(mode, checkTableInTransaction, writeLocked) :\n\t                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n\t                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n\t                if (task) {\n\t                    p._consoleTask = task;\n\t                    p = p.catch(function (err) {\n\t                        console.trace(err);\n\t                        return rejection(err);\n\t                    });\n\t                }\n\t                return p;\n\t            }\n\t            finally {\n\t                if (wasRootExec)\n\t                    endMicroTickScope();\n\t            }\n\t        };\n\t        Table.prototype.get = function (keyOrCrit, cb) {\n\t            var _this = this;\n\t            if (keyOrCrit && keyOrCrit.constructor === Object)\n\t                return this.where(keyOrCrit).first(cb);\n\t            if (keyOrCrit == null)\n\t                return rejection(new exceptions.Type(\"Invalid argument to Table.get()\"));\n\t            return this._trans('readonly', function (trans) {\n\t                return _this.core.get({ trans: trans, key: keyOrCrit })\n\t                    .then(function (res) { return _this.hook.reading.fire(res); });\n\t            }).then(cb);\n\t        };\n\t        Table.prototype.where = function (indexOrCrit) {\n\t            if (typeof indexOrCrit === 'string')\n\t                return new this.db.WhereClause(this, indexOrCrit);\n\t            if (isArray(indexOrCrit))\n\t                return new this.db.WhereClause(this, \"[\".concat(indexOrCrit.join('+'), \"]\"));\n\t            var keyPaths = keys(indexOrCrit);\n\t            if (keyPaths.length === 1)\n\t                return this\n\t                    .where(keyPaths[0])\n\t                    .equals(indexOrCrit[keyPaths[0]]);\n\t            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n\t                if (ix.compound &&\n\t                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n\t                    for (var i = 0; i < keyPaths.length; ++i) {\n\t                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n\t                            return false;\n\t                    }\n\t                    return true;\n\t                }\n\t                return false;\n\t            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n\t            if (compoundIndex && this.db._maxKey !== maxString) {\n\t                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n\t                return this\n\t                    .where(keyPathsInValidOrder)\n\t                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n\t            }\n\t            if (!compoundIndex && debug)\n\t                console.warn(\"The query \".concat(JSON.stringify(indexOrCrit), \" on \").concat(this.name, \" would benefit from a \") +\n\t                    \"compound index [\".concat(keyPaths.join('+'), \"]\"));\n\t            var idxByName = this.schema.idxByName;\n\t            var idb = this.db._deps.indexedDB;\n\t            function equals(a, b) {\n\t                return idb.cmp(a, b) === 0;\n\t            }\n\t            var _a = keyPaths.reduce(function (_a, keyPath) {\n\t                var prevIndex = _a[0], prevFilterFn = _a[1];\n\t                var index = idxByName[keyPath];\n\t                var value = indexOrCrit[keyPath];\n\t                return [\n\t                    prevIndex || index,\n\t                    prevIndex || !index ?\n\t                        combine(prevFilterFn, index && index.multi ?\n\t                            function (x) {\n\t                                var prop = getByKeyPath(x, keyPath);\n\t                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n\t                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n\t                        : prevFilterFn\n\t                ];\n\t            }, [null, null]), idx = _a[0], filterFunction = _a[1];\n\t            return idx ?\n\t                this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n\t                    .filter(filterFunction) :\n\t                compoundIndex ?\n\t                    this.filter(filterFunction) :\n\t                    this.where(keyPaths).equals('');\n\t        };\n\t        Table.prototype.filter = function (filterFunction) {\n\t            return this.toCollection().and(filterFunction);\n\t        };\n\t        Table.prototype.count = function (thenShortcut) {\n\t            return this.toCollection().count(thenShortcut);\n\t        };\n\t        Table.prototype.offset = function (offset) {\n\t            return this.toCollection().offset(offset);\n\t        };\n\t        Table.prototype.limit = function (numRows) {\n\t            return this.toCollection().limit(numRows);\n\t        };\n\t        Table.prototype.each = function (callback) {\n\t            return this.toCollection().each(callback);\n\t        };\n\t        Table.prototype.toArray = function (thenShortcut) {\n\t            return this.toCollection().toArray(thenShortcut);\n\t        };\n\t        Table.prototype.toCollection = function () {\n\t            return new this.db.Collection(new this.db.WhereClause(this));\n\t        };\n\t        Table.prototype.orderBy = function (index) {\n\t            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n\t                \"[\".concat(index.join('+'), \"]\") :\n\t                index));\n\t        };\n\t        Table.prototype.reverse = function () {\n\t            return this.toCollection().reverse();\n\t        };\n\t        Table.prototype.mapToClass = function (constructor) {\n\t            var _a = this, db = _a.db, tableName = _a.name;\n\t            this.schema.mappedClass = constructor;\n\t            if (constructor.prototype instanceof Entity) {\n\t                constructor =  (function (_super) {\n\t                    __extends(class_1, _super);\n\t                    function class_1() {\n\t                        return _super !== null && _super.apply(this, arguments) || this;\n\t                    }\n\t                    Object.defineProperty(class_1.prototype, \"db\", {\n\t                        get: function () { return db; },\n\t                        enumerable: false,\n\t                        configurable: true\n\t                    });\n\t                    class_1.prototype.table = function () { return tableName; };\n\t                    return class_1;\n\t                }(constructor));\n\t            }\n\t            var inheritedProps = new Set();\n\t            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {\n\t                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });\n\t            }\n\t            var readHook = function (obj) {\n\t                if (!obj)\n\t                    return obj;\n\t                var res = Object.create(constructor.prototype);\n\t                for (var m in obj)\n\t                    if (!inheritedProps.has(m))\n\t                        try {\n\t                            res[m] = obj[m];\n\t                        }\n\t                        catch (_) { }\n\t                return res;\n\t            };\n\t            if (this.schema.readHook) {\n\t                this.hook.reading.unsubscribe(this.schema.readHook);\n\t            }\n\t            this.schema.readHook = readHook;\n\t            this.hook(\"reading\", readHook);\n\t            return constructor;\n\t        };\n\t        Table.prototype.defineClass = function () {\n\t            function Class(content) {\n\t                extend(this, content);\n\t            }\n\t            return this.mapToClass(Class);\n\t        };\n\t        Table.prototype.add = function (obj, key) {\n\t            var _this = this;\n\t            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t            var objToAdd = obj;\n\t            if (keyPath && auto) {\n\t                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n\t            }\n\t            return this._trans('readwrite', function (trans) {\n\t                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n\t            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n\t                .then(function (lastResult) {\n\t                if (keyPath) {\n\t                    try {\n\t                        setByKeyPath(obj, keyPath, lastResult);\n\t                    }\n\t                    catch (_) { }\n\t                }\n\t                return lastResult;\n\t            });\n\t        };\n\t        Table.prototype.update = function (keyOrObject, modifications) {\n\t            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n\t                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n\t                if (key === undefined)\n\t                    return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n\t                return this.where(\":id\").equals(key).modify(modifications);\n\t            }\n\t            else {\n\t                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n\t            }\n\t        };\n\t        Table.prototype.put = function (obj, key) {\n\t            var _this = this;\n\t            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t            var objToAdd = obj;\n\t            if (keyPath && auto) {\n\t                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n\t            }\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n\t                .then(function (lastResult) {\n\t                if (keyPath) {\n\t                    try {\n\t                        setByKeyPath(obj, keyPath, lastResult);\n\t                    }\n\t                    catch (_) { }\n\t                }\n\t                return lastResult;\n\t            });\n\t        };\n\t        Table.prototype.delete = function (key) {\n\t            var _this = this;\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n\t        };\n\t        Table.prototype.clear = function () {\n\t            var _this = this;\n\t            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })\n\t                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n\t        };\n\t        Table.prototype.bulkGet = function (keys) {\n\t            var _this = this;\n\t            return this._trans('readonly', function (trans) {\n\t                return _this.core.getMany({\n\t                    keys: keys,\n\t                    trans: trans\n\t                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n\t            });\n\t        };\n\t        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n\t            var _this = this;\n\t            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n\t            options = options || (keys ? undefined : keysOrOptions);\n\t            var wantResults = options ? options.allKeys : undefined;\n\t            return this._trans('readwrite', function (trans) {\n\t                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t                if (keyPath && keys)\n\t                    throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n\t                if (keys && keys.length !== objects.length)\n\t                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\t                var numObjects = objects.length;\n\t                var objectsToAdd = keyPath && auto ?\n\t                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n\t                    objects;\n\t                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n\t                    .then(function (_a) {\n\t                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n\t                    var result = wantResults ? results : lastResult;\n\t                    if (numFailures === 0)\n\t                        return result;\n\t                    throw new BulkError(\"\".concat(_this.name, \".bulkAdd(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n\t            var _this = this;\n\t            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n\t            options = options || (keys ? undefined : keysOrOptions);\n\t            var wantResults = options ? options.allKeys : undefined;\n\t            return this._trans('readwrite', function (trans) {\n\t                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n\t                if (keyPath && keys)\n\t                    throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n\t                if (keys && keys.length !== objects.length)\n\t                    throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\t                var numObjects = objects.length;\n\t                var objectsToPut = keyPath && auto ?\n\t                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n\t                    objects;\n\t                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n\t                    .then(function (_a) {\n\t                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n\t                    var result = wantResults ? results : lastResult;\n\t                    if (numFailures === 0)\n\t                        return result;\n\t                    throw new BulkError(\"\".concat(_this.name, \".bulkPut(): \").concat(numFailures, \" of \").concat(numObjects, \" operations failed\"), failures);\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkUpdate = function (keysAndChanges) {\n\t            var _this = this;\n\t            var coreTable = this.core;\n\t            var keys = keysAndChanges.map(function (entry) { return entry.key; });\n\t            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });\n\t            var offsetMap = [];\n\t            return this._trans('readwrite', function (trans) {\n\t                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {\n\t                    var resultKeys = [];\n\t                    var resultObjs = [];\n\t                    keysAndChanges.forEach(function (_a, idx) {\n\t                        var key = _a.key, changes = _a.changes;\n\t                        var obj = objs[idx];\n\t                        if (obj) {\n\t                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {\n\t                                var keyPath = _b[_i];\n\t                                var value = changes[keyPath];\n\t                                if (keyPath === _this.schema.primKey.keyPath) {\n\t                                    if (cmp(value, key) !== 0) {\n\t                                        throw new exceptions.Constraint(\"Cannot update primary key in bulkUpdate()\");\n\t                                    }\n\t                                }\n\t                                else {\n\t                                    setByKeyPath(obj, keyPath, value);\n\t                                }\n\t                            }\n\t                            offsetMap.push(idx);\n\t                            resultKeys.push(key);\n\t                            resultObjs.push(obj);\n\t                        }\n\t                    });\n\t                    var numEntries = resultKeys.length;\n\t                    return coreTable\n\t                        .mutate({\n\t                        trans: trans,\n\t                        type: 'put',\n\t                        keys: resultKeys,\n\t                        values: resultObjs,\n\t                        updates: {\n\t                            keys: keys,\n\t                            changeSpecs: changeSpecs\n\t                        }\n\t                    })\n\t                        .then(function (_a) {\n\t                        var numFailures = _a.numFailures, failures = _a.failures;\n\t                        if (numFailures === 0)\n\t                            return numEntries;\n\t                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {\n\t                            var offset = _b[_i];\n\t                            var mappedOffset = offsetMap[Number(offset)];\n\t                            if (mappedOffset != null) {\n\t                                var failure = failures[offset];\n\t                                delete failures[offset];\n\t                                failures[mappedOffset] = failure;\n\t                            }\n\t                        }\n\t                        throw new BulkError(\"\".concat(_this.name, \".bulkUpdate(): \").concat(numFailures, \" of \").concat(numEntries, \" operations failed\"), failures);\n\t                    });\n\t                });\n\t            });\n\t        };\n\t        Table.prototype.bulkDelete = function (keys) {\n\t            var _this = this;\n\t            var numKeys = keys.length;\n\t            return this._trans('readwrite', function (trans) {\n\t                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });\n\t            }).then(function (_a) {\n\t                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n\t                if (numFailures === 0)\n\t                    return lastResult;\n\t                throw new BulkError(\"\".concat(_this.name, \".bulkDelete(): \").concat(numFailures, \" of \").concat(numKeys, \" operations failed\"), failures);\n\t            });\n\t        };\n\t        return Table;\n\t    }());\n\n\t    function Events(ctx) {\n\t        var evs = {};\n\t        var rv = function (eventName, subscriber) {\n\t            if (subscriber) {\n\t                var i = arguments.length, args = new Array(i - 1);\n\t                while (--i)\n\t                    args[i - 1] = arguments[i];\n\t                evs[eventName].subscribe.apply(null, args);\n\t                return ctx;\n\t            }\n\t            else if (typeof (eventName) === 'string') {\n\t                return evs[eventName];\n\t            }\n\t        };\n\t        rv.addEventType = add;\n\t        for (var i = 1, l = arguments.length; i < l; ++i) {\n\t            add(arguments[i]);\n\t        }\n\t        return rv;\n\t        function add(eventName, chainFunction, defaultFunction) {\n\t            if (typeof eventName === 'object')\n\t                return addConfiguredEvents(eventName);\n\t            if (!chainFunction)\n\t                chainFunction = reverseStoppableEventChain;\n\t            if (!defaultFunction)\n\t                defaultFunction = nop;\n\t            var context = {\n\t                subscribers: [],\n\t                fire: defaultFunction,\n\t                subscribe: function (cb) {\n\t                    if (context.subscribers.indexOf(cb) === -1) {\n\t                        context.subscribers.push(cb);\n\t                        context.fire = chainFunction(context.fire, cb);\n\t                    }\n\t                },\n\t                unsubscribe: function (cb) {\n\t                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n\t                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n\t                }\n\t            };\n\t            evs[eventName] = rv[eventName] = context;\n\t            return context;\n\t        }\n\t        function addConfiguredEvents(cfg) {\n\t            keys(cfg).forEach(function (eventName) {\n\t                var args = cfg[eventName];\n\t                if (isArray(args)) {\n\t                    add(eventName, cfg[eventName][0], cfg[eventName][1]);\n\t                }\n\t                else if (args === 'asap') {\n\t                    var context = add(eventName, mirror, function fire() {\n\t                        var i = arguments.length, args = new Array(i);\n\t                        while (i--)\n\t                            args[i] = arguments[i];\n\t                        context.subscribers.forEach(function (fn) {\n\t                            asap$1(function fireEvent() {\n\t                                fn.apply(null, args);\n\t                            });\n\t                        });\n\t                    });\n\t                }\n\t                else\n\t                    throw new exceptions.InvalidArgument(\"Invalid event config\");\n\t            });\n\t        }\n\t    }\n\n\t    function makeClassConstructor(prototype, constructor) {\n\t        derive(constructor).from({ prototype: prototype });\n\t        return constructor;\n\t    }\n\n\t    function createTableConstructor(db) {\n\t        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n\t            this.db = db;\n\t            this._tx = trans;\n\t            this.name = name;\n\t            this.schema = tableSchema;\n\t            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n\t                \"creating\": [hookCreatingChain, nop],\n\t                \"reading\": [pureFunctionChain, mirror],\n\t                \"updating\": [hookUpdatingChain, nop],\n\t                \"deleting\": [hookDeletingChain, nop]\n\t            });\n\t        });\n\t    }\n\n\t    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n\t        return !(ctx.filter || ctx.algorithm || ctx.or) &&\n\t            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n\t    }\n\t    function addFilter(ctx, fn) {\n\t        ctx.filter = combine(ctx.filter, fn);\n\t    }\n\t    function addReplayFilter(ctx, factory, isLimitFilter) {\n\t        var curr = ctx.replayFilter;\n\t        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n\t        ctx.justLimit = isLimitFilter && !curr;\n\t    }\n\t    function addMatchFilter(ctx, fn) {\n\t        ctx.isMatch = combine(ctx.isMatch, fn);\n\t    }\n\t    function getIndexOrStore(ctx, coreSchema) {\n\t        if (ctx.isPrimKey)\n\t            return coreSchema.primaryKey;\n\t        var index = coreSchema.getIndexByKeyPath(ctx.index);\n\t        if (!index)\n\t            throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n\t        return index;\n\t    }\n\t    function openCursor(ctx, coreTable, trans) {\n\t        var index = getIndexOrStore(ctx, coreTable.schema);\n\t        return coreTable.openCursor({\n\t            trans: trans,\n\t            values: !ctx.keysOnly,\n\t            reverse: ctx.dir === 'prev',\n\t            unique: !!ctx.unique,\n\t            query: {\n\t                index: index,\n\t                range: ctx.range\n\t            }\n\t        });\n\t    }\n\t    function iter(ctx, fn, coreTrans, coreTable) {\n\t        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n\t        if (!ctx.or) {\n\t            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n\t        }\n\t        else {\n\t            var set_1 = {};\n\t            var union = function (item, cursor, advance) {\n\t                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n\t                    var primaryKey = cursor.primaryKey;\n\t                    var key = '' + primaryKey;\n\t                    if (key === '[object ArrayBuffer]')\n\t                        key = '' + new Uint8Array(primaryKey);\n\t                    if (!hasOwn(set_1, key)) {\n\t                        set_1[key] = true;\n\t                        fn(item, cursor, advance);\n\t                    }\n\t                }\n\t            };\n\t            return Promise.all([\n\t                ctx.or._iterate(union, coreTrans),\n\t                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n\t            ]);\n\t        }\n\t    }\n\t    function iterate(cursorPromise, filter, fn, valueMapper) {\n\t        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n\t        var wrappedFn = wrap(mappedFn);\n\t        return cursorPromise.then(function (cursor) {\n\t            if (cursor) {\n\t                return cursor.start(function () {\n\t                    var c = function () { return cursor.continue(); };\n\t                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n\t                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n\t                    c();\n\t                });\n\t            }\n\t        });\n\t    }\n\n\t    var PropModSymbol = Symbol();\n\t    var PropModification =  (function () {\n\t        function PropModification(spec) {\n\t            Object.assign(this, spec);\n\t        }\n\t        PropModification.prototype.execute = function (value) {\n\t            var _a;\n\t            if (this.add !== undefined) {\n\t                var term = this.add;\n\t                if (isArray(term)) {\n\t                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();\n\t                }\n\t                if (typeof term === 'number')\n\t                    return (Number(value) || 0) + term;\n\t                if (typeof term === 'bigint') {\n\t                    try {\n\t                        return BigInt(value) + term;\n\t                    }\n\t                    catch (_b) {\n\t                        return BigInt(0) + term;\n\t                    }\n\t                }\n\t                throw new TypeError(\"Invalid term \".concat(term));\n\t            }\n\t            if (this.remove !== undefined) {\n\t                var subtrahend_1 = this.remove;\n\t                if (isArray(subtrahend_1)) {\n\t                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];\n\t                }\n\t                if (typeof subtrahend_1 === 'number')\n\t                    return Number(value) - subtrahend_1;\n\t                if (typeof subtrahend_1 === 'bigint') {\n\t                    try {\n\t                        return BigInt(value) - subtrahend_1;\n\t                    }\n\t                    catch (_c) {\n\t                        return BigInt(0) - subtrahend_1;\n\t                    }\n\t                }\n\t                throw new TypeError(\"Invalid subtrahend \".concat(subtrahend_1));\n\t            }\n\t            var prefixToReplace = (_a = this.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];\n\t            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {\n\t                return this.replacePrefix[1] + value.substring(prefixToReplace.length);\n\t            }\n\t            return value;\n\t        };\n\t        return PropModification;\n\t    }());\n\n\t    var Collection =  (function () {\n\t        function Collection() {\n\t        }\n\t        Collection.prototype._read = function (fn, cb) {\n\t            var ctx = this._ctx;\n\t            return ctx.error ?\n\t                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n\t                ctx.table._trans('readonly', fn).then(cb);\n\t        };\n\t        Collection.prototype._write = function (fn) {\n\t            var ctx = this._ctx;\n\t            return ctx.error ?\n\t                ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n\t                ctx.table._trans('readwrite', fn, \"locked\");\n\t        };\n\t        Collection.prototype._addAlgorithm = function (fn) {\n\t            var ctx = this._ctx;\n\t            ctx.algorithm = combine(ctx.algorithm, fn);\n\t        };\n\t        Collection.prototype._iterate = function (fn, coreTrans) {\n\t            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n\t        };\n\t        Collection.prototype.clone = function (props) {\n\t            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n\t            if (props)\n\t                extend(ctx, props);\n\t            rv._ctx = ctx;\n\t            return rv;\n\t        };\n\t        Collection.prototype.raw = function () {\n\t            this._ctx.valueMapper = null;\n\t            return this;\n\t        };\n\t        Collection.prototype.each = function (fn) {\n\t            var ctx = this._ctx;\n\t            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n\t        };\n\t        Collection.prototype.count = function (cb) {\n\t            var _this = this;\n\t            return this._read(function (trans) {\n\t                var ctx = _this._ctx;\n\t                var coreTable = ctx.table.core;\n\t                if (isPlainKeyRange(ctx, true)) {\n\t                    return coreTable.count({\n\t                        trans: trans,\n\t                        query: {\n\t                            index: getIndexOrStore(ctx, coreTable.schema),\n\t                            range: ctx.range\n\t                        }\n\t                    }).then(function (count) { return Math.min(count, ctx.limit); });\n\t                }\n\t                else {\n\t                    var count = 0;\n\t                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n\t                        .then(function () { return count; });\n\t                }\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.sortBy = function (keyPath, cb) {\n\t            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n\t            function getval(obj, i) {\n\t                if (i)\n\t                    return getval(obj[parts[i]], i - 1);\n\t                return obj[lastPart];\n\t            }\n\t            var order = this._ctx.dir === \"next\" ? 1 : -1;\n\t            function sorter(a, b) {\n\t                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n\t                return aVal < bVal ? -order : aVal > bVal ? order : 0;\n\t            }\n\t            return this.toArray(function (a) {\n\t                return a.sort(sorter);\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.toArray = function (cb) {\n\t            var _this = this;\n\t            return this._read(function (trans) {\n\t                var ctx = _this._ctx;\n\t                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n\t                    var valueMapper_1 = ctx.valueMapper;\n\t                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n\t                    return ctx.table.core.query({\n\t                        trans: trans,\n\t                        limit: ctx.limit,\n\t                        values: true,\n\t                        query: {\n\t                            index: index,\n\t                            range: ctx.range\n\t                        }\n\t                    }).then(function (_a) {\n\t                        var result = _a.result;\n\t                        return valueMapper_1 ? result.map(valueMapper_1) : result;\n\t                    });\n\t                }\n\t                else {\n\t                    var a_1 = [];\n\t                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n\t                }\n\t            }, cb);\n\t        };\n\t        Collection.prototype.offset = function (offset) {\n\t            var ctx = this._ctx;\n\t            if (offset <= 0)\n\t                return this;\n\t            ctx.offset += offset;\n\t            if (isPlainKeyRange(ctx)) {\n\t                addReplayFilter(ctx, function () {\n\t                    var offsetLeft = offset;\n\t                    return function (cursor, advance) {\n\t                        if (offsetLeft === 0)\n\t                            return true;\n\t                        if (offsetLeft === 1) {\n\t                            --offsetLeft;\n\t                            return false;\n\t                        }\n\t                        advance(function () {\n\t                            cursor.advance(offsetLeft);\n\t                            offsetLeft = 0;\n\t                        });\n\t                        return false;\n\t                    };\n\t                });\n\t            }\n\t            else {\n\t                addReplayFilter(ctx, function () {\n\t                    var offsetLeft = offset;\n\t                    return function () { return (--offsetLeft < 0); };\n\t                });\n\t            }\n\t            return this;\n\t        };\n\t        Collection.prototype.limit = function (numRows) {\n\t            this._ctx.limit = Math.min(this._ctx.limit, numRows);\n\t            addReplayFilter(this._ctx, function () {\n\t                var rowsLeft = numRows;\n\t                return function (cursor, advance, resolve) {\n\t                    if (--rowsLeft <= 0)\n\t                        advance(resolve);\n\t                    return rowsLeft >= 0;\n\t                };\n\t            }, true);\n\t            return this;\n\t        };\n\t        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n\t            addFilter(this._ctx, function (cursor, advance, resolve) {\n\t                if (filterFunction(cursor.value)) {\n\t                    advance(resolve);\n\t                    return bIncludeStopEntry;\n\t                }\n\t                else {\n\t                    return true;\n\t                }\n\t            });\n\t            return this;\n\t        };\n\t        Collection.prototype.first = function (cb) {\n\t            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n\t        };\n\t        Collection.prototype.last = function (cb) {\n\t            return this.reverse().first(cb);\n\t        };\n\t        Collection.prototype.filter = function (filterFunction) {\n\t            addFilter(this._ctx, function (cursor) {\n\t                return filterFunction(cursor.value);\n\t            });\n\t            addMatchFilter(this._ctx, filterFunction);\n\t            return this;\n\t        };\n\t        Collection.prototype.and = function (filter) {\n\t            return this.filter(filter);\n\t        };\n\t        Collection.prototype.or = function (indexName) {\n\t            return new this.db.WhereClause(this._ctx.table, indexName, this);\n\t        };\n\t        Collection.prototype.reverse = function () {\n\t            this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n\t            if (this._ondirectionchange)\n\t                this._ondirectionchange(this._ctx.dir);\n\t            return this;\n\t        };\n\t        Collection.prototype.desc = function () {\n\t            return this.reverse();\n\t        };\n\t        Collection.prototype.eachKey = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n\t        };\n\t        Collection.prototype.eachUniqueKey = function (cb) {\n\t            this._ctx.unique = \"unique\";\n\t            return this.eachKey(cb);\n\t        };\n\t        Collection.prototype.eachPrimaryKey = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n\t        };\n\t        Collection.prototype.keys = function (cb) {\n\t            var ctx = this._ctx;\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            var a = [];\n\t            return this.each(function (item, cursor) {\n\t                a.push(cursor.key);\n\t            }).then(function () {\n\t                return a;\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.primaryKeys = function (cb) {\n\t            var ctx = this._ctx;\n\t            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n\t                return this._read(function (trans) {\n\t                    var index = getIndexOrStore(ctx, ctx.table.core.schema);\n\t                    return ctx.table.core.query({\n\t                        trans: trans,\n\t                        values: false,\n\t                        limit: ctx.limit,\n\t                        query: {\n\t                            index: index,\n\t                            range: ctx.range\n\t                        }\n\t                    });\n\t                }).then(function (_a) {\n\t                    var result = _a.result;\n\t                    return result;\n\t                }).then(cb);\n\t            }\n\t            ctx.keysOnly = !ctx.isMatch;\n\t            var a = [];\n\t            return this.each(function (item, cursor) {\n\t                a.push(cursor.primaryKey);\n\t            }).then(function () {\n\t                return a;\n\t            }).then(cb);\n\t        };\n\t        Collection.prototype.uniqueKeys = function (cb) {\n\t            this._ctx.unique = \"unique\";\n\t            return this.keys(cb);\n\t        };\n\t        Collection.prototype.firstKey = function (cb) {\n\t            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n\t        };\n\t        Collection.prototype.lastKey = function (cb) {\n\t            return this.reverse().firstKey(cb);\n\t        };\n\t        Collection.prototype.distinct = function () {\n\t            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n\t            if (!idx || !idx.multi)\n\t                return this;\n\t            var set = {};\n\t            addFilter(this._ctx, function (cursor) {\n\t                var strKey = cursor.primaryKey.toString();\n\t                var found = hasOwn(set, strKey);\n\t                set[strKey] = true;\n\t                return !found;\n\t            });\n\t            return this;\n\t        };\n\t        Collection.prototype.modify = function (changes) {\n\t            var _this = this;\n\t            var ctx = this._ctx;\n\t            return this._write(function (trans) {\n\t                var modifyer;\n\t                if (typeof changes === 'function') {\n\t                    modifyer = changes;\n\t                }\n\t                else {\n\t                    var keyPaths = keys(changes);\n\t                    var numKeys = keyPaths.length;\n\t                    modifyer = function (item) {\n\t                        var anythingModified = false;\n\t                        for (var i = 0; i < numKeys; ++i) {\n\t                            var keyPath = keyPaths[i];\n\t                            var val = changes[keyPath];\n\t                            var origVal = getByKeyPath(item, keyPath);\n\t                            if (val instanceof PropModification) {\n\t                                setByKeyPath(item, keyPath, val.execute(origVal));\n\t                                anythingModified = true;\n\t                            }\n\t                            else if (origVal !== val) {\n\t                                setByKeyPath(item, keyPath, val);\n\t                                anythingModified = true;\n\t                            }\n\t                        }\n\t                        return anythingModified;\n\t                    };\n\t                }\n\t                var coreTable = ctx.table.core;\n\t                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n\t                var limit = _this.db._options.modifyChunkSize || 200;\n\t                var totalFailures = [];\n\t                var successCount = 0;\n\t                var failedKeys = [];\n\t                var applyMutateResult = function (expectedCount, res) {\n\t                    var failures = res.failures, numFailures = res.numFailures;\n\t                    successCount += expectedCount - numFailures;\n\t                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n\t                        var pos = _a[_i];\n\t                        totalFailures.push(failures[pos]);\n\t                    }\n\t                };\n\t                return _this.clone().primaryKeys().then(function (keys) {\n\t                    var criteria = isPlainKeyRange(ctx) &&\n\t                        ctx.limit === Infinity &&\n\t                        (typeof changes !== 'function' || changes === deleteCallback) && {\n\t                        index: ctx.index,\n\t                        range: ctx.range\n\t                    };\n\t                    var nextChunk = function (offset) {\n\t                        var count = Math.min(limit, keys.length - offset);\n\t                        return coreTable.getMany({\n\t                            trans: trans,\n\t                            keys: keys.slice(offset, offset + count),\n\t                            cache: \"immutable\"\n\t                        }).then(function (values) {\n\t                            var addValues = [];\n\t                            var putValues = [];\n\t                            var putKeys = outbound ? [] : null;\n\t                            var deleteKeys = [];\n\t                            for (var i = 0; i < count; ++i) {\n\t                                var origValue = values[i];\n\t                                var ctx_1 = {\n\t                                    value: deepClone(origValue),\n\t                                    primKey: keys[offset + i]\n\t                                };\n\t                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n\t                                    if (ctx_1.value == null) {\n\t                                        deleteKeys.push(keys[offset + i]);\n\t                                    }\n\t                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n\t                                        deleteKeys.push(keys[offset + i]);\n\t                                        addValues.push(ctx_1.value);\n\t                                    }\n\t                                    else {\n\t                                        putValues.push(ctx_1.value);\n\t                                        if (outbound)\n\t                                            putKeys.push(keys[offset + i]);\n\t                                    }\n\t                                }\n\t                            }\n\t                            return Promise.resolve(addValues.length > 0 &&\n\t                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n\t                                    .then(function (res) {\n\t                                    for (var pos in res.failures) {\n\t                                        deleteKeys.splice(parseInt(pos), 1);\n\t                                    }\n\t                                    applyMutateResult(addValues.length, res);\n\t                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n\t                                coreTable.mutate({\n\t                                    trans: trans,\n\t                                    type: 'put',\n\t                                    keys: putKeys,\n\t                                    values: putValues,\n\t                                    criteria: criteria,\n\t                                    changeSpec: typeof changes !== 'function'\n\t                                        && changes,\n\t                                    isAdditionalChunk: offset > 0\n\t                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n\t                                coreTable.mutate({\n\t                                    trans: trans,\n\t                                    type: 'delete',\n\t                                    keys: deleteKeys,\n\t                                    criteria: criteria,\n\t                                    isAdditionalChunk: offset > 0\n\t                                }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n\t                                return keys.length > offset + count && nextChunk(offset + limit);\n\t                            });\n\t                        });\n\t                    };\n\t                    return nextChunk(0).then(function () {\n\t                        if (totalFailures.length > 0)\n\t                            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n\t                        return keys.length;\n\t                    });\n\t                });\n\t            });\n\t        };\n\t        Collection.prototype.delete = function () {\n\t            var ctx = this._ctx, range = ctx.range;\n\t            if (isPlainKeyRange(ctx) &&\n\t                (ctx.isPrimKey || range.type === 3 ))\n\t             {\n\t                return this._write(function (trans) {\n\t                    var primaryKey = ctx.table.core.schema.primaryKey;\n\t                    var coreRange = range;\n\t                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n\t                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n\t                            .then(function (_a) {\n\t                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;\n\t                            if (numFailures)\n\t                                throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n\t                            return count - numFailures;\n\t                        });\n\t                    });\n\t                });\n\t            }\n\t            return this.modify(deleteCallback);\n\t        };\n\t        return Collection;\n\t    }());\n\t    var deleteCallback = function (value, ctx) { return ctx.value = null; };\n\n\t    function createCollectionConstructor(db) {\n\t        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n\t            this.db = db;\n\t            var keyRange = AnyRange, error = null;\n\t            if (keyRangeGenerator)\n\t                try {\n\t                    keyRange = keyRangeGenerator();\n\t                }\n\t                catch (ex) {\n\t                    error = ex;\n\t                }\n\t            var whereCtx = whereClause._ctx;\n\t            var table = whereCtx.table;\n\t            var readingHook = table.hook.reading.fire;\n\t            this._ctx = {\n\t                table: table,\n\t                index: whereCtx.index,\n\t                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n\t                range: keyRange,\n\t                keysOnly: false,\n\t                dir: \"next\",\n\t                unique: \"\",\n\t                algorithm: null,\n\t                filter: null,\n\t                replayFilter: null,\n\t                justLimit: true,\n\t                isMatch: null,\n\t                offset: 0,\n\t                limit: Infinity,\n\t                error: error,\n\t                or: whereCtx.or,\n\t                valueMapper: readingHook !== mirror ? readingHook : null\n\t            };\n\t        });\n\t    }\n\n\t    function simpleCompare(a, b) {\n\t        return a < b ? -1 : a === b ? 0 : 1;\n\t    }\n\t    function simpleCompareReverse(a, b) {\n\t        return a > b ? -1 : a === b ? 0 : 1;\n\t    }\n\n\t    function fail(collectionOrWhereClause, err, T) {\n\t        var collection = collectionOrWhereClause instanceof WhereClause ?\n\t            new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n\t            collectionOrWhereClause;\n\t        collection._ctx.error = T ? new T(err) : new TypeError(err);\n\t        return collection;\n\t    }\n\t    function emptyCollection(whereClause) {\n\t        return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n\t    }\n\t    function upperFactory(dir) {\n\t        return dir === \"next\" ?\n\t            function (s) { return s.toUpperCase(); } :\n\t            function (s) { return s.toLowerCase(); };\n\t    }\n\t    function lowerFactory(dir) {\n\t        return dir === \"next\" ?\n\t            function (s) { return s.toLowerCase(); } :\n\t            function (s) { return s.toUpperCase(); };\n\t    }\n\t    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n\t        var length = Math.min(key.length, lowerNeedle.length);\n\t        var llp = -1;\n\t        for (var i = 0; i < length; ++i) {\n\t            var lwrKeyChar = lowerKey[i];\n\t            if (lwrKeyChar !== lowerNeedle[i]) {\n\t                if (cmp(key[i], upperNeedle[i]) < 0)\n\t                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n\t                if (cmp(key[i], lowerNeedle[i]) < 0)\n\t                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n\t                if (llp >= 0)\n\t                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n\t                return null;\n\t            }\n\t            if (cmp(key[i], lwrKeyChar) < 0)\n\t                llp = i;\n\t        }\n\t        if (length < lowerNeedle.length && dir === \"next\")\n\t            return key + upperNeedle.substr(key.length);\n\t        if (length < key.length && dir === \"prev\")\n\t            return key.substr(0, upperNeedle.length);\n\t        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n\t    }\n\t    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n\t        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n\t        if (!needles.every(function (s) { return typeof s === 'string'; })) {\n\t            return fail(whereClause, STRING_EXPECTED);\n\t        }\n\t        function initDirection(dir) {\n\t            upper = upperFactory(dir);\n\t            lower = lowerFactory(dir);\n\t            compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n\t            var needleBounds = needles.map(function (needle) {\n\t                return { lower: lower(needle), upper: upper(needle) };\n\t            }).sort(function (a, b) {\n\t                return compare(a.lower, b.lower);\n\t            });\n\t            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n\t            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n\t            direction = dir;\n\t            nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n\t        }\n\t        initDirection(\"next\");\n\t        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n\t        c._ondirectionchange = function (direction) {\n\t            initDirection(direction);\n\t        };\n\t        var firstPossibleNeedle = 0;\n\t        c._addAlgorithm(function (cursor, advance, resolve) {\n\t            var key = cursor.key;\n\t            if (typeof key !== 'string')\n\t                return false;\n\t            var lowerKey = lower(key);\n\t            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n\t                return true;\n\t            }\n\t            else {\n\t                var lowestPossibleCasing = null;\n\t                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n\t                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n\t                    if (casing === null && lowestPossibleCasing === null)\n\t                        firstPossibleNeedle = i + 1;\n\t                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n\t                        lowestPossibleCasing = casing;\n\t                    }\n\t                }\n\t                if (lowestPossibleCasing !== null) {\n\t                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n\t                }\n\t                else {\n\t                    advance(resolve);\n\t                }\n\t                return false;\n\t            }\n\t        });\n\t        return c;\n\t    }\n\t    function createRange(lower, upper, lowerOpen, upperOpen) {\n\t        return {\n\t            type: 2 ,\n\t            lower: lower,\n\t            upper: upper,\n\t            lowerOpen: lowerOpen,\n\t            upperOpen: upperOpen\n\t        };\n\t    }\n\t    function rangeEqual(value) {\n\t        return {\n\t            type: 1 ,\n\t            lower: value,\n\t            upper: value\n\t        };\n\t    }\n\n\t    var WhereClause =  (function () {\n\t        function WhereClause() {\n\t        }\n\t        Object.defineProperty(WhereClause.prototype, \"Collection\", {\n\t            get: function () {\n\t                return this._ctx.table.db.Collection;\n\t            },\n\t            enumerable: false,\n\t            configurable: true\n\t        });\n\t        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n\t            includeLower = includeLower !== false;\n\t            includeUpper = includeUpper === true;\n\t            try {\n\t                if ((this._cmp(lower, upper) > 0) ||\n\t                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n\t                    return emptyCollection(this);\n\t                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t        };\n\t        WhereClause.prototype.equals = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return rangeEqual(value); });\n\t        };\n\t        WhereClause.prototype.above = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(value, undefined, true); });\n\t        };\n\t        WhereClause.prototype.aboveOrEqual = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(value, undefined, false); });\n\t        };\n\t        WhereClause.prototype.below = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n\t        };\n\t        WhereClause.prototype.belowOrEqual = function (value) {\n\t            if (value == null)\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            return new this.Collection(this, function () { return createRange(undefined, value); });\n\t        };\n\t        WhereClause.prototype.startsWith = function (str) {\n\t            if (typeof str !== 'string')\n\t                return fail(this, STRING_EXPECTED);\n\t            return this.between(str, str + maxString, true, true);\n\t        };\n\t        WhereClause.prototype.startsWithIgnoreCase = function (str) {\n\t            if (str === \"\")\n\t                return this.startsWith(str);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n\t        };\n\t        WhereClause.prototype.equalsIgnoreCase = function (str) {\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n\t        };\n\t        WhereClause.prototype.anyOfIgnoreCase = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n\t        };\n\t        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n\t        };\n\t        WhereClause.prototype.anyOf = function () {\n\t            var _this = this;\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            var compare = this._cmp;\n\t            try {\n\t                set.sort(compare);\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n\t            c._ondirectionchange = function (direction) {\n\t                compare = (direction === \"next\" ?\n\t                    _this._ascending :\n\t                    _this._descending);\n\t                set.sort(compare);\n\t            };\n\t            var i = 0;\n\t            c._addAlgorithm(function (cursor, advance, resolve) {\n\t                var key = cursor.key;\n\t                while (compare(key, set[i]) > 0) {\n\t                    ++i;\n\t                    if (i === set.length) {\n\t                        advance(resolve);\n\t                        return false;\n\t                    }\n\t                }\n\t                if (compare(key, set[i]) === 0) {\n\t                    return true;\n\t                }\n\t                else {\n\t                    advance(function () { cursor.continue(set[i]); });\n\t                    return false;\n\t                }\n\t            });\n\t            return c;\n\t        };\n\t        WhereClause.prototype.notEqual = function (value) {\n\t            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n\t        };\n\t        WhereClause.prototype.noneOf = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (set.length === 0)\n\t                return new this.Collection(this);\n\t            try {\n\t                set.sort(this._ascending);\n\t            }\n\t            catch (e) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            var ranges = set.reduce(function (res, val) { return res ?\n\t                res.concat([[res[res.length - 1][1], val]]) :\n\t                [[minKey, val]]; }, null);\n\t            ranges.push([set[set.length - 1], this.db._maxKey]);\n\t            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n\t        };\n\t        WhereClause.prototype.inAnyRange = function (ranges, options) {\n\t            var _this = this;\n\t            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n\t            if (ranges.length === 0)\n\t                return emptyCollection(this);\n\t            if (!ranges.every(function (range) {\n\t                return range[0] !== undefined &&\n\t                    range[1] !== undefined &&\n\t                    ascending(range[0], range[1]) <= 0;\n\t            })) {\n\t                return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n\t            }\n\t            var includeLowers = !options || options.includeLowers !== false;\n\t            var includeUppers = options && options.includeUppers === true;\n\t            function addRange(ranges, newRange) {\n\t                var i = 0, l = ranges.length;\n\t                for (; i < l; ++i) {\n\t                    var range = ranges[i];\n\t                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n\t                        range[0] = min(range[0], newRange[0]);\n\t                        range[1] = max(range[1], newRange[1]);\n\t                        break;\n\t                    }\n\t                }\n\t                if (i === l)\n\t                    ranges.push(newRange);\n\t                return ranges;\n\t            }\n\t            var sortDirection = ascending;\n\t            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n\t            var set;\n\t            try {\n\t                set = ranges.reduce(addRange, []);\n\t                set.sort(rangeSorter);\n\t            }\n\t            catch (ex) {\n\t                return fail(this, INVALID_KEY_ARGUMENT);\n\t            }\n\t            var rangePos = 0;\n\t            var keyIsBeyondCurrentEntry = includeUppers ?\n\t                function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n\t                function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n\t            var keyIsBeforeCurrentEntry = includeLowers ?\n\t                function (key) { return descending(key, set[rangePos][0]) > 0; } :\n\t                function (key) { return descending(key, set[rangePos][0]) >= 0; };\n\t            function keyWithinCurrentRange(key) {\n\t                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n\t            }\n\t            var checkKey = keyIsBeyondCurrentEntry;\n\t            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n\t            c._ondirectionchange = function (direction) {\n\t                if (direction === \"next\") {\n\t                    checkKey = keyIsBeyondCurrentEntry;\n\t                    sortDirection = ascending;\n\t                }\n\t                else {\n\t                    checkKey = keyIsBeforeCurrentEntry;\n\t                    sortDirection = descending;\n\t                }\n\t                set.sort(rangeSorter);\n\t            };\n\t            c._addAlgorithm(function (cursor, advance, resolve) {\n\t                var key = cursor.key;\n\t                while (checkKey(key)) {\n\t                    ++rangePos;\n\t                    if (rangePos === set.length) {\n\t                        advance(resolve);\n\t                        return false;\n\t                    }\n\t                }\n\t                if (keyWithinCurrentRange(key)) {\n\t                    return true;\n\t                }\n\t                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n\t                    return false;\n\t                }\n\t                else {\n\t                    advance(function () {\n\t                        if (sortDirection === ascending)\n\t                            cursor.continue(set[rangePos][0]);\n\t                        else\n\t                            cursor.continue(set[rangePos][1]);\n\t                    });\n\t                    return false;\n\t                }\n\t            });\n\t            return c;\n\t        };\n\t        WhereClause.prototype.startsWithAnyOf = function () {\n\t            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\t            if (!set.every(function (s) { return typeof s === 'string'; })) {\n\t                return fail(this, \"startsWithAnyOf() only works with strings\");\n\t            }\n\t            if (set.length === 0)\n\t                return emptyCollection(this);\n\t            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n\t        };\n\t        return WhereClause;\n\t    }());\n\n\t    function createWhereClauseConstructor(db) {\n\t        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n\t            this.db = db;\n\t            this._ctx = {\n\t                table: table,\n\t                index: index === \":id\" ? null : index,\n\t                or: orCollection\n\t            };\n\t            this._cmp = this._ascending = cmp;\n\t            this._descending = function (a, b) { return cmp(b, a); };\n\t            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };\n\t            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };\n\t            this._IDBKeyRange = db._deps.IDBKeyRange;\n\t            if (!this._IDBKeyRange)\n\t                throw new exceptions.MissingAPI();\n\t        });\n\t    }\n\n\t    function eventRejectHandler(reject) {\n\t        return wrap(function (event) {\n\t            preventDefault(event);\n\t            reject(event.target.error);\n\t            return false;\n\t        });\n\t    }\n\t    function preventDefault(event) {\n\t        if (event.stopPropagation)\n\t            event.stopPropagation();\n\t        if (event.preventDefault)\n\t            event.preventDefault();\n\t    }\n\n\t    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n\t    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n\t    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\n\t    var Transaction =  (function () {\n\t        function Transaction() {\n\t        }\n\t        Transaction.prototype._lock = function () {\n\t            assert(!PSD.global);\n\t            ++this._reculock;\n\t            if (this._reculock === 1 && !PSD.global)\n\t                PSD.lockOwnerFor = this;\n\t            return this;\n\t        };\n\t        Transaction.prototype._unlock = function () {\n\t            assert(!PSD.global);\n\t            if (--this._reculock === 0) {\n\t                if (!PSD.global)\n\t                    PSD.lockOwnerFor = null;\n\t                while (this._blockedFuncs.length > 0 && !this._locked()) {\n\t                    var fnAndPSD = this._blockedFuncs.shift();\n\t                    try {\n\t                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n\t                    }\n\t                    catch (e) { }\n\t                }\n\t            }\n\t            return this;\n\t        };\n\t        Transaction.prototype._locked = function () {\n\t            return this._reculock && PSD.lockOwnerFor !== this;\n\t        };\n\t        Transaction.prototype.create = function (idbtrans) {\n\t            var _this = this;\n\t            if (!this.mode)\n\t                return this;\n\t            var idbdb = this.db.idbdb;\n\t            var dbOpenError = this.db._state.dbOpenError;\n\t            assert(!this.idbtrans);\n\t            if (!idbtrans && !idbdb) {\n\t                switch (dbOpenError && dbOpenError.name) {\n\t                    case \"DatabaseClosedError\":\n\t                        throw new exceptions.DatabaseClosed(dbOpenError);\n\t                    case \"MissingAPIError\":\n\t                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n\t                    default:\n\t                        throw new exceptions.OpenFailed(dbOpenError);\n\t                }\n\t            }\n\t            if (!this.active)\n\t                throw new exceptions.TransactionInactive();\n\t            assert(this._completion._state === null);\n\t            idbtrans = this.idbtrans = idbtrans ||\n\t                (this.db.core\n\t                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n\t                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n\t            idbtrans.onerror = wrap(function (ev) {\n\t                preventDefault(ev);\n\t                _this._reject(idbtrans.error);\n\t            });\n\t            idbtrans.onabort = wrap(function (ev) {\n\t                preventDefault(ev);\n\t                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n\t                _this.active = false;\n\t                _this.on(\"abort\").fire(ev);\n\t            });\n\t            idbtrans.oncomplete = wrap(function () {\n\t                _this.active = false;\n\t                _this._resolve();\n\t                if ('mutatedParts' in idbtrans) {\n\t                    globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n\t                }\n\t            });\n\t            return this;\n\t        };\n\t        Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n\t            var _this = this;\n\t            if (mode === 'readwrite' && this.mode !== 'readwrite')\n\t                return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n\t            if (!this.active)\n\t                return rejection(new exceptions.TransactionInactive());\n\t            if (this._locked()) {\n\t                return new DexiePromise(function (resolve, reject) {\n\t                    _this._blockedFuncs.push([function () {\n\t                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n\t                        }, PSD]);\n\t                });\n\t            }\n\t            else if (bWriteLock) {\n\t                return newScope(function () {\n\t                    var p = new DexiePromise(function (resolve, reject) {\n\t                        _this._lock();\n\t                        var rv = fn(resolve, reject, _this);\n\t                        if (rv && rv.then)\n\t                            rv.then(resolve, reject);\n\t                    });\n\t                    p.finally(function () { return _this._unlock(); });\n\t                    p._lib = true;\n\t                    return p;\n\t                });\n\t            }\n\t            else {\n\t                var p = new DexiePromise(function (resolve, reject) {\n\t                    var rv = fn(resolve, reject, _this);\n\t                    if (rv && rv.then)\n\t                        rv.then(resolve, reject);\n\t                });\n\t                p._lib = true;\n\t                return p;\n\t            }\n\t        };\n\t        Transaction.prototype._root = function () {\n\t            return this.parent ? this.parent._root() : this;\n\t        };\n\t        Transaction.prototype.waitFor = function (promiseLike) {\n\t            var root = this._root();\n\t            var promise = DexiePromise.resolve(promiseLike);\n\t            if (root._waitingFor) {\n\t                root._waitingFor = root._waitingFor.then(function () { return promise; });\n\t            }\n\t            else {\n\t                root._waitingFor = promise;\n\t                root._waitingQueue = [];\n\t                var store = root.idbtrans.objectStore(root.storeNames[0]);\n\t                (function spin() {\n\t                    ++root._spinCount;\n\t                    while (root._waitingQueue.length)\n\t                        (root._waitingQueue.shift())();\n\t                    if (root._waitingFor)\n\t                        store.get(-Infinity).onsuccess = spin;\n\t                }());\n\t            }\n\t            var currentWaitPromise = root._waitingFor;\n\t            return new DexiePromise(function (resolve, reject) {\n\t                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n\t                    if (root._waitingFor === currentWaitPromise) {\n\t                        root._waitingFor = null;\n\t                    }\n\t                });\n\t            });\n\t        };\n\t        Transaction.prototype.abort = function () {\n\t            if (this.active) {\n\t                this.active = false;\n\t                if (this.idbtrans)\n\t                    this.idbtrans.abort();\n\t                this._reject(new exceptions.Abort());\n\t            }\n\t        };\n\t        Transaction.prototype.table = function (tableName) {\n\t            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n\t            if (hasOwn(memoizedTables, tableName))\n\t                return memoizedTables[tableName];\n\t            var tableSchema = this.schema[tableName];\n\t            if (!tableSchema) {\n\t                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n\t            }\n\t            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n\t            transactionBoundTable.core = this.db.core.table(tableName);\n\t            memoizedTables[tableName] = transactionBoundTable;\n\t            return transactionBoundTable;\n\t        };\n\t        return Transaction;\n\t    }());\n\n\t    function createTransactionConstructor(db) {\n\t        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n\t            var _this = this;\n\t            this.db = db;\n\t            this.mode = mode;\n\t            this.storeNames = storeNames;\n\t            this.schema = dbschema;\n\t            this.chromeTransactionDurability = chromeTransactionDurability;\n\t            this.idbtrans = null;\n\t            this.on = Events(this, \"complete\", \"error\", \"abort\");\n\t            this.parent = parent || null;\n\t            this.active = true;\n\t            this._reculock = 0;\n\t            this._blockedFuncs = [];\n\t            this._resolve = null;\n\t            this._reject = null;\n\t            this._waitingFor = null;\n\t            this._waitingQueue = null;\n\t            this._spinCount = 0;\n\t            this._completion = new DexiePromise(function (resolve, reject) {\n\t                _this._resolve = resolve;\n\t                _this._reject = reject;\n\t            });\n\t            this._completion.then(function () {\n\t                _this.active = false;\n\t                _this.on.complete.fire();\n\t            }, function (e) {\n\t                var wasActive = _this.active;\n\t                _this.active = false;\n\t                _this.on.error.fire(e);\n\t                _this.parent ?\n\t                    _this.parent._reject(e) :\n\t                    wasActive && _this.idbtrans && _this.idbtrans.abort();\n\t                return rejection(e);\n\t            });\n\t        });\n\t    }\n\n\t    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n\t        return {\n\t            name: name,\n\t            keyPath: keyPath,\n\t            unique: unique,\n\t            multi: multi,\n\t            auto: auto,\n\t            compound: compound,\n\t            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n\t        };\n\t    }\n\t    function nameFromKeyPath(keyPath) {\n\t        return typeof keyPath === 'string' ?\n\t            keyPath :\n\t            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n\t    }\n\n\t    function createTableSchema(name, primKey, indexes) {\n\t        return {\n\t            name: name,\n\t            primKey: primKey,\n\t            indexes: indexes,\n\t            mappedClass: null,\n\t            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })\n\t        };\n\t    }\n\n\t    function safariMultiStoreFix(storeNames) {\n\t        return storeNames.length === 1 ? storeNames[0] : storeNames;\n\t    }\n\t    var getMaxKey = function (IdbKeyRange) {\n\t        try {\n\t            IdbKeyRange.only([[]]);\n\t            getMaxKey = function () { return [[]]; };\n\t            return [[]];\n\t        }\n\t        catch (e) {\n\t            getMaxKey = function () { return maxString; };\n\t            return maxString;\n\t        }\n\t    };\n\n\t    function getKeyExtractor(keyPath) {\n\t        if (keyPath == null) {\n\t            return function () { return undefined; };\n\t        }\n\t        else if (typeof keyPath === 'string') {\n\t            return getSinglePathKeyExtractor(keyPath);\n\t        }\n\t        else {\n\t            return function (obj) { return getByKeyPath(obj, keyPath); };\n\t        }\n\t    }\n\t    function getSinglePathKeyExtractor(keyPath) {\n\t        var split = keyPath.split('.');\n\t        if (split.length === 1) {\n\t            return function (obj) { return obj[keyPath]; };\n\t        }\n\t        else {\n\t            return function (obj) { return getByKeyPath(obj, keyPath); };\n\t        }\n\t    }\n\n\t    function arrayify(arrayLike) {\n\t        return [].slice.call(arrayLike);\n\t    }\n\t    var _id_counter = 0;\n\t    function getKeyPathAlias(keyPath) {\n\t        return keyPath == null ?\n\t            \":id\" :\n\t            typeof keyPath === 'string' ?\n\t                keyPath :\n\t                \"[\".concat(keyPath.join('+'), \"]\");\n\t    }\n\t    function createDBCore(db, IdbKeyRange, tmpTrans) {\n\t        function extractSchema(db, trans) {\n\t            var tables = arrayify(db.objectStoreNames);\n\t            return {\n\t                schema: {\n\t                    name: db.name,\n\t                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n\t                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n\t                        var compound = isArray(keyPath);\n\t                        var outbound = keyPath == null;\n\t                        var indexByKeyPath = {};\n\t                        var result = {\n\t                            name: store.name,\n\t                            primaryKey: {\n\t                                name: null,\n\t                                isPrimaryKey: true,\n\t                                outbound: outbound,\n\t                                compound: compound,\n\t                                keyPath: keyPath,\n\t                                autoIncrement: autoIncrement,\n\t                                unique: true,\n\t                                extractKey: getKeyExtractor(keyPath)\n\t                            },\n\t                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n\t                                .map(function (index) {\n\t                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n\t                                var compound = isArray(keyPath);\n\t                                var result = {\n\t                                    name: name,\n\t                                    compound: compound,\n\t                                    keyPath: keyPath,\n\t                                    unique: unique,\n\t                                    multiEntry: multiEntry,\n\t                                    extractKey: getKeyExtractor(keyPath)\n\t                                };\n\t                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n\t                                return result;\n\t                            }),\n\t                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n\t                        };\n\t                        indexByKeyPath[\":id\"] = result.primaryKey;\n\t                        if (keyPath != null) {\n\t                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n\t                        }\n\t                        return result;\n\t                    })\n\t                },\n\t                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n\t                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n\t                        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n\t                        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n\t            };\n\t        }\n\t        function makeIDBKeyRange(range) {\n\t            if (range.type === 3 )\n\t                return null;\n\t            if (range.type === 4 )\n\t                throw new Error(\"Cannot convert never type to IDBKeyRange\");\n\t            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n\t            var idbRange = lower === undefined ?\n\t                upper === undefined ?\n\t                    null :\n\t                    IdbKeyRange.upperBound(upper, !!upperOpen) :\n\t                upper === undefined ?\n\t                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n\t                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n\t            return idbRange;\n\t        }\n\t        function createDbCoreTable(tableSchema) {\n\t            var tableName = tableSchema.name;\n\t            function mutate(_a) {\n\t                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n\t                return new Promise(function (resolve, reject) {\n\t                    resolve = wrap(resolve);\n\t                    var store = trans.objectStore(tableName);\n\t                    var outbound = store.keyPath == null;\n\t                    var isAddOrPut = type === \"put\" || type === \"add\";\n\t                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n\t                        throw new Error(\"Invalid operation type: \" + type);\n\t                    var length = (keys || values || { length: 1 }).length;\n\t                    if (keys && values && keys.length !== values.length) {\n\t                        throw new Error(\"Given keys array must have same length as given values array.\");\n\t                    }\n\t                    if (length === 0)\n\t                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n\t                    var req;\n\t                    var reqs = [];\n\t                    var failures = [];\n\t                    var numFailures = 0;\n\t                    var errorHandler = function (event) {\n\t                        ++numFailures;\n\t                        preventDefault(event);\n\t                    };\n\t                    if (type === 'deleteRange') {\n\t                        if (range.type === 4 )\n\t                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n\t                        if (range.type === 3 )\n\t                            reqs.push(req = store.clear());\n\t                        else\n\t                            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n\t                    }\n\t                    else {\n\t                        var _a = isAddOrPut ?\n\t                            outbound ?\n\t                                [values, keys] :\n\t                                [values, null] :\n\t                            [keys, null], args1 = _a[0], args2 = _a[1];\n\t                        if (isAddOrPut) {\n\t                            for (var i = 0; i < length; ++i) {\n\t                                reqs.push(req = (args2 && args2[i] !== undefined ?\n\t                                    store[type](args1[i], args2[i]) :\n\t                                    store[type](args1[i])));\n\t                                req.onerror = errorHandler;\n\t                            }\n\t                        }\n\t                        else {\n\t                            for (var i = 0; i < length; ++i) {\n\t                                reqs.push(req = store[type](args1[i]));\n\t                                req.onerror = errorHandler;\n\t                            }\n\t                        }\n\t                    }\n\t                    var done = function (event) {\n\t                        var lastResult = event.target.result;\n\t                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n\t                        resolve({\n\t                            numFailures: numFailures,\n\t                            failures: failures,\n\t                            results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n\t                            lastResult: lastResult\n\t                        });\n\t                    };\n\t                    req.onerror = function (event) {\n\t                        errorHandler(event);\n\t                        done(event);\n\t                    };\n\t                    req.onsuccess = done;\n\t                });\n\t            }\n\t            function openCursor(_a) {\n\t                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n\t                return new Promise(function (resolve, reject) {\n\t                    resolve = wrap(resolve);\n\t                    var index = query.index, range = query.range;\n\t                    var store = trans.objectStore(tableName);\n\t                    var source = index.isPrimaryKey ?\n\t                        store :\n\t                        store.index(index.name);\n\t                    var direction = reverse ?\n\t                        unique ?\n\t                            \"prevunique\" :\n\t                            \"prev\" :\n\t                        unique ?\n\t                            \"nextunique\" :\n\t                            \"next\";\n\t                    var req = values || !('openKeyCursor' in source) ?\n\t                        source.openCursor(makeIDBKeyRange(range), direction) :\n\t                        source.openKeyCursor(makeIDBKeyRange(range), direction);\n\t                    req.onerror = eventRejectHandler(reject);\n\t                    req.onsuccess = wrap(function (ev) {\n\t                        var cursor = req.result;\n\t                        if (!cursor) {\n\t                            resolve(null);\n\t                            return;\n\t                        }\n\t                        cursor.___id = ++_id_counter;\n\t                        cursor.done = false;\n\t                        var _cursorContinue = cursor.continue.bind(cursor);\n\t                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n\t                        if (_cursorContinuePrimaryKey)\n\t                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n\t                        var _cursorAdvance = cursor.advance.bind(cursor);\n\t                        var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n\t                        var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n\t                        cursor.trans = trans;\n\t                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n\t                        cursor.fail = wrap(reject);\n\t                        cursor.next = function () {\n\t                            var _this = this;\n\t                            var gotOne = 1;\n\t                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n\t                        };\n\t                        cursor.start = function (callback) {\n\t                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n\t                                resolveIteration = wrap(resolveIteration);\n\t                                req.onerror = eventRejectHandler(rejectIteration);\n\t                                cursor.fail = rejectIteration;\n\t                                cursor.stop = function (value) {\n\t                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n\t                                    resolveIteration(value);\n\t                                };\n\t                            });\n\t                            var guardedCallback = function () {\n\t                                if (req.result) {\n\t                                    try {\n\t                                        callback();\n\t                                    }\n\t                                    catch (err) {\n\t                                        cursor.fail(err);\n\t                                    }\n\t                                }\n\t                                else {\n\t                                    cursor.done = true;\n\t                                    cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n\t                                    cursor.stop();\n\t                                }\n\t                            };\n\t                            req.onsuccess = wrap(function (ev) {\n\t                                req.onsuccess = guardedCallback;\n\t                                guardedCallback();\n\t                            });\n\t                            cursor.continue = _cursorContinue;\n\t                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n\t                            cursor.advance = _cursorAdvance;\n\t                            guardedCallback();\n\t                            return iterationPromise;\n\t                        };\n\t                        resolve(cursor);\n\t                    }, reject);\n\t                });\n\t            }\n\t            function query(hasGetAll) {\n\t                return function (request) {\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n\t                        var nonInfinitLimit = limit === Infinity ? undefined : limit;\n\t                        var index = query.index, range = query.range;\n\t                        var store = trans.objectStore(tableName);\n\t                        var source = index.isPrimaryKey ? store : store.index(index.name);\n\t                        var idbKeyRange = makeIDBKeyRange(range);\n\t                        if (limit === 0)\n\t                            return resolve({ result: [] });\n\t                        if (hasGetAll) {\n\t                            var req = values ?\n\t                                source.getAll(idbKeyRange, nonInfinitLimit) :\n\t                                source.getAllKeys(idbKeyRange, nonInfinitLimit);\n\t                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n\t                            req.onerror = eventRejectHandler(reject);\n\t                        }\n\t                        else {\n\t                            var count_1 = 0;\n\t                            var req_1 = values || !('openKeyCursor' in source) ?\n\t                                source.openCursor(idbKeyRange) :\n\t                                source.openKeyCursor(idbKeyRange);\n\t                            var result_1 = [];\n\t                            req_1.onsuccess = function (event) {\n\t                                var cursor = req_1.result;\n\t                                if (!cursor)\n\t                                    return resolve({ result: result_1 });\n\t                                result_1.push(values ? cursor.value : cursor.primaryKey);\n\t                                if (++count_1 === limit)\n\t                                    return resolve({ result: result_1 });\n\t                                cursor.continue();\n\t                            };\n\t                            req_1.onerror = eventRejectHandler(reject);\n\t                        }\n\t                    });\n\t                };\n\t            }\n\t            return {\n\t                name: tableName,\n\t                schema: tableSchema,\n\t                mutate: mutate,\n\t                getMany: function (_a) {\n\t                    var trans = _a.trans, keys = _a.keys;\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var store = trans.objectStore(tableName);\n\t                        var length = keys.length;\n\t                        var result = new Array(length);\n\t                        var keyCount = 0;\n\t                        var callbackCount = 0;\n\t                        var req;\n\t                        var successHandler = function (event) {\n\t                            var req = event.target;\n\t                            if ((result[req._pos] = req.result) != null)\n\t                                ;\n\t                            if (++callbackCount === keyCount)\n\t                                resolve(result);\n\t                        };\n\t                        var errorHandler = eventRejectHandler(reject);\n\t                        for (var i = 0; i < length; ++i) {\n\t                            var key = keys[i];\n\t                            if (key != null) {\n\t                                req = store.get(keys[i]);\n\t                                req._pos = i;\n\t                                req.onsuccess = successHandler;\n\t                                req.onerror = errorHandler;\n\t                                ++keyCount;\n\t                            }\n\t                        }\n\t                        if (keyCount === 0)\n\t                            resolve(result);\n\t                    });\n\t                },\n\t                get: function (_a) {\n\t                    var trans = _a.trans, key = _a.key;\n\t                    return new Promise(function (resolve, reject) {\n\t                        resolve = wrap(resolve);\n\t                        var store = trans.objectStore(tableName);\n\t                        var req = store.get(key);\n\t                        req.onsuccess = function (event) { return resolve(event.target.result); };\n\t                        req.onerror = eventRejectHandler(reject);\n\t                    });\n\t                },\n\t                query: query(hasGetAll),\n\t                openCursor: openCursor,\n\t                count: function (_a) {\n\t                    var query = _a.query, trans = _a.trans;\n\t                    var index = query.index, range = query.range;\n\t                    return new Promise(function (resolve, reject) {\n\t                        var store = trans.objectStore(tableName);\n\t                        var source = index.isPrimaryKey ? store : store.index(index.name);\n\t                        var idbKeyRange = makeIDBKeyRange(range);\n\t                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n\t                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n\t                        req.onerror = eventRejectHandler(reject);\n\t                    });\n\t                }\n\t            };\n\t        }\n\t        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n\t        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n\t        var tableMap = {};\n\t        tables.forEach(function (table) { return tableMap[table.name] = table; });\n\t        return {\n\t            stack: \"dbcore\",\n\t            transaction: db.transaction.bind(db),\n\t            table: function (name) {\n\t                var result = tableMap[name];\n\t                if (!result)\n\t                    throw new Error(\"Table '\".concat(name, \"' not found\"));\n\t                return tableMap[name];\n\t            },\n\t            MIN_KEY: -Infinity,\n\t            MAX_KEY: getMaxKey(IdbKeyRange),\n\t            schema: schema\n\t        };\n\t    }\n\n\t    function createMiddlewareStack(stackImpl, middlewares) {\n\t        return middlewares.reduce(function (down, _a) {\n\t            var create = _a.create;\n\t            return (__assign(__assign({}, down), create(down)));\n\t        }, stackImpl);\n\t    }\n\t    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n\t        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n\t        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n\t        return {\n\t            dbcore: dbcore\n\t        };\n\t    }\n\t    function generateMiddlewareStacks(db, tmpTrans) {\n\t        var idbdb = tmpTrans.db;\n\t        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n\t        db.core = stacks.dbcore;\n\t        db.tables.forEach(function (table) {\n\t            var tableName = table.name;\n\t            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n\t                table.core = db.core.table(tableName);\n\t                if (db[tableName] instanceof db.Table) {\n\t                    db[tableName].core = table.core;\n\t                }\n\t            }\n\t        });\n\t    }\n\n\t    function setApiOnPlace(db, objs, tableNames, dbschema) {\n\t        tableNames.forEach(function (tableName) {\n\t            var schema = dbschema[tableName];\n\t            objs.forEach(function (obj) {\n\t                var propDesc = getPropertyDescriptor(obj, tableName);\n\t                if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n\t                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n\t                        setProp(obj, tableName, {\n\t                            get: function () { return this.table(tableName); },\n\t                            set: function (value) {\n\t                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n\t                            }\n\t                        });\n\t                    }\n\t                    else {\n\t                        obj[tableName] = new db.Table(tableName, schema);\n\t                    }\n\t                }\n\t            });\n\t        });\n\t    }\n\t    function removeTablesApi(db, objs) {\n\t        objs.forEach(function (obj) {\n\t            for (var key in obj) {\n\t                if (obj[key] instanceof db.Table)\n\t                    delete obj[key];\n\t            }\n\t        });\n\t    }\n\t    function lowerVersionFirst(a, b) {\n\t        return a._cfg.version - b._cfg.version;\n\t    }\n\t    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n\t        var globalSchema = db._dbSchema;\n\t        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {\n\t            globalSchema.$meta = createTableSchema(\"$meta\", parseIndexSyntax(\"\")[0], []);\n\t            db._storeNames.push('$meta');\n\t        }\n\t        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n\t        trans.create(idbUpgradeTrans);\n\t        trans._completion.catch(reject);\n\t        var rejectTransaction = trans._reject.bind(trans);\n\t        var transless = PSD.transless || PSD;\n\t        newScope(function () {\n\t            PSD.trans = trans;\n\t            PSD.transless = transless;\n\t            if (oldVersion === 0) {\n\t                keys(globalSchema).forEach(function (tableName) {\n\t                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n\t                });\n\t                generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n\t            }\n\t            else {\n\t                generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                return getExistingVersion(db, trans, oldVersion)\n\t                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })\n\t                    .catch(rejectTransaction);\n\t            }\n\t        });\n\t    }\n\t    function patchCurrentVersion(db, idbUpgradeTrans) {\n\t        createMissingTables(db._dbSchema, idbUpgradeTrans);\n\t        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {\n\t            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');\n\t        }\n\t        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n\t        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);\n\t        var diff = getSchemaDiff(globalSchema, db._dbSchema);\n\t        var _loop_1 = function (tableChange) {\n\t            if (tableChange.change.length || tableChange.recreate) {\n\t                console.warn(\"Unable to patch indexes of table \".concat(tableChange.name, \" because it has changes on the type of index or primary key.\"));\n\t                return { value: void 0 };\n\t            }\n\t            var store = idbUpgradeTrans.objectStore(tableChange.name);\n\t            tableChange.add.forEach(function (idx) {\n\t                if (debug)\n\t                    console.debug(\"Dexie upgrade patch: Creating missing index \".concat(tableChange.name, \".\").concat(idx.src));\n\t                addIndex(store, idx);\n\t            });\n\t        };\n\t        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {\n\t            var tableChange = _a[_i];\n\t            var state_1 = _loop_1(tableChange);\n\t            if (typeof state_1 === \"object\")\n\t                return state_1.value;\n\t        }\n\t    }\n\t    function getExistingVersion(db, trans, oldVersion) {\n\t        if (trans.storeNames.includes('$meta')) {\n\t            return trans.table('$meta').get('version').then(function (metaVersion) {\n\t                return metaVersion != null ? metaVersion : oldVersion;\n\t            });\n\t        }\n\t        else {\n\t            return DexiePromise.resolve(oldVersion);\n\t        }\n\t    }\n\t    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {\n\t        var queue = [];\n\t        var versions = db._versions;\n\t        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n\t        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n\t        if (versToRun.length === 0) {\n\t            return DexiePromise.resolve();\n\t        }\n\t        versToRun.forEach(function (version) {\n\t            queue.push(function () {\n\t                var oldSchema = globalSchema;\n\t                var newSchema = version._cfg.dbschema;\n\t                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n\t                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n\t                globalSchema = db._dbSchema = newSchema;\n\t                var diff = getSchemaDiff(oldSchema, newSchema);\n\t                diff.add.forEach(function (tuple) {\n\t                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n\t                });\n\t                diff.change.forEach(function (change) {\n\t                    if (change.recreate) {\n\t                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n\t                    }\n\t                    else {\n\t                        var store_1 = idbUpgradeTrans.objectStore(change.name);\n\t                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n\t                        change.change.forEach(function (idx) {\n\t                            store_1.deleteIndex(idx.name);\n\t                            addIndex(store_1, idx);\n\t                        });\n\t                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n\t                    }\n\t                });\n\t                var contentUpgrade = version._cfg.contentUpgrade;\n\t                if (contentUpgrade && version._cfg.version > oldVersion) {\n\t                    generateMiddlewareStacks(db, idbUpgradeTrans);\n\t                    trans._memoizedTables = {};\n\t                    var upgradeSchema_1 = shallowClone(newSchema);\n\t                    diff.del.forEach(function (table) {\n\t                        upgradeSchema_1[table] = oldSchema[table];\n\t                    });\n\t                    removeTablesApi(db, [db.Transaction.prototype]);\n\t                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n\t                    trans.schema = upgradeSchema_1;\n\t                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n\t                    if (contentUpgradeIsAsync_1) {\n\t                        incrementExpectedAwaits();\n\t                    }\n\t                    var returnValue_1;\n\t                    var promiseFollowed = DexiePromise.follow(function () {\n\t                        returnValue_1 = contentUpgrade(trans);\n\t                        if (returnValue_1) {\n\t                            if (contentUpgradeIsAsync_1) {\n\t                                var decrementor = decrementExpectedAwaits.bind(null, null);\n\t                                returnValue_1.then(decrementor, decrementor);\n\t                            }\n\t                        }\n\t                    });\n\t                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n\t                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n\t                }\n\t            });\n\t            queue.push(function (idbtrans) {\n\t                var newSchema = version._cfg.dbschema;\n\t                deleteRemovedTables(newSchema, idbtrans);\n\t                removeTablesApi(db, [db.Transaction.prototype]);\n\t                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n\t                trans.schema = db._dbSchema;\n\t            });\n\t            queue.push(function (idbtrans) {\n\t                if (db.idbdb.objectStoreNames.contains('$meta')) {\n\t                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {\n\t                        db.idbdb.deleteObjectStore('$meta');\n\t                        delete db._dbSchema.$meta;\n\t                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });\n\t                    }\n\t                    else {\n\t                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');\n\t                    }\n\t                }\n\t            });\n\t        });\n\t        function runQueue() {\n\t            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n\t                DexiePromise.resolve();\n\t        }\n\t        return runQueue().then(function () {\n\t            createMissingTables(globalSchema, idbUpgradeTrans);\n\t        });\n\t    }\n\t    function getSchemaDiff(oldSchema, newSchema) {\n\t        var diff = {\n\t            del: [],\n\t            add: [],\n\t            change: []\n\t        };\n\t        var table;\n\t        for (table in oldSchema) {\n\t            if (!newSchema[table])\n\t                diff.del.push(table);\n\t        }\n\t        for (table in newSchema) {\n\t            var oldDef = oldSchema[table], newDef = newSchema[table];\n\t            if (!oldDef) {\n\t                diff.add.push([table, newDef]);\n\t            }\n\t            else {\n\t                var change = {\n\t                    name: table,\n\t                    def: newDef,\n\t                    recreate: false,\n\t                    del: [],\n\t                    add: [],\n\t                    change: []\n\t                };\n\t                if ((\n\t                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n\t                    (oldDef.primKey.auto !== newDef.primKey.auto)) {\n\t                    change.recreate = true;\n\t                    diff.change.push(change);\n\t                }\n\t                else {\n\t                    var oldIndexes = oldDef.idxByName;\n\t                    var newIndexes = newDef.idxByName;\n\t                    var idxName = void 0;\n\t                    for (idxName in oldIndexes) {\n\t                        if (!newIndexes[idxName])\n\t                            change.del.push(idxName);\n\t                    }\n\t                    for (idxName in newIndexes) {\n\t                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n\t                        if (!oldIdx)\n\t                            change.add.push(newIdx);\n\t                        else if (oldIdx.src !== newIdx.src)\n\t                            change.change.push(newIdx);\n\t                    }\n\t                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n\t                        diff.change.push(change);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return diff;\n\t    }\n\t    function createTable(idbtrans, tableName, primKey, indexes) {\n\t        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n\t            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n\t            { autoIncrement: primKey.auto });\n\t        indexes.forEach(function (idx) { return addIndex(store, idx); });\n\t        return store;\n\t    }\n\t    function createMissingTables(newSchema, idbtrans) {\n\t        keys(newSchema).forEach(function (tableName) {\n\t            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n\t                if (debug)\n\t                    console.debug('Dexie: Creating missing table', tableName);\n\t                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n\t            }\n\t        });\n\t    }\n\t    function deleteRemovedTables(newSchema, idbtrans) {\n\t        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n\t            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n\t        });\n\t    }\n\t    function addIndex(store, idx) {\n\t        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n\t    }\n\t    function buildGlobalSchema(db, idbdb, tmpTrans) {\n\t        var globalSchema = {};\n\t        var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n\t        dbStoreNames.forEach(function (storeName) {\n\t            var store = tmpTrans.objectStore(storeName);\n\t            var keyPath = store.keyPath;\n\t            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n\t            var indexes = [];\n\t            for (var j = 0; j < store.indexNames.length; ++j) {\n\t                var idbindex = store.index(store.indexNames[j]);\n\t                keyPath = idbindex.keyPath;\n\t                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n\t                indexes.push(index);\n\t            }\n\t            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n\t        });\n\t        return globalSchema;\n\t    }\n\t    function readGlobalSchema(db, idbdb, tmpTrans) {\n\t        db.verno = idbdb.version / 10;\n\t        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n\t        db._storeNames = slice(idbdb.objectStoreNames, 0);\n\t        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n\t    }\n\t    function verifyInstalledSchema(db, tmpTrans) {\n\t        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n\t        var diff = getSchemaDiff(installedSchema, db._dbSchema);\n\t        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n\t    }\n\t    function adjustToExistingIndexNames(db, schema, idbtrans) {\n\t        var storeNames = idbtrans.db.objectStoreNames;\n\t        for (var i = 0; i < storeNames.length; ++i) {\n\t            var storeName = storeNames[i];\n\t            var store = idbtrans.objectStore(storeName);\n\t            db._hasGetAll = 'getAll' in store;\n\t            for (var j = 0; j < store.indexNames.length; ++j) {\n\t                var indexName = store.indexNames[j];\n\t                var keyPath = store.index(indexName).keyPath;\n\t                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n\t                if (schema[storeName]) {\n\t                    var indexSpec = schema[storeName].idxByName[dexieName];\n\t                    if (indexSpec) {\n\t                        indexSpec.name = indexName;\n\t                        delete schema[storeName].idxByName[dexieName];\n\t                        schema[storeName].idxByName[indexName] = indexSpec;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n\t            !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n\t            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n\t            [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n\t            db._hasGetAll = false;\n\t        }\n\t    }\n\t    function parseIndexSyntax(primKeyAndIndexes) {\n\t        return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n\t            index = index.trim();\n\t            var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n\t            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n\t            return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n\t        });\n\t    }\n\n\t    var Version =  (function () {\n\t        function Version() {\n\t        }\n\t        Version.prototype._parseStoresSpec = function (stores, outSchema) {\n\t            keys(stores).forEach(function (tableName) {\n\t                if (stores[tableName] !== null) {\n\t                    var indexes = parseIndexSyntax(stores[tableName]);\n\t                    var primKey = indexes.shift();\n\t                    primKey.unique = true;\n\t                    if (primKey.multi)\n\t                        throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n\t                    indexes.forEach(function (idx) {\n\t                        if (idx.auto)\n\t                            throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n\t                        if (!idx.keyPath)\n\t                            throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n\t                    });\n\t                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n\t                }\n\t            });\n\t        };\n\t        Version.prototype.stores = function (stores) {\n\t            var db = this.db;\n\t            this._cfg.storesSource = this._cfg.storesSource ?\n\t                extend(this._cfg.storesSource, stores) :\n\t                stores;\n\t            var versions = db._versions;\n\t            var storesSpec = {};\n\t            var dbschema = {};\n\t            versions.forEach(function (version) {\n\t                extend(storesSpec, version._cfg.storesSource);\n\t                dbschema = (version._cfg.dbschema = {});\n\t                version._parseStoresSpec(storesSpec, dbschema);\n\t            });\n\t            db._dbSchema = dbschema;\n\t            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n\t            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n\t            db._storeNames = keys(dbschema);\n\t            return this;\n\t        };\n\t        Version.prototype.upgrade = function (upgradeFunction) {\n\t            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n\t            return this;\n\t        };\n\t        return Version;\n\t    }());\n\n\t    function createVersionConstructor(db) {\n\t        return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n\t            this.db = db;\n\t            this._cfg = {\n\t                version: versionNumber,\n\t                storesSource: null,\n\t                dbschema: {},\n\t                tables: {},\n\t                contentUpgrade: null\n\t            };\n\t        });\n\t    }\n\n\t    function getDbNamesTable(indexedDB, IDBKeyRange) {\n\t        var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n\t        if (!dbNamesDB) {\n\t            dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n\t                addons: [],\n\t                indexedDB: indexedDB,\n\t                IDBKeyRange: IDBKeyRange,\n\t            });\n\t            dbNamesDB.version(1).stores({ dbnames: \"name\" });\n\t        }\n\t        return dbNamesDB.table(\"dbnames\");\n\t    }\n\t    function hasDatabasesNative(indexedDB) {\n\t        return indexedDB && typeof indexedDB.databases === \"function\";\n\t    }\n\t    function getDatabaseNames(_a) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        return hasDatabasesNative(indexedDB)\n\t            ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n\t                return infos\n\t                    .map(function (info) { return info.name; })\n\t                    .filter(function (name) { return name !== DBNAMES_DB; });\n\t            })\n\t            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n\t    }\n\t    function _onDatabaseCreated(_a, name) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        !hasDatabasesNative(indexedDB) &&\n\t            name !== DBNAMES_DB &&\n\t            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n\t    }\n\t    function _onDatabaseDeleted(_a, name) {\n\t        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n\t        !hasDatabasesNative(indexedDB) &&\n\t            name !== DBNAMES_DB &&\n\t            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n\t    }\n\n\t    function vip(fn) {\n\t        return newScope(function () {\n\t            PSD.letThrough = true;\n\t            return fn();\n\t        });\n\t    }\n\n\t    function idbReady() {\n\t        var isSafari = !navigator.userAgentData &&\n\t            /Safari\\//.test(navigator.userAgent) &&\n\t            !/Chrom(e|ium)\\//.test(navigator.userAgent);\n\t        if (!isSafari || !indexedDB.databases)\n\t            return Promise.resolve();\n\t        var intervalId;\n\t        return new Promise(function (resolve) {\n\t            var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n\t            intervalId = setInterval(tryIdb, 100);\n\t            tryIdb();\n\t        }).finally(function () { return clearInterval(intervalId); });\n\t    }\n\n\t    var _a;\n\t    function isEmptyRange(node) {\n\t        return !(\"from\" in node);\n\t    }\n\t    var RangeSet = function (fromOrTree, to) {\n\t        if (this) {\n\t            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n\t        }\n\t        else {\n\t            var rv = new RangeSet();\n\t            if (fromOrTree && (\"d\" in fromOrTree)) {\n\t                extend(rv, fromOrTree);\n\t            }\n\t            return rv;\n\t        }\n\t    };\n\t    props(RangeSet.prototype, (_a = {\n\t            add: function (rangeSet) {\n\t                mergeRanges(this, rangeSet);\n\t                return this;\n\t            },\n\t            addKey: function (key) {\n\t                addRange(this, key, key);\n\t                return this;\n\t            },\n\t            addKeys: function (keys) {\n\t                var _this = this;\n\t                keys.forEach(function (key) { return addRange(_this, key, key); });\n\t                return this;\n\t            },\n\t            hasKey: function (key) {\n\t                var node = getRangeSetIterator(this).next(key).value;\n\t                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;\n\t            }\n\t        },\n\t        _a[iteratorSymbol] = function () {\n\t            return getRangeSetIterator(this);\n\t        },\n\t        _a));\n\t    function addRange(target, from, to) {\n\t        var diff = cmp(from, to);\n\t        if (isNaN(diff))\n\t            return;\n\t        if (diff > 0)\n\t            throw RangeError();\n\t        if (isEmptyRange(target))\n\t            return extend(target, { from: from, to: to, d: 1 });\n\t        var left = target.l;\n\t        var right = target.r;\n\t        if (cmp(to, target.from) < 0) {\n\t            left\n\t                ? addRange(left, from, to)\n\t                : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n\t            return rebalance(target);\n\t        }\n\t        if (cmp(from, target.to) > 0) {\n\t            right\n\t                ? addRange(right, from, to)\n\t                : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n\t            return rebalance(target);\n\t        }\n\t        if (cmp(from, target.from) < 0) {\n\t            target.from = from;\n\t            target.l = null;\n\t            target.d = right ? right.d + 1 : 1;\n\t        }\n\t        if (cmp(to, target.to) > 0) {\n\t            target.to = to;\n\t            target.r = null;\n\t            target.d = target.l ? target.l.d + 1 : 1;\n\t        }\n\t        var rightWasCutOff = !target.r;\n\t        if (left && !target.l) {\n\t            mergeRanges(target, left);\n\t        }\n\t        if (right && rightWasCutOff) {\n\t            mergeRanges(target, right);\n\t        }\n\t    }\n\t    function mergeRanges(target, newSet) {\n\t        function _addRangeSet(target, _a) {\n\t            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n\t            addRange(target, from, to);\n\t            if (l)\n\t                _addRangeSet(target, l);\n\t            if (r)\n\t                _addRangeSet(target, r);\n\t        }\n\t        if (!isEmptyRange(newSet))\n\t            _addRangeSet(target, newSet);\n\t    }\n\t    function rangesOverlap(rangeSet1, rangeSet2) {\n\t        var i1 = getRangeSetIterator(rangeSet2);\n\t        var nextResult1 = i1.next();\n\t        if (nextResult1.done)\n\t            return false;\n\t        var a = nextResult1.value;\n\t        var i2 = getRangeSetIterator(rangeSet1);\n\t        var nextResult2 = i2.next(a.from);\n\t        var b = nextResult2.value;\n\t        while (!nextResult1.done && !nextResult2.done) {\n\t            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n\t                return true;\n\t            cmp(a.from, b.from) < 0\n\t                ? (a = (nextResult1 = i1.next(b.from)).value)\n\t                : (b = (nextResult2 = i2.next(a.from)).value);\n\t        }\n\t        return false;\n\t    }\n\t    function getRangeSetIterator(node) {\n\t        var state = isEmptyRange(node) ? null : { s: 0, n: node };\n\t        return {\n\t            next: function (key) {\n\t                var keyProvided = arguments.length > 0;\n\t                while (state) {\n\t                    switch (state.s) {\n\t                        case 0:\n\t                            state.s = 1;\n\t                            if (keyProvided) {\n\t                                while (state.n.l && cmp(key, state.n.from) < 0)\n\t                                    state = { up: state, n: state.n.l, s: 1 };\n\t                            }\n\t                            else {\n\t                                while (state.n.l)\n\t                                    state = { up: state, n: state.n.l, s: 1 };\n\t                            }\n\t                        case 1:\n\t                            state.s = 2;\n\t                            if (!keyProvided || cmp(key, state.n.to) <= 0)\n\t                                return { value: state.n, done: false };\n\t                        case 2:\n\t                            if (state.n.r) {\n\t                                state.s = 3;\n\t                                state = { up: state, n: state.n.r, s: 0 };\n\t                                continue;\n\t                            }\n\t                        case 3:\n\t                            state = state.up;\n\t                    }\n\t                }\n\t                return { done: true };\n\t            },\n\t        };\n\t    }\n\t    function rebalance(target) {\n\t        var _a, _b;\n\t        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n\t        var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n\t        if (r) {\n\t            var l = r === \"r\" ? \"l\" : \"r\";\n\t            var rootClone = __assign({}, target);\n\t            var oldRootRight = target[r];\n\t            target.from = oldRootRight.from;\n\t            target.to = oldRootRight.to;\n\t            target[r] = oldRootRight[r];\n\t            rootClone[r] = oldRootRight[l];\n\t            target[l] = rootClone;\n\t            rootClone.d = computeDepth(rootClone);\n\t        }\n\t        target.d = computeDepth(target);\n\t    }\n\t    function computeDepth(_a) {\n\t        var r = _a.r, l = _a.l;\n\t        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n\t    }\n\n\t    function extendObservabilitySet(target, newSet) {\n\t        keys(newSet).forEach(function (part) {\n\t            if (target[part])\n\t                mergeRanges(target[part], newSet[part]);\n\t            else\n\t                target[part] = cloneSimpleObjectTree(newSet[part]);\n\t        });\n\t        return target;\n\t    }\n\n\t    function obsSetsOverlap(os1, os2) {\n\t        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });\n\t    }\n\n\t    var cache = {};\n\n\t    var unsignaledParts = {};\n\t    var isTaskEnqueued = false;\n\t    function signalSubscribersLazily(part, optimistic) {\n\t        extendObservabilitySet(unsignaledParts, part);\n\t        if (!isTaskEnqueued) {\n\t            isTaskEnqueued = true;\n\t            setTimeout(function () {\n\t                isTaskEnqueued = false;\n\t                var parts = unsignaledParts;\n\t                unsignaledParts = {};\n\t                signalSubscribersNow(parts, false);\n\t            }, 0);\n\t        }\n\t    }\n\t    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {\n\t        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }\n\t        var queriesToSignal = new Set();\n\t        if (updatedParts.all) {\n\t            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {\n\t                var tblCache = _a[_i];\n\t                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in updatedParts) {\n\t                var parts = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(key);\n\t                if (parts) {\n\t                    var dbName = parts[1], tableName = parts[2];\n\t                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t                    if (tblCache)\n\t                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);\n\t                }\n\t            }\n\t        }\n\t        queriesToSignal.forEach(function (requery) { return requery(); });\n\t    }\n\t    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {\n\t        var updatedEntryLists = [];\n\t        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {\n\t            var _b = _a[_i], indexName = _b[0], entries = _b[1];\n\t            var filteredEntries = [];\n\t            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {\n\t                var entry = entries_1[_c];\n\t                if (obsSetsOverlap(updatedParts, entry.obsSet)) {\n\t                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });\n\t                }\n\t                else if (deleteAffectedCacheEntries) {\n\t                    filteredEntries.push(entry);\n\t                }\n\t            }\n\t            if (deleteAffectedCacheEntries)\n\t                updatedEntryLists.push([indexName, filteredEntries]);\n\t        }\n\t        if (deleteAffectedCacheEntries) {\n\t            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {\n\t                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];\n\t                tblCache.queries.query[indexName] = filteredEntries;\n\t            }\n\t        }\n\t    }\n\n\t    function dexieOpen(db) {\n\t        var state = db._state;\n\t        var indexedDB = db._deps.indexedDB;\n\t        if (state.isBeingOpened || db.idbdb)\n\t            return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n\t                rejection(state.dbOpenError) :\n\t                db; });\n\t        state.isBeingOpened = true;\n\t        state.dbOpenError = null;\n\t        state.openComplete = false;\n\t        var openCanceller = state.openCanceller;\n\t        var nativeVerToOpen = Math.round(db.verno * 10);\n\t        var schemaPatchMode = false;\n\t        function throwIfCancelled() {\n\t            if (state.openCanceller !== openCanceller)\n\t                throw new exceptions.DatabaseClosed('db.open() was cancelled');\n\t        }\n\t        var resolveDbReady = state.dbReadyResolve,\n\t        upgradeTransaction = null, wasCreated = false;\n\t        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n\t            throwIfCancelled();\n\t            if (!indexedDB)\n\t                throw new exceptions.MissingAPI();\n\t            var dbName = db.name;\n\t            var req = state.autoSchema || !nativeVerToOpen ?\n\t                indexedDB.open(dbName) :\n\t                indexedDB.open(dbName, nativeVerToOpen);\n\t            if (!req)\n\t                throw new exceptions.MissingAPI();\n\t            req.onerror = eventRejectHandler(reject);\n\t            req.onblocked = wrap(db._fireOnBlocked);\n\t            req.onupgradeneeded = wrap(function (e) {\n\t                upgradeTransaction = req.transaction;\n\t                if (state.autoSchema && !db._options.allowEmptyDB) {\n\t                    req.onerror = preventDefault;\n\t                    upgradeTransaction.abort();\n\t                    req.result.close();\n\t                    var delreq = indexedDB.deleteDatabase(dbName);\n\t                    delreq.onsuccess = delreq.onerror = wrap(function () {\n\t                        reject(new exceptions.NoSuchDatabase(\"Database \".concat(dbName, \" doesnt exist\")));\n\t                    });\n\t                }\n\t                else {\n\t                    upgradeTransaction.onerror = eventRejectHandler(reject);\n\t                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n\t                    wasCreated = oldVer < 1;\n\t                    db.idbdb = req.result;\n\t                    if (schemaPatchMode) {\n\t                        patchCurrentVersion(db, upgradeTransaction);\n\t                    }\n\t                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n\t                }\n\t            }, reject);\n\t            req.onsuccess = wrap(function () {\n\t                upgradeTransaction = null;\n\t                var idbdb = db.idbdb = req.result;\n\t                var objectStoreNames = slice(idbdb.objectStoreNames);\n\t                if (objectStoreNames.length > 0)\n\t                    try {\n\t                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n\t                        if (state.autoSchema)\n\t                            readGlobalSchema(db, idbdb, tmpTrans);\n\t                        else {\n\t                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n\t                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {\n\t                                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.\");\n\t                                idbdb.close();\n\t                                nativeVerToOpen = idbdb.version + 1;\n\t                                schemaPatchMode = true;\n\t                                return resolve(tryOpenDB());\n\t                            }\n\t                        }\n\t                        generateMiddlewareStacks(db, tmpTrans);\n\t                    }\n\t                    catch (e) {\n\t                    }\n\t                connections.push(db);\n\t                idbdb.onversionchange = wrap(function (ev) {\n\t                    state.vcFired = true;\n\t                    db.on(\"versionchange\").fire(ev);\n\t                });\n\t                idbdb.onclose = wrap(function (ev) {\n\t                    db.on(\"close\").fire(ev);\n\t                });\n\t                if (wasCreated)\n\t                    _onDatabaseCreated(db._deps, dbName);\n\t                resolve();\n\t            }, reject);\n\t        }).catch(function (err) {\n\t            switch (err === null || err === void 0 ? void 0 : err.name) {\n\t                case \"UnknownError\":\n\t                    if (state.PR1398_maxLoop > 0) {\n\t                        state.PR1398_maxLoop--;\n\t                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n\t                        return tryOpenDB();\n\t                    }\n\t                    break;\n\t                case \"VersionError\":\n\t                    if (nativeVerToOpen > 0) {\n\t                        nativeVerToOpen = 0;\n\t                        return tryOpenDB();\n\t                    }\n\t                    break;\n\t            }\n\t            return DexiePromise.reject(err);\n\t        }); };\n\t        return DexiePromise.race([\n\t            openCanceller,\n\t            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n\t        ]).then(function () {\n\t            throwIfCancelled();\n\t            state.onReadyBeingFired = [];\n\t            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n\t                if (state.onReadyBeingFired.length > 0) {\n\t                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n\t                    state.onReadyBeingFired = [];\n\t                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n\t                }\n\t            });\n\t        }).finally(function () {\n\t            if (state.openCanceller === openCanceller) {\n\t                state.onReadyBeingFired = null;\n\t                state.isBeingOpened = false;\n\t            }\n\t        }).catch(function (err) {\n\t            state.dbOpenError = err;\n\t            try {\n\t                upgradeTransaction && upgradeTransaction.abort();\n\t            }\n\t            catch (_a) { }\n\t            if (openCanceller === state.openCanceller) {\n\t                db._close();\n\t            }\n\t            return rejection(err);\n\t        }).finally(function () {\n\t            state.openComplete = true;\n\t            resolveDbReady();\n\t        }).then(function () {\n\t            if (wasCreated) {\n\t                var everything_1 = {};\n\t                db.tables.forEach(function (table) {\n\t                    table.schema.indexes.forEach(function (idx) {\n\t                        if (idx.name)\n\t                            everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);\n\t                    });\n\t                    everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/\")] = everything_1[\"idb://\".concat(db.name, \"/\").concat(table.name, \"/:dels\")] = new RangeSet(-Infinity, [[[]]]);\n\t                });\n\t                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);\n\t                signalSubscribersNow(everything_1, true);\n\t            }\n\t            return db;\n\t        });\n\t    }\n\n\t    function awaitIterator(iterator) {\n\t        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n\t        function step(getNext) {\n\t            return function (val) {\n\t                var next = getNext(val), value = next.value;\n\t                return next.done ? value :\n\t                    (!value || typeof value.then !== 'function' ?\n\t                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n\t                        value.then(onSuccess, onError));\n\t            };\n\t        }\n\t        return step(callNext)();\n\t    }\n\n\t    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n\t        var i = arguments.length;\n\t        if (i < 2)\n\t            throw new exceptions.InvalidArgument(\"Too few arguments\");\n\t        var args = new Array(i - 1);\n\t        while (--i)\n\t            args[i - 1] = arguments[i];\n\t        scopeFunc = args.pop();\n\t        var tables = flatten(args);\n\t        return [mode, tables, scopeFunc];\n\t    }\n\t    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n\t        return DexiePromise.resolve().then(function () {\n\t            var transless = PSD.transless || PSD;\n\t            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n\t            trans.explicit = true;\n\t            var zoneProps = {\n\t                trans: trans,\n\t                transless: transless\n\t            };\n\t            if (parentTransaction) {\n\t                trans.idbtrans = parentTransaction.idbtrans;\n\t            }\n\t            else {\n\t                try {\n\t                    trans.create();\n\t                    trans.idbtrans._explicit = true;\n\t                    db._state.PR1398_maxLoop = 3;\n\t                }\n\t                catch (ex) {\n\t                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n\t                        console.warn('Dexie: Need to reopen db');\n\t                        db.close({ disableAutoOpen: false });\n\t                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n\t                    }\n\t                    return rejection(ex);\n\t                }\n\t            }\n\t            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n\t            if (scopeFuncIsAsync) {\n\t                incrementExpectedAwaits();\n\t            }\n\t            var returnValue;\n\t            var promiseFollowed = DexiePromise.follow(function () {\n\t                returnValue = scopeFunc.call(trans, trans);\n\t                if (returnValue) {\n\t                    if (scopeFuncIsAsync) {\n\t                        var decrementor = decrementExpectedAwaits.bind(null, null);\n\t                        returnValue.then(decrementor, decrementor);\n\t                    }\n\t                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n\t                        returnValue = awaitIterator(returnValue);\n\t                    }\n\t                }\n\t            }, zoneProps);\n\t            return (returnValue && typeof returnValue.then === 'function' ?\n\t                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n\t                    x\n\t                    : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n\t                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n\t                if (parentTransaction)\n\t                    trans._resolve();\n\t                return trans._completion.then(function () { return x; });\n\t            }).catch(function (e) {\n\t                trans._reject(e);\n\t                return rejection(e);\n\t            });\n\t        });\n\t    }\n\n\t    function pad(a, value, count) {\n\t        var result = isArray(a) ? a.slice() : [a];\n\t        for (var i = 0; i < count; ++i)\n\t            result.push(value);\n\t        return result;\n\t    }\n\t    function createVirtualIndexMiddleware(down) {\n\t        return __assign(__assign({}, down), { table: function (tableName) {\n\t                var table = down.table(tableName);\n\t                var schema = table.schema;\n\t                var indexLookup = {};\n\t                var allVirtualIndexes = [];\n\t                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n\t                    var keyPathAlias = getKeyPathAlias(keyPath);\n\t                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n\t                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n\t                    var isVirtual = keyTail > 0;\n\t                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual\n\t                            ? \"\".concat(keyPathAlias, \"(virtual-from:\").concat(lowLevelIndex.name, \")\")\n\t                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n\t                    indexList.push(virtualIndex);\n\t                    if (!virtualIndex.isPrimaryKey) {\n\t                        allVirtualIndexes.push(virtualIndex);\n\t                    }\n\t                    if (keyLength > 1) {\n\t                        var virtualKeyPath = keyLength === 2 ?\n\t                            keyPath[0] :\n\t                            keyPath.slice(0, keyLength - 1);\n\t                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n\t                    }\n\t                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n\t                    return virtualIndex;\n\t                }\n\t                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n\t                indexLookup[\":id\"] = [primaryKey];\n\t                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n\t                    var index = _a[_i];\n\t                    addVirtualIndexes(index.keyPath, 0, index);\n\t                }\n\t                function findBestIndex(keyPath) {\n\t                    var result = indexLookup[getKeyPathAlias(keyPath)];\n\t                    return result && result[0];\n\t                }\n\t                function translateRange(range, keyTail) {\n\t                    return {\n\t                        type: range.type === 1  ?\n\t                            2  :\n\t                            range.type,\n\t                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n\t                        lowerOpen: true,\n\t                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n\t                        upperOpen: true\n\t                    };\n\t                }\n\t                function translateRequest(req) {\n\t                    var index = req.query.index;\n\t                    return index.isVirtual ? __assign(__assign({}, req), { query: {\n\t                            index: index.lowLevelIndex,\n\t                            range: translateRange(req.query.range, index.keyTail)\n\t                        } }) : req;\n\t                }\n\t                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n\t                        return table.count(translateRequest(req));\n\t                    }, query: function (req) {\n\t                        return table.query(translateRequest(req));\n\t                    }, openCursor: function (req) {\n\t                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n\t                        if (!isVirtual)\n\t                            return table.openCursor(req);\n\t                        function createVirtualCursor(cursor) {\n\t                            function _continue(key) {\n\t                                key != null ?\n\t                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n\t                                    req.unique ?\n\t                                        cursor.continue(cursor.key.slice(0, keyLength)\n\t                                            .concat(req.reverse\n\t                                            ? down.MIN_KEY\n\t                                            : down.MAX_KEY, keyTail)) :\n\t                                        cursor.continue();\n\t                            }\n\t                            var virtualCursor = Object.create(cursor, {\n\t                                continue: { value: _continue },\n\t                                continuePrimaryKey: {\n\t                                    value: function (key, primaryKey) {\n\t                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n\t                                    }\n\t                                },\n\t                                primaryKey: {\n\t                                    get: function () {\n\t                                        return cursor.primaryKey;\n\t                                    }\n\t                                },\n\t                                key: {\n\t                                    get: function () {\n\t                                        var key = cursor.key;\n\t                                        return keyLength === 1 ?\n\t                                            key[0] :\n\t                                            key.slice(0, keyLength);\n\t                                    }\n\t                                },\n\t                                value: {\n\t                                    get: function () {\n\t                                        return cursor.value;\n\t                                    }\n\t                                }\n\t                            });\n\t                            return virtualCursor;\n\t                        }\n\t                        return table.openCursor(translateRequest(req))\n\t                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n\t                    } });\n\t                return result;\n\t            } });\n\t    }\n\t    var virtualIndexMiddleware = {\n\t        stack: \"dbcore\",\n\t        name: \"VirtualIndexMiddleware\",\n\t        level: 1,\n\t        create: createVirtualIndexMiddleware\n\t    };\n\n\t    function getObjectDiff(a, b, rv, prfx) {\n\t        rv = rv || {};\n\t        prfx = prfx || '';\n\t        keys(a).forEach(function (prop) {\n\t            if (!hasOwn(b, prop)) {\n\t                rv[prfx + prop] = undefined;\n\t            }\n\t            else {\n\t                var ap = a[prop], bp = b[prop];\n\t                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n\t                    var apTypeName = toStringTag(ap);\n\t                    var bpTypeName = toStringTag(bp);\n\t                    if (apTypeName !== bpTypeName) {\n\t                        rv[prfx + prop] = b[prop];\n\t                    }\n\t                    else if (apTypeName === 'Object') {\n\t                        getObjectDiff(ap, bp, rv, prfx + prop + '.');\n\t                    }\n\t                    else if (ap !== bp) {\n\t                        rv[prfx + prop] = b[prop];\n\t                    }\n\t                }\n\t                else if (ap !== bp)\n\t                    rv[prfx + prop] = b[prop];\n\t            }\n\t        });\n\t        keys(b).forEach(function (prop) {\n\t            if (!hasOwn(a, prop)) {\n\t                rv[prfx + prop] = b[prop];\n\t            }\n\t        });\n\t        return rv;\n\t    }\n\n\t    function getEffectiveKeys(primaryKey, req) {\n\t        if (req.type === 'delete')\n\t            return req.keys;\n\t        return req.keys || req.values.map(primaryKey.extractKey);\n\t    }\n\n\t    var hooksMiddleware = {\n\t        stack: \"dbcore\",\n\t        name: \"HooksMiddleware\",\n\t        level: 2,\n\t        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n\t                var downTable = downCore.table(tableName);\n\t                var primaryKey = downTable.schema.primaryKey;\n\t                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n\t                        var dxTrans = PSD.trans;\n\t                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n\t                        switch (req.type) {\n\t                            case 'add':\n\t                                if (creating.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'put':\n\t                                if (creating.fire === nop && updating.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'delete':\n\t                                if (deleting.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n\t                            case 'deleteRange':\n\t                                if (deleting.fire === nop)\n\t                                    break;\n\t                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n\t                        }\n\t                        return downTable.mutate(req);\n\t                        function addPutOrDelete(req) {\n\t                            var dxTrans = PSD.trans;\n\t                            var keys = req.keys || getEffectiveKeys(primaryKey, req);\n\t                            if (!keys)\n\t                                throw new Error(\"Keys missing\");\n\t                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n\t                            if (req.type !== 'delete')\n\t                                req.values = __spreadArray([], req.values, true);\n\t                            if (req.keys)\n\t                                req.keys = __spreadArray([], req.keys, true);\n\t                            return getExistingValues(downTable, req, keys).then(function (existingValues) {\n\t                                var contexts = keys.map(function (key, i) {\n\t                                    var existingValue = existingValues[i];\n\t                                    var ctx = { onerror: null, onsuccess: null };\n\t                                    if (req.type === 'delete') {\n\t                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n\t                                    }\n\t                                    else if (req.type === 'add' || existingValue === undefined) {\n\t                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n\t                                        if (key == null && generatedPrimaryKey != null) {\n\t                                            key = generatedPrimaryKey;\n\t                                            req.keys[i] = key;\n\t                                            if (!primaryKey.outbound) {\n\t                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                    else {\n\t                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);\n\t                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n\t                                        if (additionalChanges_1) {\n\t                                            var requestedValue_1 = req.values[i];\n\t                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {\n\t                                                if (hasOwn(requestedValue_1, keyPath)) {\n\t                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n\t                                                }\n\t                                                else {\n\t                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n\t                                                }\n\t                                            });\n\t                                        }\n\t                                    }\n\t                                    return ctx;\n\t                                });\n\t                                return downTable.mutate(req).then(function (_a) {\n\t                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n\t                                    for (var i = 0; i < keys.length; ++i) {\n\t                                        var primKey = results ? results[i] : keys[i];\n\t                                        var ctx = contexts[i];\n\t                                        if (primKey == null) {\n\t                                            ctx.onerror && ctx.onerror(failures[i]);\n\t                                        }\n\t                                        else {\n\t                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n\t                                                req.values[i] :\n\t                                                primKey\n\t                                            );\n\t                                        }\n\t                                    }\n\t                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n\t                                }).catch(function (error) {\n\t                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n\t                                    return Promise.reject(error);\n\t                                });\n\t                            });\n\t                        }\n\t                        function deleteRange(req) {\n\t                            return deleteNextChunk(req.trans, req.range, 10000);\n\t                        }\n\t                        function deleteNextChunk(trans, range, limit) {\n\t                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n\t                                .then(function (_a) {\n\t                                var result = _a.result;\n\t                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n\t                                    if (res.numFailures > 0)\n\t                                        return Promise.reject(res.failures[0]);\n\t                                    if (result.length < limit) {\n\t                                        return { failures: [], numFailures: 0, lastResult: undefined };\n\t                                    }\n\t                                    else {\n\t                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n\t                                    }\n\t                                });\n\t                            });\n\t                        }\n\t                    } });\n\t                return tableMiddleware;\n\t            } })); }\n\t    };\n\t    function getExistingValues(table, req, effectiveKeys) {\n\t        return req.type === \"add\"\n\t            ? Promise.resolve([])\n\t            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n\t    }\n\n\t    function getFromTransactionCache(keys, cache, clone) {\n\t        try {\n\t            if (!cache)\n\t                return null;\n\t            if (cache.keys.length < keys.length)\n\t                return null;\n\t            var result = [];\n\t            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n\t                if (cmp(cache.keys[i], keys[j]) !== 0)\n\t                    continue;\n\t                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n\t                ++j;\n\t            }\n\t            return result.length === keys.length ? result : null;\n\t        }\n\t        catch (_a) {\n\t            return null;\n\t        }\n\t    }\n\t    var cacheExistingValuesMiddleware = {\n\t        stack: \"dbcore\",\n\t        level: -1,\n\t        create: function (core) {\n\t            return {\n\t                table: function (tableName) {\n\t                    var table = core.table(tableName);\n\t                    return __assign(__assign({}, table), { getMany: function (req) {\n\t                            if (!req.cache) {\n\t                                return table.getMany(req);\n\t                            }\n\t                            var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n\t                            if (cachedResult) {\n\t                                return DexiePromise.resolve(cachedResult);\n\t                            }\n\t                            return table.getMany(req).then(function (res) {\n\t                                req.trans[\"_cache\"] = {\n\t                                    keys: req.keys,\n\t                                    values: req.cache === \"clone\" ? deepClone(res) : res,\n\t                                };\n\t                                return res;\n\t                            });\n\t                        }, mutate: function (req) {\n\t                            if (req.type !== \"add\")\n\t                                req.trans[\"_cache\"] = null;\n\t                            return table.mutate(req);\n\t                        } });\n\t                },\n\t            };\n\t        },\n\t    };\n\n\t    function isCachableContext(ctx, table) {\n\t        return (ctx.trans.mode === 'readonly' &&\n\t            !!ctx.subscr &&\n\t            !ctx.trans.explicit &&\n\t            ctx.trans.db._options.cache !== 'disabled' &&\n\t            !table.schema.primaryKey.outbound);\n\t    }\n\n\t    function isCachableRequest(type, req) {\n\t        switch (type) {\n\t            case 'query':\n\t                return req.values && !req.unique;\n\t            case 'get':\n\t                return false;\n\t            case 'getMany':\n\t                return false;\n\t            case 'count':\n\t                return false;\n\t            case 'openCursor':\n\t                return false;\n\t        }\n\t    }\n\n\t    var observabilityMiddleware = {\n\t        stack: \"dbcore\",\n\t        level: 0,\n\t        name: \"Observability\",\n\t        create: function (core) {\n\t            var dbName = core.schema.name;\n\t            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n\t            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n\t                    if (PSD.subscr && mode !== 'readonly') {\n\t                        throw new exceptions.ReadOnly(\"Readwrite transaction in liveQuery context. Querier source: \".concat(PSD.querier));\n\t                    }\n\t                    return core.transaction(stores, mode, options);\n\t                }, table: function (tableName) {\n\t                    var table = core.table(tableName);\n\t                    var schema = table.schema;\n\t                    var primaryKey = schema.primaryKey, indexes = schema.indexes;\n\t                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n\t                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });\n\t                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n\t                            var trans = req.trans;\n\t                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});\n\t                            var getRangeSet = function (indexName) {\n\t                                var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n\t                                return (mutatedParts[part] ||\n\t                                    (mutatedParts[part] = new RangeSet()));\n\t                            };\n\t                            var pkRangeSet = getRangeSet(\"\");\n\t                            var delsRangeSet = getRangeSet(\":dels\");\n\t                            var type = req.type;\n\t                            var _a = req.type === \"deleteRange\"\n\t                                ? [req.range]\n\t                                : req.type === \"delete\"\n\t                                    ? [req.keys]\n\t                                    : req.values.length < 50\n\t                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]\n\t                                        : [], keys = _a[0], newObjs = _a[1];\n\t                            var oldCache = req.trans[\"_cache\"];\n\t                            if (isArray(keys)) {\n\t                                pkRangeSet.addKeys(keys);\n\t                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;\n\t                                if (!oldObjs) {\n\t                                    delsRangeSet.addKeys(keys);\n\t                                }\n\t                                if (oldObjs || newObjs) {\n\t                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n\t                                }\n\t                            }\n\t                            else if (keys) {\n\t                                var range = { from: keys.lower, to: keys.upper };\n\t                                delsRangeSet.add(range);\n\t                                pkRangeSet.add(range);\n\t                            }\n\t                            else {\n\t                                pkRangeSet.add(FULL_RANGE);\n\t                                delsRangeSet.add(FULL_RANGE);\n\t                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n\t                            }\n\t                            return table.mutate(req).then(function (res) {\n\t                                if (keys && (req.type === 'add' || req.type === 'put')) {\n\t                                    pkRangeSet.addKeys(res.results);\n\t                                    if (indexesWithAutoIncPK) {\n\t                                        indexesWithAutoIncPK.forEach(function (idx) {\n\t                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });\n\t                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });\n\t                                            res.results.forEach(function (pk) { return idxVals[pkPos] = pk; });\n\t                                            getRangeSet(idx.name).addKeys(idxVals);\n\t                                        });\n\t                                    }\n\t                                }\n\t                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);\n\t                                return res;\n\t                            });\n\t                        } });\n\t                    var getRange = function (_a) {\n\t                        var _b, _c;\n\t                        var _d = _a.query, index = _d.index, range = _d.range;\n\t                        return [\n\t                            index,\n\t                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n\t                        ];\n\t                    };\n\t                    var readSubscribers = {\n\t                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n\t                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n\t                        count: getRange,\n\t                        query: getRange,\n\t                        openCursor: getRange,\n\t                    };\n\t                    keys(readSubscribers).forEach(function (method) {\n\t                        tableClone[method] = function (req) {\n\t                            var subscr = PSD.subscr;\n\t                            var isLiveQuery = !!subscr;\n\t                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);\n\t                            var obsSet = cachable\n\t                                ? req.obsSet = {}\n\t                                : subscr;\n\t                            if (isLiveQuery) {\n\t                                var getRangeSet = function (indexName) {\n\t                                    var part = \"idb://\".concat(dbName, \"/\").concat(tableName, \"/\").concat(indexName);\n\t                                    return (obsSet[part] ||\n\t                                        (obsSet[part] = new RangeSet()));\n\t                                };\n\t                                var pkRangeSet_1 = getRangeSet(\"\");\n\t                                var delsRangeSet_1 = getRangeSet(\":dels\");\n\t                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n\t                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {\n\t                                    delsRangeSet_1.add(queriedRanges);\n\t                                }\n\t                                else {\n\t                                    getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n\t                                }\n\t                                if (!queriedIndex.isPrimaryKey) {\n\t                                    if (method === \"count\") {\n\t                                        delsRangeSet_1.add(FULL_RANGE);\n\t                                    }\n\t                                    else {\n\t                                        var keysPromise_1 = method === \"query\" &&\n\t                                            outbound &&\n\t                                            req.values &&\n\t                                            table.query(__assign(__assign({}, req), { values: false }));\n\t                                        return table[method].apply(this, arguments).then(function (res) {\n\t                                            if (method === \"query\") {\n\t                                                if (outbound && req.values) {\n\t                                                    return keysPromise_1.then(function (_a) {\n\t                                                        var resultingKeys = _a.result;\n\t                                                        pkRangeSet_1.addKeys(resultingKeys);\n\t                                                        return res;\n\t                                                    });\n\t                                                }\n\t                                                var pKeys = req.values\n\t                                                    ? res.result.map(extractKey)\n\t                                                    : res.result;\n\t                                                if (req.values) {\n\t                                                    pkRangeSet_1.addKeys(pKeys);\n\t                                                }\n\t                                                else {\n\t                                                    delsRangeSet_1.addKeys(pKeys);\n\t                                                }\n\t                                            }\n\t                                            else if (method === \"openCursor\") {\n\t                                                var cursor_1 = res;\n\t                                                var wantValues_1 = req.values;\n\t                                                return (cursor_1 &&\n\t                                                    Object.create(cursor_1, {\n\t                                                        key: {\n\t                                                            get: function () {\n\t                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);\n\t                                                                return cursor_1.key;\n\t                                                            },\n\t                                                        },\n\t                                                        primaryKey: {\n\t                                                            get: function () {\n\t                                                                var pkey = cursor_1.primaryKey;\n\t                                                                delsRangeSet_1.addKey(pkey);\n\t                                                                return pkey;\n\t                                                            },\n\t                                                        },\n\t                                                        value: {\n\t                                                            get: function () {\n\t                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n\t                                                                return cursor_1.value;\n\t                                                            },\n\t                                                        },\n\t                                                    }));\n\t                                            }\n\t                                            return res;\n\t                                        });\n\t                                    }\n\t                                }\n\t                            }\n\t                            return table[method].apply(this, arguments);\n\t                        };\n\t                    });\n\t                    return tableClone;\n\t                } });\n\t        },\n\t    };\n\t    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n\t        function addAffectedIndex(ix) {\n\t            var rangeSet = getRangeSet(ix.name || \"\");\n\t            function extractKey(obj) {\n\t                return obj != null ? ix.extractKey(obj) : null;\n\t            }\n\t            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n\t                ? key.forEach(function (key) { return rangeSet.addKey(key); })\n\t                : rangeSet.addKey(key); };\n\t            (oldObjs || newObjs).forEach(function (_, i) {\n\t                var oldKey = oldObjs && extractKey(oldObjs[i]);\n\t                var newKey = newObjs && extractKey(newObjs[i]);\n\t                if (cmp(oldKey, newKey) !== 0) {\n\t                    if (oldKey != null)\n\t                        addKeyOrKeys(oldKey);\n\t                    if (newKey != null)\n\t                        addKeyOrKeys(newKey);\n\t                }\n\t            });\n\t        }\n\t        schema.indexes.forEach(addAffectedIndex);\n\t    }\n\n\t    function adjustOptimisticFromFailures(tblCache, req, res) {\n\t        if (res.numFailures === 0)\n\t            return req;\n\t        if (req.type === 'deleteRange') {\n\t            return null;\n\t        }\n\t        var numBulkOps = req.keys\n\t            ? req.keys.length\n\t            : 'values' in req && req.values\n\t                ? req.values.length\n\t                : 1;\n\t        if (res.numFailures === numBulkOps) {\n\t            return null;\n\t        }\n\t        var clone = __assign({}, req);\n\t        if (isArray(clone.keys)) {\n\t            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });\n\t        }\n\t        if ('values' in clone && isArray(clone.values)) {\n\t            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });\n\t        }\n\t        return clone;\n\t    }\n\n\t    function isAboveLower(key, range) {\n\t        return range.lower === undefined\n\t            ? true\n\t            : range.lowerOpen\n\t                ? cmp(key, range.lower) > 0\n\t                : cmp(key, range.lower) >= 0;\n\t    }\n\t    function isBelowUpper(key, range) {\n\t        return range.upper === undefined\n\t            ? true\n\t            : range.upperOpen\n\t                ? cmp(key, range.upper) < 0\n\t                : cmp(key, range.upper) <= 0;\n\t    }\n\t    function isWithinRange(key, range) {\n\t        return isAboveLower(key, range) && isBelowUpper(key, range);\n\t    }\n\n\t    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {\n\t        if (!ops || ops.length === 0)\n\t            return result;\n\t        var index = req.query.index;\n\t        var multiEntry = index.multiEntry;\n\t        var queryRange = req.query.range;\n\t        var primaryKey = table.schema.primaryKey;\n\t        var extractPrimKey = primaryKey.extractKey;\n\t        var extractIndex = index.extractKey;\n\t        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;\n\t        var finalResult = ops.reduce(function (result, op) {\n\t            var modifedResult = result;\n\t            var includedValues = [];\n\t            if (op.type === 'add' || op.type === 'put') {\n\t                var includedPKs = new RangeSet();\n\t                for (var i = op.values.length - 1; i >= 0; --i) {\n\t                    var value = op.values[i];\n\t                    var pk = extractPrimKey(value);\n\t                    if (includedPKs.hasKey(pk))\n\t                        continue;\n\t                    var key = extractIndex(value);\n\t                    if (multiEntry && isArray(key)\n\t                        ? key.some(function (k) { return isWithinRange(k, queryRange); })\n\t                        : isWithinRange(key, queryRange)) {\n\t                        includedPKs.addKey(pk);\n\t                        includedValues.push(value);\n\t                    }\n\t                }\n\t            }\n\t            switch (op.type) {\n\t                case 'add':\n\t                    modifedResult = result.concat(req.values\n\t                        ? includedValues\n\t                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n\t                    break;\n\t                case 'put':\n\t                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));\n\t                    modifedResult = result\n\t                        .filter(\n\t                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })\n\t                        .concat(\n\t                    req.values\n\t                        ? includedValues\n\t                        : includedValues.map(function (v) { return extractPrimKey(v); }));\n\t                    break;\n\t                case 'delete':\n\t                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);\n\t                    modifedResult = result.filter(function (item) { return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item); });\n\t                    break;\n\t                case 'deleteRange':\n\t                    var range_1 = op.range;\n\t                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });\n\t                    break;\n\t            }\n\t            return modifedResult;\n\t        }, result);\n\t        if (finalResult === result)\n\t            return result;\n\t        finalResult.sort(function (a, b) {\n\t            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||\n\t                cmp(extractPrimKey(a), extractPrimKey(b));\n\t        });\n\t        if (req.limit && req.limit < Infinity) {\n\t            if (finalResult.length > req.limit) {\n\t                finalResult.length = req.limit;\n\t            }\n\t            else if (result.length === req.limit && finalResult.length < req.limit) {\n\t                cacheEntry.dirty = true;\n\t            }\n\t        }\n\t        return immutable ? Object.freeze(finalResult) : finalResult;\n\t    }\n\n\t    function areRangesEqual(r1, r2) {\n\t        return (cmp(r1.lower, r2.lower) === 0 &&\n\t            cmp(r1.upper, r2.upper) === 0 &&\n\t            !!r1.lowerOpen === !!r2.lowerOpen &&\n\t            !!r1.upperOpen === !!r2.upperOpen);\n\t    }\n\n\t    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {\n\t        if (lower1 === undefined)\n\t            return lower2 !== undefined ? -1 : 0;\n\t        if (lower2 === undefined)\n\t            return 1;\n\t        var c = cmp(lower1, lower2);\n\t        if (c === 0) {\n\t            if (lowerOpen1 && lowerOpen2)\n\t                return 0;\n\t            if (lowerOpen1)\n\t                return 1;\n\t            if (lowerOpen2)\n\t                return -1;\n\t        }\n\t        return c;\n\t    }\n\t    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {\n\t        if (upper1 === undefined)\n\t            return upper2 !== undefined ? 1 : 0;\n\t        if (upper2 === undefined)\n\t            return -1;\n\t        var c = cmp(upper1, upper2);\n\t        if (c === 0) {\n\t            if (upperOpen1 && upperOpen2)\n\t                return 0;\n\t            if (upperOpen1)\n\t                return -1;\n\t            if (upperOpen2)\n\t                return 1;\n\t        }\n\t        return c;\n\t    }\n\t    function isSuperRange(r1, r2) {\n\t        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&\n\t            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);\n\t    }\n\n\t    function findCompatibleQuery(dbName, tableName, type, req) {\n\t        var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t        if (!tblCache)\n\t            return [];\n\t        var queries = tblCache.queries[type];\n\t        if (!queries)\n\t            return [null, false, tblCache, null];\n\t        var indexName = req.query ? req.query.index.name : null;\n\t        var entries = queries[indexName || ''];\n\t        if (!entries)\n\t            return [null, false, tblCache, null];\n\t        switch (type) {\n\t            case 'query':\n\t                var equalEntry = entries.find(function (entry) {\n\t                    return entry.req.limit === req.limit &&\n\t                        entry.req.values === req.values &&\n\t                        areRangesEqual(entry.req.query.range, req.query.range);\n\t                });\n\t                if (equalEntry)\n\t                    return [\n\t                        equalEntry,\n\t                        true,\n\t                        tblCache,\n\t                        entries,\n\t                    ];\n\t                var superEntry = entries.find(function (entry) {\n\t                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;\n\t                    return (limit >= req.limit &&\n\t                        (req.values ? entry.req.values : true) &&\n\t                        isSuperRange(entry.req.query.range, req.query.range));\n\t                });\n\t                return [superEntry, false, tblCache, entries];\n\t            case 'count':\n\t                var countQuery = entries.find(function (entry) {\n\t                    return areRangesEqual(entry.req.query.range, req.query.range);\n\t                });\n\t                return [countQuery, !!countQuery, tblCache, entries];\n\t        }\n\t    }\n\n\t    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {\n\t        cacheEntry.subscribers.add(requery);\n\t        signal.addEventListener(\"abort\", function () {\n\t            cacheEntry.subscribers.delete(requery);\n\t            if (cacheEntry.subscribers.size === 0) {\n\t                enqueForDeletion(cacheEntry, container);\n\t            }\n\t        });\n\t    }\n\t    function enqueForDeletion(cacheEntry, container) {\n\t        setTimeout(function () {\n\t            if (cacheEntry.subscribers.size === 0) {\n\t                delArrayItem(container, cacheEntry);\n\t            }\n\t        }, 3000);\n\t    }\n\n\t    var cacheMiddleware = {\n\t        stack: 'dbcore',\n\t        level: 0,\n\t        name: 'Cache',\n\t        create: function (core) {\n\t            var dbName = core.schema.name;\n\t            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {\n\t                    var idbtrans = core.transaction(stores, mode, options);\n\t                    if (mode === 'readwrite') {\n\t                        var ac_1 = new AbortController();\n\t                        var signal = ac_1.signal;\n\t                        var endTransaction = function (wasCommitted) { return function () {\n\t                            ac_1.abort();\n\t                            if (mode === 'readwrite') {\n\t                                var affectedSubscribers_1 = new Set();\n\t                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {\n\t                                    var storeName = stores_1[_i];\n\t                                    var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(storeName)];\n\t                                    if (tblCache) {\n\t                                        var table = core.table(storeName);\n\t                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });\n\t                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {\n\t                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {\n\t                                                var entries = _b[_a];\n\t                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {\n\t                                                    var entry = _d[_c];\n\t                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {\n\t                                                        delArrayItem(entries, entry);\n\t                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                    }\n\t                                                }\n\t                                            }\n\t                                        }\n\t                                        else if (ops.length > 0) {\n\t                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });\n\t                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {\n\t                                                var entries = _f[_e];\n\t                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {\n\t                                                    var entry = _h[_g];\n\t                                                    if (entry.res != null &&\n\t                                                        idbtrans.mutatedParts\n\t    ) {\n\t                                                        if (wasCommitted && !entry.dirty) {\n\t                                                            var freezeResults = Object.isFrozen(entry.res);\n\t                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);\n\t                                                            if (entry.dirty) {\n\t                                                                delArrayItem(entries, entry);\n\t                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                            }\n\t                                                            else if (modRes !== entry.res) {\n\t                                                                entry.res = modRes;\n\t                                                                entry.promise = DexiePromise.resolve({ result: modRes });\n\t                                                            }\n\t                                                        }\n\t                                                        else {\n\t                                                            if (entry.dirty) {\n\t                                                                delArrayItem(entries, entry);\n\t                                                            }\n\t                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });\n\t                                                        }\n\t                                                    }\n\t                                                }\n\t                                            }\n\t                                        }\n\t                                    }\n\t                                }\n\t                                affectedSubscribers_1.forEach(function (requery) { return requery(); });\n\t                            }\n\t                        }; };\n\t                        idbtrans.addEventListener('abort', endTransaction(false), {\n\t                            signal: signal,\n\t                        });\n\t                        idbtrans.addEventListener('error', endTransaction(false), {\n\t                            signal: signal,\n\t                        });\n\t                        idbtrans.addEventListener('complete', endTransaction(true), {\n\t                            signal: signal,\n\t                        });\n\t                    }\n\t                    return idbtrans;\n\t                }, table: function (tableName) {\n\t                    var downTable = core.table(tableName);\n\t                    var primKey = downTable.schema.primaryKey;\n\t                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {\n\t                            var trans = PSD.trans;\n\t                            if (primKey.outbound ||\n\t                                trans.db._options.cache === 'disabled' ||\n\t                                trans.explicit\n\t                            ) {\n\t                                return downTable.mutate(req);\n\t                            }\n\t                            var tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)];\n\t                            if (!tblCache)\n\t                                return downTable.mutate(req);\n\t                            var promise = downTable.mutate(req);\n\t                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {\n\t                                promise.then(function (res) {\n\t                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {\n\t                                            var _a;\n\t                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))\n\t                                                ? deepClone(value)\n\t                                                : __assign({}, value);\n\t                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);\n\t                                            return valueWithKey;\n\t                                        }) });\n\t                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);\n\t                                    tblCache.optimisticOps.push(adjustedReq);\n\t                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });\n\t                                });\n\t                            }\n\t                            else {\n\t                                tblCache.optimisticOps.push(req);\n\t                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                promise.then(function (res) {\n\t                                    if (res.numFailures > 0) {\n\t                                        delArrayItem(tblCache.optimisticOps, req);\n\t                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);\n\t                                        if (adjustedReq) {\n\t                                            tblCache.optimisticOps.push(adjustedReq);\n\t                                        }\n\t                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                    }\n\t                                });\n\t                                promise.catch(function () {\n\t                                    delArrayItem(tblCache.optimisticOps, req);\n\t                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);\n\t                                });\n\t                            }\n\t                            return promise;\n\t                        }, query: function (req) {\n\t                            var _a;\n\t                            if (!isCachableContext(PSD, downTable) || !isCachableRequest(\"query\", req))\n\t                                return downTable.query(req);\n\t                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';\n\t                            var _b = PSD, requery = _b.requery, signal = _b.signal;\n\t                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];\n\t                            if (cacheEntry && exactMatch) {\n\t                                cacheEntry.obsSet = req.obsSet;\n\t                            }\n\t                            else {\n\t                                var promise = downTable.query(req).then(function (res) {\n\t                                    var result = res.result;\n\t                                    if (cacheEntry)\n\t                                        cacheEntry.res = result;\n\t                                    if (freezeResults) {\n\t                                        for (var i = 0, l = result.length; i < l; ++i) {\n\t                                            Object.freeze(result[i]);\n\t                                        }\n\t                                        Object.freeze(result);\n\t                                    }\n\t                                    else {\n\t                                        res.result = deepClone(result);\n\t                                    }\n\t                                    return res;\n\t                                }).catch(function (error) {\n\t                                    if (container && cacheEntry)\n\t                                        delArrayItem(container, cacheEntry);\n\t                                    return Promise.reject(error);\n\t                                });\n\t                                cacheEntry = {\n\t                                    obsSet: req.obsSet,\n\t                                    promise: promise,\n\t                                    subscribers: new Set(),\n\t                                    type: 'query',\n\t                                    req: req,\n\t                                    dirty: false,\n\t                                };\n\t                                if (container) {\n\t                                    container.push(cacheEntry);\n\t                                }\n\t                                else {\n\t                                    container = [cacheEntry];\n\t                                    if (!tblCache) {\n\t                                        tblCache = cache[\"idb://\".concat(dbName, \"/\").concat(tableName)] = {\n\t                                            queries: {\n\t                                                query: {},\n\t                                                count: {},\n\t                                            },\n\t                                            objs: new Map(),\n\t                                            optimisticOps: [],\n\t                                            unsignaledParts: {}\n\t                                        };\n\t                                    }\n\t                                    tblCache.queries.query[req.query.index.name || ''] = container;\n\t                                }\n\t                            }\n\t                            subscribeToCacheEntry(cacheEntry, container, requery, signal);\n\t                            return cacheEntry.promise.then(function (res) {\n\t                                return {\n\t                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),\n\t                                };\n\t                            });\n\t                        } });\n\t                    return tableMW;\n\t                } });\n\t            return coreMW;\n\t        },\n\t    };\n\n\t    function vipify(target, vipDb) {\n\t        return new Proxy(target, {\n\t            get: function (target, prop, receiver) {\n\t                if (prop === 'db')\n\t                    return vipDb;\n\t                return Reflect.get(target, prop, receiver);\n\t            }\n\t        });\n\t    }\n\n\t    var Dexie$1 =  (function () {\n\t        function Dexie(name, options) {\n\t            var _this = this;\n\t            this._middlewares = {};\n\t            this.verno = 0;\n\t            var deps = Dexie.dependencies;\n\t            this._options = options = __assign({\n\t                addons: Dexie.addons, autoOpen: true,\n\t                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);\n\t            this._deps = {\n\t                indexedDB: options.indexedDB,\n\t                IDBKeyRange: options.IDBKeyRange\n\t            };\n\t            var addons = options.addons;\n\t            this._dbSchema = {};\n\t            this._versions = [];\n\t            this._storeNames = [];\n\t            this._allTables = {};\n\t            this.idbdb = null;\n\t            this._novip = this;\n\t            var state = {\n\t                dbOpenError: null,\n\t                isBeingOpened: false,\n\t                onReadyBeingFired: null,\n\t                openComplete: false,\n\t                dbReadyResolve: nop,\n\t                dbReadyPromise: null,\n\t                cancelOpen: nop,\n\t                openCanceller: null,\n\t                autoSchema: true,\n\t                PR1398_maxLoop: 3,\n\t                autoOpen: options.autoOpen,\n\t            };\n\t            state.dbReadyPromise = new DexiePromise(function (resolve) {\n\t                state.dbReadyResolve = resolve;\n\t            });\n\t            state.openCanceller = new DexiePromise(function (_, reject) {\n\t                state.cancelOpen = reject;\n\t            });\n\t            this._state = state;\n\t            this.name = name;\n\t            this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n\t            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n\t                return function (subscriber, bSticky) {\n\t                    Dexie.vip(function () {\n\t                        var state = _this._state;\n\t                        if (state.openComplete) {\n\t                            if (!state.dbOpenError)\n\t                                DexiePromise.resolve().then(subscriber);\n\t                            if (bSticky)\n\t                                subscribe(subscriber);\n\t                        }\n\t                        else if (state.onReadyBeingFired) {\n\t                            state.onReadyBeingFired.push(subscriber);\n\t                            if (bSticky)\n\t                                subscribe(subscriber);\n\t                        }\n\t                        else {\n\t                            subscribe(subscriber);\n\t                            var db_1 = _this;\n\t                            if (!bSticky)\n\t                                subscribe(function unsubscribe() {\n\t                                    db_1.on.ready.unsubscribe(subscriber);\n\t                                    db_1.on.ready.unsubscribe(unsubscribe);\n\t                                });\n\t                        }\n\t                    });\n\t                };\n\t            });\n\t            this.Collection = createCollectionConstructor(this);\n\t            this.Table = createTableConstructor(this);\n\t            this.Transaction = createTransactionConstructor(this);\n\t            this.Version = createVersionConstructor(this);\n\t            this.WhereClause = createWhereClauseConstructor(this);\n\t            this.on(\"versionchange\", function (ev) {\n\t                if (ev.newVersion > 0)\n\t                    console.warn(\"Another connection wants to upgrade database '\".concat(_this.name, \"'. Closing db now to resume the upgrade.\"));\n\t                else\n\t                    console.warn(\"Another connection wants to delete database '\".concat(_this.name, \"'. Closing db now to resume the delete request.\"));\n\t                _this.close({ disableAutoOpen: false });\n\t            });\n\t            this.on(\"blocked\", function (ev) {\n\t                if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n\t                    console.warn(\"Dexie.delete('\".concat(_this.name, \"') was blocked\"));\n\t                else\n\t                    console.warn(\"Upgrade '\".concat(_this.name, \"' blocked by other connection holding version \").concat(ev.oldVersion / 10));\n\t            });\n\t            this._maxKey = getMaxKey(options.IDBKeyRange);\n\t            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n\t            this._fireOnBlocked = function (ev) {\n\t                _this.on(\"blocked\").fire(ev);\n\t                connections\n\t                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n\t                    .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n\t            };\n\t            this.use(cacheExistingValuesMiddleware);\n\t            this.use(cacheMiddleware);\n\t            this.use(observabilityMiddleware);\n\t            this.use(virtualIndexMiddleware);\n\t            this.use(hooksMiddleware);\n\t            var vipDB = new Proxy(this, {\n\t                get: function (_, prop, receiver) {\n\t                    if (prop === '_vip')\n\t                        return true;\n\t                    if (prop === 'table')\n\t                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };\n\t                    var rv = Reflect.get(_, prop, receiver);\n\t                    if (rv instanceof Table)\n\t                        return vipify(rv, vipDB);\n\t                    if (prop === 'tables')\n\t                        return rv.map(function (t) { return vipify(t, vipDB); });\n\t                    if (prop === '_createTransaction')\n\t                        return function () {\n\t                            var tx = rv.apply(this, arguments);\n\t                            return vipify(tx, vipDB);\n\t                        };\n\t                    return rv;\n\t                }\n\t            });\n\t            this.vip = vipDB;\n\t            addons.forEach(function (addon) { return addon(_this); });\n\t        }\n\t        Dexie.prototype.version = function (versionNumber) {\n\t            if (isNaN(versionNumber) || versionNumber < 0.1)\n\t                throw new exceptions.Type(\"Given version is not a positive number\");\n\t            versionNumber = Math.round(versionNumber * 10) / 10;\n\t            if (this.idbdb || this._state.isBeingOpened)\n\t                throw new exceptions.Schema(\"Cannot add version when database is open\");\n\t            this.verno = Math.max(this.verno, versionNumber);\n\t            var versions = this._versions;\n\t            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n\t            if (versionInstance)\n\t                return versionInstance;\n\t            versionInstance = new this.Version(versionNumber);\n\t            versions.push(versionInstance);\n\t            versions.sort(lowerVersionFirst);\n\t            versionInstance.stores({});\n\t            this._state.autoSchema = false;\n\t            return versionInstance;\n\t        };\n\t        Dexie.prototype._whenReady = function (fn) {\n\t            var _this = this;\n\t            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n\t                if (_this._state.openComplete) {\n\t                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n\t                }\n\t                if (!_this._state.isBeingOpened) {\n\t                    if (!_this._state.autoOpen) {\n\t                        reject(new exceptions.DatabaseClosed());\n\t                        return;\n\t                    }\n\t                    _this.open().catch(nop);\n\t                }\n\t                _this._state.dbReadyPromise.then(resolve, reject);\n\t            }).then(fn);\n\t        };\n\t        Dexie.prototype.use = function (_a) {\n\t            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n\t            if (name)\n\t                this.unuse({ stack: stack, name: name });\n\t            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n\t            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n\t            middlewares.sort(function (a, b) { return a.level - b.level; });\n\t            return this;\n\t        };\n\t        Dexie.prototype.unuse = function (_a) {\n\t            var stack = _a.stack, name = _a.name, create = _a.create;\n\t            if (stack && this._middlewares[stack]) {\n\t                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n\t                    return create ? mw.create !== create :\n\t                        name ? mw.name !== name :\n\t                            false;\n\t                });\n\t            }\n\t            return this;\n\t        };\n\t        Dexie.prototype.open = function () {\n\t            var _this = this;\n\t            return usePSD(globalPSD,\n\t            function () { return dexieOpen(_this); });\n\t        };\n\t        Dexie.prototype._close = function () {\n\t            var state = this._state;\n\t            var idx = connections.indexOf(this);\n\t            if (idx >= 0)\n\t                connections.splice(idx, 1);\n\t            if (this.idbdb) {\n\t                try {\n\t                    this.idbdb.close();\n\t                }\n\t                catch (e) { }\n\t                this.idbdb = null;\n\t            }\n\t            if (!state.isBeingOpened) {\n\t                state.dbReadyPromise = new DexiePromise(function (resolve) {\n\t                    state.dbReadyResolve = resolve;\n\t                });\n\t                state.openCanceller = new DexiePromise(function (_, reject) {\n\t                    state.cancelOpen = reject;\n\t                });\n\t            }\n\t        };\n\t        Dexie.prototype.close = function (_a) {\n\t            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;\n\t            var state = this._state;\n\t            if (disableAutoOpen) {\n\t                if (state.isBeingOpened) {\n\t                    state.cancelOpen(new exceptions.DatabaseClosed());\n\t                }\n\t                this._close();\n\t                state.autoOpen = false;\n\t                state.dbOpenError = new exceptions.DatabaseClosed();\n\t            }\n\t            else {\n\t                this._close();\n\t                state.autoOpen = this._options.autoOpen ||\n\t                    state.isBeingOpened;\n\t                state.openComplete = false;\n\t                state.dbOpenError = null;\n\t            }\n\t        };\n\t        Dexie.prototype.delete = function (closeOptions) {\n\t            var _this = this;\n\t            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }\n\t            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';\n\t            var state = this._state;\n\t            return new DexiePromise(function (resolve, reject) {\n\t                var doDelete = function () {\n\t                    _this.close(closeOptions);\n\t                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n\t                    req.onsuccess = wrap(function () {\n\t                        _onDatabaseDeleted(_this._deps, _this.name);\n\t                        resolve();\n\t                    });\n\t                    req.onerror = eventRejectHandler(reject);\n\t                    req.onblocked = _this._fireOnBlocked;\n\t                };\n\t                if (hasInvalidArguments)\n\t                    throw new exceptions.InvalidArgument(\"Invalid closeOptions argument to db.delete()\");\n\t                if (state.isBeingOpened) {\n\t                    state.dbReadyPromise.then(doDelete);\n\t                }\n\t                else {\n\t                    doDelete();\n\t                }\n\t            });\n\t        };\n\t        Dexie.prototype.backendDB = function () {\n\t            return this.idbdb;\n\t        };\n\t        Dexie.prototype.isOpen = function () {\n\t            return this.idbdb !== null;\n\t        };\n\t        Dexie.prototype.hasBeenClosed = function () {\n\t            var dbOpenError = this._state.dbOpenError;\n\t            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n\t        };\n\t        Dexie.prototype.hasFailed = function () {\n\t            return this._state.dbOpenError !== null;\n\t        };\n\t        Dexie.prototype.dynamicallyOpened = function () {\n\t            return this._state.autoSchema;\n\t        };\n\t        Object.defineProperty(Dexie.prototype, \"tables\", {\n\t            get: function () {\n\t                var _this = this;\n\t                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n\t            },\n\t            enumerable: false,\n\t            configurable: true\n\t        });\n\t        Dexie.prototype.transaction = function () {\n\t            var args = extractTransactionArgs.apply(this, arguments);\n\t            return this._transaction.apply(this, args);\n\t        };\n\t        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n\t            var _this = this;\n\t            var parentTransaction = PSD.trans;\n\t            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n\t                parentTransaction = null;\n\t            var onlyIfCompatible = mode.indexOf('?') !== -1;\n\t            mode = mode.replace('!', '').replace('?', '');\n\t            var idbMode, storeNames;\n\t            try {\n\t                storeNames = tables.map(function (table) {\n\t                    var storeName = table instanceof _this.Table ? table.name : table;\n\t                    if (typeof storeName !== 'string')\n\t                        throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n\t                    return storeName;\n\t                });\n\t                if (mode == \"r\" || mode === READONLY)\n\t                    idbMode = READONLY;\n\t                else if (mode == \"rw\" || mode == READWRITE)\n\t                    idbMode = READWRITE;\n\t                else\n\t                    throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\t                if (parentTransaction) {\n\t                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n\t                        if (onlyIfCompatible) {\n\t                            parentTransaction = null;\n\t                        }\n\t                        else\n\t                            throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n\t                    }\n\t                    if (parentTransaction) {\n\t                        storeNames.forEach(function (storeName) {\n\t                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n\t                                if (onlyIfCompatible) {\n\t                                    parentTransaction = null;\n\t                                }\n\t                                else\n\t                                    throw new exceptions.SubTransaction(\"Table \" + storeName +\n\t                                        \" not included in parent transaction.\");\n\t                            }\n\t                        });\n\t                    }\n\t                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n\t                        parentTransaction = null;\n\t                    }\n\t                }\n\t            }\n\t            catch (e) {\n\t                return parentTransaction ?\n\t                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n\t                    rejection(e);\n\t            }\n\t            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n\t            return (parentTransaction ?\n\t                parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n\t                PSD.trans ?\n\t                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n\t                    this._whenReady(enterTransaction));\n\t        };\n\t        Dexie.prototype.table = function (tableName) {\n\t            if (!hasOwn(this._allTables, tableName)) {\n\t                throw new exceptions.InvalidTable(\"Table \".concat(tableName, \" does not exist\"));\n\t            }\n\t            return this._allTables[tableName];\n\t        };\n\t        return Dexie;\n\t    }());\n\n\t    var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n\t        ? Symbol.observable\n\t        : \"@@observable\";\n\t    var Observable =  (function () {\n\t        function Observable(subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t        Observable.prototype.subscribe = function (x, error, complete) {\n\t            return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n\t        };\n\t        Observable.prototype[symbolObservable] = function () {\n\t            return this;\n\t        };\n\t        return Observable;\n\t    }());\n\n\t    var domDeps;\n\t    try {\n\t        domDeps = {\n\t            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n\t            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n\t        };\n\t    }\n\t    catch (e) {\n\t        domDeps = { indexedDB: null, IDBKeyRange: null };\n\t    }\n\n\t    function liveQuery(querier) {\n\t        var hasValue = false;\n\t        var currentValue;\n\t        var observable = new Observable(function (observer) {\n\t            var scopeFuncIsAsync = isAsyncFunction(querier);\n\t            function execute(ctx) {\n\t                var wasRootExec = beginMicroTickScope();\n\t                try {\n\t                    if (scopeFuncIsAsync) {\n\t                        incrementExpectedAwaits();\n\t                    }\n\t                    var rv = newScope(querier, ctx);\n\t                    if (scopeFuncIsAsync) {\n\t                        rv = rv.finally(decrementExpectedAwaits);\n\t                    }\n\t                    return rv;\n\t                }\n\t                finally {\n\t                    wasRootExec && endMicroTickScope();\n\t                }\n\t            }\n\t            var closed = false;\n\t            var abortController;\n\t            var accumMuts = {};\n\t            var currentObs = {};\n\t            var subscription = {\n\t                get closed() {\n\t                    return closed;\n\t                },\n\t                unsubscribe: function () {\n\t                    if (closed)\n\t                        return;\n\t                    closed = true;\n\t                    if (abortController)\n\t                        abortController.abort();\n\t                    if (startedListening)\n\t                        globalEvents.storagemutated.unsubscribe(mutationListener);\n\t                },\n\t            };\n\t            observer.start && observer.start(subscription);\n\t            var startedListening = false;\n\t            var doQuery = function () { return execInGlobalContext(_doQuery); };\n\t            function shouldNotify() {\n\t                return obsSetsOverlap(currentObs, accumMuts);\n\t            }\n\t            var mutationListener = function (parts) {\n\t                extendObservabilitySet(accumMuts, parts);\n\t                if (shouldNotify()) {\n\t                    doQuery();\n\t                }\n\t            };\n\t            var _doQuery = function () {\n\t                if (closed ||\n\t                    !domDeps.indexedDB)\n\t                 {\n\t                    return;\n\t                }\n\t                accumMuts = {};\n\t                var subscr = {};\n\t                if (abortController)\n\t                    abortController.abort();\n\t                abortController = new AbortController();\n\t                var ctx = {\n\t                    subscr: subscr,\n\t                    signal: abortController.signal,\n\t                    requery: doQuery,\n\t                    querier: querier,\n\t                    trans: null\n\t                };\n\t                var ret = execute(ctx);\n\t                Promise.resolve(ret).then(function (result) {\n\t                    hasValue = true;\n\t                    currentValue = result;\n\t                    if (closed || ctx.signal.aborted) {\n\t                        return;\n\t                    }\n\t                    accumMuts = {};\n\t                    currentObs = subscr;\n\t                    if (!objectIsEmpty(currentObs) && !startedListening) {\n\t                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n\t                        startedListening = true;\n\t                    }\n\t                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });\n\t                }, function (err) {\n\t                    hasValue = false;\n\t                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n\t                        if (!closed)\n\t                            execInGlobalContext(function () {\n\t                                if (closed)\n\t                                    return;\n\t                                observer.error && observer.error(err);\n\t                            });\n\t                    }\n\t                });\n\t            };\n\t            setTimeout(doQuery, 0);\n\t            return subscription;\n\t        });\n\t        observable.hasValue = function () { return hasValue; };\n\t        observable.getValue = function () { return currentValue; };\n\t        return observable;\n\t    }\n\n\t    var Dexie = Dexie$1;\n\t    props(Dexie, __assign(__assign({}, fullNameExceptions), {\n\t        delete: function (databaseName) {\n\t            var db = new Dexie(databaseName, { addons: [] });\n\t            return db.delete();\n\t        },\n\t        exists: function (name) {\n\t            return new Dexie(name, { addons: [] }).open().then(function (db) {\n\t                db.close();\n\t                return true;\n\t            }).catch('NoSuchDatabaseError', function () { return false; });\n\t        },\n\t        getDatabaseNames: function (cb) {\n\t            try {\n\t                return getDatabaseNames(Dexie.dependencies).then(cb);\n\t            }\n\t            catch (_a) {\n\t                return rejection(new exceptions.MissingAPI());\n\t            }\n\t        },\n\t        defineClass: function () {\n\t            function Class(content) {\n\t                extend(this, content);\n\t            }\n\t            return Class;\n\t        }, ignoreTransaction: function (scopeFunc) {\n\t            return PSD.trans ?\n\t                usePSD(PSD.transless, scopeFunc) :\n\t                scopeFunc();\n\t        }, vip: vip, async: function (generatorFn) {\n\t            return function () {\n\t                try {\n\t                    var rv = awaitIterator(generatorFn.apply(this, arguments));\n\t                    if (!rv || typeof rv.then !== 'function')\n\t                        return DexiePromise.resolve(rv);\n\t                    return rv;\n\t                }\n\t                catch (e) {\n\t                    return rejection(e);\n\t                }\n\t            };\n\t        }, spawn: function (generatorFn, args, thiz) {\n\t            try {\n\t                var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n\t                if (!rv || typeof rv.then !== 'function')\n\t                    return DexiePromise.resolve(rv);\n\t                return rv;\n\t            }\n\t            catch (e) {\n\t                return rejection(e);\n\t            }\n\t        },\n\t        currentTransaction: {\n\t            get: function () { return PSD.trans || null; }\n\t        }, waitFor: function (promiseOrFunction, optionalTimeout) {\n\t            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n\t                Dexie.ignoreTransaction(promiseOrFunction) :\n\t                promiseOrFunction)\n\t                .timeout(optionalTimeout || 60000);\n\t            return PSD.trans ?\n\t                PSD.trans.waitFor(promise) :\n\t                promise;\n\t        },\n\t        Promise: DexiePromise,\n\t        debug: {\n\t            get: function () { return debug; },\n\t            set: function (value) {\n\t                setDebug(value);\n\t            }\n\t        },\n\t        derive: derive, extend: extend, props: props, override: override,\n\t        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n\t        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n\t        minKey: minKey,\n\t        addons: [],\n\t        connections: connections,\n\t        errnames: errnames,\n\t        dependencies: domDeps, cache: cache,\n\t        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n\t            .map(function (n) { return parseInt(n); })\n\t            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\n\t    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\n\t    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n\t        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n\t            if (!propagatingLocally) {\n\t                var event_1;\n\t                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n\t                    detail: updatedParts\n\t                });\n\t                propagatingLocally = true;\n\t                dispatchEvent(event_1);\n\t                propagatingLocally = false;\n\t            }\n\t        });\n\t        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n\t            var detail = _a.detail;\n\t            if (!propagatingLocally) {\n\t                propagateLocally(detail);\n\t            }\n\t        });\n\t    }\n\t    function propagateLocally(updateParts) {\n\t        var wasMe = propagatingLocally;\n\t        try {\n\t            propagatingLocally = true;\n\t            globalEvents.storagemutated.fire(updateParts);\n\t            signalSubscribersNow(updateParts, true);\n\t        }\n\t        finally {\n\t            propagatingLocally = wasMe;\n\t        }\n\t    }\n\t    var propagatingLocally = false;\n\n\t    var bc;\n\t    var createBC = function () { };\n\t    if (typeof BroadcastChannel !== 'undefined') {\n\t        createBC = function () {\n\t            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n\t            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };\n\t        };\n\t        createBC();\n\t        if (typeof bc.unref === 'function') {\n\t            bc.unref();\n\t        }\n\t        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n\t            if (!propagatingLocally) {\n\t                bc.postMessage(changedParts);\n\t            }\n\t        });\n\t    }\n\n\t    if (typeof addEventListener !== 'undefined') {\n\t        addEventListener('pagehide', function (event) {\n\t            if (!Dexie$1.disableBfCache && event.persisted) {\n\t                if (debug)\n\t                    console.debug('Dexie: handling persisted pagehide');\n\t                bc === null || bc === void 0 ? void 0 : bc.close();\n\t                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {\n\t                    var db = connections_1[_i];\n\t                    db.close({ disableAutoOpen: false });\n\t                }\n\t            }\n\t        });\n\t        addEventListener('pageshow', function (event) {\n\t            if (!Dexie$1.disableBfCache && event.persisted) {\n\t                if (debug)\n\t                    console.debug('Dexie: handling persisted pageshow');\n\t                createBC();\n\t                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });\n\t            }\n\t        });\n\t    }\n\n\t    function add(value) {\n\t        return new PropModification({ add: value });\n\t    }\n\n\t    function remove(value) {\n\t        return new PropModification({ remove: value });\n\t    }\n\n\t    function replacePrefix(a, b) {\n\t        return new PropModification({ replacePrefix: [a, b] });\n\t    }\n\n\t    DexiePromise.rejectionMapper = mapError;\n\t    setDebug(debug);\n\n\t    var namedExports = /*#__PURE__*/Object.freeze({\n\t        __proto__: null,\n\t        Dexie: Dexie$1,\n\t        liveQuery: liveQuery,\n\t        Entity: Entity,\n\t        cmp: cmp,\n\t        PropModSymbol: PropModSymbol,\n\t        PropModification: PropModification,\n\t        replacePrefix: replacePrefix,\n\t        add: add,\n\t        remove: remove,\n\t        'default': Dexie$1,\n\t        RangeSet: RangeSet,\n\t        mergeRanges: mergeRanges,\n\t        rangesOverlap: rangesOverlap\n\t    });\n\n\t    __assign(Dexie$1, namedExports, { default: Dexie$1 });\n\n\t    return Dexie$1;\n\n\t}));\n\t\n} (dexie));\n\nvar dexieExports = dexie.exports;\nvar _Dexie = /*@__PURE__*/getDefaultExportFromCjs(dexieExports);\n\n// Making the module version consumable via require - to prohibit\n// multiple occurrancies of the same module in the same app\n// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)\nconst DexieSymbol = Symbol.for(\"Dexie\");\nconst Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);\nif (_Dexie.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);\n}\n\n// Helper for undefined values, like map for Option<T> in Rust.\n// A better name for this is welcome.\nconst mapOption = (value, func) => {\n    return value != undefined ? func(value) : undefined;\n};\n// Anything can be thrown as an error in raw JS (also the TS compiler can't type-check exceptions),\n// so we allow it here.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst logWebStoreError = (error, errorContext) => {\n    if (error instanceof Dexie.DexieError) {\n        if (errorContext) {\n            console.error(`${errorContext}: Indexdb error (${error.name}): ${error.message}`);\n        }\n        else {\n            console.error(`Indexdb error: (${error.name}): ${error.message}`);\n        }\n        mapOption(error.stack, (stack) => {\n            console.error(`Stacktrace: \\n ${stack}`);\n        });\n        mapOption(error.inner, (innerException) => logWebStoreError(innerException));\n    }\n    else if (error instanceof Error) {\n        console.error(`Unexpected error while accessing indexdb: ${error.toString()}`);\n        mapOption(error.stack, (stack) => {\n            console.error(`Stacktrace: ${stack}`);\n        });\n    }\n    else {\n        console.error(`Got an exception with a non-error value, as JSON: \\n ${JSON.stringify(error)}. As String \\n ${String(error)} `);\n        console.trace();\n    }\n    throw error;\n};\nconst uint8ArrayToBase64 = (bytes) => {\n    const binary = bytes.reduce((acc, byte) => acc + String.fromCharCode(byte), \"\");\n    return btoa(binary);\n};\n\nconst DATABASE_NAME = \"MidenClientDB\";\nasync function openDatabase() {\n    console.log(\"Opening database...\");\n    try {\n        await db.open();\n        console.log(\"Database opened successfully\");\n        return true;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to open database\");\n        return false;\n    }\n}\nvar Table;\n(function (Table) {\n    Table[\"AccountCode\"] = \"accountCode\";\n    Table[\"AccountStorage\"] = \"accountStorage\";\n    Table[\"AccountAssets\"] = \"accountAssets\";\n    Table[\"StorageMapEntries\"] = \"storageMapEntries\";\n    Table[\"AccountAuth\"] = \"accountAuth\";\n    Table[\"Accounts\"] = \"accounts\";\n    Table[\"Addresses\"] = \"addresses\";\n    Table[\"Transactions\"] = \"transactions\";\n    Table[\"TransactionScripts\"] = \"transactionScripts\";\n    Table[\"InputNotes\"] = \"inputNotes\";\n    Table[\"OutputNotes\"] = \"outputNotes\";\n    Table[\"NotesScripts\"] = \"notesScripts\";\n    Table[\"StateSync\"] = \"stateSync\";\n    Table[\"BlockHeaders\"] = \"blockHeaders\";\n    Table[\"PartialBlockchainNodes\"] = \"partialBlockchainNodes\";\n    Table[\"Tags\"] = \"tags\";\n    Table[\"ForeignAccountCode\"] = \"foreignAccountCode\";\n    Table[\"Settings\"] = \"settings\";\n    Table[\"TrackedAccounts\"] = \"trackedAccounts\";\n})(Table || (Table = {}));\nconst db = new Dexie(DATABASE_NAME);\ndb.version(1).stores({\n    [Table.AccountCode]: indexes(\"root\"),\n    [Table.AccountStorage]: indexes(\"[commitment+slotIndex]\", \"commitment\"),\n    [Table.StorageMapEntries]: indexes(\"[root+key]\", \"root\"),\n    [Table.AccountAssets]: indexes(\"[root+vaultKey]\", \"root\", \"faucetIdPrefix\"),\n    [Table.AccountAuth]: indexes(\"pubKey\"),\n    [Table.Accounts]: indexes(\"&accountCommitment\", \"id\", \"[id+nonce]\", \"codeRoot\", \"storageRoot\", \"vaultRoot\"),\n    [Table.Addresses]: indexes(\"address\", \"id\"),\n    [Table.Transactions]: indexes(\"id\", \"statusVariant\"),\n    [Table.TransactionScripts]: indexes(\"scriptRoot\"),\n    [Table.InputNotes]: indexes(\"noteId\", \"nullifier\", \"stateDiscriminant\"),\n    [Table.OutputNotes]: indexes(\"noteId\", \"recipientDigest\", \"stateDiscriminant\", \"nullifier\"),\n    [Table.NotesScripts]: indexes(\"scriptRoot\"),\n    [Table.StateSync]: indexes(\"id\"),\n    [Table.BlockHeaders]: indexes(\"blockNum\", \"hasClientNotes\"),\n    [Table.PartialBlockchainNodes]: indexes(\"id\"),\n    [Table.Tags]: indexes(\"id++\", \"tag\", \"source_note_id\", \"source_account_id\"),\n    [Table.ForeignAccountCode]: indexes(\"accountId\"),\n    [Table.Settings]: indexes(\"key\"),\n    [Table.TrackedAccounts]: indexes(\"&id\"),\n});\nfunction indexes(...items) {\n    return items.join(\",\");\n}\ndb.on(\"populate\", () => {\n    // Populate the stateSync table with default values\n    stateSync\n        .put({ id: 1, blockNum: \"0\" })\n        .catch((err) => logWebStoreError(err, \"Failed to populate DB\"));\n});\nconst accountCodes = db.table(Table.AccountCode);\nconst accountStorages = db.table(Table.AccountStorage);\nconst storageMapEntries = db.table(Table.StorageMapEntries);\nconst accountAssets = db.table(Table.AccountAssets);\nconst accountAuths = db.table(Table.AccountAuth);\nconst accounts = db.table(Table.Accounts);\nconst addresses = db.table(Table.Addresses);\nconst transactions = db.table(Table.Transactions);\nconst transactionScripts = db.table(Table.TransactionScripts);\nconst inputNotes = db.table(Table.InputNotes);\nconst outputNotes = db.table(Table.OutputNotes);\nconst notesScripts = db.table(Table.NotesScripts);\nconst stateSync = db.table(Table.StateSync);\nconst blockHeaders = db.table(Table.BlockHeaders);\nconst partialBlockchainNodes = db.table(Table.PartialBlockchainNodes);\nconst tags = db.table(Table.Tags);\nconst foreignAccountCode = db.table(Table.ForeignAccountCode);\nconst settings = db.table(Table.Settings);\nconst trackedAccounts = db.table(Table.TrackedAccounts);\n\n// GET FUNCTIONS\nasync function getAccountIds() {\n    try {\n        const tracked = await trackedAccounts.toArray();\n        return tracked.map((entry) => entry.id);\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error while fetching account IDs\");\n    }\n    return [];\n}\nasync function getAllAccountHeaders() {\n    try {\n        // Use a Map to track the latest record for each id based on nonce\n        const latestRecordsMap = new Map();\n        await accounts.each((record) => {\n            const existingRecord = latestRecordsMap.get(record.id);\n            if (!existingRecord ||\n                BigInt(record.nonce) > BigInt(existingRecord.nonce)) {\n                latestRecordsMap.set(record.id, record);\n            }\n        });\n        // Extract the latest records from the Map\n        const latestRecords = Array.from(latestRecordsMap.values());\n        const resultObject = await Promise.all(latestRecords.map((record) => {\n            let accountSeedBase64 = undefined;\n            if (record.accountSeed) {\n                const seedAsBytes = new Uint8Array(record.accountSeed);\n                if (seedAsBytes.length > 0) {\n                    accountSeedBase64 = uint8ArrayToBase64(seedAsBytes);\n                }\n            }\n            return {\n                id: record.id,\n                nonce: record.nonce,\n                vaultRoot: record.vaultRoot, // Fallback if missing\n                storageRoot: record.storageRoot || \"\",\n                codeRoot: record.codeRoot || \"\",\n                accountSeed: accountSeedBase64, // null or base64 string\n                locked: record.locked,\n                committed: record.committed, // Use actual value or default\n                accountCommitment: record.accountCommitment || \"\", // Keep original field name\n            };\n        }));\n        return resultObject;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error while fetching account headers\");\n    }\n}\nasync function getAccountHeader(accountId) {\n    try {\n        // Fetch all records matching the given id\n        const allMatchingRecords = await accounts\n            .where(\"id\")\n            .equals(accountId)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No account header record found for given ID.\");\n            return null;\n        }\n        // Convert nonce to BigInt and sort\n        // Note: This assumes all nonces are valid BigInt strings.\n        const sortedRecords = allMatchingRecords.sort((a, b) => {\n            const bigIntA = BigInt(a.nonce);\n            const bigIntB = BigInt(b.nonce);\n            return bigIntA > bigIntB ? -1 : bigIntA < bigIntB ? 1 : 0;\n        });\n        // The first record is the most recent one due to the sorting\n        const mostRecentRecord = sortedRecords[0];\n        if (mostRecentRecord === undefined) {\n            return null;\n        }\n        let accountSeedBase64 = undefined;\n        if (mostRecentRecord.accountSeed) {\n            // Ensure accountSeed is processed as a Uint8Array and converted to Base64\n            if (mostRecentRecord.accountSeed.length > 0) {\n                accountSeedBase64 = uint8ArrayToBase64(mostRecentRecord.accountSeed);\n            }\n        }\n        const AccountHeader = {\n            id: mostRecentRecord.id,\n            nonce: mostRecentRecord.nonce,\n            vaultRoot: mostRecentRecord.vaultRoot,\n            storageRoot: mostRecentRecord.storageRoot,\n            codeRoot: mostRecentRecord.codeRoot,\n            accountSeed: accountSeedBase64,\n            locked: mostRecentRecord.locked,\n        };\n        return AccountHeader;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching account header for id: ${accountId}`);\n    }\n}\nasync function getAccountHeaderByCommitment(accountCommitment) {\n    try {\n        // Fetch all records matching the given commitment\n        const allMatchingRecords = await accounts\n            .where(\"accountCommitment\")\n            .equals(accountCommitment)\n            .toArray();\n        if (allMatchingRecords.length == 0) {\n            return undefined;\n        }\n        // There should be only one match\n        const matchingRecord = allMatchingRecords[0];\n        if (matchingRecord === undefined) {\n            console.log(\"No account header record found for given commitment.\");\n            return null;\n        }\n        let accountSeedBase64 = undefined;\n        if (matchingRecord.accountSeed) {\n            accountSeedBase64 = uint8ArrayToBase64(matchingRecord.accountSeed);\n        }\n        const AccountHeader = {\n            id: matchingRecord.id,\n            nonce: matchingRecord.nonce,\n            vaultRoot: matchingRecord.vaultRoot,\n            storageRoot: matchingRecord.storageRoot,\n            codeRoot: matchingRecord.codeRoot,\n            accountSeed: accountSeedBase64,\n            locked: matchingRecord.locked,\n        };\n        return AccountHeader;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account header for commitment ${accountCommitment}`);\n    }\n}\nasync function getAccountCode(codeRoot) {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await accountCodes\n            .where(\"root\")\n            .equals(codeRoot)\n            .toArray();\n        // The first record is the only one due to the uniqueness constraint\n        const codeRecord = allMatchingRecords[0];\n        if (codeRecord === undefined) {\n            console.log(\"No records found for given code root.\");\n            return null;\n        }\n        // Convert the code Blob to an ArrayBuffer\n        const codeBase64 = uint8ArrayToBase64(codeRecord.code);\n        return {\n            root: codeRecord.root,\n            code: codeBase64,\n        };\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account code for root ${codeRoot}`);\n    }\n}\nasync function getAccountStorage(storageCommitment) {\n    try {\n        const allMatchingRecords = await accountStorages\n            .where(\"commitment\")\n            .equals(storageCommitment)\n            .toArray();\n        const slots = allMatchingRecords.map((record) => {\n            return {\n                slotIndex: record.slotIndex,\n                slotValue: record.slotValue,\n                slotType: record.slotType,\n            };\n        });\n        return slots;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account storage for commitment ${storageCommitment}`);\n    }\n}\nasync function getAccountStorageMaps(roots) {\n    try {\n        const allMatchingRecords = await storageMapEntries\n            .where(\"root\")\n            .anyOf(roots)\n            .toArray();\n        return allMatchingRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account storage maps for roots ${roots.join(\", \")}`);\n    }\n}\nasync function getAccountVaultAssets(vaultRoot) {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await accountAssets\n            .where(\"root\")\n            .equals(vaultRoot)\n            .toArray();\n        // Map the records to their asset values\n        const assets = allMatchingRecords.map((record) => {\n            return {\n                asset: record.asset,\n            };\n        });\n        return assets;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error fetching account vault for root ${vaultRoot}`);\n    }\n}\nasync function getAccountAuthByPubKey(pubKey) {\n    // Try to get the account auth from the store\n    const accountSecretKey = await accountAuths\n        .where(\"pubKey\")\n        .equals(pubKey)\n        .first();\n    // If it's not in the cache, throw an error\n    if (!accountSecretKey) {\n        throw new Error(\"Account auth not found in cache.\");\n    }\n    const data = {\n        secretKey: accountSecretKey.secretKey,\n    };\n    return data;\n}\nasync function getAccountAddresses(accountId) {\n    try {\n        // Fetch all records matching the given accountId\n        const allMatchingRecords = await addresses\n            .where(\"id\")\n            .equals(accountId)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No address records found for given account ID.\");\n            return [];\n        }\n        return allMatchingRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching account addresses for id: ${accountId}`);\n    }\n}\n// INSERT FUNCTIONS\nasync function upsertAccountCode(codeRoot, code) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            root: codeRoot, // Using codeRoot as the key\n            code,\n        };\n        // Perform the insert using Dexie\n        await accountCodes.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting code with root: ${codeRoot}`);\n    }\n}\nasync function upsertAccountStorage(storageSlots) {\n    try {\n        let processedSlots = storageSlots.map((slot) => {\n            return {\n                commitment: slot.commitment,\n                slotIndex: slot.slotIndex,\n                slotValue: slot.slotValue,\n                slotType: slot.slotType,\n            };\n        });\n        await accountStorages.bulkPut(processedSlots);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting storage slots`);\n    }\n}\nasync function upsertStorageMapEntries(entries) {\n    try {\n        let processedEntries = entries.map((entry) => {\n            return {\n                root: entry.root,\n                key: entry.key,\n                value: entry.value,\n            };\n        });\n        await storageMapEntries.bulkPut(processedEntries);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting storage map entries`);\n    }\n}\nasync function upsertVaultAssets(assets) {\n    try {\n        let processedAssets = assets.map((asset) => {\n            return {\n                root: asset.root,\n                vaultKey: asset.vaultKey,\n                faucetIdPrefix: asset.faucetIdPrefix,\n                asset: asset.asset,\n            };\n        });\n        await accountAssets.bulkPut(processedAssets);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting assets`);\n    }\n}\nasync function upsertAccountRecord(accountId, codeRoot, storageRoot, vaultRoot, nonce, committed, commitment, accountSeed) {\n    try {\n        const data = {\n            id: accountId,\n            codeRoot,\n            storageRoot,\n            vaultRoot,\n            nonce,\n            committed,\n            accountSeed,\n            accountCommitment: commitment,\n            locked: false,\n        };\n        await accounts.put(data);\n        await trackedAccounts.put({ id: accountId });\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting account: ${accountId}`);\n    }\n}\nasync function insertAccountAuth(pubKey, secretKey) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            pubKey: pubKey,\n            secretKey: secretKey,\n        };\n        // Perform the insert using Dexie\n        await accountAuths.add(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting account auth for pubKey: ${pubKey}`);\n    }\n}\nasync function insertAccountAddress(address, accountId) {\n    try {\n        // Prepare the data object to insert\n        const data = {\n            address,\n            id: accountId,\n        };\n        // Perform the insert using Dexie\n        await addresses.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting address with value: ${String(address)} for the account ID ${accountId}`);\n    }\n}\nasync function removeAccountAddress(address) {\n    try {\n        // Perform the delete using Dexie\n        await addresses.where(\"address\").equals(address).delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error removing address with value: ${String(address)}`);\n    }\n}\nasync function upsertForeignAccountCode(accountId, code, codeRoot) {\n    try {\n        await upsertAccountCode(codeRoot, code);\n        const data = {\n            accountId,\n            codeRoot,\n        };\n        await foreignAccountCode.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error upserting foreign account code for account: ${accountId}`);\n    }\n}\nasync function getForeignAccountCode(accountIds) {\n    try {\n        const foreignAccounts = await foreignAccountCode\n            .where(\"accountId\")\n            .anyOf(accountIds)\n            .toArray();\n        if (foreignAccounts.length === 0) {\n            console.log(\"No records found for the given account IDs.\");\n            return null; // No records found\n        }\n        const codeRoots = foreignAccounts.map((account) => account.codeRoot);\n        const accountCode = await accountCodes\n            .where(\"root\")\n            .anyOf(codeRoots)\n            .toArray();\n        const processedCode = foreignAccounts\n            .map((foreignAccount) => {\n            const matchingCode = accountCode.find((code) => code.root === foreignAccount.codeRoot);\n            if (matchingCode === undefined) {\n                return undefined;\n            }\n            const codeBase64 = uint8ArrayToBase64(matchingCode.code);\n            return {\n                accountId: foreignAccount.accountId,\n                code: codeBase64,\n            };\n        })\n            .filter((matchingCode) => matchingCode !== undefined);\n        return processedCode;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetching foreign account code\");\n    }\n}\nasync function lockAccount(accountId) {\n    try {\n        await accounts.where(\"id\").equals(accountId).modify({ locked: true });\n    }\n    catch (error) {\n        logWebStoreError(error, `Error locking account: ${accountId}`);\n    }\n}\n// Delete functions\nasync function undoAccountStates(accountCommitments) {\n    try {\n        await accounts\n            .where(\"accountCommitment\")\n            .anyOf(accountCommitments)\n            .delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error undoing account states: ${accountCommitments.join(\",\")}`);\n    }\n}\n\n// INSERT FUNCTIONS\nasync function insertBlockHeader(blockNum, header, partialBlockchainPeaks, hasClientNotes) {\n    try {\n        const data = {\n            blockNum: blockNum,\n            header,\n            partialBlockchainPeaks,\n            hasClientNotes: hasClientNotes.toString(),\n        };\n        const existingBlockHeader = await blockHeaders.get(blockNum);\n        if (!existingBlockHeader) {\n            await blockHeaders.add(data);\n        }\n        else {\n            console.log(\"Block header already exists, checking for update.\");\n            // Update the hasClientNotes if the existing value is false\n            if (existingBlockHeader.hasClientNotes === \"false\" && hasClientNotes) {\n                await blockHeaders.update(blockNum, {\n                    hasClientNotes: hasClientNotes.toString(),\n                });\n                console.log(\"Updated hasClientNotes to true.\");\n            }\n            else {\n                console.log(\"No update needed for hasClientNotes.\");\n            }\n        }\n    }\n    catch (err) {\n        logWebStoreError(err);\n    }\n}\nasync function insertPartialBlockchainNodes(ids, nodes) {\n    try {\n        // Check if the arrays are not of the same length\n        if (ids.length !== nodes.length) {\n            throw new Error(\"ids and nodes arrays must be of the same length\");\n        }\n        if (ids.length === 0) {\n            return;\n        }\n        // Create array of objects with id and node\n        const data = nodes.map((node, index) => ({\n            id: ids[index],\n            node: node,\n        }));\n        // Use bulkPut to add/overwrite the entries\n        await partialBlockchainNodes.bulkPut(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert partial blockchain nodes\");\n    }\n}\n// GET FUNCTIONS\nasync function getBlockHeaders(blockNumbers) {\n    try {\n        const results = await blockHeaders.bulkGet(blockNumbers);\n        const processedResults = await Promise.all(results.map((result) => {\n            if (result === undefined) {\n                return null;\n            }\n            else {\n                const headerBase64 = uint8ArrayToBase64(result.header);\n                const partialBlockchainPeaksBase64 = uint8ArrayToBase64(result.partialBlockchainPeaks);\n                return {\n                    blockNum: result.blockNum,\n                    header: headerBase64,\n                    partialBlockchainPeaks: partialBlockchainPeaksBase64,\n                    hasClientNotes: result.hasClientNotes === \"true\",\n                };\n            }\n        }));\n        return processedResults;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get block headers\");\n    }\n}\nasync function getTrackedBlockHeaders() {\n    try {\n        // Fetch all records matching the given root\n        const allMatchingRecords = await blockHeaders\n            .where(\"hasClientNotes\")\n            .equals(\"true\")\n            .toArray();\n        // Process all records with async operations\n        const processedRecords = await Promise.all(allMatchingRecords.map((record) => {\n            const headerBase64 = uint8ArrayToBase64(record.header);\n            const partialBlockchainPeaksBase64 = uint8ArrayToBase64(record.partialBlockchainPeaks);\n            return {\n                blockNum: record.blockNum,\n                header: headerBase64,\n                partialBlockchainPeaks: partialBlockchainPeaksBase64,\n                hasClientNotes: record.hasClientNotes === \"true\",\n            };\n        }));\n        return processedRecords;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get tracked block headers\");\n    }\n}\nasync function getPartialBlockchainPeaksByBlockNum(blockNum) {\n    try {\n        const blockHeader = await blockHeaders.get(blockNum);\n        if (blockHeader == undefined) {\n            return {\n                peaks: undefined,\n            };\n        }\n        const partialBlockchainPeaksBase64 = uint8ArrayToBase64(blockHeader.partialBlockchainPeaks);\n        return {\n            peaks: partialBlockchainPeaksBase64,\n        };\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain peaks\");\n    }\n}\nasync function getPartialBlockchainNodesAll() {\n    try {\n        const partialBlockchainNodesAll = await partialBlockchainNodes.toArray();\n        return partialBlockchainNodesAll;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain nodes\");\n    }\n}\nasync function getPartialBlockchainNodes(ids) {\n    try {\n        const results = await partialBlockchainNodes.bulkGet(ids);\n        return results;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get partial blockchain nodes\");\n    }\n}\nasync function pruneIrrelevantBlocks() {\n    try {\n        const syncHeight = await stateSync.get(1);\n        if (syncHeight == undefined) {\n            throw Error(\"SyncHeight is undefined -- is the state sync table empty?\");\n        }\n        const allMatchingRecords = await blockHeaders\n            .where(\"hasClientNotes\")\n            .equals(\"false\")\n            .and((record) => record.blockNum !== \"0\" && record.blockNum !== syncHeight.blockNum)\n            .toArray();\n        await blockHeaders.bulkDelete(allMatchingRecords.map((r) => r.blockNum));\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to prune irrelevant blocks\");\n    }\n}\n\n// Disabling `any` checks since this file mostly deals with exporting DB types.\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n/* eslint-disable  @typescript-eslint/no-unsafe-return */\n/* eslint-disable  @typescript-eslint/no-unsafe-assignment */\nasync function recursivelyTransformForExport(obj) {\n    switch (obj.type) {\n        case \"Uint8Array\":\n            return Array.from(obj.value);\n        case \"Blob\":\n            return {\n                __type: \"Blob\",\n                data: uint8ArrayToBase64(new Uint8Array(await obj.value.arrayBuffer())),\n            };\n        case \"Array\":\n            return await Promise.all(obj.value.map((v) => recursivelyTransformForExport({ type: getInputType(v), value: v })));\n        case \"Record\":\n            return Object.fromEntries(await Promise.all(Object.entries(obj.value).map(async ([key, value]) => [\n                key,\n                await recursivelyTransformForExport({\n                    type: getInputType(value),\n                    value,\n                }),\n            ])));\n        case \"Primitive\":\n            return obj.value;\n    }\n}\nfunction getInputType(value) {\n    if (value instanceof Uint8Array)\n        return \"Uint8Array\";\n    if (value instanceof Blob)\n        return \"Blob\";\n    if (Array.isArray(value))\n        return \"Array\";\n    if (value && typeof value === \"object\")\n        return \"Record\";\n    return \"Primitive\";\n}\nasync function transformForExport(obj) {\n    return recursivelyTransformForExport({ type: getInputType(obj), value: obj });\n}\nasync function exportStore() {\n    const dbJson = {};\n    for (const table of db.tables) {\n        const records = await table.toArray();\n        dbJson[table.name] = await Promise.all(records.map(transformForExport));\n    }\n    return JSON.stringify(dbJson);\n}\n\n// Disabling `any` checks since this file mostly deals\n// with importing DB types and we're testing this which\n// should be enough + the TS compiler.\n/* eslint-disable */\nasync function recursivelyTransformForImport(obj) {\n    switch (obj.type) {\n        case \"Blob\":\n            return new Blob([base64ToUint8Array(obj.value.data)]);\n        case \"Array\":\n            return await Promise.all(obj.value.map((v) => recursivelyTransformForImport({ type: getImportType(v), value: v })));\n        case \"Object\":\n            return Object.fromEntries(await Promise.all(Object.entries(obj.value).map(async ([key, value]) => [\n                key,\n                await recursivelyTransformForImport({\n                    type: getImportType(value),\n                    value,\n                }),\n            ])));\n        case \"Primitive\":\n            return obj.value;\n    }\n}\nfunction getImportType(value) {\n    if (value && typeof value === \"object\" && value.__type === \"Blob\") {\n        return \"Blob\";\n    }\n    if (Array.isArray(value))\n        return \"Array\";\n    if (value && typeof value === \"object\")\n        return \"Object\";\n    return \"Primitive\";\n}\nasync function transformForImport(obj) {\n    return recursivelyTransformForImport({\n        type: getImportType(obj),\n        value: obj,\n    });\n}\nasync function forceImportStore(jsonStr) {\n    try {\n        if (!db.isOpen) {\n            await openDatabase();\n        }\n        let dbJson = JSON.parse(jsonStr);\n        if (typeof dbJson === \"string\") {\n            dbJson = JSON.parse(dbJson);\n        }\n        const jsonTableNames = Object.keys(dbJson);\n        const dbTableNames = db.tables.map((t) => t.name);\n        if (jsonTableNames.length === 0) {\n            throw new Error(\"No tables found in the provided JSON.\");\n        }\n        await db.transaction(\"rw\", dbTableNames, async () => {\n            await Promise.all(db.tables.map((t) => t.clear()));\n            for (const tableName of jsonTableNames) {\n                const table = db.table(tableName);\n                if (!dbTableNames.includes(tableName)) {\n                    console.warn(`Table \"${tableName}\" does not exist in the database schema. Skipping.`);\n                    continue;\n                }\n                const records = dbJson[tableName];\n                const transformedRecords = await Promise.all(records.map(transformForImport));\n                await table.bulkPut(transformedRecords);\n            }\n        });\n        console.log(\"Store imported successfully.\");\n    }\n    catch (err) {\n        logWebStoreError(err);\n    }\n}\nfunction base64ToUint8Array(base64) {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n\nasync function getOutputNotes(states) {\n    try {\n        let notes = states.length == 0\n            ? await outputNotes.toArray()\n            : await outputNotes.where(\"stateDiscriminant\").anyOf(states).toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes\");\n    }\n}\nasync function getInputNotes(states) {\n    try {\n        let notes;\n        if (states.length === 0) {\n            notes = await inputNotes.toArray();\n        }\n        else {\n            notes = await inputNotes\n                .where(\"stateDiscriminant\")\n                .anyOf(states)\n                .toArray();\n        }\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes\");\n    }\n}\nasync function getInputNotesFromIds(noteIds) {\n    try {\n        let notes = await inputNotes.where(\"noteId\").anyOf(noteIds).toArray();\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes from IDs\");\n    }\n}\nasync function getInputNotesFromNullifiers(nullifiers) {\n    try {\n        let notes = await inputNotes.where(\"nullifier\").anyOf(nullifiers).toArray();\n        return await processInputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get input notes from nullifiers\");\n    }\n}\nasync function getOutputNotesFromNullifiers(nullifiers) {\n    try {\n        let notes = await outputNotes\n            .where(\"nullifier\")\n            .anyOf(nullifiers)\n            .toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes from nullifiers\");\n    }\n}\nasync function getOutputNotesFromIds(noteIds) {\n    try {\n        let notes = await outputNotes.where(\"noteId\").anyOf(noteIds).toArray();\n        return await processOutputNotes(notes);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get output notes from IDs\");\n    }\n}\nasync function getUnspentInputNoteNullifiers() {\n    try {\n        const notes = await inputNotes\n            .where(\"stateDiscriminant\")\n            .anyOf([2, 4, 5])\n            .toArray();\n        return notes.map((note) => note.nullifier);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get unspent input note nullifiers\");\n    }\n}\nasync function getNoteScript(scriptRoot) {\n    try {\n        const noteScript = await notesScripts\n            .where(\"scriptRoot\")\n            .equals(scriptRoot)\n            .first();\n        return noteScript;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get note script from root\");\n    }\n}\nasync function upsertInputNote(noteId, assets, serialNumber, inputs, scriptRoot, serializedNoteScript, nullifier, serializedCreatedAt, stateDiscriminant, state) {\n    return db.transaction(\"rw\", inputNotes, notesScripts, async (tx) => {\n        try {\n            const data = {\n                noteId,\n                assets,\n                serialNumber,\n                inputs,\n                scriptRoot,\n                nullifier,\n                state,\n                stateDiscriminant,\n                serializedCreatedAt,\n            };\n            await tx.inputNotes.put(data);\n            const noteScriptData = {\n                scriptRoot,\n                serializedNoteScript,\n            };\n            await tx.notesScripts.put(noteScriptData);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note: ${noteId}`);\n        }\n    });\n}\nasync function upsertOutputNote(noteId, assets, recipientDigest, metadata, nullifier, expectedHeight, stateDiscriminant, state) {\n    return db.transaction(\"rw\", outputNotes, notesScripts, async (tx) => {\n        try {\n            const data = {\n                noteId,\n                assets,\n                recipientDigest,\n                metadata,\n                nullifier: nullifier ? nullifier : undefined,\n                expectedHeight,\n                stateDiscriminant,\n                state,\n            };\n            await tx.outputNotes.put(data);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note: ${noteId}`);\n        }\n    });\n}\nasync function processInputNotes(notes) {\n    return await Promise.all(notes.map(async (note) => {\n        const assetsBase64 = uint8ArrayToBase64(note.assets);\n        const serialNumberBase64 = uint8ArrayToBase64(note.serialNumber);\n        const inputsBase64 = uint8ArrayToBase64(note.inputs);\n        let serializedNoteScriptBase64 = undefined;\n        if (note.scriptRoot) {\n            let record = await notesScripts.get(note.scriptRoot);\n            if (record) {\n                serializedNoteScriptBase64 = uint8ArrayToBase64(record.serializedNoteScript);\n            }\n        }\n        const stateBase64 = uint8ArrayToBase64(note.state);\n        return {\n            assets: assetsBase64,\n            serialNumber: serialNumberBase64,\n            inputs: inputsBase64,\n            createdAt: note.serializedCreatedAt,\n            serializedNoteScript: serializedNoteScriptBase64,\n            state: stateBase64,\n        };\n    }));\n}\nasync function processOutputNotes(notes) {\n    return await Promise.all(notes.map((note) => {\n        const assetsBase64 = uint8ArrayToBase64(note.assets);\n        const metadataBase64 = uint8ArrayToBase64(note.metadata);\n        const stateBase64 = uint8ArrayToBase64(note.state);\n        return {\n            assets: assetsBase64,\n            recipientDigest: note.recipientDigest,\n            metadata: metadataBase64,\n            expectedHeight: note.expectedHeight,\n            state: stateBase64,\n        };\n    }));\n}\nasync function upsertNoteScript(scriptRoot, serializedNoteScript) {\n    return db.transaction(\"rw\", outputNotes, notesScripts, async (tx) => {\n        try {\n            const noteScriptData = {\n                scriptRoot,\n                serializedNoteScript,\n            };\n            await tx.notesScripts.put(noteScriptData);\n        }\n        catch (error) {\n            logWebStoreError(error, `Error inserting note script: ${scriptRoot}`);\n        }\n    });\n}\n\nasync function getSetting(key) {\n    try {\n        // Fetch all records matching the given key\n        const allMatchingRecords = await settings\n            .where(\"key\")\n            .equals(key)\n            .toArray();\n        if (allMatchingRecords.length === 0) {\n            console.log(\"No setting record found for given key.\");\n            return null;\n        }\n        // There should be only one match\n        const matchingRecord = allMatchingRecords[0];\n        // Convert the setting value to base64\n        const valueBase64 = uint8ArrayToBase64(matchingRecord.value);\n        return {\n            key: matchingRecord.key,\n            value: valueBase64,\n        };\n    }\n    catch (error) {\n        logWebStoreError(error, `Error while fetching setting key: ${key}`);\n    }\n}\nasync function insertSetting(key, value) {\n    try {\n        const setting = {\n            key,\n            value,\n        };\n        await settings.put(setting);\n    }\n    catch (error) {\n        logWebStoreError(error, `Error inserting setting with key: ${key} and value(base64): ${uint8ArrayToBase64(value)}`);\n    }\n}\nasync function removeSetting(key) {\n    try {\n        await settings.where(\"key\").equals(key).delete();\n    }\n    catch (error) {\n        logWebStoreError(error, `Error deleting setting with key: ${key}`);\n    }\n}\nasync function listSettingKeys() {\n    try {\n        const keys = await settings\n            .toArray()\n            .then((settings) => settings.map((setting) => setting.key));\n        return keys;\n    }\n    catch (error) {\n        logWebStoreError(error, `Error listing setting keys`);\n    }\n}\n\nconst IDS_FILTER_PREFIX = \"Ids:\";\nconst EXPIRED_BEFORE_FILTER_PREFIX = \"ExpiredPending:\";\nconst STATUS_COMMITTED_VARIANT = 1;\nconst STATUS_DISCARDED_VARIANT = 2;\nasync function getTransactions(filter) {\n    let transactionRecords = [];\n    try {\n        if (filter === \"Uncommitted\") {\n            transactionRecords = await transactions\n                .filter((tx) => tx.statusVariant !== STATUS_COMMITTED_VARIANT)\n                .toArray();\n        }\n        else if (filter.startsWith(IDS_FILTER_PREFIX)) {\n            const idsString = filter.substring(IDS_FILTER_PREFIX.length);\n            const ids = idsString.split(\",\");\n            if (ids.length > 0) {\n                transactionRecords = await transactions\n                    .where(\"id\")\n                    .anyOf(ids)\n                    .toArray();\n            }\n            else {\n                transactionRecords = [];\n            }\n        }\n        else if (filter.startsWith(EXPIRED_BEFORE_FILTER_PREFIX)) {\n            const blockNumString = filter.substring(EXPIRED_BEFORE_FILTER_PREFIX.length);\n            const blockNum = parseInt(blockNumString);\n            transactionRecords = await transactions\n                .filter((tx) => tx.blockNum < blockNum &&\n                tx.statusVariant !== STATUS_COMMITTED_VARIANT &&\n                tx.statusVariant !== STATUS_DISCARDED_VARIANT)\n                .toArray();\n        }\n        else {\n            transactionRecords = await transactions.toArray();\n        }\n        if (transactionRecords.length === 0) {\n            return [];\n        }\n        const scriptRoots = transactionRecords\n            .map((transactionRecord) => {\n            return transactionRecord.scriptRoot;\n        })\n            .filter((scriptRoot) => scriptRoot != undefined);\n        const scripts = await transactionScripts\n            .where(\"scriptRoot\")\n            .anyOf(scriptRoots)\n            .toArray();\n        // Create a map of scriptRoot to script for quick lookup\n        const scriptMap = new Map();\n        scripts.forEach((script) => {\n            if (script.txScript) {\n                scriptMap.set(script.scriptRoot, script.txScript);\n            }\n        });\n        const processedTransactions = await Promise.all(transactionRecords.map((transactionRecord) => {\n            let txScriptBase64 = undefined;\n            if (transactionRecord.scriptRoot) {\n                const txScript = scriptMap.get(transactionRecord.scriptRoot);\n                if (txScript) {\n                    txScriptBase64 = uint8ArrayToBase64(txScript);\n                }\n            }\n            const detailsBase64 = uint8ArrayToBase64(transactionRecord.details);\n            const statusBase64 = uint8ArrayToBase64(transactionRecord.status);\n            const data = {\n                id: transactionRecord.id,\n                details: detailsBase64,\n                scriptRoot: transactionRecord.scriptRoot,\n                txScript: txScriptBase64,\n                blockNum: transactionRecord.blockNum.toString(),\n                statusVariant: transactionRecord.statusVariant,\n                status: statusBase64,\n            };\n            return data;\n        }));\n        return processedTransactions;\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to get transactions\");\n    }\n}\nasync function insertTransactionScript(scriptRoot, txScript) {\n    try {\n        const scriptRootArray = new Uint8Array(scriptRoot);\n        const scriptRootBase64 = uint8ArrayToBase64(scriptRootArray);\n        const data = {\n            scriptRoot: scriptRootBase64,\n            txScript: mapOption(txScript, (txScript) => new Uint8Array(txScript)),\n        };\n        await transactionScripts.put(data);\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to insert transaction script\");\n    }\n}\nasync function upsertTransactionRecord(transactionId, details, blockNum, statusVariant, status, scriptRoot) {\n    try {\n        const data = {\n            id: transactionId,\n            details,\n            scriptRoot: mapOption(scriptRoot, (root) => uint8ArrayToBase64(root)),\n            blockNum: parseInt(blockNum, 10),\n            statusVariant,\n            status,\n        };\n        await transactions.put(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert proven transaction data\");\n    }\n}\n\nasync function getNoteTags() {\n    try {\n        let records = await tags.toArray();\n        let processedRecords = records.map((record) => {\n            record.sourceNoteId =\n                record.sourceNoteId == \"\" ? undefined : record.sourceNoteId;\n            record.sourceAccountId =\n                record.sourceAccountId == \"\" ? undefined : record.sourceAccountId;\n            return record;\n        });\n        return processedRecords;\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetch tag record\");\n    }\n}\nasync function getSyncHeight() {\n    try {\n        const record = await stateSync.get(1); // Since id is the primary key and always 1\n        if (record) {\n            let data = {\n                blockNum: record.blockNum,\n            };\n            return data;\n        }\n        else {\n            return null;\n        }\n    }\n    catch (error) {\n        logWebStoreError(error, \"Error fetching sync height\");\n    }\n}\nasync function addNoteTag(tag, sourceNoteId, sourceAccountId) {\n    try {\n        let tagArray = new Uint8Array(tag);\n        let tagBase64 = uint8ArrayToBase64(tagArray);\n        await tags.add({\n            tag: tagBase64,\n            sourceNoteId: sourceNoteId ? sourceNoteId : \"\",\n            sourceAccountId: sourceAccountId ? sourceAccountId : \"\",\n        });\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to add note tag\");\n    }\n}\nasync function removeNoteTag(tag, sourceNoteId, sourceAccountId) {\n    try {\n        let tagArray = new Uint8Array(tag);\n        let tagBase64 = uint8ArrayToBase64(tagArray);\n        return await tags\n            .where({\n            tag: tagBase64,\n            sourceNoteId: sourceNoteId ? sourceNoteId : \"\",\n            sourceAccountId: sourceAccountId ? sourceAccountId : \"\",\n        })\n            .delete();\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to remove note tag\");\n    }\n}\n/*\n * Takes a `JsStateSyncUpdate` object and writes the state update into the store.\n * @param {JsStateSyncUpdate}\n */\nasync function applyStateSync(stateUpdate) {\n    const { blockNum, // Target block number for this sync\n    flattenedNewBlockHeaders, // Serialized block headers to be reconstructed\n    flattenedPartialBlockChainPeaks, // Serialized blockchain peaks for verification\n    newBlockNums, // Block numbers corresponding to new headers\n    blockHasRelevantNotes, // Flags indicating which blocks have relevant notes\n    serializedNodeIds, // IDs for new authentication nodes\n    serializedNodes, // Authentication node data for merkle proofs\n    committedNoteIds, // Note tags to be cleaned up/removed\n    serializedInputNotes, // Input notes consumed in transactions\n    serializedOutputNotes, // Output notes created in transactions\n    accountUpdates, // Account state changes\n    transactionUpdates, // Transaction records and scripts\n     } = stateUpdate;\n    // Block headers and Blockchain peaks are flattened before calling\n    // this function, here we rebuild them.\n    const newBlockHeaders = reconstructFlattenedVec(flattenedNewBlockHeaders);\n    const partialBlockchainPeaks = reconstructFlattenedVec(flattenedPartialBlockChainPeaks);\n    // Create promises to insert each input note. Each note will have its own transaction,\n    // and therefore, nested inside the final transaction inside this function.\n    let inputNotesWriteOp = Promise.all(serializedInputNotes.map((note) => {\n        return upsertInputNote(note.noteId, note.noteAssets, note.serialNumber, note.inputs, note.noteScriptRoot, note.noteScript, note.nullifier, note.createdAt, note.stateDiscriminant, note.state);\n    }));\n    // See comment above, the same thing applies here, but for Output Notes.\n    let outputNotesWriteOp = Promise.all(serializedOutputNotes.map((note) => {\n        return upsertOutputNote(note.noteId, note.noteAssets, note.recipientDigest, note.metadata, note.nullifier, note.expectedHeight, note.stateDiscriminant, note.state);\n    }));\n    // Promises to insert each transaction update.\n    let transactionWriteOp = Promise.all(transactionUpdates.map((transactionRecord) => {\n        let promises = [\n            upsertTransactionRecord(transactionRecord.id, transactionRecord.details, transactionRecord.blockNum, transactionRecord.statusVariant, transactionRecord.status, transactionRecord.scriptRoot),\n        ];\n        if (transactionRecord.scriptRoot && transactionRecord.txScript) {\n            promises.push(insertTransactionScript(transactionRecord.scriptRoot, transactionRecord.txScript));\n        }\n        return Promise.all(promises);\n    }));\n    // Promises to insert each account update.\n    let accountUpdatesWriteOp = Promise.all(accountUpdates.flatMap((accountUpdate) => {\n        return [\n            upsertAccountStorage(accountUpdate.storageSlots),\n            upsertStorageMapEntries(accountUpdate.storageMapEntries),\n            upsertVaultAssets(accountUpdate.assets),\n            upsertAccountRecord(accountUpdate.accountId, accountUpdate.codeRoot, accountUpdate.storageRoot, accountUpdate.assetVaultRoot, accountUpdate.nonce, accountUpdate.committed, accountUpdate.accountCommitment, accountUpdate.accountSeed),\n        ];\n    }));\n    const tablesToAccess = [\n        stateSync,\n        inputNotes,\n        outputNotes,\n        transactions,\n        blockHeaders,\n        partialBlockchainNodes,\n        tags,\n    ];\n    // Write everything in a single transaction, this transaction will atomically do the operations\n    // below, since every operation here (or at least, most of them), is done in a nested transaction.\n    // For more information on this, check: https://dexie.org/docs/Dexie/Dexie.transaction()\n    return await db.transaction(\"rw\", tablesToAccess, async (tx) => {\n        // Everything is under a single promise since otherwise the tx expires.\n        await Promise.all([\n            inputNotesWriteOp,\n            outputNotesWriteOp,\n            transactionWriteOp,\n            accountUpdatesWriteOp,\n            updateSyncHeight(tx, blockNum),\n            updatePartialBlockchainNodes(tx, serializedNodeIds, serializedNodes),\n            updateCommittedNoteTags(tx, committedNoteIds),\n            Promise.all(newBlockHeaders.map((newBlockHeader, i) => {\n                return updateBlockHeader(tx, newBlockNums[i], newBlockHeader, partialBlockchainPeaks[i], blockHasRelevantNotes[i] == 1);\n            })),\n        ]);\n    });\n}\nasync function updateSyncHeight(tx, blockNum) {\n    try {\n        await tx.stateSync.update(1, { blockNum: blockNum });\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to update sync height\");\n    }\n}\nasync function updateBlockHeader(tx, blockNum, blockHeader, partialBlockchainPeaks, hasClientNotes) {\n    try {\n        const data = {\n            blockNum: blockNum,\n            header: blockHeader,\n            partialBlockchainPeaks,\n            hasClientNotes: hasClientNotes.toString(),\n        };\n        const existingBlockHeader = await tx.blockHeaders.get(blockNum);\n        if (!existingBlockHeader) {\n            await tx.blockHeaders.add(data);\n        }\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to insert block header\");\n    }\n}\nasync function updatePartialBlockchainNodes(tx, nodeIndexes, nodes) {\n    try {\n        // Check if the arrays are not of the same length\n        if (nodeIndexes.length !== nodes.length) {\n            throw new Error(\"nodeIndexes and nodes arrays must be of the same length\");\n        }\n        if (nodeIndexes.length === 0) {\n            return;\n        }\n        // Create array of objects with id and node\n        const data = nodes.map((node, index) => ({\n            id: nodeIndexes[index],\n            node: node,\n        }));\n        // Use bulkPut to add/overwrite the entries\n        await tx.partialBlockchainNodes.bulkPut(data);\n    }\n    catch (err) {\n        logWebStoreError(err, \"Failed to update partial blockchain nodes\");\n    }\n}\nasync function updateCommittedNoteTags(tx, inputNoteIds) {\n    try {\n        for (let i = 0; i < inputNoteIds.length; i++) {\n            const noteId = inputNoteIds[i];\n            // Remove note tags\n            await tx.tags.where(\"source_note_id\").equals(noteId).delete();\n        }\n    }\n    catch (error) {\n        logWebStoreError(error, \"Failed to pudate committed note tags\");\n    }\n}\n// Helper function to reconstruct arrays from flattened data\nfunction reconstructFlattenedVec(flattenedVec) {\n    const data = flattenedVec.data();\n    const lengths = flattenedVec.lengths();\n    let index = 0;\n    const result = [];\n    lengths.forEach((length) => {\n        result.push(data.slice(index, index + length));\n        index += length;\n    });\n    return result;\n}\n\nlet wasm;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export4(addHeapObject(e));\n    }\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getDataViewMemory0();\n    const result = [];\n    for (let i = ptr; i < ptr + 4 * len; i += 4) {\n        result.push(takeObject(mem.getUint32(i, true)));\n    }\n    return result;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => state.dtor(state.a, state.b));\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            state.a = a;\n            real._wbg_cb_unref();\n        }\n    };\n    real._wbg_cb_unref = () => {\n        if (--state.cnt === 0) {\n            state.dtor(state.a, state.b);\n            state.a = 0;\n            CLOSURE_DTORS.unregister(state);\n        }\n    };\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    const mem = getDataViewMemory0();\n    for (let i = 0; i < array.length; i++) {\n        mem.setUint32(ptr + 4 * i, addHeapObject(array[i]), true);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nlet cachedBigUint64ArrayMemory0 = null;\n\nfunction getBigUint64ArrayMemory0() {\n    if (cachedBigUint64ArrayMemory0 === null || cachedBigUint64ArrayMemory0.byteLength === 0) {\n        cachedBigUint64ArrayMemory0 = new BigUint64Array(wasm.memory.buffer);\n    }\n    return cachedBigUint64ArrayMemory0;\n}\n\nfunction passArray64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8, 8) >>> 0;\n    getBigUint64ArrayMemory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU64FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getBigUint64ArrayMemory0().subarray(ptr / 8, ptr / 8 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\nfunction __wasm_bindgen_func_elem_9375(arg0, arg1, arg2) {\n    wasm.__wasm_bindgen_func_elem_9375(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wasm_bindgen_func_elem_9309(arg0, arg1) {\n    wasm.__wasm_bindgen_func_elem_9309(arg0, arg1);\n}\n\nfunction __wasm_bindgen_func_elem_3677(arg0, arg1, arg2, arg3) {\n    wasm.__wasm_bindgen_func_elem_3677(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n * @enum {0}\n */\nconst AccountInterface = Object.freeze({\n    BasicWallet: 0, \"0\": \"BasicWallet\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nconst AccountType = Object.freeze({\n    FungibleFaucet: 0, \"0\": \"FungibleFaucet\",\n    NonFungibleFaucet: 1, \"1\": \"NonFungibleFaucet\",\n    RegularAccountImmutableCode: 2, \"2\": \"RegularAccountImmutableCode\",\n    RegularAccountUpdatableCode: 3, \"3\": \"RegularAccountUpdatableCode\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8}\n */\nconst InputNoteState = Object.freeze({\n    Expected: 0, \"0\": \"Expected\",\n    Unverified: 1, \"1\": \"Unverified\",\n    Committed: 2, \"2\": \"Committed\",\n    Invalid: 3, \"3\": \"Invalid\",\n    ProcessingAuthenticated: 4, \"4\": \"ProcessingAuthenticated\",\n    ProcessingUnauthenticated: 5, \"5\": \"ProcessingUnauthenticated\",\n    ConsumedAuthenticatedLocal: 6, \"6\": \"ConsumedAuthenticatedLocal\",\n    ConsumedUnauthenticatedLocal: 7, \"7\": \"ConsumedUnauthenticatedLocal\",\n    ConsumedExternal: 8, \"8\": \"ConsumedExternal\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst NetworkId = Object.freeze({\n    Mainnet: 0, \"0\": \"Mainnet\",\n    Testnet: 1, \"1\": \"Testnet\",\n    Devnet: 2, \"2\": \"Devnet\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8}\n */\nconst NoteFilterTypes = Object.freeze({\n    All: 0, \"0\": \"All\",\n    Consumed: 1, \"1\": \"Consumed\",\n    Committed: 2, \"2\": \"Committed\",\n    Expected: 3, \"3\": \"Expected\",\n    Processing: 4, \"4\": \"Processing\",\n    List: 5, \"5\": \"List\",\n    Unique: 6, \"6\": \"Unique\",\n    Nullifiers: 7, \"7\": \"Nullifiers\",\n    Unverified: 8, \"8\": \"Unverified\",\n});\n/**\n * @enum {2 | 3 | 1}\n */\nconst NoteType = Object.freeze({\n    /**\n     * Notes with this type have only their hash published to the network.\n     */\n    Private: 2, \"2\": \"Private\",\n    /**\n     * Notes with this type are shared with the network encrypted.\n     */\n    Encrypted: 3, \"3\": \"Encrypted\",\n    /**\n     * Notes with this type are fully shared with the network.\n     */\n    Public: 1, \"1\": \"Public\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst SigningInputsType = Object.freeze({\n    TransactionSummary: 0, \"0\": \"TransactionSummary\",\n    Arbitrary: 1, \"1\": \"Arbitrary\",\n    Blind: 2, \"2\": \"Blind\",\n});\n\nconst __wbindgen_enum_AddressInterface = [\"BasicWallet\"];\n\nconst __wbindgen_enum_ReadableStreamType = [\"bytes\"];\n\nconst __wbindgen_enum_ReferrerPolicy = [\"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"origin\", \"origin-when-cross-origin\", \"unsafe-url\", \"same-origin\", \"strict-origin\", \"strict-origin-when-cross-origin\"];\n\nconst __wbindgen_enum_RequestCache = [\"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\"];\n\nconst __wbindgen_enum_RequestCredentials = [\"omit\", \"same-origin\", \"include\"];\n\nconst __wbindgen_enum_RequestMode = [\"same-origin\", \"no-cors\", \"cors\", \"navigate\"];\n\nconst __wbindgen_enum_RequestRedirect = [\"follow\", \"error\", \"manual\"];\n\nconst AccountFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_account_free(ptr >>> 0, 1));\n\nclass Account {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Account.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Account)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_account_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.account_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.account_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonce() {\n        const ret = wasm.account_nonce(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {AssetVault}\n     */\n    vault() {\n        const ret = wasm.account_vault(this.__wbg_ptr);\n        return AssetVault.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorage}\n     */\n    storage() {\n        const ret = wasm.account_storage(this.__wbg_ptr);\n        return AccountStorage.__wrap(ret);\n    }\n    /**\n     * @returns {AccountCode}\n     */\n    code() {\n        const ret = wasm.account_code(this.__wbg_ptr);\n        return AccountCode.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFaucet() {\n        const ret = wasm.account_isFaucet(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isRegularAccount() {\n        const ret = wasm.account_isRegularAccount(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isUpdatable() {\n        const ret = wasm.account_isUpdatable(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPublic() {\n        const ret = wasm.account_isPublic(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPrivate() {\n        const ret = wasm.account_isPrivate(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNetwork() {\n        const ret = wasm.account_isNetwork(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNew() {\n        const ret = wasm.account_isNew(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.account_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Account}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.account_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Account.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {Word[]}\n     */\n    getPublicKeys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.account_getPublicKeys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Account.prototype[Symbol.dispose] = Account.prototype.free;\n\nconst AccountArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountarray_free(ptr >>> 0, 1));\n\nclass AccountArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountarray_free(ptr, 0);\n    }\n    /**\n     * @param {Account[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        AccountArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {Account}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Account.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {Account} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Account);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.accountarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Account} element\n     */\n    push(element) {\n        _assertClass(element, Account);\n        wasm.accountarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.accountarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) AccountArray.prototype[Symbol.dispose] = AccountArray.prototype.free;\n\nconst AccountBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountbuilder_free(ptr >>> 0, 1));\n\nclass AccountBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountbuilder_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array} init_seed\n     */\n    constructor(init_seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountbuilder_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            AccountBuilderFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountType} account_type\n     * @returns {AccountBuilder}\n     */\n    accountType(account_type) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountbuilder_accountType(ptr, account_type);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @returns {AccountBuilder}\n     */\n    storageMode(storage_mode) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(storage_mode, AccountStorageMode);\n        const ret = wasm.accountbuilder_storageMode(ptr, storage_mode.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountComponent} account_component\n     * @returns {AccountBuilder}\n     */\n    withComponent(account_component) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(account_component, AccountComponent);\n        const ret = wasm.accountbuilder_withComponent(ptr, account_component.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AccountComponent} account_component\n     * @returns {AccountBuilder}\n     */\n    withAuthComponent(account_component) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(account_component, AccountComponent);\n        const ret = wasm.accountbuilder_withAuthComponent(ptr, account_component.__wbg_ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {AccountBuilder}\n     */\n    withNoAuthComponent() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountbuilder_withNoAuthComponent(ptr);\n        return AccountBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {AccountBuilderResult}\n     */\n    build() {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountbuilder_build(retptr, ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountBuilderResult.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountBuilder.prototype[Symbol.dispose] = AccountBuilder.prototype.free;\n\nconst AccountBuilderResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountbuilderresult_free(ptr >>> 0, 1));\n\nclass AccountBuilderResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountBuilderResult.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountBuilderResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountBuilderResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountbuilderresult_free(ptr, 0);\n    }\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        const ret = wasm.accountbuilderresult_account(this.__wbg_ptr);\n        return Account.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    get seed() {\n        const ret = wasm.accountbuilderresult_seed(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountBuilderResult.prototype[Symbol.dispose] = AccountBuilderResult.prototype.free;\n\nconst AccountCodeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountcode_free(ptr >>> 0, 1));\n\nclass AccountCode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountCode.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountCodeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountCodeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountcode_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {Word} mast_root\n     * @returns {boolean}\n     */\n    hasProcedure(mast_root) {\n        _assertClass(mast_root, Word);\n        var ptr0 = mast_root.__destroy_into_raw();\n        const ret = wasm.accountcode_hasProcedure(this.__wbg_ptr, ptr0);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) AccountCode.prototype[Symbol.dispose] = AccountCode.prototype.free;\n\nconst AccountComponentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountcomponent_free(ptr >>> 0, 1));\n\nclass AccountComponent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountComponent.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountComponentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountComponentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountcomponent_free(ptr, 0);\n    }\n    /**\n     * @param {string} account_code\n     * @param {ScriptBuilder} builder\n     * @param {StorageSlot[]} storage_slots\n     * @returns {AccountComponent}\n     */\n    static compile(account_code, builder, storage_slots) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(account_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            _assertClass(builder, ScriptBuilder);\n            const ptr1 = passArrayJsValueToWasm0(storage_slots, wasm.__wbindgen_export);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.accountcomponent_compile(retptr, ptr0, len0, builder.__wbg_ptr, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountComponent}\n     */\n    withSupportsAllTypes() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.accountcomponent_withSupportsAllTypes(ptr);\n        return AccountComponent.__wrap(ret);\n    }\n    /**\n     * @param {string} procedure_name\n     * @returns {string}\n     */\n    getProcedureHash(procedure_name) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(procedure_name, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountcomponent_getProcedureHash(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @returns {GetProceduresResultItem[]}\n     */\n    getProcedures() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountcomponent_getProcedures(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {SecretKey} secret_key\n     * @returns {AccountComponent}\n     */\n    static createAuthComponent(secret_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(secret_key, SecretKey);\n            wasm.accountcomponent_createAuthComponent(retptr, secret_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Package} _package\n     * @param {StorageSlotArray} storage_slots\n     * @returns {AccountComponent}\n     */\n    static fromPackage(_package, storage_slots) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_package, Package);\n            _assertClass(storage_slots, StorageSlotArray);\n            wasm.accountcomponent_fromPackage(retptr, _package.__wbg_ptr, storage_slots.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountComponent.prototype[Symbol.dispose] = AccountComponent.prototype.free;\n\nconst AccountDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountdelta_free(ptr >>> 0, 1));\n\nclass AccountDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountdelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {AccountStorageDelta}\n     */\n    storage() {\n        const ret = wasm.accountdelta_storage(this.__wbg_ptr);\n        return AccountStorageDelta.__wrap(ret);\n    }\n    /**\n     * @returns {AccountVaultDelta}\n     */\n    vault() {\n        const ret = wasm.accountdelta_vault(this.__wbg_ptr);\n        return AccountVaultDelta.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonceDelta() {\n        const ret = wasm.accountdelta_nonceDelta(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountDelta.prototype[Symbol.dispose] = AccountDelta.prototype.free;\n\nconst AccountFileFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountfile_free(ptr >>> 0, 1));\n\nclass AccountFile {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountFile.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountFileFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountFileFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountfile_free(ptr, 0);\n    }\n    /**\n     * Serializes the `AccountFile` into a byte array\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountfile_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a byte array into an `AccountFile`\n     * @param {Uint8Array} bytes\n     * @returns {AccountFile}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountfile_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountFile.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) AccountFile.prototype[Symbol.dispose] = AccountFile.prototype.free;\n\nconst AccountHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountheader_free(ptr >>> 0, 1));\n\nclass AccountHeader {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountHeader.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountHeaderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountheader_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    id() {\n        const ret = wasm.accountheader_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    nonce() {\n        const ret = wasm.accountheader_nonce(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    vaultCommitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    storageCommitment() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    codeCommitment() {\n        const ret = wasm.accountheader_codeCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountHeader.prototype[Symbol.dispose] = AccountHeader.prototype.free;\n\nconst AccountIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountid_free(ptr >>> 0, 1));\n\nclass AccountId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountId.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof AccountId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountid_free(ptr, 0);\n    }\n    /**\n     * @param {string} hex\n     * @returns {AccountId}\n     */\n    static fromHex(hex) {\n        const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountid_fromHex(ptr0, len0);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFaucet() {\n        const ret = wasm.accountid_isFaucet(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isRegularAccount() {\n        const ret = wasm.accountid_isRegularAccount(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPublic() {\n        const ret = wasm.accountid_isPublic(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPrivate() {\n        const ret = wasm.accountid_isPrivate(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isNetwork() {\n        const ret = wasm.accountid_isNetwork(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountid_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Will turn the Account ID into its bech32 string representation. To avoid a potential\n     * wrongful encoding, this function will expect only IDs for either mainnet (\"mm\"),\n     * testnet (\"mtst\") or devnet (\"mdev\"). To use a custom bech32 prefix, see\n     * `Self::to_bech_32_custom`.\n     * @param {NetworkId} network_id\n     * @param {AccountInterface} account_interface\n     * @returns {string}\n     */\n    toBech32(network_id, account_interface) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountid_toBech32(retptr, this.__wbg_ptr, network_id, account_interface);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * Turn this Account ID into its bech32 string representation. This method accepts a custom\n     * network ID.\n     * @param {string} custom_network_id\n     * @param {AccountInterface} account_interface\n     * @returns {string}\n     */\n    toBech32Custom(custom_network_id, account_interface) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(custom_network_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountid_toBech32Custom(retptr, this.__wbg_ptr, ptr0, len0, account_interface);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @returns {Felt}\n     */\n    prefix() {\n        const ret = wasm.accountid_prefix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n    /**\n     * @returns {Felt}\n     */\n    suffix() {\n        const ret = wasm.accountid_suffix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) AccountId.prototype[Symbol.dispose] = AccountId.prototype.free;\n\nconst AccountIdArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountidarray_free(ptr >>> 0, 1));\n\nclass AccountIdArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountIdArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountidarray_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.accountidarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        AccountIdArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {AccountId}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountidarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {AccountId} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, AccountId);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.accountidarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} element\n     */\n    push(element) {\n        _assertClass(element, AccountId);\n        wasm.accountidarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.accountidarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) AccountIdArray.prototype[Symbol.dispose] = AccountIdArray.prototype.free;\n\nconst AccountStorageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstorage_free(ptr >>> 0, 1));\n\nclass AccountStorage {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorage.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstorage_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountstorage_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @returns {Word | undefined}\n     */\n    getItem(index) {\n        const ret = wasm.accountstorage_getItem(this.__wbg_ptr, index);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @param {number} index\n     * @param {Word} key\n     * @returns {Word | undefined}\n     */\n    getMapItem(index, key) {\n        _assertClass(key, Word);\n        const ret = wasm.accountstorage_getMapItem(this.__wbg_ptr, index, key.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * Get all key-value pairs from the map slot at `index`.\n     * Returns `undefined` if the slot isn't a map or `index` is out of bounds (0-255).\n     * Returns `[]` if the map exists but is empty.\n     * @param {number} index\n     * @returns {JsStorageMapEntry[] | undefined}\n     */\n    getMapEntries(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstorage_getMapEntries(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorage.prototype[Symbol.dispose] = AccountStorage.prototype.free;\n\nconst AccountStorageDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragedelta_free(ptr >>> 0, 1));\n\nclass AccountStorageDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragedelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountstoragedelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountStorageDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragedelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountstoragedelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    values() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragedelta_values(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageDelta.prototype[Symbol.dispose] = AccountStorageDelta.prototype.free;\n\nconst AccountStorageModeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragemode_free(ptr >>> 0, 1));\n\nclass AccountStorageMode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageMode.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageModeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageModeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragemode_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static private() {\n        const ret = wasm.accountstoragemode_private();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static public() {\n        const ret = wasm.accountstoragemode_public();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @returns {AccountStorageMode}\n     */\n    static network() {\n        const ret = wasm.accountstoragemode_network();\n        return AccountStorageMode.__wrap(ret);\n    }\n    /**\n     * @param {string} s\n     * @returns {AccountStorageMode}\n     */\n    static tryFromStr(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountstoragemode_tryFromStr(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageMode.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    asStr() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountstoragemode_asStr(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageMode.prototype[Symbol.dispose] = AccountStorageMode.prototype.free;\n\nconst AccountStorageRequirementsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountstoragerequirements_free(ptr >>> 0, 1));\n\nclass AccountStorageRequirements {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountStorageRequirements.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountStorageRequirementsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountStorageRequirementsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountstoragerequirements_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.accountstoragerequirements_new();\n        this.__wbg_ptr = ret >>> 0;\n        AccountStorageRequirementsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {SlotAndKeys[]} slots_and_keys\n     * @returns {AccountStorageRequirements}\n     */\n    static fromSlotAndKeysArray(slots_and_keys) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(slots_and_keys, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.accountstoragerequirements_fromSlotAndKeysArray(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountStorageRequirements.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountStorageRequirements.prototype[Symbol.dispose] = AccountStorageRequirements.prototype.free;\n\nconst AccountVaultDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_accountvaultdelta_free(ptr >>> 0, 1));\n\nclass AccountVaultDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AccountVaultDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        AccountVaultDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AccountVaultDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_accountvaultdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.accountvaultdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountVaultDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountVaultDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.accountstoragedelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {FungibleAssetDelta}\n     */\n    fungible() {\n        const ret = wasm.accountvaultdelta_fungible(this.__wbg_ptr);\n        return FungibleAssetDelta.__wrap(ret);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    addedFungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_addedFungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    removedFungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.accountvaultdelta_removedFungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AccountVaultDelta.prototype[Symbol.dispose] = AccountVaultDelta.prototype.free;\n\nconst AddressFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr >>> 0, 1));\n\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n        AddressFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AddressFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {string | null} [_interface]\n     * @returns {Address}\n     */\n    static fromAccountId(account_id, _interface) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account_id, AccountId);\n            var ptr0 = isLikeNone(_interface) ? 0 : passStringToWasm0(_interface, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_fromAccountId(retptr, account_id.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} bech32\n     * @returns {Address}\n     */\n    static fromBech32(bech32) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.address_fromBech32(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AddressInterface}\n     */\n    interface() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_interface(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return __wbindgen_enum_AddressInterface[r0];\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_accountId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    toNoteTag() {\n        const ret = wasm.address_toNoteTag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {NetworkId} network_id\n     * @returns {string}\n     */\n    toBech32(network_id) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_toBech32(retptr, this.__wbg_ptr, network_id);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Address.prototype[Symbol.dispose] = Address.prototype.free;\n\nconst AdviceInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_adviceinputs_free(ptr >>> 0, 1));\n\nclass AdviceInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AdviceInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        AdviceInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AdviceInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_adviceinputs_free(ptr, 0);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    stack() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.adviceinputs_stack(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Word} key\n     * @returns {Felt[] | undefined}\n     */\n    mappedValues(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, Word);\n            wasm.adviceinputs_mappedValues(retptr, this.__wbg_ptr, key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AdviceInputs.prototype[Symbol.dispose] = AdviceInputs.prototype.free;\n\nconst AdviceMapFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_advicemap_free(ptr >>> 0, 1));\n\nclass AdviceMap {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AdviceMapFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_advicemap_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.accountstoragerequirements_new();\n        this.__wbg_ptr = ret >>> 0;\n        AdviceMapFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {Word} key\n     * @param {FeltArray} value\n     * @returns {Felt[] | undefined}\n     */\n    insert(key, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(key, Word);\n            _assertClass(value, FeltArray);\n            wasm.advicemap_insert(retptr, this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AdviceMap.prototype[Symbol.dispose] = AdviceMap.prototype.free;\n\nconst AssetVaultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_assetvault_free(ptr >>> 0, 1));\n\nclass AssetVault {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AssetVault.prototype);\n        obj.__wbg_ptr = ptr;\n        AssetVaultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AssetVaultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetvault_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @returns {bigint}\n     */\n    getBalance(faucet_id) {\n        _assertClass(faucet_id, AccountId);\n        const ret = wasm.assetvault_getBalance(this.__wbg_ptr, faucet_id.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    fungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetvault_fungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AssetVault.prototype[Symbol.dispose] = AssetVault.prototype.free;\n\nconst AuthSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_authsecretkey_free(ptr >>> 0, 1));\n\nclass AuthSecretKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AuthSecretKey.prototype);\n        obj.__wbg_ptr = ptr;\n        AuthSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AuthSecretKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_authsecretkey_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    getRpoFalcon512PublicKeyAsWord() {\n        const ret = wasm.authsecretkey_getRpoFalcon512PublicKeyAsWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    getRpoFalcon512SecretKeyAsFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.authsecretkey_getRpoFalcon512SecretKeyAsFelts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    getEcdsaK256KeccakPublicKeyAsWord() {\n        const ret = wasm.authsecretkey_getEcdsaK256KeccakPublicKeyAsWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    getEcdsaK256KeccakSecretKeyAsFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.authsecretkey_getEcdsaK256KeccakSecretKeyAsFelts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) AuthSecretKey.prototype[Symbol.dispose] = AuthSecretKey.prototype.free;\n\nconst BasicFungibleFaucetComponentFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_basicfungiblefaucetcomponent_free(ptr >>> 0, 1));\n\nclass BasicFungibleFaucetComponent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BasicFungibleFaucetComponent.prototype);\n        obj.__wbg_ptr = ptr;\n        BasicFungibleFaucetComponentFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BasicFungibleFaucetComponentFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_basicfungiblefaucetcomponent_free(ptr, 0);\n    }\n    /**\n     * @param {Account} account\n     * @returns {BasicFungibleFaucetComponent}\n     */\n    static fromAccount(account) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account, Account);\n            var ptr0 = account.__destroy_into_raw();\n            wasm.basicfungiblefaucetcomponent_fromAccount(retptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BasicFungibleFaucetComponent.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {TokenSymbol}\n     */\n    symbol() {\n        const ret = wasm.accountid_prefix(this.__wbg_ptr);\n        return TokenSymbol.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    decimals() {\n        const ret = wasm.basicfungiblefaucetcomponent_decimals(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Felt}\n     */\n    maxSupply() {\n        const ret = wasm.accountid_suffix(this.__wbg_ptr);\n        return Felt.__wrap(ret);\n    }\n}\nif (Symbol.dispose) BasicFungibleFaucetComponent.prototype[Symbol.dispose] = BasicFungibleFaucetComponent.prototype.free;\n\nconst BlockHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_blockheader_free(ptr >>> 0, 1));\n\nclass BlockHeader {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BlockHeader.prototype);\n        obj.__wbg_ptr = ptr;\n        BlockHeaderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BlockHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    version() {\n        const ret = wasm.blockheader_version(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.blockheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    subCommitment() {\n        const ret = wasm.blockheader_subCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    prevBlockCommitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.blockheader_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    chainCommitment() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    accountRoot() {\n        const ret = wasm.accountheader_codeCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    nullifierRoot() {\n        const ret = wasm.blockheader_nullifierRoot(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    noteRoot() {\n        const ret = wasm.blockheader_noteRoot(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    txCommitment() {\n        const ret = wasm.blockheader_txCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    txKernelCommitment() {\n        const ret = wasm.accountbuilderresult_seed(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    proofCommitment() {\n        const ret = wasm.blockheader_proofCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    timestamp() {\n        const ret = wasm.blockheader_timestamp(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) BlockHeader.prototype[Symbol.dispose] = BlockHeader.prototype.free;\n\nconst ConsumableNoteRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_consumablenoterecord_free(ptr >>> 0, 1));\n\nclass ConsumableNoteRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ConsumableNoteRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        ConsumableNoteRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ConsumableNoteRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_consumablenoterecord_free(ptr, 0);\n    }\n    /**\n     * @param {InputNoteRecord} input_note_record\n     * @param {NoteConsumability[]} note_consumability\n     */\n    constructor(input_note_record, note_consumability) {\n        _assertClass(input_note_record, InputNoteRecord);\n        var ptr0 = input_note_record.__destroy_into_raw();\n        const ptr1 = passArrayJsValueToWasm0(note_consumability, wasm.__wbindgen_export);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.consumablenoterecord_new(ptr0, ptr1, len1);\n        this.__wbg_ptr = ret >>> 0;\n        ConsumableNoteRecordFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {InputNoteRecord}\n     */\n    inputNoteRecord() {\n        const ret = wasm.consumablenoterecord_inputNoteRecord(this.__wbg_ptr);\n        return InputNoteRecord.__wrap(ret);\n    }\n    /**\n     * @returns {NoteConsumability[]}\n     */\n    noteConsumability() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.consumablenoterecord_noteConsumability(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ConsumableNoteRecord.prototype[Symbol.dispose] = ConsumableNoteRecord.prototype.free;\n\nconst EndpointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_endpoint_free(ptr >>> 0, 1));\n/**\n * Represents a network endpoint for connecting to Miden nodes.\n *\n * An endpoint consists of a protocol (http/https), host, and optional port.\n * Provides convenient constructors for common network configurations.\n */\nclass Endpoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Endpoint.prototype);\n        obj.__wbg_ptr = ptr;\n        EndpointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EndpointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_endpoint_free(ptr, 0);\n    }\n    /**\n     * Creates an endpoint from a URL string.\n     *\n     * @param url - The URL string (e.g., <https://localhost:57291>)\n     * @throws throws an error if the URL is invalid\n     * @param {string} url\n     */\n    constructor(url) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.endpoint_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            EndpointFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the endpoint for the Miden testnet.\n     * @returns {Endpoint}\n     */\n    static testnet() {\n        const ret = wasm.endpoint_testnet();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the endpoint for the Miden devnet.\n     * @returns {Endpoint}\n     */\n    static devnet() {\n        const ret = wasm.endpoint_devnet();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the endpoint for a local Miden node.\n     *\n     * Uses <http://localhost:57291>\n     * @returns {Endpoint}\n     */\n    static localhost() {\n        const ret = wasm.endpoint_localhost();\n        return Endpoint.__wrap(ret);\n    }\n    /**\n     * Returns the protocol of the endpoint.\n     * @returns {string}\n     */\n    get protocol() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_protocol(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the host of the endpoint.\n     * @returns {string}\n     */\n    get host() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_host(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the port of the endpoint.\n     * @returns {number | undefined}\n     */\n    get port() {\n        const ret = wasm.endpoint_port(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n     * Returns the string representation of the endpoint.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.endpoint_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Endpoint.prototype[Symbol.dispose] = Endpoint.prototype.free;\n\nconst ExecutedTransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_executedtransaction_free(ptr >>> 0, 1));\n\nclass ExecutedTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutedTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutedTransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutedTransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executedtransaction_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.executedtransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.executedtransaction_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountHeader}\n     */\n    initialAccountHeader() {\n        const ret = wasm.executedtransaction_initialAccountHeader(this.__wbg_ptr);\n        return AccountHeader.__wrap(ret);\n    }\n    /**\n     * @returns {AccountHeader}\n     */\n    finalAccountHeader() {\n        const ret = wasm.executedtransaction_finalAccountHeader(this.__wbg_ptr);\n        return AccountHeader.__wrap(ret);\n    }\n    /**\n     * @returns {InputNotes}\n     */\n    inputNotes() {\n        const ret = wasm.executedtransaction_inputNotes(this.__wbg_ptr);\n        return InputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.executedtransaction_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionArgs}\n     */\n    txArgs() {\n        const ret = wasm.executedtransaction_txArgs(this.__wbg_ptr);\n        return TransactionArgs.__wrap(ret);\n    }\n    /**\n     * @returns {BlockHeader}\n     */\n    blockHeader() {\n        const ret = wasm.executedtransaction_blockHeader(this.__wbg_ptr);\n        return BlockHeader.__wrap(ret);\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        const ret = wasm.executedtransaction_accountDelta(this.__wbg_ptr);\n        return AccountDelta.__wrap(ret);\n    }\n}\nif (Symbol.dispose) ExecutedTransaction.prototype[Symbol.dispose] = ExecutedTransaction.prototype.free;\n\nconst FeltFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_felt_free(ptr >>> 0, 1));\n\nclass Felt {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Felt.prototype);\n        obj.__wbg_ptr = ptr;\n        FeltFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Felt)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FeltFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_felt_free(ptr, 0);\n    }\n    /**\n     * @param {bigint} value\n     */\n    constructor(value) {\n        const ret = wasm.felt_new(value);\n        this.__wbg_ptr = ret >>> 0;\n        FeltFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {bigint}\n     */\n    asInt() {\n        const ret = wasm.felt_asInt(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.felt_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) Felt.prototype[Symbol.dispose] = Felt.prototype.free;\n\nconst FeltArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_feltarray_free(ptr >>> 0, 1));\n\nclass FeltArray {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FeltArray.prototype);\n        obj.__wbg_ptr = ptr;\n        FeltArrayFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FeltArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_feltarray_free(ptr, 0);\n    }\n    /**\n     * @param {Felt[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.feltarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        FeltArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {Felt}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.feltarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Felt.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {Felt} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Felt);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.feltarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Felt} element\n     */\n    push(element) {\n        _assertClass(element, Felt);\n        wasm.feltarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.feltarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) FeltArray.prototype[Symbol.dispose] = FeltArray.prototype.free;\n\nconst FetchedNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fetchednote_free(ptr >>> 0, 1));\n/**\n * Represents a note fetched from a Miden node via RPC.\n */\nclass FetchedNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FetchedNote.prototype);\n        obj.__wbg_ptr = ptr;\n        FetchedNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FetchedNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fetchednote_free(ptr, 0);\n    }\n    /**\n     * Create a note with an optional `InputNote`.\n     * @param {NoteId} note_id\n     * @param {NoteMetadata} metadata\n     * @param {InputNote | null} [input_note]\n     */\n    constructor(note_id, metadata, input_note) {\n        _assertClass(note_id, NoteId);\n        var ptr0 = note_id.__destroy_into_raw();\n        _assertClass(metadata, NoteMetadata);\n        var ptr1 = metadata.__destroy_into_raw();\n        let ptr2 = 0;\n        if (!isLikeNone(input_note)) {\n            _assertClass(input_note, InputNote);\n            ptr2 = input_note.__destroy_into_raw();\n        }\n        const ret = wasm.fetchednote_new(ptr0, ptr1, ptr2);\n        this.__wbg_ptr = ret >>> 0;\n        FetchedNoteFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The unique identifier of the note.\n     * @returns {NoteId}\n     */\n    get noteId() {\n        const ret = wasm.fetchednote_noteId(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * The note's metadata, including sender, tag, and other properties.\n     * Available for both private and public notes.\n     * @returns {NoteMetadata}\n     */\n    get metadata() {\n        const ret = wasm.fetchednote_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * The full [`InputNote`] with inclusion proof.\n     *\n     * For public notes, it contains the complete note data and inclusion proof.\n     * For private notes, it will be ``None`.\n     * @returns {InputNote | undefined}\n     */\n    get inputNote() {\n        const ret = wasm.fetchednote_inputNote(this.__wbg_ptr);\n        return ret === 0 ? undefined : InputNote.__wrap(ret);\n    }\n    /**\n     * @returns {NoteType}\n     */\n    get noteType() {\n        const ret = wasm.fetchednote_noteType(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) FetchedNote.prototype[Symbol.dispose] = FetchedNote.prototype.free;\n\nconst FlattenedU8VecFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_flattenedu8vec_free(ptr >>> 0, 1));\n\nclass FlattenedU8Vec {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FlattenedU8Vec.prototype);\n        obj.__wbg_ptr = ptr;\n        FlattenedU8VecFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FlattenedU8VecFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_flattenedu8vec_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    data() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.flattenedu8vec_data(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint32Array}\n     */\n    lengths() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.flattenedu8vec_lengths(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    num_inner_vecs() {\n        const ret = wasm.flattenedu8vec_num_inner_vecs(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) FlattenedU8Vec.prototype[Symbol.dispose] = FlattenedU8Vec.prototype.free;\n\nconst ForeignAccountFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_foreignaccount_free(ptr >>> 0, 1));\n\nclass ForeignAccount {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ForeignAccount.prototype);\n        obj.__wbg_ptr = ptr;\n        ForeignAccountFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof ForeignAccount)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ForeignAccountFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_foreignaccount_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {AccountStorageRequirements} storage_requirements\n     * @returns {ForeignAccount}\n     */\n    static public(account_id, storage_requirements) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(account_id, AccountId);\n            var ptr0 = account_id.__destroy_into_raw();\n            _assertClass(storage_requirements, AccountStorageRequirements);\n            var ptr1 = storage_requirements.__destroy_into_raw();\n            wasm.foreignaccount_public(retptr, ptr0, ptr1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ForeignAccount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountStorageRequirements}\n     */\n    storage_slot_requirements() {\n        const ret = wasm.foreignaccount_storage_slot_requirements(this.__wbg_ptr);\n        return AccountStorageRequirements.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    account_id() {\n        const ret = wasm.foreignaccount_account_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n}\nif (Symbol.dispose) ForeignAccount.prototype[Symbol.dispose] = ForeignAccount.prototype.free;\n\nconst ForeignAccountArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_foreignaccountarray_free(ptr >>> 0, 1));\n\nclass ForeignAccountArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ForeignAccountArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_foreignaccountarray_free(ptr, 0);\n    }\n    /**\n     * @param {ForeignAccount[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.foreignaccountarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        ForeignAccountArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {ForeignAccount}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.foreignaccountarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ForeignAccount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {ForeignAccount} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, ForeignAccount);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.foreignaccountarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {ForeignAccount} element\n     */\n    push(element) {\n        _assertClass(element, ForeignAccount);\n        wasm.foreignaccountarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.foreignaccountarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) ForeignAccountArray.prototype[Symbol.dispose] = ForeignAccountArray.prototype.free;\n\nconst FungibleAssetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleasset_free(ptr >>> 0, 1));\n\nclass FungibleAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAsset.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof FungibleAsset)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleasset_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @param {bigint} amount\n     */\n    constructor(faucet_id, amount) {\n        _assertClass(faucet_id, AccountId);\n        const ret = wasm.fungibleasset_new(faucet_id.__wbg_ptr, amount);\n        this.__wbg_ptr = ret >>> 0;\n        FungibleAssetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {AccountId}\n     */\n    faucetId() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    amount() {\n        const ret = wasm.fungibleasset_amount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    intoWord() {\n        const ret = wasm.fungibleasset_intoWord(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) FungibleAsset.prototype[Symbol.dispose] = FungibleAsset.prototype.free;\n\nconst FungibleAssetDeltaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleassetdelta_free(ptr >>> 0, 1));\n\nclass FungibleAssetDelta {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAssetDelta.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetDeltaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetDeltaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleassetdelta_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.fungibleassetdelta_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {FungibleAssetDelta}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fungibleassetdelta_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FungibleAssetDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.fungibleassetdelta_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {AccountId} faucet_id\n     * @returns {bigint | undefined}\n     */\n    amount(faucet_id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(faucet_id, AccountId);\n            wasm.fungibleassetdelta_amount(retptr, this.__wbg_ptr, faucet_id.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    numAssets() {\n        const ret = wasm.fungibleassetdelta_numAssets(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {FungibleAssetDeltaItem[]}\n     */\n    assets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.fungibleassetdelta_assets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) FungibleAssetDelta.prototype[Symbol.dispose] = FungibleAssetDelta.prototype.free;\n\nconst FungibleAssetDeltaItemFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fungibleassetdeltaitem_free(ptr >>> 0, 1));\n\nclass FungibleAssetDeltaItem {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FungibleAssetDeltaItem.prototype);\n        obj.__wbg_ptr = ptr;\n        FungibleAssetDeltaItemFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FungibleAssetDeltaItemFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fungibleassetdeltaitem_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    get faucetId() {\n        const ret = wasm.accountdelta_id(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    get amount() {\n        const ret = wasm.fungibleasset_amount(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) FungibleAssetDeltaItem.prototype[Symbol.dispose] = FungibleAssetDeltaItem.prototype.free;\n\nconst GetProceduresResultItemFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_getproceduresresultitem_free(ptr >>> 0, 1));\n\nclass GetProceduresResultItem {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GetProceduresResultItem.prototype);\n        obj.__wbg_ptr = ptr;\n        GetProceduresResultItemFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GetProceduresResultItemFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_getproceduresresultitem_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    get digest() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    get isAuth() {\n        const ret = wasm.getproceduresresultitem_isAuth(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) GetProceduresResultItem.prototype[Symbol.dispose] = GetProceduresResultItem.prototype.free;\n\nconst InputNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnote_free(ptr >>> 0, 1));\n\nclass InputNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNote.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnote_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.inputnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Note}\n     */\n    note() {\n        const ret = wasm.inputnote_note(this.__wbg_ptr);\n        return Note.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.inputnote_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInclusionProof | undefined}\n     */\n    proof() {\n        const ret = wasm.inputnote_proof(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteInclusionProof.__wrap(ret);\n    }\n    /**\n     * @returns {NoteLocation | undefined}\n     */\n    location() {\n        const ret = wasm.inputnote_location(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteLocation.__wrap(ret);\n    }\n}\nif (Symbol.dispose) InputNote.prototype[Symbol.dispose] = InputNote.prototype.free;\n\nconst InputNoteRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnoterecord_free(ptr >>> 0, 1));\n\nclass InputNoteRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNoteRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNoteRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNoteRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnoterecord_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.inputnoterecord_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {InputNoteState}\n     */\n    state() {\n        const ret = wasm.inputnoterecord_state(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {NoteDetails}\n     */\n    details() {\n        const ret = wasm.inputnoterecord_details(this.__wbg_ptr);\n        return NoteDetails.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata | undefined}\n     */\n    metadata() {\n        const ret = wasm.inputnoterecord_metadata(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    commitment() {\n        const ret = wasm.inputnoterecord_commitment(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInclusionProof | undefined}\n     */\n    inclusionProof() {\n        const ret = wasm.inputnoterecord_inclusionProof(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteInclusionProof.__wrap(ret);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    consumerTransactionId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_consumerTransactionId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    nullifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_nullifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isAuthenticated() {\n        const ret = wasm.inputnoterecord_isAuthenticated(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isConsumed() {\n        const ret = wasm.inputnoterecord_isConsumed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isProcessing() {\n        const ret = wasm.inputnoterecord_isProcessing(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {InputNote}\n     */\n    toInputNote() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnoterecord_toInputNote(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return InputNote.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) InputNoteRecord.prototype[Symbol.dispose] = InputNoteRecord.prototype.free;\n\nconst InputNotesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_inputnotes_free(ptr >>> 0, 1));\n\nclass InputNotes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(InputNotes.prototype);\n        obj.__wbg_ptr = ptr;\n        InputNotesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        InputNotesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputnotes_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    numNotes() {\n        const ret = wasm.inputnotes_numNotes(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.inputnotes_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {InputNote}\n     */\n    getNote(index) {\n        const ret = wasm.inputnotes_getNote(this.__wbg_ptr, index);\n        return InputNote.__wrap(ret);\n    }\n    /**\n     * @returns {InputNote[]}\n     */\n    notes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.inputnotes_notes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) InputNotes.prototype[Symbol.dispose] = InputNotes.prototype.free;\n\nconst IntoUnderlyingByteSourceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingByteSource {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingByteSourceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingbytesource_free(ptr, 0);\n    }\n    /**\n     * @returns {ReadableStreamType}\n     */\n    get type() {\n        const ret = wasm.intounderlyingbytesource_type(this.__wbg_ptr);\n        return __wbindgen_enum_ReadableStreamType[ret];\n    }\n    /**\n     * @returns {number}\n     */\n    get autoAllocateChunkSize() {\n        const ret = wasm.intounderlyingbytesource_autoAllocateChunkSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {ReadableByteStreamController} controller\n     */\n    start(controller) {\n        wasm.intounderlyingbytesource_start(this.__wbg_ptr, addHeapObject(controller));\n    }\n    /**\n     * @param {ReadableByteStreamController} controller\n     * @returns {Promise<any>}\n     */\n    pull(controller) {\n        const ret = wasm.intounderlyingbytesource_pull(this.__wbg_ptr, addHeapObject(controller));\n        return takeObject(ret);\n    }\n    cancel() {\n        const ptr = this.__destroy_into_raw();\n        wasm.intounderlyingbytesource_cancel(ptr);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingByteSource.prototype[Symbol.dispose] = IntoUnderlyingByteSource.prototype.free;\n\nconst IntoUnderlyingSinkFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsink_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingSink {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingSinkFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingsink_free(ptr, 0);\n    }\n    /**\n     * @param {any} chunk\n     * @returns {Promise<any>}\n     */\n    write(chunk) {\n        const ret = wasm.intounderlyingsink_write(this.__wbg_ptr, addHeapObject(chunk));\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<any>}\n     */\n    close() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.intounderlyingsink_close(ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {any} reason\n     * @returns {Promise<any>}\n     */\n    abort(reason) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.intounderlyingsink_abort(ptr, addHeapObject(reason));\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingSink.prototype[Symbol.dispose] = IntoUnderlyingSink.prototype.free;\n\nconst IntoUnderlyingSourceFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_intounderlyingsource_free(ptr >>> 0, 1));\n\nclass IntoUnderlyingSource {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        IntoUnderlyingSourceFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_intounderlyingsource_free(ptr, 0);\n    }\n    /**\n     * @param {ReadableStreamDefaultController} controller\n     * @returns {Promise<any>}\n     */\n    pull(controller) {\n        const ret = wasm.intounderlyingsource_pull(this.__wbg_ptr, addHeapObject(controller));\n        return takeObject(ret);\n    }\n    cancel() {\n        const ptr = this.__destroy_into_raw();\n        wasm.intounderlyingsource_cancel(ptr);\n    }\n}\nif (Symbol.dispose) IntoUnderlyingSource.prototype[Symbol.dispose] = IntoUnderlyingSource.prototype.free;\n\nconst JsAccountUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsaccountupdate_free(ptr >>> 0, 1));\n/**\n * Represents an update to a single account's state.\n */\nclass JsAccountUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsAccountUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        JsAccountUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsAccountUpdate)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            storageRoot: this.storageRoot,\n            storageSlots: this.storageSlots,\n            storageMapEntries: this.storageMapEntries,\n            assetVaultRoot: this.assetVaultRoot,\n            assets: this.assets,\n            accountId: this.accountId,\n            codeRoot: this.codeRoot,\n            committed: this.committed,\n            nonce: this.nonce,\n            accountCommitment: this.accountCommitment,\n            accountSeed: this.accountSeed,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsAccountUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsaccountupdate_free(ptr, 0);\n    }\n    /**\n     * The merkle root of the account's storage trie.\n     * @returns {string}\n     */\n    get storageRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's storage trie.\n     * @param {string} arg0\n     */\n    set storageRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized storage slot data for this account.\n     * @returns {JsStorageSlot[]}\n     */\n    get storageSlots() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageSlots(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized storage slot data for this account.\n     * @param {JsStorageSlot[]} arg0\n     */\n    set storageSlots(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageSlots(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized storage map entries for this account.\n     * @returns {JsStorageMapEntry[]}\n     */\n    get storageMapEntries() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageMapEntries(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized storage map entries for this account.\n     * @param {JsStorageMapEntry[]} arg0\n     */\n    set storageMapEntries(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageMapEntries(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The merkle root of the account's asset vault.\n     * @returns {string}\n     */\n    get assetVaultRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assetVaultRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's asset vault.\n     * @param {string} arg0\n     */\n    set assetVaultRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assetVaultRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The account's asset vault.\n     * @returns {JsVaultAsset[]}\n     */\n    get assets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The account's asset vault.\n     * @param {JsVaultAsset[]} arg0\n     */\n    set assets(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * ID for this account.\n     * @returns {string}\n     */\n    get accountId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * ID for this account.\n     * @param {string} arg0\n     */\n    set accountId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountId(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The merkle root of the account's executable code.\n     * @returns {string}\n     */\n    get codeRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_codeRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the account's executable code.\n     * @param {string} arg0\n     */\n    set codeRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_codeRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Whether this account update has been committed.\n     * @returns {boolean}\n     */\n    get committed() {\n        const ret = wasm.__wbg_get_jsaccountupdate_committed(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Whether this account update has been committed.\n     * @param {boolean} arg0\n     */\n    set committed(arg0) {\n        wasm.__wbg_set_jsaccountupdate_committed(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The account's transaction nonce as a string.\n     * @returns {string}\n     */\n    get nonce() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_nonce(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The account's transaction nonce as a string.\n     * @param {string} arg0\n     */\n    set nonce(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_nonce(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The cryptographic commitment representing this account's current state.\n     * @returns {string}\n     */\n    get accountCommitment() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountCommitment(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The cryptographic commitment representing this account's current state.\n     * @param {string} arg0\n     */\n    set accountCommitment(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountCommitment(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Optional seed data for the account.\n     * @returns {Uint8Array | undefined}\n     */\n    get accountSeed() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountSeed(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Optional seed data for the account.\n     * @param {Uint8Array | null} [arg0]\n     */\n    set accountSeed(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountSeed(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsAccountUpdate.prototype[Symbol.dispose] = JsAccountUpdate.prototype.free;\n\nconst JsStateSyncUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstatesyncupdate_free(ptr >>> 0, 1));\n/**\n * An object that contains data for a sync update,\n * which will be received by the applyStateSync JS function.\n * under sync.js\n */\nclass JsStateSyncUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStateSyncUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStateSyncUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStateSyncUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstatesyncupdate_free(ptr, 0);\n    }\n    /**\n     * The block number for this update, stored as a string since it will be\n     * persisted in `IndexedDB`.\n     * @returns {string}\n     */\n    get blockNum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The block number for this update, stored as a string since it will be\n     * persisted in `IndexedDB`.\n     * @param {string} arg0\n     */\n    set blockNum(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The new block headers for this state update, serialized into a flattened byte array.\n     * @returns {FlattenedU8Vec}\n     */\n    get flattenedNewBlockHeaders() {\n        const ret = wasm.__wbg_get_jsstatesyncupdate_flattenedNewBlockHeaders(this.__wbg_ptr);\n        return FlattenedU8Vec.__wrap(ret);\n    }\n    /**\n     * The new block headers for this state update, serialized into a flattened byte array.\n     * @param {FlattenedU8Vec} arg0\n     */\n    set flattenedNewBlockHeaders(arg0) {\n        _assertClass(arg0, FlattenedU8Vec);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_jsstatesyncupdate_flattenedNewBlockHeaders(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * The block numbers corresponding to each header in `flattened_new_block_headers`.\n     * This vec should have the same length as the number of headers, with each index\n     * representing the block number for the header at that same index.\n     * @returns {string[]}\n     */\n    get newBlockNums() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_newBlockNums(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The block numbers corresponding to each header in `flattened_new_block_headers`.\n     * This vec should have the same length as the number of headers, with each index\n     * representing the block number for the header at that same index.\n     * @param {string[]} arg0\n     */\n    set newBlockNums(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_newBlockNums(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Flattened byte array containing partial blockchain peaks used for merkle tree\n     * verification.\n     * @returns {FlattenedU8Vec}\n     */\n    get flattenedPartialBlockChainPeaks() {\n        const ret = wasm.__wbg_get_jsstatesyncupdate_flattenedPartialBlockChainPeaks(this.__wbg_ptr);\n        return FlattenedU8Vec.__wrap(ret);\n    }\n    /**\n     * Flattened byte array containing partial blockchain peaks used for merkle tree\n     * verification.\n     * @param {FlattenedU8Vec} arg0\n     */\n    set flattenedPartialBlockChainPeaks(arg0) {\n        _assertClass(arg0, FlattenedU8Vec);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_jsstatesyncupdate_flattenedPartialBlockChainPeaks(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * For each block in this update, stores a boolean (as u8) indicating whether\n     * that block contains notes relevant to this client. Index i corresponds to\n     * the ith block, with 1 meaning relevant and 0 meaning not relevant.\n     * @returns {Uint8Array}\n     */\n    get blockHasRelevantNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_blockHasRelevantNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * For each block in this update, stores a boolean (as u8) indicating whether\n     * that block contains notes relevant to this client. Index i corresponds to\n     * the ith block, with 1 meaning relevant and 0 meaning not relevant.\n     * @param {Uint8Array} arg0\n     */\n    set blockHasRelevantNotes(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_blockHasRelevantNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Serialized IDs for new authentication nodes required to verify block headers.\n     * @returns {string[]}\n     */\n    get serializedNodeIds() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedNodeIds(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialized IDs for new authentication nodes required to verify block headers.\n     * @param {string[]} arg0\n     */\n    set serializedNodeIds(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedNodeIds(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The actual authentication node data corresponding to the IDs above.\n     * @returns {string[]}\n     */\n    get serializedNodes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedNodes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The actual authentication node data corresponding to the IDs above.\n     * @param {string[]} arg0\n     */\n    set serializedNodes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedNodes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * IDs of note tags that should be removed from the client's local state.\n     * @returns {string[]}\n     */\n    get committedNoteIds() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_committedNoteIds(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * IDs of note tags that should be removed from the client's local state.\n     * @param {string[]} arg0\n     */\n    set committedNoteIds(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_committedNoteIds(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Input notes for this state update in serialized form.\n     * @returns {SerializedInputNoteData[]}\n     */\n    get serializedInputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedInputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Input notes for this state update in serialized form.\n     * @param {SerializedInputNoteData[]} arg0\n     */\n    set serializedInputNotes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedInputNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Output notes created in this state update in serialized form.\n     * @returns {SerializedOutputNoteData[]}\n     */\n    get serializedOutputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_serializedOutputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Output notes created in this state update in serialized form.\n     * @param {SerializedOutputNoteData[]} arg0\n     */\n    set serializedOutputNotes(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_serializedOutputNotes(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Account state updates included in this sync.\n     * @returns {JsAccountUpdate[]}\n     */\n    get accountUpdates() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_accountUpdates(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Account state updates included in this sync.\n     * @param {JsAccountUpdate[]} arg0\n     */\n    set accountUpdates(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_accountUpdates(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Transaction data for transactions included in this update.\n     * @returns {SerializedTransactionData[]}\n     */\n    get transactionUpdates() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstatesyncupdate_transactionUpdates(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Transaction data for transactions included in this update.\n     * @param {SerializedTransactionData[]} arg0\n     */\n    set transactionUpdates(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstatesyncupdate_transactionUpdates(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsStateSyncUpdate.prototype[Symbol.dispose] = JsStateSyncUpdate.prototype.free;\n\nconst JsStorageMapEntryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstoragemapentry_free(ptr >>> 0, 1));\n/**\n * A JavaScript representation of a storage map entry in an account.\n */\nclass JsStorageMapEntry {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStorageMapEntry.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStorageMapEntryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsStorageMapEntry)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            root: this.root,\n            key: this.key,\n            value: this.value,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStorageMapEntryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstoragemapentry_free(ptr, 0);\n    }\n    /**\n     * The root of the storage map entry.\n     * @returns {string}\n     */\n    get root() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The root of the storage map entry.\n     * @param {string} arg0\n     */\n    set root(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The key of the storage map entry.\n     * @returns {string}\n     */\n    get key() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The key of the storage map entry.\n     * @param {string} arg0\n     */\n    set key(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The value of the storage map entry.\n     * @returns {string}\n     */\n    get value() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The value of the storage map entry.\n     * @param {string} arg0\n     */\n    set value(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsStorageMapEntry.prototype[Symbol.dispose] = JsStorageMapEntry.prototype.free;\n\nconst JsStorageSlotFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsstorageslot_free(ptr >>> 0, 1));\n/**\n * A JavaScript representation of a storage slot in an account.\n */\nclass JsStorageSlot {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsStorageSlot.prototype);\n        obj.__wbg_ptr = ptr;\n        JsStorageSlotFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsStorageSlot)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            commitment: this.commitment,\n            slotIndex: this.slotIndex,\n            slotValue: this.slotValue,\n            slotType: this.slotType,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsStorageSlotFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsstorageslot_free(ptr, 0);\n    }\n    /**\n     * Commitment of the whole account storage\n     * @returns {string}\n     */\n    get commitment() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Commitment of the whole account storage\n     * @param {string} arg0\n     */\n    set commitment(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The index of the storage slot.\n     * @returns {number}\n     */\n    get slotIndex() {\n        const ret = wasm.__wbg_get_jsstorageslot_slotIndex(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The index of the storage slot.\n     * @param {number} arg0\n     */\n    set slotIndex(arg0) {\n        wasm.__wbg_set_jsstorageslot_slotIndex(this.__wbg_ptr, arg0);\n    }\n    /**\n     * The value stored in the storage slot.\n     * @returns {string}\n     */\n    get slotValue() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The value stored in the storage slot.\n     * @param {string} arg0\n     */\n    set slotValue(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The type of the storage slot.\n     * @returns {number}\n     */\n    get slotType() {\n        const ret = wasm.__wbg_get_jsstorageslot_slotType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The type of the storage slot.\n     * @param {number} arg0\n     */\n    set slotType(arg0) {\n        wasm.__wbg_set_jsstorageslot_slotType(this.__wbg_ptr, arg0);\n    }\n}\nif (Symbol.dispose) JsStorageSlot.prototype[Symbol.dispose] = JsStorageSlot.prototype.free;\n\nconst JsVaultAssetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsvaultasset_free(ptr >>> 0, 1));\n/**\n * An object that contains a serialized vault asset\n */\nclass JsVaultAsset {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(JsVaultAsset.prototype);\n        obj.__wbg_ptr = ptr;\n        JsVaultAssetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof JsVaultAsset)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    toJSON() {\n        return {\n            root: this.root,\n            vaultKey: this.vaultKey,\n            faucetIdPrefix: this.faucetIdPrefix,\n            asset: this.asset,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsVaultAssetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsvaultasset_free(ptr, 0);\n    }\n    /**\n     * The merkle root of the vault's assets.\n     * @returns {string}\n     */\n    get root() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The merkle root of the vault's assets.\n     * @param {string} arg0\n     */\n    set root(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * The vault key associated with the asset.\n     * @returns {string}\n     */\n    get vaultKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_key(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * The vault key associated with the asset.\n     * @param {string} arg0\n     */\n    set vaultKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_key(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Asset's faucet ID prefix.\n     * @returns {string}\n     */\n    get faucetIdPrefix() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Asset's faucet ID prefix.\n     * @param {string} arg0\n     */\n    set faucetIdPrefix(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Word representing the asset.\n     * @returns {string}\n     */\n    get asset() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_assetVaultRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Word representing the asset.\n     * @param {string} arg0\n     */\n    set asset(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_assetVaultRoot(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) JsVaultAsset.prototype[Symbol.dispose] = JsVaultAsset.prototype.free;\n\nconst LibraryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_library_free(ptr >>> 0, 1));\n\nclass Library {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Library.prototype);\n        obj.__wbg_ptr = ptr;\n        LibraryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        LibraryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_library_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Library.prototype[Symbol.dispose] = Library.prototype.free;\n\nconst MerklePathFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_merklepath_free(ptr >>> 0, 1));\n\nclass MerklePath {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(MerklePath.prototype);\n        obj.__wbg_ptr = ptr;\n        MerklePathFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MerklePathFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merklepath_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    depth() {\n        const ret = wasm.merklepath_depth(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    nodes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.merklepath_nodes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {bigint} index\n     * @param {Word} node\n     * @returns {Word}\n     */\n    computeRoot(index, node) {\n        _assertClass(node, Word);\n        const ret = wasm.merklepath_computeRoot(this.__wbg_ptr, index, node.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {bigint} index\n     * @param {Word} node\n     * @param {Word} root\n     * @returns {boolean}\n     */\n    verify(index, node, root) {\n        _assertClass(node, Word);\n        _assertClass(root, Word);\n        const ret = wasm.merklepath_verify(this.__wbg_ptr, index, node.__wbg_ptr, root.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) MerklePath.prototype[Symbol.dispose] = MerklePath.prototype.free;\n\nconst NoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_note_free(ptr >>> 0, 1));\n\nclass Note {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Note.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_note_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAssets} note_assets\n     * @param {NoteMetadata} note_metadata\n     * @param {NoteRecipient} note_recipient\n     */\n    constructor(note_assets, note_metadata, note_recipient) {\n        _assertClass(note_assets, NoteAssets);\n        _assertClass(note_metadata, NoteMetadata);\n        _assertClass(note_recipient, NoteRecipient);\n        const ret = wasm.note_new(note_assets.__wbg_ptr, note_metadata.__wbg_ptr, note_recipient.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.note_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Note}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.note_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.note_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.note_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.note_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {NoteRecipient}\n     */\n    recipient() {\n        const ret = wasm.note_recipient(this.__wbg_ptr);\n        return NoteRecipient.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.note_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    script() {\n        const ret = wasm.note_script(this.__wbg_ptr);\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {AccountId} target\n     * @param {NoteAssets} assets\n     * @param {NoteType} note_type\n     * @param {Felt} aux\n     * @returns {Note}\n     */\n    static createP2IDNote(sender, target, assets, note_type, aux) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender, AccountId);\n            _assertClass(target, AccountId);\n            _assertClass(assets, NoteAssets);\n            _assertClass(aux, Felt);\n            wasm.note_createP2IDNote(retptr, sender.__wbg_ptr, target.__wbg_ptr, assets.__wbg_ptr, note_type, aux.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {AccountId} target\n     * @param {NoteAssets} assets\n     * @param {number | null | undefined} reclaim_height\n     * @param {number | null | undefined} timelock_height\n     * @param {NoteType} note_type\n     * @param {Felt} aux\n     * @returns {Note}\n     */\n    static createP2IDENote(sender, target, assets, reclaim_height, timelock_height, note_type, aux) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender, AccountId);\n            _assertClass(target, AccountId);\n            _assertClass(assets, NoteAssets);\n            _assertClass(aux, Felt);\n            wasm.note_createP2IDENote(retptr, sender.__wbg_ptr, target.__wbg_ptr, assets.__wbg_ptr, isLikeNone(reclaim_height) ? 0x100000001 : (reclaim_height) >>> 0, isLikeNone(timelock_height) ? 0x100000001 : (timelock_height) >>> 0, note_type, aux.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Note.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Note.prototype[Symbol.dispose] = Note.prototype.free;\n\nconst NoteAndArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteandargs_free(ptr >>> 0, 1));\n\nclass NoteAndArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteAndArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteAndArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteAndArgs)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAndArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteandargs_free(ptr, 0);\n    }\n    /**\n     * @param {Note} note\n     * @param {Word | null} [args]\n     */\n    constructor(note, args) {\n        _assertClass(note, Note);\n        var ptr0 = note.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(args)) {\n            _assertClass(args, Word);\n            ptr1 = args.__destroy_into_raw();\n        }\n        const ret = wasm.noteandargs_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAndArgsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteAndArgs.prototype[Symbol.dispose] = NoteAndArgs.prototype.free;\n\nconst NoteAndArgsArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteandargsarray_free(ptr >>> 0, 1));\n\nclass NoteAndArgsArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAndArgsArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteandargsarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAndArgs[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteandargsarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAndArgsArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteAndArgs}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteandargsarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteAndArgs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteAndArgs} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteAndArgs);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noteandargsarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteAndArgs} element\n     */\n    push(element) {\n        _assertClass(element, NoteAndArgs);\n        wasm.noteandargsarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noteandargsarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteAndArgsArray.prototype[Symbol.dispose] = NoteAndArgsArray.prototype.free;\n\nconst NoteAssetsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteassets_free(ptr >>> 0, 1));\n\nclass NoteAssets {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteAssets.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteAssetsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteAssetsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteassets_free(ptr, 0);\n    }\n    /**\n     * @param {FungibleAsset[] | null} [assets_array]\n     */\n    constructor(assets_array) {\n        var ptr0 = isLikeNone(assets_array) ? 0 : passArrayJsValueToWasm0(assets_array, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteassets_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteAssetsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {FungibleAsset} asset\n     */\n    push(asset) {\n        _assertClass(asset, FungibleAsset);\n        wasm.noteassets_push(this.__wbg_ptr, asset.__wbg_ptr);\n    }\n    /**\n     * @returns {FungibleAsset[]}\n     */\n    fungibleAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteassets_fungibleAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) NoteAssets.prototype[Symbol.dispose] = NoteAssets.prototype.free;\n\nconst NoteConsumabilityFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteconsumability_free(ptr >>> 0, 1));\n\nclass NoteConsumability {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteConsumability.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteConsumabilityFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteConsumability)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteConsumabilityFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteconsumability_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.noteconsumability_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    consumableAfterBlock() {\n        const ret = wasm.noteconsumability_consumableAfterBlock(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\nif (Symbol.dispose) NoteConsumability.prototype[Symbol.dispose] = NoteConsumability.prototype.free;\n\nconst NoteDetailsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetails_free(ptr >>> 0, 1));\n\nclass NoteDetails {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteDetails.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteDetailsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetails_free(ptr, 0);\n    }\n    /**\n     * @param {NoteAssets} note_assets\n     * @param {NoteRecipient} note_recipient\n     */\n    constructor(note_assets, note_recipient) {\n        _assertClass(note_assets, NoteAssets);\n        _assertClass(note_recipient, NoteRecipient);\n        const ret = wasm.notedetails_new(note_assets.__wbg_ptr, note_recipient.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.notedetails_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.notedetails_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteRecipient}\n     */\n    recipient() {\n        const ret = wasm.notedetails_recipient(this.__wbg_ptr);\n        return NoteRecipient.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteDetails.prototype[Symbol.dispose] = NoteDetails.prototype.free;\n\nconst NoteDetailsAndTagFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetailsandtag_free(ptr >>> 0, 1));\n\nclass NoteDetailsAndTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteDetailsAndTag.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteDetailsAndTagFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteDetailsAndTag)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsAndTagFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetailsandtag_free(ptr, 0);\n    }\n    /**\n     * @param {NoteDetails} note_details\n     * @param {NoteTag} tag\n     */\n    constructor(note_details, tag) {\n        _assertClass(note_details, NoteDetails);\n        var ptr0 = note_details.__destroy_into_raw();\n        _assertClass(tag, NoteTag);\n        var ptr1 = tag.__destroy_into_raw();\n        const ret = wasm.notedetailsandtag_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsAndTagFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {NoteDetails}\n     */\n    get noteDetails() {\n        const ret = wasm.notedetailsandtag_noteDetails(this.__wbg_ptr);\n        return NoteDetails.__wrap(ret);\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    get tag() {\n        const ret = wasm.notedetailsandtag_tag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteDetailsAndTag.prototype[Symbol.dispose] = NoteDetailsAndTag.prototype.free;\n\nconst NoteDetailsAndTagArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notedetailsandtagarray_free(ptr >>> 0, 1));\n\nclass NoteDetailsAndTagArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteDetailsAndTagArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notedetailsandtagarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteDetailsAndTag[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.notedetailsandtagarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteDetailsAndTagArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteDetailsAndTag}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notedetailsandtagarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteDetailsAndTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteDetailsAndTag} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteDetailsAndTag);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.notedetailsandtagarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteDetailsAndTag} element\n     */\n    push(element) {\n        _assertClass(element, NoteDetailsAndTag);\n        wasm.notedetailsandtagarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.notedetailsandtagarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteDetailsAndTagArray.prototype[Symbol.dispose] = NoteDetailsAndTagArray.prototype.free;\n\nconst NoteExecutionHintFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteexecutionhint_free(ptr >>> 0, 1));\n\nclass NoteExecutionHint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteExecutionHint.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteExecutionHintFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteExecutionHintFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteexecutionhint_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteExecutionHint}\n     */\n    static none() {\n        const ret = wasm.noteexecutionhint_none();\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @returns {NoteExecutionHint}\n     */\n    static always() {\n        const ret = wasm.noteexecutionhint_always();\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {NoteExecutionHint}\n     */\n    static afterBlock(block_num) {\n        const ret = wasm.noteexecutionhint_afterBlock(block_num);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} epoch_len\n     * @param {number} slot_len\n     * @param {number} slot_offset\n     * @returns {NoteExecutionHint}\n     */\n    static onBlockSlot(epoch_len, slot_len, slot_offset) {\n        const ret = wasm.noteexecutionhint_onBlockSlot(epoch_len, slot_len, slot_offset);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} payload\n     * @returns {NoteExecutionHint}\n     */\n    static fromParts(tag, payload) {\n        const ret = wasm.noteexecutionhint_fromParts(tag, payload);\n        return NoteExecutionHint.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {boolean}\n     */\n    canBeConsumed(block_num) {\n        const ret = wasm.noteexecutionhint_canBeConsumed(this.__wbg_ptr, block_num);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) NoteExecutionHint.prototype[Symbol.dispose] = NoteExecutionHint.prototype.free;\n\nconst NoteExecutionModeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteexecutionmode_free(ptr >>> 0, 1));\n\nclass NoteExecutionMode {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteExecutionMode.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteExecutionModeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteExecutionModeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteexecutionmode_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    static newLocal() {\n        const ret = wasm.accountstoragemode_network();\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    static newNetwork() {\n        const ret = wasm.accountstoragemode_public();\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteexecutionmode_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) NoteExecutionMode.prototype[Symbol.dispose] = NoteExecutionMode.prototype.free;\n\nconst NoteFileFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notefile_free(ptr >>> 0, 1));\n/**\n * A serialized representation of a note.\n */\nclass NoteFile {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteFile.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteFileFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFileFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notefile_free(ptr, 0);\n    }\n    /**\n     * Returns this `NoteFile`'s types.\n     * @returns {string}\n     */\n    noteType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notefile_noteType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Turn a notefile into its byte representation.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notefile_serialize(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a valid byte representation of a `NoteFile`,\n     * return it as a struct.\n     * @param {Uint8Array} bytes\n     * @returns {NoteFile}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.notefile_deserialize(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteFile.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {InputNote} note\n     * @returns {NoteFile}\n     */\n    static fromInputNote(note) {\n        _assertClass(note, InputNote);\n        const ret = wasm.notefile_fromInputNote(note.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {OutputNote} note\n     * @returns {NoteFile}\n     */\n    static fromOutputNote(note) {\n        _assertClass(note, OutputNote);\n        const ret = wasm.notefile_fromOutputNote(note.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {NoteDetails} note_details\n     * @returns {NoteFile}\n     */\n    static fromNoteDetails(note_details) {\n        _assertClass(note_details, NoteDetails);\n        const ret = wasm.notefile_fromNoteDetails(note_details.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n    /**\n     * @param {NoteId} note_details\n     * @returns {NoteFile}\n     */\n    static fromNoteId(note_details) {\n        _assertClass(note_details, NoteId);\n        const ret = wasm.notefile_fromNoteId(note_details.__wbg_ptr);\n        return NoteFile.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteFile.prototype[Symbol.dispose] = NoteFile.prototype.free;\n\nconst NoteFilterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notefilter_free(ptr >>> 0, 1));\n\nclass NoteFilter {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteFilterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notefilter_free(ptr, 0);\n    }\n    /**\n     * @param {NoteFilterTypes} note_type\n     * @param {NoteId[] | null} [note_ids]\n     */\n    constructor(note_type, note_ids) {\n        var ptr0 = isLikeNone(note_ids) ? 0 : passArrayJsValueToWasm0(note_ids, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.notefilter_new(note_type, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteFilterFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteFilter.prototype[Symbol.dispose] = NoteFilter.prototype.free;\n\nconst NoteHeaderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteheader_free(ptr >>> 0, 1));\n\nclass NoteHeader {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteHeaderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteheader_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.noteheader_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.noteheader_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.noteheader_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteHeader.prototype[Symbol.dispose] = NoteHeader.prototype.free;\n\nconst NoteIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteid_free(ptr >>> 0, 1));\n\nclass NoteId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteId.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteid_free(ptr, 0);\n    }\n    /**\n     * @param {Word} recipient_digest\n     * @param {Word} asset_commitment_digest\n     */\n    constructor(recipient_digest, asset_commitment_digest) {\n        _assertClass(recipient_digest, Word);\n        _assertClass(asset_commitment_digest, Word);\n        const ret = wasm.noteid_new(recipient_digest.__wbg_ptr, asset_commitment_digest.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {string} hex\n     * @returns {NoteId}\n     */\n    static fromHex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.noteid_fromHex(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteid_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) NoteId.prototype[Symbol.dispose] = NoteId.prototype.free;\n\nconst NoteIdAndArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteidandargs_free(ptr >>> 0, 1));\n\nclass NoteIdAndArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteIdAndArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteIdAndArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteIdAndArgs)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdAndArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteidandargs_free(ptr, 0);\n    }\n    /**\n     * @param {NoteId} note_id\n     * @param {Word | null} [args]\n     */\n    constructor(note_id, args) {\n        _assertClass(note_id, NoteId);\n        var ptr0 = note_id.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(args)) {\n            _assertClass(args, Word);\n            ptr1 = args.__destroy_into_raw();\n        }\n        const ret = wasm.noteidandargs_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdAndArgsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nif (Symbol.dispose) NoteIdAndArgs.prototype[Symbol.dispose] = NoteIdAndArgs.prototype.free;\n\nconst NoteIdAndArgsArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteidandargsarray_free(ptr >>> 0, 1));\n\nclass NoteIdAndArgsArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteIdAndArgsArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteidandargsarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteIdAndArgs[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noteidandargsarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteIdAndArgsArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteIdAndArgs}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteidandargsarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteIdAndArgs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteIdAndArgs} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteIdAndArgs);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noteidandargsarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteIdAndArgs} element\n     */\n    push(element) {\n        _assertClass(element, NoteIdAndArgs);\n        wasm.noteidandargsarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noteidandargsarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteIdAndArgsArray.prototype[Symbol.dispose] = NoteIdAndArgsArray.prototype.free;\n\nconst NoteInclusionProofFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteinclusionproof_free(ptr >>> 0, 1));\n\nclass NoteInclusionProof {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteInclusionProof.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteInclusionProofFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteInclusionProofFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteinclusionproof_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteLocation}\n     */\n    location() {\n        const ret = wasm.noteinclusionproof_location(this.__wbg_ptr);\n        return NoteLocation.__wrap(ret);\n    }\n    /**\n     * @returns {MerklePath}\n     */\n    notePath() {\n        const ret = wasm.noteinclusionproof_notePath(this.__wbg_ptr);\n        return MerklePath.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteInclusionProof.prototype[Symbol.dispose] = NoteInclusionProof.prototype.free;\n\nconst NoteInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noteinputs_free(ptr >>> 0, 1));\n\nclass NoteInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noteinputs_free(ptr, 0);\n    }\n    /**\n     * @param {FeltArray} felt_array\n     */\n    constructor(felt_array) {\n        _assertClass(felt_array, FeltArray);\n        const ret = wasm.noteinputs_new(felt_array.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteInputsFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    values() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noteinputs_values(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) NoteInputs.prototype[Symbol.dispose] = NoteInputs.prototype.free;\n\nconst NoteLocationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notelocation_free(ptr >>> 0, 1));\n\nclass NoteLocation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteLocation.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteLocationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteLocationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notelocation_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.notelocation_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    nodeIndexInBlock() {\n        const ret = wasm.notelocation_nodeIndexInBlock(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) NoteLocation.prototype[Symbol.dispose] = NoteLocation.prototype.free;\n\nconst NoteMetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notemetadata_free(ptr >>> 0, 1));\n\nclass NoteMetadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteMetadata.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteMetadataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteMetadataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notemetadata_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} sender\n     * @param {NoteType} note_type\n     * @param {NoteTag} note_tag\n     * @param {NoteExecutionHint} note_execution_hint\n     * @param {Felt | null} [aux]\n     */\n    constructor(sender, note_type, note_tag, note_execution_hint, aux) {\n        _assertClass(sender, AccountId);\n        _assertClass(note_tag, NoteTag);\n        _assertClass(note_execution_hint, NoteExecutionHint);\n        let ptr0 = 0;\n        if (!isLikeNone(aux)) {\n            _assertClass(aux, Felt);\n            ptr0 = aux.__destroy_into_raw();\n        }\n        const ret = wasm.notemetadata_new(sender.__wbg_ptr, note_type, note_tag.__wbg_ptr, note_execution_hint.__wbg_ptr, ptr0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteMetadataFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {AccountId}\n     */\n    sender() {\n        const ret = wasm.notemetadata_sender(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteTag}\n     */\n    tag() {\n        const ret = wasm.notedetailsandtag_tag(this.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @returns {NoteType}\n     */\n    noteType() {\n        const ret = wasm.notemetadata_noteType(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) NoteMetadata.prototype[Symbol.dispose] = NoteMetadata.prototype.free;\n\nconst NoteRecipientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noterecipient_free(ptr >>> 0, 1));\n\nclass NoteRecipient {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteRecipient.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteRecipientFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof NoteRecipient)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteRecipientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noterecipient_free(ptr, 0);\n    }\n    /**\n     * @param {Word} serial_num\n     * @param {NoteScript} note_script\n     * @param {NoteInputs} inputs\n     */\n    constructor(serial_num, note_script, inputs) {\n        _assertClass(serial_num, Word);\n        _assertClass(note_script, NoteScript);\n        _assertClass(inputs, NoteInputs);\n        const ret = wasm.noterecipient_new(serial_num.__wbg_ptr, note_script.__wbg_ptr, inputs.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        NoteRecipientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Word}\n     */\n    digest() {\n        const ret = wasm.accountheader_storageCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    serialNum() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    script() {\n        const ret = wasm.noterecipient_script(this.__wbg_ptr);\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteInputs}\n     */\n    inputs() {\n        const ret = wasm.noterecipient_inputs(this.__wbg_ptr);\n        return NoteInputs.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteRecipient.prototype[Symbol.dispose] = NoteRecipient.prototype.free;\n\nconst NoteRecipientArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_noterecipientarray_free(ptr >>> 0, 1));\n\nclass NoteRecipientArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteRecipientArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_noterecipientarray_free(ptr, 0);\n    }\n    /**\n     * @param {NoteRecipient[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.noterecipientarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        NoteRecipientArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {NoteRecipient}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.noterecipientarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteRecipient.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {NoteRecipient} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, NoteRecipient);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.noterecipientarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {NoteRecipient} element\n     */\n    push(element) {\n        _assertClass(element, NoteRecipient);\n        wasm.noterecipientarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.noterecipientarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteRecipientArray.prototype[Symbol.dispose] = NoteRecipientArray.prototype.free;\n\nconst NoteScriptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notescript_free(ptr >>> 0, 1));\n\nclass NoteScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteScript.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteScriptFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteScriptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notescript_free(ptr, 0);\n    }\n    /**\n     * Print the MAST source for this script.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notescript_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.notescript_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {NoteScript}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.notescript_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static p2id() {\n        const ret = wasm.notescript_p2id();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static p2ide() {\n        const ret = wasm.notescript_p2ide();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {NoteScript}\n     */\n    static swap() {\n        const ret = wasm.notescript_swap();\n        return NoteScript.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.notescript_root(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) NoteScript.prototype[Symbol.dispose] = NoteScript.prototype.free;\n\nconst NoteTagFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_notetag_free(ptr >>> 0, 1));\n\nclass NoteTag {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NoteTag.prototype);\n        obj.__wbg_ptr = ptr;\n        NoteTagFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NoteTagFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_notetag_free(ptr, 0);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {NoteTag}\n     */\n    static fromAccountId(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.notetag_fromAccountId(account_id.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {number} use_case_id\n     * @param {number} payload\n     * @param {NoteExecutionMode} execution\n     * @returns {NoteTag}\n     */\n    static forPublicUseCase(use_case_id, payload, execution) {\n        _assertClass(execution, NoteExecutionMode);\n        const ret = wasm.notetag_forPublicUseCase(use_case_id, payload, execution.__wbg_ptr);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @param {number} use_case_id\n     * @param {number} payload\n     * @returns {NoteTag}\n     */\n    static forLocalUseCase(use_case_id, payload) {\n        const ret = wasm.notetag_forLocalUseCase(use_case_id, payload);\n        return NoteTag.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isSingleTarget() {\n        const ret = wasm.notetag_isSingleTarget(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {NoteExecutionMode}\n     */\n    executionMode() {\n        const ret = wasm.notetag_executionMode(this.__wbg_ptr);\n        return NoteExecutionMode.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    asU32() {\n        const ret = wasm.notetag_asU32(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) NoteTag.prototype[Symbol.dispose] = NoteTag.prototype.free;\n\nconst OutputNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnote_free(ptr >>> 0, 1));\n\nclass OutputNote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputNote.prototype);\n        obj.__wbg_ptr = ptr;\n        OutputNoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof OutputNote)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnote_free(ptr, 0);\n    }\n    /**\n     * @param {Note} note\n     * @returns {OutputNote}\n     */\n    static full(note) {\n        _assertClass(note, Note);\n        const ret = wasm.outputnote_full(note.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @param {PartialNote} partial_note\n     * @returns {OutputNote}\n     */\n    static partial(partial_note) {\n        _assertClass(partial_note, PartialNote);\n        const ret = wasm.outputnote_partial(partial_note.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @param {NoteHeader} note_header\n     * @returns {OutputNote}\n     */\n    static header(note_header) {\n        _assertClass(note_header, NoteHeader);\n        const ret = wasm.outputnote_header(note_header.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets | undefined}\n     */\n    assets() {\n        const ret = wasm.outputnote_assets(this.__wbg_ptr);\n        return ret === 0 ? undefined : NoteAssets.__wrap(ret);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.outputnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    recipientDigest() {\n        const ret = wasm.outputnote_recipientDigest(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.outputnote_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNote}\n     */\n    shrink() {\n        const ret = wasm.outputnote_shrink(this.__wbg_ptr);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {Note | undefined}\n     */\n    intoFull() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.outputnote_intoFull(ptr);\n        return ret === 0 ? undefined : Note.__wrap(ret);\n    }\n}\nif (Symbol.dispose) OutputNote.prototype[Symbol.dispose] = OutputNote.prototype.free;\n\nconst OutputNoteArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotearray_free(ptr >>> 0, 1));\n\nclass OutputNoteArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNoteArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotearray_free(ptr, 0);\n    }\n    /**\n     * @param {OutputNote[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.outputnotearray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        OutputNoteArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {OutputNote}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotearray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNote.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {OutputNote} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, OutputNote);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.outputnotearray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {OutputNote} element\n     */\n    push(element) {\n        _assertClass(element, OutputNote);\n        wasm.outputnotearray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotearray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) OutputNoteArray.prototype[Symbol.dispose] = OutputNoteArray.prototype.free;\n\nconst OutputNotesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotes_free(ptr >>> 0, 1));\n\nclass OutputNotes {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OutputNotes.prototype);\n        obj.__wbg_ptr = ptr;\n        OutputNotesFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof OutputNotes)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNotesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotes_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    commitment() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    numNotes() {\n        const ret = wasm.outputnotes_numNotes(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        const ret = wasm.outputnotes_isEmpty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {OutputNote}\n     */\n    getNote(index) {\n        const ret = wasm.outputnotes_getNote(this.__wbg_ptr, index);\n        return OutputNote.__wrap(ret);\n    }\n    /**\n     * @returns {OutputNote[]}\n     */\n    notes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotes_notes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) OutputNotes.prototype[Symbol.dispose] = OutputNotes.prototype.free;\n\nconst OutputNotesArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_outputnotesarray_free(ptr >>> 0, 1));\n\nclass OutputNotesArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OutputNotesArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_outputnotesarray_free(ptr, 0);\n    }\n    /**\n     * @param {OutputNotes[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.outputnotesarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        OutputNotesArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {OutputNotes}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.outputnotesarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {OutputNotes} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, OutputNotes);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.outputnotesarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {OutputNotes} element\n     */\n    push(element) {\n        _assertClass(element, OutputNotes);\n        wasm.outputnotesarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotesarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) OutputNotesArray.prototype[Symbol.dispose] = OutputNotesArray.prototype.free;\n\nconst PackageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_package_free(ptr >>> 0, 1));\n\nclass Package {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Package.prototype);\n        obj.__wbg_ptr = ptr;\n        PackageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PackageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_package_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.package_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Package}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.package_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Package.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) Package.prototype[Symbol.dispose] = Package.prototype.free;\n\nconst PartialNoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_partialnote_free(ptr >>> 0, 1));\n\nclass PartialNote {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PartialNoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_partialnote_free(ptr, 0);\n    }\n    /**\n     * @returns {NoteId}\n     */\n    id() {\n        const ret = wasm.partialnote_id(this.__wbg_ptr);\n        return NoteId.__wrap(ret);\n    }\n    /**\n     * @returns {NoteMetadata}\n     */\n    metadata() {\n        const ret = wasm.note_metadata(this.__wbg_ptr);\n        return NoteMetadata.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    recipientDigest() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {NoteAssets}\n     */\n    assets() {\n        const ret = wasm.partialnote_assets(this.__wbg_ptr);\n        return NoteAssets.__wrap(ret);\n    }\n}\nif (Symbol.dispose) PartialNote.prototype[Symbol.dispose] = PartialNote.prototype.free;\n\nconst ProvenTransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_proventransaction_free(ptr >>> 0, 1));\n/**\n * WASM wrapper around the native [`ProvenTransaction`].\n */\nclass ProvenTransaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvenTransaction.prototype);\n        obj.__wbg_ptr = ptr;\n        ProvenTransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProvenTransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proventransaction_free(ptr, 0);\n    }\n    /**\n     * Serializes the proven transaction into bytes.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.proventransaction_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a proven transaction from bytes.\n     * @param {Uint8Array} bytes\n     * @returns {ProvenTransaction}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proventransaction_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvenTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Returns the transaction ID.\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.proventransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * Returns the account ID the transaction was executed against.\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.proventransaction_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * Returns the reference block number used during execution.\n     * @returns {number}\n     */\n    refBlockNumber() {\n        const ret = wasm.proventransaction_refBlockNumber(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Returns the block number at which the transaction expires.\n     * @returns {number}\n     */\n    expirationBlockNumber() {\n        const ret = wasm.proventransaction_expirationBlockNumber(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Returns notes created by this transaction.\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.proventransaction_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * Returns the commitment of the reference block.\n     * @returns {Word}\n     */\n    refBlockCommitment() {\n        const ret = wasm.proventransaction_refBlockCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * Returns the nullifiers of the consumed input notes.\n     * @returns {Word[]}\n     */\n    nullifiers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proventransaction_nullifiers(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ProvenTransaction.prototype[Symbol.dispose] = ProvenTransaction.prototype.free;\n\nconst PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0, 1));\n\nclass PublicKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PublicKey.prototype);\n        obj.__wbg_ptr = ptr;\n        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PublicKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.publickey_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PublicKey}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Word} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        _assertClass(message, Word);\n        _assertClass(signature, Signature);\n        const ret = wasm.publickey_verify(this.__wbg_ptr, message.__wbg_ptr, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Word}\n     */\n    toCommitment() {\n        const ret = wasm.publickey_toCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @param {Word} message\n     * @param {Signature} signature\n     * @returns {PublicKey}\n     */\n    static recoverFrom(message, signature) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(message, Word);\n            _assertClass(signature, Signature);\n            wasm.publickey_recoverFrom(retptr, message.__wbg_ptr, signature.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {SigningInputs} signing_inputs\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verifyData(signing_inputs, signature) {\n        _assertClass(signing_inputs, SigningInputs);\n        _assertClass(signature, Signature);\n        const ret = wasm.publickey_verifyData(this.__wbg_ptr, signing_inputs.__wbg_ptr, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\nif (Symbol.dispose) PublicKey.prototype[Symbol.dispose] = PublicKey.prototype.free;\n\nconst RpcClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rpcclient_free(ptr >>> 0, 1));\n/**\n * RPC Client for interacting with Miden nodes directly.\n */\nclass RpcClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RpcClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rpcclient_free(ptr, 0);\n    }\n    /**\n     * Creates a new RPC client instance.\n     *\n     * @param endpoint - Endpoint to connect to.\n     * @param {Endpoint} endpoint\n     */\n    constructor(endpoint) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(endpoint, Endpoint);\n            var ptr0 = endpoint.__destroy_into_raw();\n            wasm.rpcclient_new(retptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            RpcClientFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Fetches notes by their IDs from the connected Miden node.\n     *\n     * @param note_ids - Array of [`NoteId`] objects to fetch\n     * @returns Promise that resolves to  different data depending on the note type:\n     * - Private notes: Returns only `note_id` and `metadata`. The `input_note` field will be\n     *   `null`.\n     * - Public notes: Returns the full `input_note` with inclusion proof, alongside metadata and\n     *   ID.\n     * @param {NoteId[]} note_ids\n     * @returns {Promise<FetchedNote[]>}\n     */\n    getNotesById(note_ids) {\n        const ptr0 = passArrayJsValueToWasm0(note_ids, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rpcclient_getNotesById(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Fetches a note script by its root hash from the connected Miden node.\n     *\n     * @param `script_root` The root hash of the note script to fetch\n     * @returns Promise that resolves to the `NoteScript`\n     * @param {Word} script_root\n     * @returns {Promise<NoteScript>}\n     */\n    getNoteScriptByRoot(script_root) {\n        _assertClass(script_root, Word);\n        var ptr0 = script_root.__destroy_into_raw();\n        const ret = wasm.rpcclient_getNoteScriptByRoot(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) RpcClient.prototype[Symbol.dispose] = RpcClient.prototype.free;\n\nconst Rpo256Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rpo256_free(ptr >>> 0, 1));\n\nclass Rpo256 {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Rpo256Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rpo256_free(ptr, 0);\n    }\n    /**\n     * @param {FeltArray} felt_array\n     * @returns {Word}\n     */\n    static hashElements(felt_array) {\n        _assertClass(felt_array, FeltArray);\n        const ret = wasm.rpo256_hashElements(felt_array.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) Rpo256.prototype[Symbol.dispose] = Rpo256.prototype.free;\n\nconst ScriptBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_scriptbuilder_free(ptr >>> 0, 1));\n\nclass ScriptBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ScriptBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        ScriptBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ScriptBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptbuilder_free(ptr, 0);\n    }\n    /**\n     * Given a module path (something like `my_lib::module`) and source code, this will\n     * statically link it for use with scripts to be built with this builder.\n     * @param {string} module_path\n     * @param {string} module_code\n     */\n    linkModule(module_path, module_code) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(module_path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(module_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_linkModule(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Statically links the given library.\n     *\n     * Static linking means the library code is copied into the script code.\n     * Use this for most libraries that are not available on-chain.\n     *\n     * Receives as argument the library to link.\n     * @param {Library} library\n     */\n    linkStaticLibrary(library) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(library, Library);\n            wasm.scriptbuilder_linkStaticLibrary(retptr, this.__wbg_ptr, library.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * This is useful to dynamically link the [`Library`] of a foreign account\n     * that is invoked using foreign procedure invocation (FPI). Its code is available\n     * on-chain and so it does not have to be copied into the script code.\n     *\n     * For all other use cases not involving FPI, link the library statically.\n     * Receives as argument the library to be linked.\n     * @param {Library} library\n     */\n    linkDynamicLibrary(library) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(library, Library);\n            wasm.scriptbuilder_linkDynamicLibrary(retptr, this.__wbg_ptr, library.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Transaction Script's source code, compiles it with the available\n     * modules under this builder. Returns the compiled script.\n     * @param {string} tx_script\n     * @returns {TransactionScript}\n     */\n    compileTxScript(tx_script) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(tx_script, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_compileTxScript(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Note Script's source code, compiles it with the available\n     * modules under this builder. Returns the compiled script.\n     * @param {string} program\n     * @returns {NoteScript}\n     */\n    compileNoteScript(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_compileNoteScript(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteScript.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Given a Library Path, and a source code, turn it into a Library.\n     * E.g. A path library can be `miden::my_contract`. When turned into a library,\n     * this can be used from another script with an import statement, following the\n     * previous example: `use.miden::my_contract'.\n     * @param {string} library_path\n     * @param {string} source_code\n     * @returns {Library}\n     */\n    buildLibrary(library_path, source_code) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(library_path, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(source_code, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.scriptbuilder_buildLibrary(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Library.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) ScriptBuilder.prototype[Symbol.dispose] = ScriptBuilder.prototype.free;\n\nconst SecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_secretkey_free(ptr >>> 0, 1));\n\nclass SecretKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SecretKey.prototype);\n        obj.__wbg_ptr = ptr;\n        SecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SecretKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array | null} [seed]\n     * @returns {SecretKey}\n     */\n    static rpoFalconWithRNG(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_rpoFalconWithRNG(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [seed]\n     * @returns {SecretKey}\n     */\n    static ecdsaWithRNG(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_ecdsaWithRNG(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {PublicKey}\n     */\n    publicKey() {\n        const ret = wasm.secretkey_publicKey(this.__wbg_ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n     * @param {Word} message\n     * @returns {Signature}\n     */\n    sign(message) {\n        _assertClass(message, Word);\n        const ret = wasm.secretkey_sign(this.__wbg_ptr, message.__wbg_ptr);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * @param {SigningInputs} signing_inputs\n     * @returns {Signature}\n     */\n    signData(signing_inputs) {\n        _assertClass(signing_inputs, SigningInputs);\n        const ret = wasm.secretkey_signData(this.__wbg_ptr, signing_inputs.__wbg_ptr);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.secretkey_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SecretKey}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SecretKey.prototype[Symbol.dispose] = SecretKey.prototype.free;\n\nconst SerializedInputNoteDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedinputnotedata_free(ptr >>> 0, 1));\n\nclass SerializedInputNoteData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedInputNoteData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedInputNoteDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedInputNoteData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedInputNoteDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedinputnotedata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteAssets(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get serialNumber() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_serialNumber(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set serialNumber(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_serialNumber(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get inputs() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set inputs(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteScriptRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteScriptRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteScriptRoot(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteScriptRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteScript() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteScript(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteScript(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteScript(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get nullifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_codeRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set nullifier(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_codeRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get stateDiscriminant() {\n        const ret = wasm.__wbg_get_serializedinputnotedata_stateDiscriminant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set stateDiscriminant(arg0) {\n        wasm.__wbg_set_serializedinputnotedata_stateDiscriminant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set state(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_state(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get createdAt() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_accountCommitment(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set createdAt(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_accountCommitment(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedInputNoteData.prototype[Symbol.dispose] = SerializedInputNoteData.prototype.free;\n\nconst SerializedOutputNoteDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedoutputnotedata_free(ptr >>> 0, 1));\n\nclass SerializedOutputNoteData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedOutputNoteData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedOutputNoteDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedOutputNoteData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedOutputNoteDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedoutputnotedata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get noteId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set noteId(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get noteAssets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set noteAssets(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get recipientDigest() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set recipientDigest(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get metadata() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set metadata(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    get nullifier() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedoutputnotedata_nullifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string | null} [arg0]\n     */\n    set nullifier(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedoutputnotedata_nullifier(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get expectedHeight() {\n        const ret = wasm.__wbg_get_serializedoutputnotedata_expectedHeight(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set expectedHeight(arg0) {\n        wasm.__wbg_set_serializedoutputnotedata_expectedHeight(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get stateDiscriminant() {\n        const ret = wasm.__wbg_get_serializedoutputnotedata_stateDiscriminant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set stateDiscriminant(arg0) {\n        wasm.__wbg_set_serializedoutputnotedata_stateDiscriminant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedoutputnotedata_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set state(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedoutputnotedata_state(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedOutputNoteData.prototype[Symbol.dispose] = SerializedOutputNoteData.prototype.free;\n\nconst SerializedTransactionDataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_serializedtransactiondata_free(ptr >>> 0, 1));\n\nclass SerializedTransactionData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SerializedTransactionData.prototype);\n        obj.__wbg_ptr = ptr;\n        SerializedTransactionDataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SerializedTransactionData)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SerializedTransactionDataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_serializedtransactiondata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsaccountupdate_storageRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set id(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsaccountupdate_storageRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get details() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_noteAssets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set details(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_noteAssets(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    get scriptRoot() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedtransactiondata_scriptRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [arg0]\n     */\n    set scriptRoot(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedtransactiondata_scriptRoot(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    get txScript() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedtransactiondata_txScript(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array | null} [arg0]\n     */\n    set txScript(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedtransactiondata_txScript(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get blockNum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_jsstoragemapentry_value(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set blockNum(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_jsstoragemapentry_value(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {number}\n     */\n    get statusVariant() {\n        const ret = wasm.__wbg_get_serializedtransactiondata_statusVariant(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set statusVariant(arg0) {\n        wasm.__wbg_set_serializedtransactiondata_statusVariant(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    get status() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_serializedinputnotedata_inputs(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} arg0\n     */\n    set status(arg0) {\n        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_serializedinputnotedata_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) SerializedTransactionData.prototype[Symbol.dispose] = SerializedTransactionData.prototype.free;\n\nconst SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr >>> 0, 1));\n\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.signature_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Signature}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Signature.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Word} message\n     * @returns {Felt[]}\n     */\n    toPreparedSignature(message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(message, Word);\n            var ptr0 = message.__destroy_into_raw();\n            wasm.signature_toPreparedSignature(retptr, this.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v2 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Signature.prototype[Symbol.dispose] = Signature.prototype.free;\n\nconst SigningInputsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signinginputs_free(ptr >>> 0, 1));\n\nclass SigningInputs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SigningInputs.prototype);\n        obj.__wbg_ptr = ptr;\n        SigningInputsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SigningInputsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signinginputs_free(ptr, 0);\n    }\n    /**\n     * @param {TransactionSummary} summary\n     * @returns {SigningInputs}\n     */\n    static newTransactionSummary(summary) {\n        _assertClass(summary, TransactionSummary);\n        var ptr0 = summary.__destroy_into_raw();\n        const ret = wasm.signinginputs_newTransactionSummary(ptr0);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @param {Felt[]} felts\n     * @returns {SigningInputs}\n     */\n    static newArbitrary(felts) {\n        const ptr0 = passArrayJsValueToWasm0(felts, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signinginputs_newArbitrary(ptr0, len0);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @param {Word} word\n     * @returns {SigningInputs}\n     */\n    static newBlind(word) {\n        _assertClass(word, Word);\n        const ret = wasm.signinginputs_newBlind(word.__wbg_ptr);\n        return SigningInputs.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionSummary}\n     */\n    transactionSummaryPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_transactionSummaryPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    arbitraryPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_arbitraryPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return FeltArray.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    blindPayload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_blindPayload(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {SigningInputsType}\n     */\n    get variantType() {\n        const ret = wasm.signinginputs_variantType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word}\n     */\n    toCommitment() {\n        const ret = wasm.signinginputs_toCommitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    toElements() {\n        const ret = wasm.signinginputs_toElements(this.__wbg_ptr);\n        return FeltArray.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.signinginputs_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SigningInputs}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signinginputs_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SigningInputs.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SigningInputs.prototype[Symbol.dispose] = SigningInputs.prototype.free;\n\nconst SlotAndKeysFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_slotandkeys_free(ptr >>> 0, 1));\n\nclass SlotAndKeys {\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof SlotAndKeys)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SlotAndKeysFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_slotandkeys_free(ptr, 0);\n    }\n    /**\n     * @param {number} storage_slot_index\n     * @param {Word[]} storage_map_keys\n     */\n    constructor(storage_slot_index, storage_map_keys) {\n        const ptr0 = passArrayJsValueToWasm0(storage_map_keys, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.slotandkeys_new(storage_slot_index, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        SlotAndKeysFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    storage_slot_index() {\n        const ret = wasm.slotandkeys_storage_slot_index(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Word[]}\n     */\n    storage_map_keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.slotandkeys_storage_map_keys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) SlotAndKeys.prototype[Symbol.dispose] = SlotAndKeys.prototype.free;\n\nconst StorageMapFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storagemap_free(ptr >>> 0, 1));\n\nclass StorageMap {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageMapFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storagemap_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.storagemap_new();\n        this.__wbg_ptr = ret >>> 0;\n        StorageMapFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {Word} key\n     * @param {Word} value\n     * @returns {Word}\n     */\n    insert(key, value) {\n        _assertClass(key, Word);\n        _assertClass(value, Word);\n        const ret = wasm.storagemap_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) StorageMap.prototype[Symbol.dispose] = StorageMap.prototype.free;\n\nconst StorageSlotFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storageslot_free(ptr >>> 0, 1));\n\nclass StorageSlot {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(StorageSlot.prototype);\n        obj.__wbg_ptr = ptr;\n        StorageSlotFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof StorageSlot)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageSlotFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storageslot_free(ptr, 0);\n    }\n    /**\n     * @param {Word} value\n     * @returns {StorageSlot}\n     */\n    static fromValue(value) {\n        _assertClass(value, Word);\n        const ret = wasm.storageslot_fromValue(value.__wbg_ptr);\n        return StorageSlot.__wrap(ret);\n    }\n    /**\n     * @returns {StorageSlot}\n     */\n    static emptyValue() {\n        const ret = wasm.storageslot_emptyValue();\n        return StorageSlot.__wrap(ret);\n    }\n    /**\n     * @param {StorageMap} storage_map\n     * @returns {StorageSlot}\n     */\n    static map(storage_map) {\n        _assertClass(storage_map, StorageMap);\n        const ret = wasm.storageslot_map(storage_map.__wbg_ptr);\n        return StorageSlot.__wrap(ret);\n    }\n}\nif (Symbol.dispose) StorageSlot.prototype[Symbol.dispose] = StorageSlot.prototype.free;\n\nconst StorageSlotArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_storageslotarray_free(ptr >>> 0, 1));\n\nclass StorageSlotArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        StorageSlotArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_storageslotarray_free(ptr, 0);\n    }\n    /**\n     * @param {StorageSlot[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.storageslotarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        StorageSlotArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {StorageSlot}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.storageslotarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return StorageSlot.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {StorageSlot} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, StorageSlot);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.storageslotarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {StorageSlot} element\n     */\n    push(element) {\n        _assertClass(element, StorageSlot);\n        wasm.storageslotarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.storageslotarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) StorageSlotArray.prototype[Symbol.dispose] = StorageSlotArray.prototype.free;\n\nconst SyncSummaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_syncsummary_free(ptr >>> 0, 1));\n\nclass SyncSummary {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SyncSummary.prototype);\n        obj.__wbg_ptr = ptr;\n        SyncSummaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SyncSummaryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncsummary_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.syncsummary_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {NoteId[]}\n     */\n    committedNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_committedNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteId[]}\n     */\n    consumedNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_consumedNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {AccountId[]}\n     */\n    updatedAccounts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_updatedAccounts(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {TransactionId[]}\n     */\n    committedTransactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_committedTransactions(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.syncsummary_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SyncSummary}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncsummary_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SyncSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) SyncSummary.prototype[Symbol.dispose] = SyncSummary.prototype.free;\n\nconst TestUtilsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_testutils_free(ptr >>> 0, 1));\n\nclass TestUtils {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TestUtilsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_testutils_free(ptr, 0);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    static createMockAccountId() {\n        const ret = wasm.testutils_createMockAccountId();\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    static createMockSerializedPackage() {\n        const ret = wasm.testutils_createMockSerializedPackage();\n        return takeObject(ret);\n    }\n}\nif (Symbol.dispose) TestUtils.prototype[Symbol.dispose] = TestUtils.prototype.free;\n\nconst TokenSymbolFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokensymbol_free(ptr >>> 0, 1));\n\nclass TokenSymbol {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TokenSymbol.prototype);\n        obj.__wbg_ptr = ptr;\n        TokenSymbolFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenSymbolFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokensymbol_free(ptr, 0);\n    }\n    /**\n     * @param {string} symbol\n     */\n    constructor(symbol) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(symbol, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.tokensymbol_new(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            TokenSymbolFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokensymbol_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) TokenSymbol.prototype[Symbol.dispose] = TokenSymbol.prototype.free;\n\nconst TransactionArgsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionargs_free(ptr >>> 0, 1));\n\nclass TransactionArgs {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionArgs.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionArgsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionArgsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionargs_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionScript | undefined}\n     */\n    txScript() {\n        const ret = wasm.transactionargs_txScript(this.__wbg_ptr);\n        return ret === 0 ? undefined : TransactionScript.__wrap(ret);\n    }\n    /**\n     * @param {NoteId} note_id\n     * @returns {Word | undefined}\n     */\n    getNoteArgs(note_id) {\n        _assertClass(note_id, NoteId);\n        const ret = wasm.transactionargs_getNoteArgs(this.__wbg_ptr, note_id.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {AdviceInputs}\n     */\n    adviceInputs() {\n        const ret = wasm.transactionargs_adviceInputs(this.__wbg_ptr);\n        return AdviceInputs.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionArgs.prototype[Symbol.dispose] = TransactionArgs.prototype.free;\n\nconst TransactionFilterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionfilter_free(ptr >>> 0, 1));\n\nclass TransactionFilter {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionFilter.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionFilterFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionFilterFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionfilter_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionFilter}\n     */\n    static all() {\n        const ret = wasm.transactionfilter_all();\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @param {TransactionId[]} ids\n     * @returns {TransactionFilter}\n     */\n    static ids(ids) {\n        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionfilter_ids(ptr0, len0);\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionFilter}\n     */\n    static uncommitted() {\n        const ret = wasm.transactionfilter_uncommitted();\n        return TransactionFilter.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @returns {TransactionFilter}\n     */\n    static expiredBefore(block_num) {\n        const ret = wasm.transactionfilter_expiredBefore(block_num);\n        return TransactionFilter.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionFilter.prototype[Symbol.dispose] = TransactionFilter.prototype.free;\n\nconst TransactionIdFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionid_free(ptr >>> 0, 1));\n\nclass TransactionId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionId.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionIdFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof TransactionId)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionIdFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionid_free(ptr, 0);\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    asElements() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asElements(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    asBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    toHex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_toHex(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    inner() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionId.prototype[Symbol.dispose] = TransactionId.prototype.free;\n\nconst TransactionProverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionprover_free(ptr >>> 0, 1));\n\nclass TransactionProver {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionProver.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionProverFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionProverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionprover_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionProver}\n     */\n    static newLocalProver() {\n        const ret = wasm.transactionprover_newLocalProver();\n        return TransactionProver.__wrap(ret);\n    }\n    /**\n     * @param {string} endpoint\n     * @returns {TransactionProver}\n     */\n    static newRemoteProver(endpoint) {\n        const ptr0 = passStringToWasm0(endpoint, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionprover_newRemoteProver(ptr0, len0);\n        return TransactionProver.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    serialize() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionprover_serialize(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} prover_type\n     * @param {string | null} [endpoint]\n     * @returns {TransactionProver}\n     */\n    static deserialize(prover_type, endpoint) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(prover_type, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            var ptr1 = isLikeNone(endpoint) ? 0 : passStringToWasm0(endpoint, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transactionprover_deserialize(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionProver.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    endpoint() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionprover_endpoint(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionProver.prototype[Symbol.dispose] = TransactionProver.prototype.free;\n\nconst TransactionRecordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrecord_free(ptr >>> 0, 1));\n\nclass TransactionRecord {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRecord.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRecordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRecordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrecord_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * @returns {AccountId}\n     */\n    accountId() {\n        const ret = wasm.transactionrecord_accountId(this.__wbg_ptr);\n        return AccountId.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    initAccountState() {\n        const ret = wasm.transactionrecord_initAccountState(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word}\n     */\n    finalAccountState() {\n        const ret = wasm.transactionrecord_finalAccountState(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word[]}\n     */\n    inputNoteNullifiers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrecord_inputNoteNullifiers(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        const ret = wasm.transactionrecord_outputNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    blockNum() {\n        const ret = wasm.transactionrecord_blockNum(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {TransactionStatus}\n     */\n    transactionStatus() {\n        const ret = wasm.transactionrecord_transactionStatus(this.__wbg_ptr);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @returns {bigint}\n     */\n    creationTimestamp() {\n        const ret = wasm.transactionrecord_creationTimestamp(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n}\nif (Symbol.dispose) TransactionRecord.prototype[Symbol.dispose] = TransactionRecord.prototype.free;\n\nconst TransactionRequestFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrequest_free(ptr >>> 0, 1));\n\nclass TransactionRequest {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRequest.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRequestFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRequestFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrequest_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionrequest_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionRequest}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {Note[]}\n     */\n    expectedOutputOwnNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_expectedOutputOwnNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {NoteDetailsAndTag[]}\n     */\n    expectedFutureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionrequest_expectedFutureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    scriptArg() {\n        const ret = wasm.transactionrequest_scriptArg(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n    /**\n     * @returns {Word | undefined}\n     */\n    authArg() {\n        const ret = wasm.transactionrequest_authArg(this.__wbg_ptr);\n        return ret === 0 ? undefined : Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionRequest.prototype[Symbol.dispose] = TransactionRequest.prototype.free;\n\nconst TransactionRequestBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionrequestbuilder_free(ptr >>> 0, 1));\n\nclass TransactionRequestBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionRequestBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionRequestBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionRequestBuilderFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionrequestbuilder_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.transactionrequestbuilder_new();\n        this.__wbg_ptr = ret >>> 0;\n        TransactionRequestBuilderFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {NoteAndArgsArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withUnauthenticatedInputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, NoteAndArgsArray);\n        const ret = wasm.transactionrequestbuilder_withUnauthenticatedInputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteIdAndArgsArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withAuthenticatedInputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, NoteIdAndArgsArray);\n        const ret = wasm.transactionrequestbuilder_withAuthenticatedInputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {OutputNoteArray} notes\n     * @returns {TransactionRequestBuilder}\n     */\n    withOwnOutputNotes(notes) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(notes, OutputNoteArray);\n        const ret = wasm.transactionrequestbuilder_withOwnOutputNotes(ptr, notes.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {TransactionScript} script\n     * @returns {TransactionRequestBuilder}\n     */\n    withCustomScript(script) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(script, TransactionScript);\n        const ret = wasm.transactionrequestbuilder_withCustomScript(ptr, script.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteRecipientArray} recipients\n     * @returns {TransactionRequestBuilder}\n     */\n    withExpectedOutputRecipients(recipients) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(recipients, NoteRecipientArray);\n        const ret = wasm.transactionrequestbuilder_withExpectedOutputRecipients(ptr, recipients.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {NoteDetailsAndTagArray} note_details_and_tag\n     * @returns {TransactionRequestBuilder}\n     */\n    withExpectedFutureNotes(note_details_and_tag) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(note_details_and_tag, NoteDetailsAndTagArray);\n        const ret = wasm.transactionrequestbuilder_withExpectedFutureNotes(ptr, note_details_and_tag.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {AdviceMap} advice_map\n     * @returns {TransactionRequestBuilder}\n     */\n    extendAdviceMap(advice_map) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(advice_map, AdviceMap);\n        const ret = wasm.transactionrequestbuilder_extendAdviceMap(ptr, advice_map.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {ForeignAccountArray} foreign_accounts\n     * @returns {TransactionRequestBuilder}\n     */\n    withForeignAccounts(foreign_accounts) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(foreign_accounts, ForeignAccountArray);\n        const ret = wasm.transactionrequestbuilder_withForeignAccounts(ptr, foreign_accounts.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {Word} script_arg\n     * @returns {TransactionRequestBuilder}\n     */\n    withScriptArg(script_arg) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(script_arg, Word);\n        const ret = wasm.transactionrequestbuilder_withScriptArg(ptr, script_arg.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @param {Word} auth_arg\n     * @returns {TransactionRequestBuilder}\n     */\n    withAuthArg(auth_arg) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(auth_arg, Word);\n        const ret = wasm.transactionrequestbuilder_withAuthArg(ptr, auth_arg.__wbg_ptr);\n        return TransactionRequestBuilder.__wrap(ret);\n    }\n    /**\n     * @returns {TransactionRequest}\n     */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.transactionrequestbuilder_build(ptr);\n        return TransactionRequest.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionRequestBuilder.prototype[Symbol.dispose] = TransactionRequestBuilder.prototype.free;\n\nconst TransactionResultFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionresult_free(ptr >>> 0, 1));\n/**\n * WASM wrapper around the native [`TransactionResult`].\n */\nclass TransactionResult {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionResult.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionResultFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionResultFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionresult_free(ptr, 0);\n    }\n    /**\n     * Returns the ID of the transaction.\n     * @returns {TransactionId}\n     */\n    id() {\n        const ret = wasm.executedtransaction_id(this.__wbg_ptr);\n        return TransactionId.__wrap(ret);\n    }\n    /**\n     * Returns the executed transaction.\n     * @returns {ExecutedTransaction}\n     */\n    executedTransaction() {\n        const ret = wasm.transactionresult_executedTransaction(this.__wbg_ptr);\n        return ExecutedTransaction.__wrap(ret);\n    }\n    /**\n     * Returns notes that are expected to be created as a result of follow-up executions.\n     * @returns {NoteDetailsAndTag[]}\n     */\n    futureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionresult_futureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serializes the transaction result into bytes.\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionresult_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Deserializes a transaction result from bytes.\n     * @param {Uint8Array} bytes\n     * @returns {TransactionResult}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionresult_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionResult.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) TransactionResult.prototype[Symbol.dispose] = TransactionResult.prototype.free;\n\nconst TransactionScriptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscript_free(ptr >>> 0, 1));\n\nclass TransactionScript {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionScript.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionScriptFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscript_free(ptr, 0);\n    }\n    /**\n     * @returns {Word}\n     */\n    root() {\n        const ret = wasm.notescript_root(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionScript.prototype[Symbol.dispose] = TransactionScript.prototype.free;\n\nconst TransactionScriptInputPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscriptinputpair_free(ptr >>> 0, 1));\n\nclass TransactionScriptInputPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionScriptInputPair.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionScriptInputPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof TransactionScriptInputPair)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptInputPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscriptinputpair_free(ptr, 0);\n    }\n    /**\n     * @param {Word} word\n     * @param {FeltArray} felts\n     */\n    constructor(word, felts) {\n        _assertClass(word, Word);\n        var ptr0 = word.__destroy_into_raw();\n        _assertClass(felts, FeltArray);\n        const ret = wasm.transactionscriptinputpair_new(ptr0, felts.__wbg_ptr);\n        this.__wbg_ptr = ret >>> 0;\n        TransactionScriptInputPairFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Word}\n     */\n    word() {\n        const ret = wasm.accountcode_commitment(this.__wbg_ptr);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {FeltArray}\n     */\n    felts() {\n        const ret = wasm.transactionscriptinputpair_felts(this.__wbg_ptr);\n        return FeltArray.__wrap(ret);\n    }\n}\nif (Symbol.dispose) TransactionScriptInputPair.prototype[Symbol.dispose] = TransactionScriptInputPair.prototype.free;\n\nconst TransactionScriptInputPairArrayFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionscriptinputpairarray_free(ptr >>> 0, 1));\n\nclass TransactionScriptInputPairArray {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionScriptInputPairArrayFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionscriptinputpairarray_free(ptr, 0);\n    }\n    /**\n     * @param {TransactionScriptInputPair[] | null} [elements]\n     */\n    constructor(elements) {\n        var ptr0 = isLikeNone(elements) ? 0 : passArrayJsValueToWasm0(elements, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionscriptinputpairarray_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        TransactionScriptInputPairArrayFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get element at index, will always return a clone to avoid aliasing issues.\n     * @param {number} index\n     * @returns {TransactionScriptInputPair}\n     */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionscriptinputpairarray_get(retptr, this.__wbg_ptr, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionScriptInputPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} index\n     * @param {TransactionScriptInputPair} elem\n     */\n    replaceAt(index, elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, TransactionScriptInputPair);\n            var ptr0 = elem.__destroy_into_raw();\n            wasm.transactionscriptinputpairarray_replaceAt(retptr, this.__wbg_ptr, index, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {TransactionScriptInputPair} element\n     */\n    push(element) {\n        _assertClass(element, TransactionScriptInputPair);\n        wasm.transactionscriptinputpairarray_push(this.__wbg_ptr, element.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    length() {\n        const ret = wasm.outputnotesarray_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\nif (Symbol.dispose) TransactionScriptInputPairArray.prototype[Symbol.dispose] = TransactionScriptInputPairArray.prototype.free;\n\nconst TransactionStatusFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionstatus_free(ptr >>> 0, 1));\n\nclass TransactionStatus {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionStatus.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionStatusFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionStatusFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionstatus_free(ptr, 0);\n    }\n    /**\n     * @returns {TransactionStatus}\n     */\n    static pending() {\n        const ret = wasm.transactionstatus_pending();\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @param {number} block_num\n     * @param {bigint} commit_timestamp\n     * @returns {TransactionStatus}\n     */\n    static committed(block_num, commit_timestamp) {\n        const ret = wasm.transactionstatus_committed(block_num, commit_timestamp);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @param {string} cause\n     * @returns {TransactionStatus}\n     */\n    static discarded(cause) {\n        const ptr0 = passStringToWasm0(cause, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.transactionstatus_discarded(ptr0, len0);\n        return TransactionStatus.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isPending() {\n        const ret = wasm.transactionstatus_isPending(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isCommitted() {\n        const ret = wasm.transactionstatus_isCommitted(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isDiscarded() {\n        const ret = wasm.transactionstatus_isDiscarded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    getBlockNum() {\n        const ret = wasm.transactionstatus_getBlockNum(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {bigint | undefined}\n     */\n    getCommitTimestamp() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstatus_getCommitTimestamp(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionStatus.prototype[Symbol.dispose] = TransactionStatus.prototype.free;\n\nconst TransactionStoreUpdateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionstoreupdate_free(ptr >>> 0, 1));\n\nclass TransactionStoreUpdate {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionStoreUpdate.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionStoreUpdateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionStoreUpdateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionstoreupdate_free(ptr, 0);\n    }\n    /**\n     * @returns {ExecutedTransaction}\n     */\n    executedTransaction() {\n        const ret = wasm.transactionstoreupdate_executedTransaction(this.__wbg_ptr);\n        return ExecutedTransaction.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    submissionHeight() {\n        const ret = wasm.transactionstoreupdate_submissionHeight(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    createdNotes() {\n        const ret = wasm.transactionstoreupdate_createdNotes(this.__wbg_ptr);\n        return OutputNotes.__wrap(ret);\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        const ret = wasm.transactionstoreupdate_accountDelta(this.__wbg_ptr);\n        return AccountDelta.__wrap(ret);\n    }\n    /**\n     * @returns {NoteDetailsAndTag[]}\n     */\n    futureNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstoreupdate_futureNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionstoreupdate_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionStoreUpdate}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionstoreupdate_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionStoreUpdate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\nif (Symbol.dispose) TransactionStoreUpdate.prototype[Symbol.dispose] = TransactionStoreUpdate.prototype.free;\n\nconst TransactionSummaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transactionsummary_free(ptr >>> 0, 1));\n\nclass TransactionSummary {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TransactionSummary.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionSummaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionSummaryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionsummary_free(ptr, 0);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.transactionsummary_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionSummary}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionSummary.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {AccountDelta}\n     */\n    accountDelta() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_accountDelta(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return AccountDelta.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {InputNotes}\n     */\n    inputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_inputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return InputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {OutputNotes}\n     */\n    outputNotes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_outputNotes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OutputNotes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Word}\n     */\n    salt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionsummary_salt(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) TransactionSummary.prototype[Symbol.dispose] = TransactionSummary.prototype.free;\n\nconst WebClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_webclient_free(ptr >>> 0, 1));\n\nclass WebClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WebClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_webclient_free(ptr, 0);\n    }\n    /**\n     * @returns {Promise<AccountHeader[]>}\n     */\n    getAccounts() {\n        const ret = wasm.webclient_getAccounts(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<Account | undefined>}\n     */\n    getAccount(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.webclient_getAccount(this.__wbg_ptr, account_id.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Word} pub_key\n     * @returns {Promise<AuthSecretKey>}\n     */\n    getAccountAuthByPubKey(pub_key) {\n        _assertClass(pub_key, Word);\n        const ret = wasm.webclient_getAccountAuthByPubKey(this.__wbg_ptr, pub_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    insertAccountAddress(account_id, address) {\n        _assertClass(account_id, AccountId);\n        _assertClass(address, Address);\n        const ret = wasm.webclient_insertAccountAddress(this.__wbg_ptr, account_id.__wbg_ptr, address.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    removeAccountAddress(account_id, address) {\n        _assertClass(account_id, AccountId);\n        _assertClass(address, Address);\n        const ret = wasm.webclient_removeAccountAddress(this.__wbg_ptr, account_id.__wbg_ptr, address.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @param {string} export_type\n     * @returns {Promise<NoteFile>}\n     */\n    exportNoteFile(note_id, export_type) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(export_type, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_exportNoteFile(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return takeObject(ret);\n    }\n    /**\n     * Retrieves the entire underlying web store and returns it as a `JsValue`\n     *\n     * Meant to be used in conjunction with the `force_import_store` method\n     * @returns {Promise<any>}\n     */\n    exportStore() {\n        const ret = wasm.webclient_exportStore(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<AccountFile>}\n     */\n    exportAccountFile(account_id) {\n        _assertClass(account_id, AccountId);\n        var ptr0 = account_id.__destroy_into_raw();\n        const ret = wasm.webclient_exportAccountFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountFile} account_file\n     * @returns {Promise<any>}\n     */\n    importAccountFile(account_file) {\n        _assertClass(account_file, AccountFile);\n        var ptr0 = account_file.__destroy_into_raw();\n        const ret = wasm.webclient_importAccountFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} init_seed\n     * @param {boolean} mutable\n     * @param {number} auth_scheme_id\n     * @returns {Promise<Account>}\n     */\n    importPublicAccountFromSeed(init_seed, mutable, auth_scheme_id) {\n        const ptr0 = passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_importPublicAccountFromSeed(this.__wbg_ptr, ptr0, len0, mutable, auth_scheme_id);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} account_id\n     * @returns {Promise<any>}\n     */\n    importAccountById(account_id) {\n        _assertClass(account_id, AccountId);\n        const ret = wasm.webclient_importAccountById(this.__wbg_ptr, account_id.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFile} note_file\n     * @returns {Promise<NoteId>}\n     */\n    importNoteFile(note_file) {\n        _assertClass(note_file, NoteFile);\n        var ptr0 = note_file.__destroy_into_raw();\n        const ret = wasm.webclient_importNoteFile(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {any} store_dump\n     * @returns {Promise<any>}\n     */\n    forceImportStore(store_dump) {\n        const ret = wasm.webclient_forceImportStore(this.__wbg_ptr, addHeapObject(store_dump));\n        return takeObject(ret);\n    }\n    /**\n     * Creates a new client with a mock RPC API. Useful for testing purposes and proof-of-concept\n     * applications as it uses a mock chain that simulates the behavior of a real node.\n     * @param {Uint8Array | null} [seed]\n     * @param {Uint8Array | null} [serialized_mock_chain]\n     * @param {Uint8Array | null} [serialized_mock_note_transport_node]\n     * @returns {Promise<any>}\n     */\n    createMockClient(seed, serialized_mock_chain, serialized_mock_note_transport_node) {\n        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(serialized_mock_chain) ? 0 : passArray8ToWasm0(serialized_mock_chain, wasm.__wbindgen_export);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(serialized_mock_note_transport_node) ? 0 : passArray8ToWasm0(serialized_mock_note_transport_node, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createMockClient(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return takeObject(ret);\n    }\n    /**\n     * Returns the inner serialized mock chain if it exists.\n     * @returns {Uint8Array}\n     */\n    serializeMockChain() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_serializeMockChain(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the inner serialized mock note transport node if it exists.\n     * @returns {Uint8Array}\n     */\n    serializeMockNoteTransportNode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_serializeMockNoteTransportNode(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    proveBlock() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_proveBlock(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    usesMockChain() {\n        const ret = wasm.webclient_usesMockChain(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @param {boolean} mutable\n     * @param {number} auth_scheme_id\n     * @param {Uint8Array | null} [init_seed]\n     * @returns {Promise<Account>}\n     */\n    newWallet(storage_mode, mutable, auth_scheme_id, init_seed) {\n        _assertClass(storage_mode, AccountStorageMode);\n        var ptr0 = isLikeNone(init_seed) ? 0 : passArray8ToWasm0(init_seed, wasm.__wbindgen_export);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_newWallet(this.__wbg_ptr, storage_mode.__wbg_ptr, mutable, auth_scheme_id, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountStorageMode} storage_mode\n     * @param {boolean} non_fungible\n     * @param {string} token_symbol\n     * @param {number} decimals\n     * @param {bigint} max_supply\n     * @param {number} auth_scheme_id\n     * @returns {Promise<Account>}\n     */\n    newFaucet(storage_mode, non_fungible, token_symbol, decimals, max_supply, auth_scheme_id) {\n        _assertClass(storage_mode, AccountStorageMode);\n        const ptr0 = passStringToWasm0(token_symbol, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_newFaucet(this.__wbg_ptr, storage_mode.__wbg_ptr, non_fungible, ptr0, len0, decimals, max_supply, auth_scheme_id);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Account} account\n     * @param {boolean} overwrite\n     * @returns {Promise<void>}\n     */\n    newAccount(account, overwrite) {\n        _assertClass(account, Account);\n        const ret = wasm.webclient_newAccount(this.__wbg_ptr, account.__wbg_ptr, overwrite);\n        return takeObject(ret);\n    }\n    /**\n     * @param {SecretKey} secret_key\n     * @returns {Promise<void>}\n     */\n    addAccountSecretKeyToWebStore(secret_key) {\n        _assertClass(secret_key, SecretKey);\n        const ret = wasm.webclient_addAccountSecretKeyToWebStore(this.__wbg_ptr, secret_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Executes a transaction specified by the request against the specified account,\n     * proves it, submits it to the network, and updates the local database.\n     *\n     * If the transaction utilizes foreign account data, there is a chance that the client doesn't\n     * have the required block header in the local database. In these scenarios, a sync to\n     * the chain tip is performed, and the required block header is retrieved.\n     * @param {AccountId} account_id\n     * @param {TransactionRequest} transaction_request\n     * @returns {Promise<TransactionId>}\n     */\n    submitNewTransaction(account_id, transaction_request) {\n        _assertClass(account_id, AccountId);\n        _assertClass(transaction_request, TransactionRequest);\n        const ret = wasm.webclient_submitNewTransaction(this.__wbg_ptr, account_id.__wbg_ptr, transaction_request.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Executes a transaction specified by the request against the specified account but does not\n     * submit it to the network nor update the local database. The returned [`TransactionResult`]\n     * retains the execution artifacts needed to continue with the transaction lifecycle.\n     *\n     * If the transaction utilizes foreign account data, there is a chance that the client doesn't\n     * have the required block header in the local database. In these scenarios, a sync to\n     * the chain tip is performed, and the required block header is retrieved.\n     * @param {AccountId} account_id\n     * @param {TransactionRequest} transaction_request\n     * @returns {Promise<TransactionResult>}\n     */\n    executeTransaction(account_id, transaction_request) {\n        _assertClass(account_id, AccountId);\n        _assertClass(transaction_request, TransactionRequest);\n        const ret = wasm.webclient_executeTransaction(this.__wbg_ptr, account_id.__wbg_ptr, transaction_request.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Generates a transaction proof using either the provided prover or the client's default\n     * prover if none is supplied.\n     * @param {TransactionResult} transaction_result\n     * @param {TransactionProver | null} [prover]\n     * @returns {Promise<ProvenTransaction>}\n     */\n    proveTransaction(transaction_result, prover) {\n        _assertClass(transaction_result, TransactionResult);\n        let ptr0 = 0;\n        if (!isLikeNone(prover)) {\n            _assertClass(prover, TransactionProver);\n            ptr0 = prover.__destroy_into_raw();\n        }\n        const ret = wasm.webclient_proveTransaction(this.__wbg_ptr, transaction_result.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {ProvenTransaction} proven_transaction\n     * @param {TransactionResult} transaction_result\n     * @returns {Promise<number>}\n     */\n    submitProvenTransaction(proven_transaction, transaction_result) {\n        _assertClass(proven_transaction, ProvenTransaction);\n        _assertClass(transaction_result, TransactionResult);\n        const ret = wasm.webclient_submitProvenTransaction(this.__wbg_ptr, proven_transaction.__wbg_ptr, transaction_result.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {TransactionResult} transaction_result\n     * @param {number} submission_height\n     * @returns {Promise<TransactionStoreUpdate>}\n     */\n    applyTransaction(transaction_result, submission_height) {\n        _assertClass(transaction_result, TransactionResult);\n        const ret = wasm.webclient_applyTransaction(this.__wbg_ptr, transaction_result.__wbg_ptr, submission_height);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId} target_account_id\n     * @param {AccountId} faucet_id\n     * @param {NoteType} note_type\n     * @param {bigint} amount\n     * @returns {TransactionRequest}\n     */\n    newMintTransactionRequest(target_account_id, faucet_id, note_type, amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(target_account_id, AccountId);\n            _assertClass(faucet_id, AccountId);\n            wasm.webclient_newMintTransactionRequest(retptr, this.__wbg_ptr, target_account_id.__wbg_ptr, faucet_id.__wbg_ptr, note_type, amount);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender_account_id\n     * @param {AccountId} target_account_id\n     * @param {AccountId} faucet_id\n     * @param {NoteType} note_type\n     * @param {bigint} amount\n     * @param {number | null} [recall_height]\n     * @param {number | null} [timelock_height]\n     * @returns {TransactionRequest}\n     */\n    newSendTransactionRequest(sender_account_id, target_account_id, faucet_id, note_type, amount, recall_height, timelock_height) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender_account_id, AccountId);\n            _assertClass(target_account_id, AccountId);\n            _assertClass(faucet_id, AccountId);\n            wasm.webclient_newSendTransactionRequest(retptr, this.__wbg_ptr, sender_account_id.__wbg_ptr, target_account_id.__wbg_ptr, faucet_id.__wbg_ptr, note_type, amount, isLikeNone(recall_height) ? 0x100000001 : (recall_height) >>> 0, isLikeNone(timelock_height) ? 0x100000001 : (timelock_height) >>> 0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string[]} list_of_note_ids\n     * @returns {TransactionRequest}\n     */\n    newConsumeTransactionRequest(list_of_note_ids) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(list_of_note_ids, wasm.__wbindgen_export);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.webclient_newConsumeTransactionRequest(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {AccountId} sender_account_id\n     * @param {AccountId} offered_asset_faucet_id\n     * @param {bigint} offered_asset_amount\n     * @param {AccountId} requested_asset_faucet_id\n     * @param {bigint} requested_asset_amount\n     * @param {NoteType} note_type\n     * @param {NoteType} payback_note_type\n     * @returns {TransactionRequest}\n     */\n    newSwapTransactionRequest(sender_account_id, offered_asset_faucet_id, offered_asset_amount, requested_asset_faucet_id, requested_asset_amount, note_type, payback_note_type) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(sender_account_id, AccountId);\n            _assertClass(offered_asset_faucet_id, AccountId);\n            _assertClass(requested_asset_faucet_id, AccountId);\n            wasm.webclient_newSwapTransactionRequest(retptr, this.__wbg_ptr, sender_account_id.__wbg_ptr, offered_asset_faucet_id.__wbg_ptr, offered_asset_amount, requested_asset_faucet_id.__wbg_ptr, requested_asset_amount, note_type, payback_note_type);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionRequest.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Send a private note via the note transport layer\n     * @param {Note} note\n     * @param {Address} address\n     * @returns {Promise<void>}\n     */\n    sendPrivateNote(note, address) {\n        _assertClass(note, Note);\n        var ptr0 = note.__destroy_into_raw();\n        _assertClass(address, Address);\n        var ptr1 = address.__destroy_into_raw();\n        const ret = wasm.webclient_sendPrivateNote(this.__wbg_ptr, ptr0, ptr1);\n        return takeObject(ret);\n    }\n    /**\n     * Fetch private notes from the note transport layer\n     *\n     * Uses an internal pagination mechanism to avoid fetching duplicate notes.\n     * @returns {Promise<void>}\n     */\n    fetchPrivateNotes() {\n        const ret = wasm.webclient_fetchPrivateNotes(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Fetch all private notes from the note transport layer\n     *\n     * Fetches all notes stored in the transport layer, with no pagination.\n     * Prefer using [`WebClient::fetch_private_notes`] for a more efficient, on-going,\n     * fetching mechanism.\n     * @returns {Promise<void>}\n     */\n    fetchAllPrivateNotes() {\n        const ret = wasm.webclient_fetchAllPrivateNotes(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFilter} filter\n     * @returns {Promise<InputNoteRecord[]>}\n     */\n    getInputNotes(filter) {\n        _assertClass(filter, NoteFilter);\n        var ptr0 = filter.__destroy_into_raw();\n        const ret = wasm.webclient_getInputNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @returns {Promise<InputNoteRecord | undefined>}\n     */\n    getInputNote(note_id) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getInputNote(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteFilter} filter\n     * @returns {Promise<any>}\n     */\n    getOutputNotes(filter) {\n        _assertClass(filter, NoteFilter);\n        var ptr0 = filter.__destroy_into_raw();\n        const ret = wasm.webclient_getOutputNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} note_id\n     * @returns {Promise<any>}\n     */\n    getOutputNote(note_id) {\n        const ptr0 = passStringToWasm0(note_id, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getOutputNote(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {AccountId | null} [account_id]\n     * @returns {Promise<ConsumableNoteRecord[]>}\n     */\n    getConsumableNotes(account_id) {\n        let ptr0 = 0;\n        if (!isLikeNone(account_id)) {\n            _assertClass(account_id, AccountId);\n            ptr0 = account_id.__destroy_into_raw();\n        }\n        const ret = wasm.webclient_getConsumableNotes(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    /**\n     * Retrieves the setting value for `key`, or `None` if it hasnt been set.\n     * @param {string} key\n     * @returns {Promise<any | undefined>}\n     */\n    getSetting(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_getSetting(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Sets a setting key-value in the store. It can then be retrieved using `get_setting`.\n     * @param {string} key\n     * @param {any} value\n     * @returns {Promise<void>}\n     */\n    setSetting(key, value) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_setSetting(this.__wbg_ptr, ptr0, len0, addHeapObject(value));\n        return takeObject(ret);\n    }\n    /**\n     * Deletes a setting key-value from the store.\n     * @param {string} key\n     * @returns {Promise<void>}\n     */\n    removeSetting(key) {\n        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_removeSetting(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * Returns all the existing setting keys from the store.\n     * @returns {Promise<string[]>}\n     */\n    listSettingKeys() {\n        const ret = wasm.webclient_listSettingKeys(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<SyncSummary>}\n     */\n    syncState() {\n        const ret = wasm.webclient_syncState(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<number>}\n     */\n    getSyncHeight() {\n        const ret = wasm.webclient_getSyncHeight(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {NoteType} note_type\n     * @param {AccountId} offered_asset_faucet_id\n     * @param {bigint} offered_asset_amount\n     * @param {AccountId} requested_asset_faucet_id\n     * @param {bigint} requested_asset_amount\n     * @returns {NoteTag}\n     */\n    static buildSwapTag(note_type, offered_asset_faucet_id, offered_asset_amount, requested_asset_faucet_id, requested_asset_amount) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(offered_asset_faucet_id, AccountId);\n            _assertClass(requested_asset_faucet_id, AccountId);\n            wasm.webclient_buildSwapTag(retptr, note_type, offered_asset_faucet_id.__wbg_ptr, offered_asset_amount, requested_asset_faucet_id.__wbg_ptr, requested_asset_amount);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NoteTag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} tag\n     * @returns {Promise<void>}\n     */\n    addTag(tag) {\n        const ptr0 = passStringToWasm0(tag, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_addTag(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @param {string} tag\n     * @returns {Promise<void>}\n     */\n    removeTag(tag) {\n        const ptr0 = passStringToWasm0(tag, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_removeTag(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Promise<any>}\n     */\n    listTags() {\n        const ret = wasm.webclient_listTags(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {TransactionFilter} transaction_filter\n     * @returns {Promise<TransactionRecord[]>}\n     */\n    getTransactions(transaction_filter) {\n        _assertClass(transaction_filter, TransactionFilter);\n        var ptr0 = transaction_filter.__destroy_into_raw();\n        const ret = wasm.webclient_getTransactions(this.__wbg_ptr, ptr0);\n        return takeObject(ret);\n    }\n    constructor() {\n        const ret = wasm.webclient_new();\n        this.__wbg_ptr = ret >>> 0;\n        WebClientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Creates a new client with the given node URL and optional seed.\n     * If `node_url` is `None`, it defaults to the testnet endpoint.\n     * @param {string | null} [node_url]\n     * @param {string | null} [node_note_transport_url]\n     * @param {Uint8Array | null} [seed]\n     * @returns {Promise<any>}\n     */\n    createClient(node_url, node_note_transport_url, seed) {\n        var ptr0 = isLikeNone(node_url) ? 0 : passStringToWasm0(node_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(node_note_transport_url) ? 0 : passStringToWasm0(node_note_transport_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createClient(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        return takeObject(ret);\n    }\n    /**\n     * Creates a new client with the given node URL, optional seed, and external keystore\n     * callbacks. If `node_url` is `None`, it defaults to the testnet endpoint.\n     * @param {string | null} [node_url]\n     * @param {string | null} [node_note_transport_url]\n     * @param {Uint8Array | null} [seed]\n     * @param {Function | null} [get_key_cb]\n     * @param {Function | null} [insert_key_cb]\n     * @param {Function | null} [sign_cb]\n     * @returns {Promise<any>}\n     */\n    createClientWithExternalKeystore(node_url, node_note_transport_url, seed, get_key_cb, insert_key_cb, sign_cb) {\n        var ptr0 = isLikeNone(node_url) ? 0 : passStringToWasm0(node_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(node_note_transport_url) ? 0 : passStringToWasm0(node_note_transport_url, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_export);\n        var len2 = WASM_VECTOR_LEN;\n        const ret = wasm.webclient_createClientWithExternalKeystore(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, isLikeNone(get_key_cb) ? 0 : addHeapObject(get_key_cb), isLikeNone(insert_key_cb) ? 0 : addHeapObject(insert_key_cb), isLikeNone(sign_cb) ? 0 : addHeapObject(sign_cb));\n        return takeObject(ret);\n    }\n    /**\n     * @returns {ScriptBuilder}\n     */\n    createScriptBuilder() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.webclient_createScriptBuilder(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ScriptBuilder.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) WebClient.prototype[Symbol.dispose] = WebClient.prototype.free;\n\nconst WordFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_word_free(ptr >>> 0, 1));\n\nclass Word {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Word.prototype);\n        obj.__wbg_ptr = ptr;\n        WordFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Word)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        WordFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_word_free(ptr, 0);\n    }\n    /**\n     * @param {BigUint64Array} u64_vec\n     */\n    constructor(u64_vec) {\n        const ptr0 = passArray64ToWasm0(u64_vec, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.word_new(ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        WordFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Creates a Word from a hex string.\n     * Fails if the provided string is not a valid hex representation of a Word.\n     * @param {string} hex\n     * @returns {Word}\n     */\n    static fromHex(hex) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.word_fromHex(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Felt[]} felt_vec\n     * @returns {Word}\n     */\n    static newFromFelts(felt_vec) {\n        const ptr0 = passArrayJsValueToWasm0(felt_vec, wasm.__wbindgen_export);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.word_newFromFelts(ptr0, len0);\n        return Word.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toHex() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_toHex(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    serialize() {\n        const ret = wasm.word_serialize(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Word}\n     */\n    static deserialize(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.word_deserialize(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Word.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {BigUint64Array}\n     */\n    toU64s() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.word_toU64s(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU64FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 8, 8);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Felt[]}\n     */\n    toFelts() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionid_asElements(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export3(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nif (Symbol.dispose) Word.prototype[Symbol.dispose] = Word.prototype.free;\n\nconst EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_Error_e83987f665cf5504 = function(arg0, arg1) {\n        const ret = Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_Number_bb48ca12f395cd08 = function(arg0) {\n        const ret = Number(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_bigint_get_as_i64_f3ebc5a755000afd = function(arg0, arg1) {\n        const v = getObject(arg1);\n        const ret = typeof(v) === 'bigint' ? v : undefined;\n        getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbg___wbindgen_boolean_get_6d5a1ee65bab5f68 = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? v : undefined;\n        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n    };\n    imports.wbg.__wbg___wbindgen_debug_string_df47ffb5e35e6763 = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_in_bb933bd9e1b3bc0f = function(arg0, arg1) {\n        const ret = getObject(arg0) in getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_bigint_cb320707dcd35f0b = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'bigint';\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_function_ee8a6c5833c90377 = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_null_5e69f72e906cc57c = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_object_c818261d21f283a4 = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_is_undefined_2d472862bd29a478 = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_jsval_eq_6b13ab83478b1c50 = function(arg0, arg1) {\n        const ret = getObject(arg0) === getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_jsval_loose_eq_b664b38a2f582147 = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg___wbindgen_number_get_a20bf9b85341449d = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbg___wbindgen_string_get_e4f06c90489ad01b = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export, wasm.__wbindgen_export2);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg___wbindgen_throw_b855445ff6a94295 = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg__wbg_cb_unref_2454a539ea5790d9 = function(arg0) {\n        getObject(arg0)._wbg_cb_unref();\n    };\n    imports.wbg.__wbg_abort_28ad55c5825b004d = function(arg0, arg1) {\n        getObject(arg0).abort(getObject(arg1));\n    };\n    imports.wbg.__wbg_abort_e7eb059f72f9ed0c = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_account_new = function(arg0) {\n        const ret = Account.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_account_unwrap = function(arg0) {\n        const ret = Account.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_accountfile_new = function(arg0) {\n        const ret = AccountFile.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountheader_new = function(arg0) {\n        const ret = AccountHeader.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountid_new = function(arg0) {\n        const ret = AccountId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_accountid_unwrap = function(arg0) {\n        const ret = AccountId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_addNoteTag_948ab4cc7d3d784b = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getStringFromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        let v2;\n        if (arg4 !== 0) {\n            v2 = getStringFromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n        }\n        const ret = addNoteTag(v0, v1, v2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_b577eb3a177bc0fa = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_applyStateSync_687415d1bcf4dd8a = function(arg0) {\n        const ret = applyStateSync(JsStateSyncUpdate.__wrap(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_authsecretkey_new = function(arg0) {\n        const ret = AuthSecretKey.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_body_587542b2fd8e06c0 = function(arg0) {\n        const ret = getObject(arg0).body;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_ccc4520b36d3ccf4 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_byobRequest_2344e6975f27456e = function(arg0) {\n        const ret = getObject(arg0).byobRequest;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_byteLength_bcd42e4025299788 = function(arg0) {\n        const ret = getObject(arg0).byteLength;\n        return ret;\n    };\n    imports.wbg.__wbg_byteOffset_ca3a6cf7944b364b = function(arg0) {\n        const ret = getObject(arg0).byteOffset;\n        return ret;\n    };\n    imports.wbg.__wbg_call_525440f72fbfc0ea = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e45d2cf9fc925fcf = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e762c39fa8ea36bf = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_cancel_48ab6f9dc366e369 = function(arg0) {\n        const ret = getObject(arg0).cancel();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_catch_943836faa5d29bfb = function(arg0, arg1) {\n        const ret = getObject(arg0).catch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_clearTimeout_2e2c4939388cdfbb = function(arg0) {\n        const ret = clearTimeout(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_close_5a6caed3231b68cd = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_close_6956df845478561a = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_consumablenoterecord_new = function(arg0) {\n        const ret = ConsumableNoteRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_done_2042aa2670fb1db1 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_enqueue_7b18a650aec77898 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).enqueue(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_exportStore_13b5274b45367269 = function() {\n        const ret = exportStore();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_felt_new = function(arg0) {\n        const ret = Felt.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_felt_unwrap = function(arg0) {\n        const ret = Felt.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fetch_53eef7df7b439a49 = function(arg0, arg1) {\n        const ret = fetch(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_8725865ff47e7fcc = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).fetch(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetchednote_new = function(arg0) {\n        const ret = FetchedNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_forceImportStore_e4f1437d6b4cff0e = function(arg0) {\n        const ret = forceImportStore(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_foreignaccount_unwrap = function(arg0) {\n        const ret = ForeignAccount.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fungibleasset_new = function(arg0) {\n        const ret = FungibleAsset.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fungibleasset_unwrap = function(arg0) {\n        const ret = FungibleAsset.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_fungibleassetdeltaitem_new = function(arg0) {\n        const ret = FungibleAssetDeltaItem.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountAddresses_57dcaf04403ffff6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountAddresses(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountAuthByPubKey_a99268a0c5e781fc = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountAuthByPubKey(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountCode_255c47880027604f = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountCode(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountHeaderByCommitment_2457b381278acd9d = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountHeaderByCommitment(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountHeader_3e3c0fd16ce78046 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountHeader(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountIds_1dc3cc9beb00dac4 = function() {\n        const ret = getAccountIds();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountStorageMaps_52d390f59d39870a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getAccountStorageMaps(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getAccountStorage_e7e314d3a8c68188 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountStorage(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAccountVaultAssets_058aa7a3e85f9d7e = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getAccountVaultAssets(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getAllAccountHeaders_21ae58fbd74bc207 = function() {\n        const ret = getAllAccountHeaders();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getBlockHeaders_ffbe629419e49f24 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getBlockHeaders(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getForeignAccountCode_84f81a9fb264b2a8 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getForeignAccountCode(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotesFromIds_a4814ff3ee6838f4 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getInputNotesFromIds(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotesFromNullifiers_b125192521cb2707 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getInputNotesFromNullifiers(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getInputNotes_9e7daab3e11aada9 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = getInputNotes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getNoteScript_8db4a87f1daa5732 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getNoteScript(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getNoteTags_445672fbda7617ca = function() {\n        const ret = getNoteTags();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotesFromIds_a9f95eee5aea111a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getOutputNotesFromIds(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotesFromNullifiers_15708419209f0017 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getOutputNotesFromNullifiers(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getOutputNotes_7e9034b7845d8547 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = getOutputNotes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainNodesAll_f7b99da4ecc2cf67 = function() {\n        const ret = getPartialBlockchainNodesAll();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainNodes_4b59f3cf3d67885a = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = getPartialBlockchainNodes(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getPartialBlockchainPeaksByBlockNum_c3683954cf872601 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getPartialBlockchainPeaksByBlockNum(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getRandomValues_1c61fac11405ffdc = function() { return handleError(function (arg0, arg1) {\n        globalThis.crypto.getRandomValues(getArrayU8FromWasm0(arg0, arg1));\n    }, arguments) };\n    imports.wbg.__wbg_getReader_48e00749fe3f6089 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).getReader();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_getSetting_30d487e26ed3ecff = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getSetting(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getSyncHeight_f7c4ff032d6e8719 = function() {\n        const ret = getSyncHeight();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_14776bfb48a1bff9 = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_getTrackedBlockHeaders_0e922af05410981b = function() {\n        const ret = getTrackedBlockHeaders();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTransactions_7511822ed7df4a04 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = getTransactions(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getUnspentInputNoteNullifiers_a53ee1887b305122 = function() {\n        const ret = getUnspentInputNoteNullifiers();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_7bed016f185add81 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_done_a0463af43a1fc764 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n    };\n    imports.wbg.__wbg_get_efcb449f58ec27c2 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_value_5ce96c9f81ce7398 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_with_ref_key_1dc361bd10053bfe = function(arg0, arg1) {\n        const ret = getObject(arg0)[getObject(arg1)];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getproceduresresultitem_new = function(arg0) {\n        const ret = GetProceduresResultItem.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_787fafc980c3ccdb = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_headers_b87d7eaba61c3278 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_inputnote_new = function(arg0) {\n        const ret = InputNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_inputnoterecord_new = function(arg0) {\n        const ret = InputNoteRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_insertAccountAddress_819a7abb57d5c50e = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = insertAccountAddress(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertAccountAuth_88fdf1ae9cfe0155 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            deferred1_0 = arg2;\n            deferred1_1 = arg3;\n            const ret = insertAccountAuth(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertBlockHeader_5e4c39a64aba945d = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            var v2 = getArrayU8FromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n            const ret = insertBlockHeader(getStringFromWasm0(arg0, arg1), v1, v2, arg6 !== 0);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertPartialBlockchainNodes_5139cc9702ff0a99 = function(arg0, arg1, arg2, arg3) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        var v1 = getArrayJsValueFromWasm0(arg2, arg3).slice();\n        wasm.__wbindgen_export3(arg2, arg3 * 4, 4);\n        const ret = insertPartialBlockchainNodes(v0, v1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_insertSetting_1e2fa0de524f2782 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = insertSetting(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_insertTransactionScript_8e5b6d2bcc70c826 = function(arg0, arg1, arg2, arg3) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        const ret = insertTransactionScript(v0, v1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_70beb1189ca63b38 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Promise_001fdd42afa1b7ef = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Promise;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_20c8e73002f7af98 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_isArray_96e0af9891d0945d = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_isSafeInteger_d216eda7911dde36 = function(arg0) {\n        const ret = Number.isSafeInteger(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_e5822695327a3c39 = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsaccountupdate_new = function(arg0) {\n        const ret = JsAccountUpdate.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsaccountupdate_unwrap = function(arg0) {\n        const ret = JsAccountUpdate.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsstoragemapentry_new = function(arg0) {\n        const ret = JsStorageMapEntry.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsstoragemapentry_unwrap = function(arg0) {\n        const ret = JsStorageMapEntry.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsstorageslot_new = function(arg0) {\n        const ret = JsStorageSlot.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsstorageslot_unwrap = function(arg0) {\n        const ret = JsStorageSlot.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_jsvaultasset_new = function(arg0) {\n        const ret = JsVaultAsset.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_jsvaultasset_unwrap = function(arg0) {\n        const ret = JsVaultAsset.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_length_69bca3cb64fc8748 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_cdd215e10d9dd507 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_listSettingKeys_6940be01c27a8e08 = function() {\n        const ret = listSettingKeys();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_lockAccount_17e6307335343eaa = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = lockAccount(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_new_0_f9740686d739025c = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_1acc0b6eea89d040 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_2531773dac38ebb3 = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_3c3d849046688a66 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wasm_bindgen_func_elem_3677(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_new_5a79be3ab53b8aa5 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_9edf9838a2def39c = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_a7442b4b19c1a356 = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_e17d9f43105b08be = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_from_slice_92f4d78ca282a2d2 = function(arg0, arg1) {\n        const ret = new Uint8Array(getArrayU8FromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_no_args_ee98eee5275000a4 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_with_byte_offset_and_length_46e3e6a5e9f9e89b = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_with_str_and_init_0ae7728b6ec367b1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_020810e0ae8ebcb0 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_2c826fe5dfec6b6a = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_note_new = function(arg0) {\n        const ret = Note.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteandargs_unwrap = function(arg0) {\n        const ret = NoteAndArgs.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noteconsumability_new = function(arg0) {\n        const ret = NoteConsumability.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteconsumability_unwrap = function(arg0) {\n        const ret = NoteConsumability.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notedetailsandtag_new = function(arg0) {\n        const ret = NoteDetailsAndTag.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_notedetailsandtag_unwrap = function(arg0) {\n        const ret = NoteDetailsAndTag.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notefile_new = function(arg0) {\n        const ret = NoteFile.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteid_new = function(arg0) {\n        const ret = NoteId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_noteid_unwrap = function(arg0) {\n        const ret = NoteId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noteidandargs_unwrap = function(arg0) {\n        const ret = NoteIdAndArgs.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_noterecipient_unwrap = function(arg0) {\n        const ret = NoteRecipient.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_notescript_new = function(arg0) {\n        const ret = NoteScript.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_openDatabase_f242cd782d300916 = function() {\n        const ret = openDatabase();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_outputnote_new = function(arg0) {\n        const ret = OutputNote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_outputnote_unwrap = function(arg0) {\n        const ret = OutputNote.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_outputnotes_unwrap = function(arg0) {\n        const ret = OutputNotes.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_prototypesetcall_2a6620b6922694b2 = function(arg0, arg1, arg2) {\n        Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), getObject(arg2));\n    };\n    imports.wbg.__wbg_proventransaction_new = function(arg0) {\n        const ret = ProvenTransaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_pruneIrrelevantBlocks_ce5174b85cbd83fa = function() {\n        const ret = pruneIrrelevantBlocks();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_34d692c25c47d05b = function(arg0) {\n        const ret = getObject(arg0).queueMicrotask;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_9d76cacb20c84d58 = function(arg0) {\n        queueMicrotask(getObject(arg0));\n    };\n    imports.wbg.__wbg_read_48f1593df542f968 = function(arg0) {\n        const ret = getObject(arg0).read();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_releaseLock_5d0b5a68887b891d = function(arg0) {\n        getObject(arg0).releaseLock();\n    };\n    imports.wbg.__wbg_removeAccountAddress_94b451fd5476b672 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        const ret = removeAccountAddress(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_removeNoteTag_550b0385167f2dcf = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        let v1;\n        if (arg2 !== 0) {\n            v1 = getStringFromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n        }\n        let v2;\n        if (arg4 !== 0) {\n            v2 = getStringFromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n        }\n        const ret = removeNoteTag(v0, v1, v2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_removeSetting_9f59cbfbe95f4843 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            const ret = removeSetting(getStringFromWasm0(arg0, arg1));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_resolve_caf97c30b83f7053 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_respond_0f4dbf5386f5c73e = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).respond(arg1 >>> 0);\n    }, arguments) };\n    imports.wbg.__wbg_serializedinputnotedata_new = function(arg0) {\n        const ret = SerializedInputNoteData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedinputnotedata_unwrap = function(arg0) {\n        const ret = SerializedInputNoteData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_serializedoutputnotedata_new = function(arg0) {\n        const ret = SerializedOutputNoteData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedoutputnotedata_unwrap = function(arg0) {\n        const ret = SerializedOutputNoteData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_serializedtransactiondata_new = function(arg0) {\n        const ret = SerializedTransactionData.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_serializedtransactiondata_unwrap = function(arg0) {\n        const ret = SerializedTransactionData.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_setTimeout_929c97a7c0f23d36 = function(arg0, arg1) {\n        const ret = setTimeout(getObject(arg0), arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_8b342d8cd9d2a02c = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_set_9e6516df7b7d0f19 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_set_body_3c365989753d61f4 = function(arg0, arg1) {\n        getObject(arg0).body = getObject(arg1);\n    };\n    imports.wbg.__wbg_set_c213c871859d6500 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_set_c2abbebe8b9ebee1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_set_cache_2f9deb19b92b81e3 = function(arg0, arg1) {\n        getObject(arg0).cache = __wbindgen_enum_RequestCache[arg1];\n    };\n    imports.wbg.__wbg_set_credentials_f621cd2d85c0c228 = function(arg0, arg1) {\n        getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];\n    };\n    imports.wbg.__wbg_set_headers_6926da238cd32ee4 = function(arg0, arg1) {\n        getObject(arg0).headers = getObject(arg1);\n    };\n    imports.wbg.__wbg_set_integrity_62a46fc792832f41 = function(arg0, arg1, arg2) {\n        getObject(arg0).integrity = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_method_c02d8cbbe204ac2d = function(arg0, arg1, arg2) {\n        getObject(arg0).method = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_mode_52ef73cfa79639cb = function(arg0, arg1) {\n        getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];\n    };\n    imports.wbg.__wbg_set_redirect_df0285496ec45ff8 = function(arg0, arg1) {\n        getObject(arg0).redirect = __wbindgen_enum_RequestRedirect[arg1];\n    };\n    imports.wbg.__wbg_set_referrer_ec9cf8a8a315d50c = function(arg0, arg1, arg2) {\n        getObject(arg0).referrer = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_set_referrer_policy_99c1f299b4e37446 = function(arg0, arg1) {\n        getObject(arg0).referrerPolicy = __wbindgen_enum_ReferrerPolicy[arg1];\n    };\n    imports.wbg.__wbg_set_signal_dda2cf7ccb6bee0f = function(arg0, arg1) {\n        getObject(arg0).signal = getObject(arg1);\n    };\n    imports.wbg.__wbg_signal_4db5aa055bf9eb9a = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_slotandkeys_unwrap = function(arg0) {\n        const ret = SlotAndKeys.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_89e1d9ac6a1b250e = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_8b530f326a9e48ac = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_6fdf4b64710cc91b = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_b45bfc5a37f6cfa2 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_status_de7eed5a7a5bfd5d = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_storageslot_unwrap = function(arg0) {\n        const ret = StorageSlot.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_syncsummary_new = function(arg0) {\n        const ret = SyncSummary.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_4f46f6544e6b4a28 = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_70d05cf780a18d77 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_toString_7da7c8dbec78fcb8 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionid_new = function(arg0) {\n        const ret = TransactionId.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionid_unwrap = function(arg0) {\n        const ret = TransactionId.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_transactionrecord_new = function(arg0) {\n        const ret = TransactionRecord.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionresult_new = function(arg0) {\n        const ret = TransactionResult.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transactionscriptinputpair_unwrap = function(arg0) {\n        const ret = TransactionScriptInputPair.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_transactionstoreupdate_new = function(arg0) {\n        const ret = TransactionStoreUpdate.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_undoAccountStates_fe9da382937036bd = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = undoAccountStates(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertAccountCode_c93e9111b2c73274 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = upsertAccountCode(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertAccountRecord_88843ee6a71cc8b3 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred1_0;\n        let deferred1_1;\n        let deferred2_0;\n        let deferred2_1;\n        let deferred3_0;\n        let deferred3_1;\n        let deferred4_0;\n        let deferred4_1;\n        let deferred5_0;\n        let deferred5_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            deferred1_0 = arg2;\n            deferred1_1 = arg3;\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            deferred3_0 = arg6;\n            deferred3_1 = arg7;\n            deferred4_0 = arg8;\n            deferred4_1 = arg9;\n            deferred5_0 = arg11;\n            deferred5_1 = arg12;\n            let v6;\n            if (arg13 !== 0) {\n                v6 = getArrayU8FromWasm0(arg13, arg14).slice();\n                wasm.__wbindgen_export3(arg13, arg14 * 1, 1);\n            }\n            const ret = upsertAccountRecord(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7), getStringFromWasm0(arg8, arg9), arg10 !== 0, getStringFromWasm0(arg11, arg12), v6);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred1_0, deferred1_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n            wasm.__wbindgen_export3(deferred3_0, deferred3_1, 1);\n            wasm.__wbindgen_export3(deferred4_0, deferred4_1, 1);\n            wasm.__wbindgen_export3(deferred5_0, deferred5_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertAccountStorage_71aea983d8e45253 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertAccountStorage(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertForeignAccountCode_a2ffdd0deb87c063 = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            const ret = upsertForeignAccountCode(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5));\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertInputNote_7733702c48e2ae17 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred4_0;\n        let deferred4_1;\n        let deferred6_0;\n        let deferred6_1;\n        let deferred7_0;\n        let deferred7_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            var v2 = getArrayU8FromWasm0(arg4, arg5).slice();\n            wasm.__wbindgen_export3(arg4, arg5 * 1, 1);\n            var v3 = getArrayU8FromWasm0(arg6, arg7).slice();\n            wasm.__wbindgen_export3(arg6, arg7 * 1, 1);\n            deferred4_0 = arg8;\n            deferred4_1 = arg9;\n            var v5 = getArrayU8FromWasm0(arg10, arg11).slice();\n            wasm.__wbindgen_export3(arg10, arg11 * 1, 1);\n            deferred6_0 = arg12;\n            deferred6_1 = arg13;\n            deferred7_0 = arg14;\n            deferred7_1 = arg15;\n            var v8 = getArrayU8FromWasm0(arg17, arg18).slice();\n            wasm.__wbindgen_export3(arg17, arg18 * 1, 1);\n            const ret = upsertInputNote(getStringFromWasm0(arg0, arg1), v1, v2, v3, getStringFromWasm0(arg8, arg9), v5, getStringFromWasm0(arg12, arg13), getStringFromWasm0(arg14, arg15), arg16, v8);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred4_0, deferred4_1, 1);\n            wasm.__wbindgen_export3(deferred6_0, deferred6_1, 1);\n            wasm.__wbindgen_export3(deferred7_0, deferred7_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertNoteScript_3c569a673eff21c9 = function(arg0, arg1, arg2, arg3) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            const ret = upsertNoteScript(getStringFromWasm0(arg0, arg1), v1);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertOutputNote_1a9c6b80bc3b2979 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            var v3 = getArrayU8FromWasm0(arg6, arg7).slice();\n            wasm.__wbindgen_export3(arg6, arg7 * 1, 1);\n            let v4;\n            if (arg8 !== 0) {\n                v4 = getStringFromWasm0(arg8, arg9).slice();\n                wasm.__wbindgen_export3(arg8, arg9 * 1, 1);\n            }\n            var v5 = getArrayU8FromWasm0(arg12, arg13).slice();\n            wasm.__wbindgen_export3(arg12, arg13 * 1, 1);\n            const ret = upsertOutputNote(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5), v3, v4, arg10 >>> 0, arg11, v5);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertStorageMapEntries_57da734cbee448bf = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertStorageMapEntries(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_upsertTransactionRecord_e4a8b05f1b3714ea = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {\n        let deferred0_0;\n        let deferred0_1;\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            var v1 = getArrayU8FromWasm0(arg2, arg3).slice();\n            wasm.__wbindgen_export3(arg2, arg3 * 1, 1);\n            deferred2_0 = arg4;\n            deferred2_1 = arg5;\n            var v3 = getArrayU8FromWasm0(arg7, arg8).slice();\n            wasm.__wbindgen_export3(arg7, arg8 * 1, 1);\n            let v4;\n            if (arg9 !== 0) {\n                v4 = getArrayU8FromWasm0(arg9, arg10).slice();\n                wasm.__wbindgen_export3(arg9, arg10 * 1, 1);\n            }\n            const ret = upsertTransactionRecord(getStringFromWasm0(arg0, arg1), v1, getStringFromWasm0(arg4, arg5), arg6, v3, v4);\n            return addHeapObject(ret);\n        } finally {\n            wasm.__wbindgen_export3(deferred0_0, deferred0_1, 1);\n            wasm.__wbindgen_export3(deferred2_0, deferred2_1, 1);\n        }\n    };\n    imports.wbg.__wbg_upsertVaultAssets_ce549ede4457df6e = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        const ret = upsertVaultAssets(v0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_value_692627309814bb8c = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_view_f6c15ac9fed63bbd = function(arg0) {\n        const ret = getObject(arg0).view;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_word_new = function(arg0) {\n        const ret = Word.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_word_unwrap = function(arg0) {\n        const ret = Word.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_cast_1ff30c89f8c13d4b = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"TransactionRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_2241b6af4c4b2941 = function(arg0, arg1) {\n        // Cast intrinsic for `Ref(String) -> Externref`.\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_25a0a844437d0e92 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"string\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_298dfd99998f1bbf = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"ConsumableNoteRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_3186144f3014a6e9 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"FetchedNote\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_356a649c76ea3d4a = function(arg0, arg1) {\n        // Cast intrinsic for `Closure(Closure { dtor_idx: 516, function: Function { arguments: [], shim_idx: 517, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n        const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_9308, __wasm_bindgen_func_elem_9309);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_4625c577ab2ec9ee = function(arg0) {\n        // Cast intrinsic for `U64 -> Externref`.\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_61180cf2da5580dc = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"AccountHeader\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_77bc3e92745e9a35 = function(arg0, arg1) {\n        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 1, 1);\n        // Cast intrinsic for `Vector(U8) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_a0c9c97993851672 = function(arg0, arg1) {\n        var v0 = getArrayJsValueFromWasm0(arg0, arg1).slice();\n        wasm.__wbindgen_export3(arg0, arg1 * 4, 4);\n        // Cast intrinsic for `Vector(NamedExternref(\"InputNoteRecord\")) -> Externref`.\n        const ret = v0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_c8873871663829dd = function(arg0, arg1) {\n        // Cast intrinsic for `Closure(Closure { dtor_idx: 516, function: Function { arguments: [Externref], shim_idx: 521, ret: Unit, inner_ret: Some(Unit) }, mutable: true }) -> Externref`.\n        const ret = makeMutClosure(arg0, arg1, wasm.__wasm_bindgen_func_elem_9308, __wasm_bindgen_func_elem_9375);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cast_d6cd19b81560fd6e = function(arg0) {\n        // Cast intrinsic for `F64 -> Externref`.\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n\n    return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedBigUint64ArrayMemory0 = null;\n    cachedDataViewMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module);\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path);\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n        }\n    }\n\n\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nconst module = /* asset import */ new __webpack_require__.U(__webpack_require__(/*! assets/miden_client_web.wasm */ \"(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/workers/assets/miden_client_web.wasm\"));\n                \n                    await __wbg_init({ module_or_path: module });\n\n\n//# sourceMappingURL=Cargo-acbd8ac5-acbd8ac5.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGVtb3gtbGFicy9taWRlbi1zZGsvZGlzdC93b3JrZXJzL0NhcmdvLWFjYmQ4YWM1LWFjYmQ4YWM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3hGLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJFQUEyRTtBQUMxRixlQUFlLDZEQUE2RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxtREFBbUQsMkJBQTJCLElBQUksMEJBQTBCLG9CQUFvQjtBQUN6TSx3RUFBd0Usb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQ0FBbUMsa0NBQWtDO0FBQ3JFLDBDQUEwQyw0QkFBNEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx1QkFBdUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkNBQTJDLElBQUk7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGLGNBQWM7QUFDZCw2RUFBNkUsNEJBQTRCO0FBQ3pHLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNkNBQTZDO0FBQ3hHO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QixjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJEQUEyRDtBQUMxRyxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MscUNBQXFDO0FBQ3JDLFVBQVU7QUFDVix3QkFBd0IsbUJBQW1CLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxxQ0FBcUM7QUFDckMsVUFBVTtBQUNWO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RCxxQ0FBcUM7QUFDckMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUF1RCxzQkFBc0Isc0NBQXNDLHNCQUFzQixzQkFBc0IsdUNBQXVDO0FBQ3RRLDZDQUE2Qyx5Q0FBeUMsSUFBSTtBQUMxRixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsdURBQXVELHdCQUF3QjtBQUMvSTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixtQkFBbUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtEQUFrRCxxQ0FBcUM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBeUQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsbURBQW1EO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RCx5REFBeUQsbURBQW1EO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGdCQUFnQjtBQUM1RyxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJFQUEyRTtBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9FQUFvRSxJQUFJLCtDQUErQztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RSw0Q0FBNEMsc0NBQXNDO0FBQ2xGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwwQ0FBMEM7QUFDbkcscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5Qiw2Q0FBNkM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UseUJBQXlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDZCQUE2QjtBQUNsSCwrQkFBK0IsaUJBQWlCLGlEQUFpRDtBQUNqRztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2REFBNkQ7QUFDN0Q7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVELGlGQUFpRixzQ0FBc0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUZBQWlGO0FBQzdILGNBQWMsd0JBQXdCLGlGQUFpRjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQixpRkFBaUYsSUFBSTtBQUNoTCx3Q0FBd0MsaUZBQWlGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQiwyQ0FBMkMsSUFBSTtBQUMxSSx3Q0FBd0MsNEVBQTRFO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkIsb0RBQW9ELElBQUk7QUFDbkosd0NBQXdDLDRFQUE0RTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkIsbUNBQW1DLHNDQUFzQyxJQUFJO0FBQzFILGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1RkFBdUY7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1RkFBdUY7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQkFBbUI7QUFDakYscUVBQXFFLHVCQUF1QjtBQUM1RjtBQUNBO0FBQ0EsNENBQTRDLDBDQUEwQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBDQUEwQztBQUN0RixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esc0ZBQXNGLG1CQUFtQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFDQUFxQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDZCQUE2QixtQkFBbUIsMEJBQTBCO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUNBQW1DO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHlFQUF5RSxzQkFBc0IsbUJBQW1CLGtCQUFrQixVQUFVLGlCQUFpQixnQkFBZ0IsVUFBVTtBQUN6TCwrRUFBK0Usc0JBQXNCO0FBQ3JHO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxzQ0FBc0M7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4Q0FBOEM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCLG9DQUFvQztBQUNwRjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxlQUFlO0FBQzVFLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx3QkFBd0IsNENBQTRDLGFBQWE7QUFDekk7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHlCQUF5QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdDQUFnQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOENBQThDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0Isa0RBQWtELElBQUkscUJBQXFCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0IsbURBQW1ELElBQUk7QUFDakg7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdUJBQXVCLHVDQUF1QztBQUNqSCx3REFBd0QscURBQXFEO0FBQzdHO0FBQ0EseURBQXlELGVBQWUsWUFBWTtBQUNwRjtBQUNBLGtJQUFrSSx1QkFBdUI7QUFDeko7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx3QkFBd0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCw2REFBNkQsa0JBQWtCO0FBQy9FLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkVBQTZFO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQXdEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUVBQWlFO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkJBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDZDQUE2QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw4Q0FBOEM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0RBQW9EO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHVDQUF1QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsK0JBQStCO0FBQ2xHO0FBQ0E7QUFDQSxtRUFBbUUsb0JBQW9CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsNkJBQTZCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsNkJBQTZCLDRCQUE0QixJQUFJO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtEQUFrRDtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw0Q0FBNEM7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLG1DQUFtQztBQUNuQztBQUNBLDhDQUE4Qyw0Q0FBNEM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUErQztBQUNqRixrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0MsZ0RBQWdEO0FBQ2xGLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3RkFBd0Y7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQ0FBZ0M7QUFDN0Y7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsOENBQThDO0FBQzVILHVFQUF1RSw4Q0FBOEM7QUFDckg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdFQUFnRSxtQkFBbUIsK0RBQStEO0FBQ2pNO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw2QkFBNkI7QUFDL0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQ0FBa0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDRGQUE0RixnQ0FBZ0M7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QixzQ0FBc0M7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0ZBQWtGO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0RBQXdEO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixvQkFBb0I7QUFDL0c7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsb0RBQW9ELHFCQUFxQixlQUFlO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpQkFBaUIsNkJBQTZCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUNBQW1DO0FBQ2pHO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdDQUF3QztBQUN6RztBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdDQUFnQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQStCO0FBQy9FO0FBQ0EsbUVBQW1FLG9FQUFvRTtBQUN2STtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxtREFBbUQsb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdFQUF3RTtBQUMzSDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxzQ0FBc0M7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdDQUFnQztBQUM3RjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsaUVBQWlFLHNDQUFzQztBQUN2RztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtHQUFrRyx1QkFBdUI7QUFDekg7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsMEJBQTBCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUF3RDtBQUN2RSxlQUFlLDZCQUE2QjtBQUM1QywwQ0FBMEMsOEJBQThCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0RBQW9ELDJDQUEyQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDJDQUEyQztBQUNqSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0QsK0NBQStDLDZCQUE2QjtBQUM1RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsVUFBVSx3QkFBd0IsbUNBQW1DO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxRUFBcUUsSUFBSSxNQUFNO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RSx1REFBdUQ7QUFDcEk7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZ0JBQWdCO0FBQ3ZGO0FBQ0E7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQSxvRUFBb0UseUNBQXlDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQ0FBaUM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtDQUFrQztBQUM3RjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsOEJBQThCO0FBQ2pHO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSw0Q0FBNEMsK0JBQStCLCtCQUErQiwrQkFBK0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RCw2REFBNkQsc0VBQXNFO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxpSUFBaUk7QUFDakksc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0EsNkRBQTZELFdBQVc7QUFDeEUsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvQkFBb0I7QUFDaEY7QUFDQSxpT0FBaU87QUFDak87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUU7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGtEQUFrRCxZQUFZLDRCQUE0QixhQUFhLHNGQUFzRjtBQUM3TDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtDQUErQztBQUN0Ryx3QkFBd0I7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRCQUE0QixlQUFlO0FBQ2xGO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw2QkFBNkI7QUFDakg7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDZCQUE2QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNkJBQTZCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiwwQkFBMEI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csVUFBVSxZQUFZLGVBQWU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxrQ0FBa0M7QUFDbEMsdUVBQXVFLDJDQUEyQztBQUNsSDtBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQ0FBc0MsaUNBQWlDLGdCQUFnQjtBQUM3STtBQUNBO0FBQ0EseURBQXlELDRDQUE0QztBQUNyRztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLDJGQUEyRixZQUFZLG1EQUFtRDtBQUMxSjtBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkRBQTJEO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsc0VBQXNFO0FBQ3BMLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFlBQVk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLCtDQUErQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsMkJBQTJCO0FBQ3BILGlHQUFpRyxxQ0FBcUM7QUFDdEksaUZBQWlGLDZCQUE2QjtBQUM5RztBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGLG1EQUFtRCx3REFBd0Q7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxVQUFVLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMERBQTBEO0FBQzFELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxvQkFBb0I7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGdEQUFnRCw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSw4REFBOEQsOEJBQThCO0FBQzVGO0FBQ0E7QUFDQSxrRUFBa0UsOEJBQThCO0FBQ2hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQ0FBc0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMkJBQTJCO0FBQ3hGO0FBQ0E7QUFDQSx3RkFBd0YsMkJBQTJCO0FBQ25IO0FBQ0E7QUFDQSx1Q0FBdUMsb0VBQW9FO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDBFQUEwRTtBQUMvSTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsdURBQXVEO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLCtCQUErQjtBQUNoSTtBQUNBLDBHQUEwRyxnQkFBZ0I7QUFDMUg7QUFDQSx3RkFBd0YsZ0JBQWdCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLHdHQUF3Ryw0Q0FBNEM7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCwrQkFBK0I7QUFDbkosMEdBQTBHLGdCQUFnQjtBQUMxSDtBQUNBLHdGQUF3RixnQkFBZ0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILDRDQUE0QztBQUM1SjtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csZ0JBQWdCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryw0Q0FBNEM7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsbUJBQW1CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnS0FBZ0sscUJBQXFCO0FBQ3JMO0FBQ0EsbUZBQW1GLFVBQVU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRztBQUM3QztBQUNBO0FBQ0Esa0VBQWtFLHVFQUF1RTtBQUN6SSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE9BQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHVGQUF1RiwrQkFBK0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtRUFBbUU7QUFDL0cseUNBQXlDLHdDQUF3QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDBDQUEwQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0EsZ0NBQWdDLDZFQUE2RTtBQUM3RyxnREFBZ0QsMkJBQTJCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQ0FBZ0M7QUFDcEcsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFlBQVk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRDQUE0QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsNENBQTRDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkRBQTJEO0FBQ2xILGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0EsY0FBYyw2Q0FBNkMsZUFBZTtBQUMxRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnQ0FBZ0M7QUFDaEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RCwwQ0FBMEMsdUNBQXVDLEdBQUc7QUFDcEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDJCQUEyQjtBQUMxRjtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EOztBQUVBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7O0FBRUE7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTix1Q0FBdUMsa0JBQWtCOztBQUV6RDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGVBQWUsTUFBTSxhQUFhO0FBQ2pIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxtQkFBbUIsV0FBVyxLQUFLLGNBQWM7QUFDM0Y7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLEtBQUssY0FBYztBQUMzRTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhFQUE4RSxzQkFBc0IsaUJBQWlCLGVBQWU7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0JBQWtCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsU0FBUztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixrQkFBa0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixpQkFBaUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsVUFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixVQUFVO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUIscUJBQXFCLFVBQVU7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFVBQVU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw2QkFBNkI7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlDQUFpQztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQ0FBcUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixrQ0FBa0M7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE9BQU87QUFDcEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsS0FBSyxxQkFBcUIsMEJBQTBCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLElBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELDhCQUE4Qjs7QUFFakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxJQUFJLFlBQVksSUFBSSxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsNEJBQTRCO0FBQzNDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSwwQkFBMEI7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsV0FBVztBQUMxQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxtQkFBbUI7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsS0FBSztBQUNMLDREQUE0RDtBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLEtBQUs7QUFDTCxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0NBQW9DLGdFQUFnRSxpQkFBaUI7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9DQUFvQyx5RUFBeUUsaUJBQWlCO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLFVBQVU7QUFDVix3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsVUFBVTtBQUNWLHVGQUF1RjtBQUN2RjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBbUI7O0FBRS9CO0FBQ0E7O0FBRUEsZUFBZSwyTUFBd0Q7QUFDdkU7QUFDQSx1Q0FBdUMsd0JBQXdCOztBQUUrMUQ7QUFDOTVEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXERFTExcXERlc2t0b3BcXGNyYWJkYW8tYWdlbnRcXG1pZGVuLXdlYi10dXRvcmlhbHNcXG5vZGVfbW9kdWxlc1xcQGRlbW94LWxhYnNcXG1pZGVuLXNka1xcZGlzdFxcd29ya2Vyc1xcQ2FyZ28tYWNiZDhhYzUtYWNiZDhhYzUuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBkZXhpZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qXG4gKiBEZXhpZS5qcyAtIGEgbWluaW1hbGlzdGljIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCeSBEYXZpZCBGYWhsYW5kZXIsIGRhdmlkLmZhaGxhbmRlckBnbWFpbC5jb21cbiAqXG4gKiBWZXJzaW9uIDQuMC44LCBXZWQgSnVsIDEwIDIwMjRcbiAqXG4gKiBodHRwczovL2RleGllLm9yZ1xuICpcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9cbiAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgO1xuXHR9KShjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cdCAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0ICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblx0ICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblx0ICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuXHQgICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuXHQgICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5cdCAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuXHQgICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuXHQgICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cblx0ICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH1cblx0ICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHQ7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG5cdCAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcblx0ICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIF9nbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDpcblx0ICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDpcblx0ICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuXHQgICAgICAgICAgICAgICAgY29tbW9uanNHbG9iYWw7XG5cblx0ICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cdCAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cdCAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmICFfZ2xvYmFsLlByb21pc2UpIHtcblx0ICAgICAgICBfZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZXh0ZW5zaW9uKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdvYmplY3QnKVxuXHQgICAgICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgb2JqW2tleV0gPSBleHRlbnNpb25ba2V5XTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgfVxuXHQgICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXHQgICAgdmFyIF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0ICAgIGZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcblx0ICAgICAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwcm9wcyhwcm90bywgZXh0ZW5zaW9uKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuXHQgICAgICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHNldFByb3AocHJvdG8sIGtleSwgZXh0ZW5zaW9uW2tleV0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHQgICAgZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnMpIHtcblx0ICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGV4dGVuZChmdW5jdGlvbk9yR2V0U2V0ICYmIGhhc093bihmdW5jdGlvbk9yR2V0U2V0LCBcImdldFwiKSAmJiB0eXBlb2YgZnVuY3Rpb25PckdldFNldC5nZXQgPT09ICdmdW5jdGlvbicgP1xuXHQgICAgICAgICAgICB7IGdldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IDpcblx0ICAgICAgICAgICAgeyB2YWx1ZTogZnVuY3Rpb25PckdldFNldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LCBvcHRpb25zKSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG5cdCAgICAgICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuXHQgICAgICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblx0ICAgIGZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApIHtcblx0ICAgICAgICB2YXIgcGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcblx0ICAgICAgICB2YXIgcHJvdG87XG5cdCAgICAgICAgcmV0dXJuIHBkIHx8IChwcm90byA9IGdldFByb3RvKG9iaikpICYmIGdldFByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG5cdCAgICB9XG5cdCAgICB2YXIgX3NsaWNlID0gW10uc2xpY2U7XG5cdCAgICBmdW5jdGlvbiBzbGljZShhcmdzLCBzdGFydCwgZW5kKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcblx0ICAgICAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhc3NlcnQoYikge1xuXHQgICAgICAgIGlmICghYilcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIEZhaWxlZFwiKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFzYXAkMShmbikge1xuXHQgICAgICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSlcblx0ICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcblx0ICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtLCBpKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG5cdCAgICAgICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG5cdCAgICAgICAgICAgICAgICByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LCB7fSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBoYXNPd24ob2JqLCBrZXlQYXRoKSlcblx0ICAgICAgICAgICAgcmV0dXJuIG9ialtrZXlQYXRoXTtcblx0ICAgICAgICBpZiAoIWtleVBhdGgpXG5cdCAgICAgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICB2YXIgcnYgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuXHQgICAgICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuXHQgICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcblx0ICAgICAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG5cdCAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG5cdCAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0tleVBhdGggPSBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdLZXlQYXRoID09PSBcIlwiKVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGN1cnJlbnRLZXlQYXRoKSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtjdXJyZW50S2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgb2JqW2tleVBhdGhdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcblx0ICAgICAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuXHQgICAgICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbiAoa3ApIHtcblx0ICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcblx0ICAgICAgICB2YXIgcnYgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBtIGluIG9iaikge1xuXHQgICAgICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG5cdCAgICAgICAgICAgICAgICBydlttXSA9IG9ialttXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXHQgICAgdmFyIGNvbmNhdCA9IFtdLmNvbmNhdDtcblx0ICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuXHQgICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xuXHQgICAgfVxuXHQgICAgdmFyIGludHJpbnNpY1R5cGVOYW1lcyA9IFwiQmlnVWludDY0QXJyYXksQmlnSW50NjRBcnJheSxBcnJheSxCb29sZWFuLFN0cmluZyxEYXRlLFJlZ0V4cCxCbG9iLEZpbGUsRmlsZUxpc3QsRmlsZVN5c3RlbUZpbGVIYW5kbGUsRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSxBcnJheUJ1ZmZlcixEYXRhVmlldyxVaW50OENsYW1wZWRBcnJheSxJbWFnZUJpdG1hcCxJbWFnZURhdGEsTWFwLFNldCxDcnlwdG9LZXlcIlxuXHQgICAgICAgIC5zcGxpdCgnLCcpLmNvbmNhdChmbGF0dGVuKFs4LCAxNiwgMzIsIDY0XS5tYXAoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gW1wiSW50XCIsIFwiVWludFwiLCBcIkZsb2F0XCJdLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdCArIG51bSArIFwiQXJyYXlcIjsgfSk7IH0pKSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZ2xvYmFsW3RdOyB9KTtcblx0ICAgIHZhciBpbnRyaW5zaWNUeXBlcyA9IG5ldyBTZXQoaW50cmluc2ljVHlwZU5hbWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSkpO1xuXHQgICAgZnVuY3Rpb24gY2xvbmVTaW1wbGVPYmplY3RUcmVlKG8pIHtcblx0ICAgICAgICB2YXIgcnYgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBrIGluIG8pXG5cdCAgICAgICAgICAgIGlmIChoYXNPd24obywgaykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2ID0gb1trXTtcblx0ICAgICAgICAgICAgICAgIHJ2W2tdID0gIXYgfHwgdHlwZW9mIHYgIT09ICdvYmplY3QnIHx8IGludHJpbnNpY1R5cGVzLmhhcyh2LmNvbnN0cnVjdG9yKSA/IHYgOiBjbG9uZVNpbXBsZU9iamVjdFRyZWUodik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBvYmplY3RJc0VtcHR5KG8pIHtcblx0ICAgICAgICBmb3IgKHZhciBrIGluIG8pXG5cdCAgICAgICAgICAgIGlmIChoYXNPd24obywgaykpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB2YXIgY2lyY3VsYXJSZWZzID0gbnVsbDtcblx0ICAgIGZ1bmN0aW9uIGRlZXBDbG9uZShhbnkpIHtcblx0ICAgICAgICBjaXJjdWxhclJlZnMgPSBuZXcgV2Vha01hcCgpO1xuXHQgICAgICAgIHZhciBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG5cdCAgICAgICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpbm5lckRlZXBDbG9uZSh4KSB7XG5cdCAgICAgICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jylcblx0ICAgICAgICAgICAgcmV0dXJuIHg7XG5cdCAgICAgICAgdmFyIHJ2ID0gY2lyY3VsYXJSZWZzLmdldCh4KTtcblx0ICAgICAgICBpZiAocnYpXG5cdCAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICBpZiAoaXNBcnJheSh4KSkge1xuXHQgICAgICAgICAgICBydiA9IFtdO1xuXHQgICAgICAgICAgICBjaXJjdWxhclJlZnMuc2V0KHgsIHJ2KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZSh4W2ldKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoaW50cmluc2ljVHlwZXMuaGFzKHguY29uc3RydWN0b3IpKSB7XG5cdCAgICAgICAgICAgIHJ2ID0geDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvKHgpO1xuXHQgICAgICAgICAgICBydiA9IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvKTtcblx0ICAgICAgICAgICAgY2lyY3VsYXJSZWZzLnNldCh4LCBydik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4geCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhc093bih4LCBwcm9wKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJ2W3Byb3BdID0gaW5uZXJEZWVwQ2xvbmUoeFtwcm9wXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXHQgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cdCAgICBmdW5jdGlvbiB0b1N0cmluZ1RhZyhvKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuXHQgICAgfVxuXHQgICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgP1xuXHQgICAgICAgIFN5bWJvbC5pdGVyYXRvciA6XG5cdCAgICAgICAgJ0BAaXRlcmF0b3InO1xuXHQgICAgdmFyIGdldEl0ZXJhdG9yT2YgPSB0eXBlb2YgaXRlcmF0b3JTeW1ib2wgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgIHZhciBpO1xuXHQgICAgICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcblx0ICAgIH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuXHQgICAgZnVuY3Rpb24gZGVsQXJyYXlJdGVtKGEsIHgpIHtcblx0ICAgICAgICB2YXIgaSA9IGEuaW5kZXhPZih4KTtcblx0ICAgICAgICBpZiAoaSA+PSAwKVxuXHQgICAgICAgICAgICBhLnNwbGljZShpLCAxKTtcblx0ICAgICAgICByZXR1cm4gaSA+PSAwO1xuXHQgICAgfVxuXHQgICAgdmFyIE5PX0NIQVJfQVJSQVkgPSB7fTtcblx0ICAgIGZ1bmN0aW9uIGdldEFycmF5T2YoYXJyYXlMaWtlKSB7XG5cdCAgICAgICAgdmFyIGksIGEsIHgsIGl0O1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0FycmF5KGFycmF5TGlrZSkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlMaWtlLnNsaWNlKCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzID09PSBOT19DSEFSX0FSUkFZICYmIHR5cGVvZiBhcnJheUxpa2UgPT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuXHQgICAgICAgICAgICBpZiAoKGl0ID0gZ2V0SXRlcmF0b3JPZihhcnJheUxpa2UpKSkge1xuXHQgICAgICAgICAgICAgICAgYSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKCh4ID0gaXQubmV4dCgpKSwgIXguZG9uZSlcblx0ICAgICAgICAgICAgICAgICAgICBhLnB1c2goeC52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoYXJyYXlMaWtlID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG5cdCAgICAgICAgICAgIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgICAgICAgICBhID0gbmV3IEFycmF5KGkpO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcblx0ICAgICAgICAgICAgICAgICAgICBhW2ldID0gYXJyYXlMaWtlW2ldO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICAgICAgICBhID0gbmV3IEFycmF5KGkpO1xuXHQgICAgICAgIHdoaWxlIChpLS0pXG5cdCAgICAgICAgICAgIGFbaV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgcmV0dXJuIGE7XG5cdCAgICB9XG5cdCAgICB2YXIgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcblx0ICAgICAgICA/IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nOyB9XG5cdCAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuXHQgICAgdmFyIGRleGllRXJyb3JOYW1lcyA9IFtcblx0ICAgICAgICAnTW9kaWZ5Jyxcblx0ICAgICAgICAnQnVsaycsXG5cdCAgICAgICAgJ09wZW5GYWlsZWQnLFxuXHQgICAgICAgICdWZXJzaW9uQ2hhbmdlJyxcblx0ICAgICAgICAnU2NoZW1hJyxcblx0ICAgICAgICAnVXBncmFkZScsXG5cdCAgICAgICAgJ0ludmFsaWRUYWJsZScsXG5cdCAgICAgICAgJ01pc3NpbmdBUEknLFxuXHQgICAgICAgICdOb1N1Y2hEYXRhYmFzZScsXG5cdCAgICAgICAgJ0ludmFsaWRBcmd1bWVudCcsXG5cdCAgICAgICAgJ1N1YlRyYW5zYWN0aW9uJyxcblx0ICAgICAgICAnVW5zdXBwb3J0ZWQnLFxuXHQgICAgICAgICdJbnRlcm5hbCcsXG5cdCAgICAgICAgJ0RhdGFiYXNlQ2xvc2VkJyxcblx0ICAgICAgICAnUHJlbWF0dXJlQ29tbWl0Jyxcblx0ICAgICAgICAnRm9yZWlnbkF3YWl0J1xuXHQgICAgXTtcblx0ICAgIHZhciBpZGJEb21FcnJvck5hbWVzID0gW1xuXHQgICAgICAgICdVbmtub3duJyxcblx0ICAgICAgICAnQ29uc3RyYWludCcsXG5cdCAgICAgICAgJ0RhdGEnLFxuXHQgICAgICAgICdUcmFuc2FjdGlvbkluYWN0aXZlJyxcblx0ICAgICAgICAnUmVhZE9ubHknLFxuXHQgICAgICAgICdWZXJzaW9uJyxcblx0ICAgICAgICAnTm90Rm91bmQnLFxuXHQgICAgICAgICdJbnZhbGlkU3RhdGUnLFxuXHQgICAgICAgICdJbnZhbGlkQWNjZXNzJyxcblx0ICAgICAgICAnQWJvcnQnLFxuXHQgICAgICAgICdUaW1lb3V0Jyxcblx0ICAgICAgICAnUXVvdGFFeGNlZWRlZCcsXG5cdCAgICAgICAgJ1N5bnRheCcsXG5cdCAgICAgICAgJ0RhdGFDbG9uZSdcblx0ICAgIF07XG5cdCAgICB2YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcblx0ICAgIHZhciBkZWZhdWx0VGV4dHMgPSB7XG5cdCAgICAgICAgVmVyc2lvbkNoYW5nZWQ6IFwiRGF0YWJhc2UgdmVyc2lvbiBjaGFuZ2VkIGJ5IG90aGVyIGRhdGFiYXNlIGNvbm5lY3Rpb25cIixcblx0ICAgICAgICBEYXRhYmFzZUNsb3NlZDogXCJEYXRhYmFzZSBoYXMgYmVlbiBjbG9zZWRcIixcblx0ICAgICAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG5cdCAgICAgICAgVHJhbnNhY3Rpb25JbmFjdGl2ZTogXCJUcmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQgb3IgZmFpbGVkXCIsXG5cdCAgICAgICAgTWlzc2luZ0FQSTogXCJJbmRleGVkREIgQVBJIG1pc3NpbmcuIFBsZWFzZSB2aXNpdCBodHRwczovL3Rpbnl1cmwuY29tL3kydXV2c2tiXCJcblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuXHQgICAgfVxuXHQgICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oRXJyb3IpLmV4dGVuZCh7XG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfVxuXHQgICAgfSk7XG5cdCAgICBmdW5jdGlvbiBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKSB7XG5cdCAgICAgICAgcmV0dXJuIG1zZyArIFwiLiBFcnJvcnM6IFwiICsgT2JqZWN0LmtleXMoZmFpbHVyZXMpXG5cdCAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZmFpbHVyZXNba2V5XS50b1N0cmluZygpOyB9KVxuXHQgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2LCBpLCBzKSB7IHJldHVybiBzLmluZGV4T2YodikgPT09IGk7IH0pXG5cdCAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIE1vZGlmeUVycm9yKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuXHQgICAgICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcblx0ICAgICAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuXHQgICAgICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xuXHQgICAgICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xuXHQgICAgfVxuXHQgICAgZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuXHQgICAgZnVuY3Rpb24gQnVsa0Vycm9yKG1zZywgZmFpbHVyZXMpIHtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcIkJ1bGtFcnJvclwiO1xuXHQgICAgICAgIHRoaXMuZmFpbHVyZXMgPSBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGZhaWx1cmVzW3Bvc107IH0pO1xuXHQgICAgICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuXHQgICAgICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgdGhpcy5mYWlsdXJlcyk7XG5cdCAgICB9XG5cdCAgICBkZXJpdmUoQnVsa0Vycm9yKS5mcm9tKERleGllRXJyb3IpO1xuXHQgICAgdmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7IHJldHVybiAob2JqW25hbWVdID0gbmFtZSArIFwiRXJyb3JcIiwgb2JqKTsgfSwge30pO1xuXHQgICAgdmFyIEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xuXHQgICAgdmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcblx0ICAgICAgICB2YXIgZnVsbE5hbWUgPSBuYW1lICsgXCJFcnJvclwiO1xuXHQgICAgICAgIGZ1bmN0aW9uIERleGllRXJyb3IobXNnT3JJbm5lciwgaW5uZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG5cdCAgICAgICAgICAgIGlmICghbXNnT3JJbm5lcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZGVmYXVsdFRleHRzW25hbWVdIHx8IGZ1bGxOYW1lO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChtc2dPcklubmVyKS5jb25jYXQoIWlubmVyID8gJycgOiAnXFxuICcgKyBpbm5lcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gaW5uZXIgfHwgbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiXCIuY29uY2F0KG1zZ09ySW5uZXIubmFtZSwgXCIgXCIpLmNvbmNhdChtc2dPcklubmVyLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IG1zZ09ySW5uZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oQmFzZUV4Y2VwdGlvbik7XG5cdCAgICAgICAgb2JqW25hbWVdID0gRGV4aWVFcnJvcjtcblx0ICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgfSwge30pO1xuXHQgICAgZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcblx0ICAgIGV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcblx0ICAgIGV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xuXHQgICAgdmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcblx0ICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuXHQgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9LCB7fSk7XG5cdCAgICBmdW5jdGlvbiBtYXBFcnJvcihkb21FcnJvciwgbWVzc2FnZSkge1xuXHQgICAgICAgIGlmICghZG9tRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBEZXhpZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgfHwgIWRvbUVycm9yLm5hbWUgfHwgIWV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXSlcblx0ICAgICAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuXHQgICAgICAgIHZhciBydiA9IG5ldyBleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0obWVzc2FnZSB8fCBkb21FcnJvci5tZXNzYWdlLCBkb21FcnJvcik7XG5cdCAgICAgICAgaWYgKFwic3RhY2tcIiBpbiBkb21FcnJvcikge1xuXHQgICAgICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnY7XG5cdCAgICB9XG5cdCAgICB2YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG5cdCAgICAgICAgaWYgKFtcIlN5bnRheFwiLCBcIlR5cGVcIiwgXCJSYW5nZVwiXS5pbmRleE9mKG5hbWUpID09PSAtMSlcblx0ICAgICAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcblx0ICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgfSwge30pO1xuXHQgICAgZnVsbE5hbWVFeGNlcHRpb25zLk1vZGlmeUVycm9yID0gTW9kaWZ5RXJyb3I7XG5cdCAgICBmdWxsTmFtZUV4Y2VwdGlvbnMuRGV4aWVFcnJvciA9IERleGllRXJyb3I7XG5cdCAgICBmdWxsTmFtZUV4Y2VwdGlvbnMuQnVsa0Vycm9yID0gQnVsa0Vycm9yO1xuXG5cdCAgICBmdW5jdGlvbiBub3AoKSB7IH1cblx0ICAgIGZ1bmN0aW9uIG1pcnJvcih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuXHQgICAgZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2hhaW4oZjEsIGYyKSB7XG5cdCAgICAgICAgaWYgKGYxID09IG51bGwgfHwgZjEgPT09IG1pcnJvcilcblx0ICAgICAgICAgICAgcmV0dXJuIGYyO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmMihmMSh2YWwpKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY2FsbEJvdGgob24xLCBvbjIpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBvbjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGhvb2tDcmVhdGluZ0NoYWluKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMSA9PT0gbm9wKVxuXHQgICAgICAgICAgICByZXR1cm4gZjI7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHJlcztcblx0ICAgICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuXHQgICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuXHQgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG5cdCAgICAgICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKG9uc3VjY2Vzcylcblx0ICAgICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2Vzcztcblx0ICAgICAgICAgICAgaWYgKG9uZXJyb3IpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMSA9PT0gbm9wKVxuXHQgICAgICAgICAgICByZXR1cm4gZjI7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuXHQgICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuXHQgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25lcnJvciA9IG51bGw7XG5cdCAgICAgICAgICAgIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG5cdCAgICAgICAgICAgIGlmIChvbmVycm9yKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMSA9PT0gbm9wKVxuXHQgICAgICAgICAgICByZXR1cm4gZjI7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTtcblx0ICAgICAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuXHQgICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuXHQgICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG5cdCAgICAgICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKG9uc3VjY2Vzcylcblx0ICAgICAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2Vzcztcblx0ICAgICAgICAgICAgaWYgKG9uZXJyb3IpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgICAgICAgIChyZXMyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZXMyKSA6XG5cdCAgICAgICAgICAgICAgICAoZXh0ZW5kKHJlcywgcmVzMikpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbihmMSwgZjIpIHtcblx0ICAgICAgICBpZiAoZjEgPT09IG5vcClcblx0ICAgICAgICAgICAgcmV0dXJuIGYyO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHByb21pc2FibGVDaGFpbihmMSwgZjIpIHtcblx0ICAgICAgICBpZiAoZjEgPT09IG5vcClcblx0ICAgICAgICAgICAgcmV0dXJuIGYyO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoaXogPSB0aGlzLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICAgIC9eKGh0dHB8aHR0cHMpOlxcL1xcLyhsb2NhbGhvc3R8MTI3XFwuMFxcLjBcXC4xKS8udGVzdChsb2NhdGlvbi5ocmVmKTtcblx0ICAgIGZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBmaWx0ZXIpIHtcblx0ICAgICAgICBkZWJ1ZyA9IHZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgSU5URVJOQUwgPSB7fTtcblx0ICAgIHZhciBaT05FX0VDSE9fTElNSVQgPSAxMDAsIF9hJDEgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgP1xuXHQgICAgICAgIFtdIDpcblx0ICAgICAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZ2xvYmFsUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNyeXB0by5zdWJ0bGUpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW2dsb2JhbFAsIGdldFByb3RvKGdsb2JhbFApLCBnbG9iYWxQXTtcblx0ICAgICAgICAgICAgdmFyIG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG5cdCAgICAgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgICAgICBuYXRpdmVQLFxuXHQgICAgICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG5cdCAgICAgICAgICAgICAgICBnbG9iYWxQXG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgfSkoKSwgcmVzb2x2ZWROYXRpdmVQcm9taXNlID0gX2EkMVswXSwgbmF0aXZlUHJvbWlzZVByb3RvID0gX2EkMVsxXSwgcmVzb2x2ZWRHbG9iYWxQcm9taXNlID0gX2EkMVsyXSwgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG5cdCAgICB2YXIgTmF0aXZlUHJvbWlzZSA9IHJlc29sdmVkTmF0aXZlUHJvbWlzZSAmJiByZXNvbHZlZE5hdGl2ZVByb21pc2UuY29uc3RydWN0b3I7XG5cdCAgICB2YXIgcGF0Y2hHbG9iYWxQcm9taXNlID0gISFyZXNvbHZlZEdsb2JhbFByb21pc2U7XG5cdCAgICBmdW5jdGlvbiBzY2hlZHVsZVBoeXNpY2FsVGljaygpIHtcblx0ICAgICAgICBxdWV1ZU1pY3JvdGFzayhwaHlzaWNhbFRpY2spO1xuXHQgICAgfVxuXHQgICAgdmFyIGFzYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcblx0ICAgICAgICBtaWNyb3RpY2tRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnc10pO1xuXHQgICAgICAgIGlmIChuZWVkc05ld1BoeXNpY2FsVGljaykge1xuXHQgICAgICAgICAgICBzY2hlZHVsZVBoeXNpY2FsVGljaygpO1xuXHQgICAgICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICB2YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZSxcblx0ICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZSxcblx0ICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdLFxuXHQgICAgcmVqZWN0aW5nRXJyb3JzID0gW10sXG5cdCAgICByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7XG5cdCAgICB2YXIgZ2xvYmFsUFNEID0ge1xuXHQgICAgICAgIGlkOiAnZ2xvYmFsJyxcblx0ICAgICAgICBnbG9iYWw6IHRydWUsXG5cdCAgICAgICAgcmVmOiAwLFxuXHQgICAgICAgIHVuaGFuZGxlZHM6IFtdLFxuXHQgICAgICAgIG9udW5oYW5kbGVkOiBub3AsXG5cdCAgICAgICAgcGdwOiBmYWxzZSxcblx0ICAgICAgICBlbnY6IHt9LFxuXHQgICAgICAgIGZpbmFsaXplOiBub3Bcblx0ICAgIH07XG5cdCAgICB2YXIgUFNEID0gZ2xvYmFsUFNEO1xuXHQgICAgdmFyIG1pY3JvdGlja1F1ZXVlID0gW107XG5cdCAgICB2YXIgbnVtU2NoZWR1bGVkQ2FsbHMgPSAwO1xuXHQgICAgdmFyIHRpY2tGaW5hbGl6ZXJzID0gW107XG5cdCAgICBmdW5jdGlvbiBEZXhpZVByb21pc2UoZm4pIHtcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcblx0ICAgICAgICB0aGlzLl9saWIgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgcHNkID0gKHRoaXMuX1BTRCA9IFBTRCk7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBpZiAoZm4gIT09IElOVEVSTkFMKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBhcmd1bWVudHNbMV07XG5cdCAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZhbHNlKVxuXHQgICAgICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHRoaXMsIHRoaXMuX3ZhbHVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuXHQgICAgICAgICsrcHNkLnJlZjtcblx0ICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2sodGhpcywgZm4pO1xuXHQgICAgfVxuXHQgICAgdmFyIHRoZW5Qcm9wID0ge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcHNkID0gUFNELCBtaWNyb1Rhc2tJZCA9IHRvdGFsRWNob2VzO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjbGVhbnVwID0gcG9zc2libGVBd2FpdCAmJiAhZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIoX3RoaXMsIG5ldyBMaXN0ZW5lcihuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uRnVsZmlsbGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksIHJlc29sdmUsIHJlamVjdCwgcHNkKSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb25zb2xlVGFzaylcblx0ICAgICAgICAgICAgICAgICAgICBydi5fY29uc29sZVRhc2sgPSB0aGlzLl9jb25zb2xlVGFzaztcblx0ICAgICAgICAgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhlbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHNldFByb3AodGhpcywgJ3RoZW4nLCB2YWx1ZSAmJiB2YWx1ZS5wcm90b3R5cGUgPT09IElOVEVSTkFMID9cblx0ICAgICAgICAgICAgICAgIHRoZW5Qcm9wIDpcblx0ICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0OiB0aGVuUHJvcC5zZXRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBwcm9wcyhEZXhpZVByb21pc2UucHJvdG90eXBlLCB7XG5cdCAgICAgICAgdGhlbjogdGhlblByb3AsXG5cdCAgICAgICAgX3RoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHQgICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihudWxsLCBudWxsLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgUFNEKSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuXHQgICAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgOiB0aGlzLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLm5hbWUgPT09IHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZpbmFsbHk6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG5cdCAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlUmVqZWN0KGVycik7IH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cblx0ICAgICAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpOyB9LCBtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMudGhlbihyZXNvbHZlLCByZWplY3QpLmZpbmFsbHkoY2xlYXJUaW1lb3V0LmJpbmQobnVsbCwgaGFuZGxlKSk7XG5cdCAgICAgICAgICAgICAgICB9KSA6IHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKVxuXHQgICAgICAgIHNldFByb3AoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCAnRGV4aWUuUHJvbWlzZScpO1xuXHQgICAgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5cdCAgICBmdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG5cdCAgICAgICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcblx0ICAgICAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuXHQgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG5cdCAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG5cdCAgICAgICAgdGhpcy5wc2QgPSB6b25lO1xuXHQgICAgfVxuXHQgICAgcHJvcHMoRGV4aWVQcm9taXNlLCB7XG5cdCAgICAgICAgYWxsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcblx0ICAgICAgICAgICAgICAgIC5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShhKS50aGVuKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG5cdCAgICAgICAgICAgICAgICB9LCByZWplY3QpOyB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIHRydWUsIHZhbHVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmVqZWN0OiBQcm9taXNlUmVqZWN0LFxuXHQgICAgICAgIHJhY2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7IH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFBTRDoge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBTRDsgfSxcblx0ICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFBTRCA9IHZhbHVlOyB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0b3RhbEVjaG9lczogeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvdGFsRWNob2VzOyB9IH0sXG5cdCAgICAgICAgbmV3UFNEOiBuZXdTY29wZSxcblx0ICAgICAgICB1c2VQU0Q6IHVzZVBTRCxcblx0ICAgICAgICBzY2hlZHVsZXI6IHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2FwOyB9LFxuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyBhc2FwID0gdmFsdWU7IH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJlamVjdGlvbk1hcHBlcjoge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdGlvbk1hcHBlcjsgfSxcblx0ICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7IH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZvbGxvdzogZnVuY3Rpb24gKGZuLCB6b25lUHJvcHMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuXHQgICAgICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgcHNkLm9udW5oYW5kbGVkID0gcmVqZWN0O1xuXHQgICAgICAgICAgICAgICAgICAgIHBzZC5maW5hbGl6ZSA9IGNhbGxCb3RoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdChfdGhpcy51bmhhbmRsZWRzWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcblx0ICAgICAgICAgICAgICAgICAgICBmbigpO1xuXHQgICAgICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIGlmIChOYXRpdmVQcm9taXNlKSB7XG5cdCAgICAgICAgaWYgKE5hdGl2ZVByb21pc2UuYWxsU2V0dGxlZClcblx0ICAgICAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcblx0ICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9OyB9LCBmdW5jdGlvbiAocmVhc29uKSB7IHJldHVybiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTsgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIGlmIChOYXRpdmVQcm9taXNlLmFueSAmJiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgIT09ICd1bmRlZmluZWQnKVxuXHQgICAgICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbnlcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlcyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHJlc29sdmUodmFsdWUpOyB9LCBmdW5jdGlvbiAoZmFpbHVyZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlc1tpXSA9IGZhaWx1cmU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWx1cmVzKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZuKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEZXhpZVByb21pc2UgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX3RoZW4ocmVzb2x2ZSwgcmVqZWN0KSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgfSwgaGFuZGxlUmVqZWN0aW9uLmJpbmQobnVsbCwgcHJvbWlzZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIGV4KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG5cdCAgICAgICAgcmVqZWN0aW5nRXJyb3JzLnB1c2gocmVhc29uKTtcblx0ICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgIHJlYXNvbiA9IHJlamVjdGlvbk1hcHBlcihyZWFzb24pO1xuXHQgICAgICAgIHByb21pc2UuX3N0YXRlID0gZmFsc2U7XG5cdCAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSByZWFzb247XG5cdCAgICAgICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcblx0ICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG5cdCAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuXHQgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpIHtcblx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuXHQgICAgICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuXHQgICAgICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTtcblx0ICAgICAgICBpZiAobnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIHtcblx0ICAgICAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcblx0ICAgICAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuXHQgICAgICAgICAgICB9LCBbXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNiID0gcHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5vbkZ1bGZpbGxlZCA6IGxpc3RlbmVyLm9uUmVqZWN0ZWQ7XG5cdCAgICAgICAgaWYgKGNiID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KShwcm9taXNlLl92YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgICsrbGlzdGVuZXIucHNkLnJlZjtcblx0ICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuXHQgICAgICAgIGFzYXAoY2FsbExpc3RlbmVyLCBbY2IsIHByb21pc2UsIGxpc3RlbmVyXSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjYWxsTGlzdGVuZXIoY2IsIHByb21pc2UsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFyIHJldCwgdmFsdWUgPSBwcm9taXNlLl92YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9zdGF0ZSAmJiByZWplY3RpbmdFcnJvcnMubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgcmVqZWN0aW5nRXJyb3JzID0gW107XG5cdCAgICAgICAgICAgIHJldCA9IGRlYnVnICYmIHByb21pc2UuX2NvbnNvbGVUYXNrID8gcHJvbWlzZS5fY29uc29sZVRhc2sucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNiKHZhbHVlKTsgfSkgOiBjYih2YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmICghcHJvbWlzZS5fc3RhdGUgJiYgcmVqZWN0aW5nRXJyb3JzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxpc3RlbmVyLnJlc29sdmUocmV0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgbGlzdGVuZXIucmVqZWN0KGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG5cdCAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuXHQgICAgICAgICAgICAtLWxpc3RlbmVyLnBzZC5yZWYgfHwgbGlzdGVuZXIucHNkLmZpbmFsaXplKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuXHQgICAgICAgIHVzZVBTRChnbG9iYWxQU0QsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgYmVnaW5NaWNyb1RpY2tTY29wZSgpICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBiZWdpbk1pY3JvVGlja1Njb3BlKCkge1xuXHQgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGlzT3V0c2lkZU1pY3JvVGljaztcblx0ICAgICAgICBpc091dHNpZGVNaWNyb1RpY2sgPSBmYWxzZTtcblx0ICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuXHQgICAgICAgIHJldHVybiB3YXNSb290RXhlYztcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGVuZE1pY3JvVGlja1Njb3BlKCkge1xuXHQgICAgICAgIHZhciBjYWxsYmFja3MsIGksIGw7XG5cdCAgICAgICAgZG8ge1xuXHQgICAgICAgICAgICB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gbWljcm90aWNrUXVldWU7XG5cdCAgICAgICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgbCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbVswXS5hcHBseShudWxsLCBpdGVtWzFdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApO1xuXHQgICAgICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWU7XG5cdCAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZmluYWxpemVQaHlzaWNhbFRpY2soKSB7XG5cdCAgICAgICAgdmFyIHVuaGFuZGxlZEVycnMgPSB1bmhhbmRsZWRFcnJvcnM7XG5cdCAgICAgICAgdW5oYW5kbGVkRXJyb3JzID0gW107XG5cdCAgICAgICAgdW5oYW5kbGVkRXJycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgZmluYWxpemVycyA9IHRpY2tGaW5hbGl6ZXJzLnNsaWNlKDApO1xuXHQgICAgICAgIHZhciBpID0gZmluYWxpemVycy5sZW5ndGg7XG5cdCAgICAgICAgd2hpbGUgKGkpXG5cdCAgICAgICAgICAgIGZpbmFsaXplcnNbLS1pXSgpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmbikge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcblx0ICAgICAgICAgICAgZm4oKTtcblx0ICAgICAgICAgICAgdGlja0ZpbmFsaXplcnMuc3BsaWNlKHRpY2tGaW5hbGl6ZXJzLmluZGV4T2YoZmluYWxpemVyKSwgMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcblx0ICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuXHQgICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcblx0ICAgICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG5cdCAgICAgICAgfSwgW10pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKSB7XG5cdCAgICAgICAgaWYgKCF1bmhhbmRsZWRFcnJvcnMuc29tZShmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlOyB9KSlcblx0ICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuXHQgICAgICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcblx0ICAgICAgICB3aGlsZSAoaSlcblx0ICAgICAgICAgICAgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gd3JhcChmbiwgZXJyb3JDYXRjaGVyKSB7XG5cdCAgICAgICAgdmFyIHBzZCA9IFBTRDtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksIG91dGVyU2NvcGUgPSBQU0Q7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcblx0ICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHZhciB0YXNrID0geyBhd2FpdHM6IDAsIGVjaG9lczogMCwgaWQ6IDAgfTtcblx0ICAgIHZhciB0YXNrQ291bnRlciA9IDA7XG5cdCAgICB2YXIgem9uZVN0YWNrID0gW107XG5cdCAgICB2YXIgem9uZUVjaG9lcyA9IDA7XG5cdCAgICB2YXIgdG90YWxFY2hvZXMgPSAwO1xuXHQgICAgdmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG5cdCAgICBmdW5jdGlvbiBuZXdTY29wZShmbiwgcHJvcHMsIGExLCBhMikge1xuXHQgICAgICAgIHZhciBwYXJlbnQgPSBQU0QsIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcblx0ICAgICAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuXHQgICAgICAgIHBzZC5yZWYgPSAwO1xuXHQgICAgICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcblx0ICAgICAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcblx0ICAgICAgICBnbG9iYWxQU0QuZW52O1xuXHQgICAgICAgIHBzZC5lbnYgPSBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG5cdCAgICAgICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcblx0ICAgICAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuXHQgICAgICAgICAgICBhbGw6IERleGllUHJvbWlzZS5hbGwsXG5cdCAgICAgICAgICAgIHJhY2U6IERleGllUHJvbWlzZS5yYWNlLFxuXHQgICAgICAgICAgICBhbGxTZXR0bGVkOiBEZXhpZVByb21pc2UuYWxsU2V0dGxlZCxcblx0ICAgICAgICAgICAgYW55OiBEZXhpZVByb21pc2UuYW55LFxuXHQgICAgICAgICAgICByZXNvbHZlOiBEZXhpZVByb21pc2UucmVzb2x2ZSxcblx0ICAgICAgICAgICAgcmVqZWN0OiBEZXhpZVByb21pc2UucmVqZWN0LFxuXHQgICAgICAgIH0gOiB7fTtcblx0ICAgICAgICBpZiAocHJvcHMpXG5cdCAgICAgICAgICAgIGV4dGVuZChwc2QsIHByb3BzKTtcblx0ICAgICAgICArK3BhcmVudC5yZWY7XG5cdCAgICAgICAgcHNkLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAtLXRoaXMucGFyZW50LnJlZiB8fCB0aGlzLnBhcmVudC5maW5hbGl6ZSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIHJ2ID0gdXNlUFNEKHBzZCwgZm4sIGExLCBhMik7XG5cdCAgICAgICAgaWYgKHBzZC5yZWYgPT09IDApXG5cdCAgICAgICAgICAgIHBzZC5maW5hbGl6ZSgpO1xuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuXHQgICAgICAgIGlmICghdGFzay5pZClcblx0ICAgICAgICAgICAgdGFzay5pZCA9ICsrdGFza0NvdW50ZXI7XG5cdCAgICAgICAgKyt0YXNrLmF3YWl0cztcblx0ICAgICAgICB0YXNrLmVjaG9lcyArPSBaT05FX0VDSE9fTElNSVQ7XG5cdCAgICAgICAgcmV0dXJuIHRhc2suaWQ7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcblx0ICAgICAgICBpZiAoIXRhc2suYXdhaXRzKVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApXG5cdCAgICAgICAgICAgIHRhc2suaWQgPSAwO1xuXHQgICAgICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoKCcnICsgbmF0aXZlUHJvbWlzZVRoZW4pLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA9PT0gLTEpIHtcblx0ICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gbm9wO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gb25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKHBvc3NpYmxlUHJvbWlzZSkge1xuXHQgICAgICAgIGlmICh0YXNrLmVjaG9lcyAmJiBwb3NzaWJsZVByb21pc2UgJiYgcG9zc2libGVQcm9taXNlLmNvbnN0cnVjdG9yID09PSBOYXRpdmVQcm9taXNlKSB7XG5cdCAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZVByb21pc2UudGhlbihmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB4O1xuXHQgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG5cdCAgICAgICAgKyt0b3RhbEVjaG9lcztcblx0ICAgICAgICBpZiAoIXRhc2suZWNob2VzIHx8IC0tdGFzay5lY2hvZXMgPT09IDApIHtcblx0ICAgICAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmF3YWl0cyA9IHRhc2suaWQgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB6b25lU3RhY2sucHVzaChQU0QpO1xuXHQgICAgICAgIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHpvbmVMZWF2ZUVjaG8oKSB7XG5cdCAgICAgICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aCAtIDFdO1xuXHQgICAgICAgIHpvbmVTdGFjay5wb3AoKTtcblx0ICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgZmFsc2UpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIGJFbnRlcmluZ1pvbmUpIHtcblx0ICAgICAgICB2YXIgY3VycmVudFpvbmUgPSBQU0Q7XG5cdCAgICAgICAgaWYgKGJFbnRlcmluZ1pvbmUgPyB0YXNrLmVjaG9lcyAmJiAoIXpvbmVFY2hvZXMrKyB8fCB0YXJnZXRab25lICE9PSBQU0QpIDogem9uZUVjaG9lcyAmJiAoIS0tem9uZUVjaG9lcyB8fCB0YXJnZXRab25lICE9PSBQU0QpKSB7XG5cdCAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIFBTRCA9IHRhcmdldFpvbmU7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRab25lID09PSBnbG9iYWxQU0QpXG5cdCAgICAgICAgICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuXHQgICAgICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcblx0ICAgICAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG5cdCAgICAgICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcblx0ICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsID0gdGFyZ2V0RW52LmFsbDtcblx0ICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmFjZSA9IHRhcmdldEVudi5yYWNlO1xuXHQgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZXNvbHZlID0gdGFyZ2V0RW52LnJlc29sdmU7XG5cdCAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlamVjdCA9IHRhcmdldEVudi5yZWplY3Q7XG5cdCAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFsbFNldHRsZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkID0gdGFyZ2V0RW52LmFsbFNldHRsZWQ7XG5cdCAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFueSlcblx0ICAgICAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFueSA9IHRhcmdldEVudi5hbnk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBzbmFwU2hvdCgpIHtcblx0ICAgICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IF9nbG9iYWwuUHJvbWlzZTtcblx0ICAgICAgICByZXR1cm4gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuXHQgICAgICAgICAgICBQcm9taXNlOiBHbG9iYWxQcm9taXNlLFxuXHQgICAgICAgICAgICBQcm9taXNlUHJvcDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfZ2xvYmFsLCBcIlByb21pc2VcIiksXG5cdCAgICAgICAgICAgIGFsbDogR2xvYmFsUHJvbWlzZS5hbGwsXG5cdCAgICAgICAgICAgIHJhY2U6IEdsb2JhbFByb21pc2UucmFjZSxcblx0ICAgICAgICAgICAgYWxsU2V0dGxlZDogR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkLFxuXHQgICAgICAgICAgICBhbnk6IEdsb2JhbFByb21pc2UuYW55LFxuXHQgICAgICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG5cdCAgICAgICAgICAgIHJlamVjdDogR2xvYmFsUHJvbWlzZS5yZWplY3QsXG5cdCAgICAgICAgfSA6IHt9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gdXNlUFNEKHBzZCwgZm4sIGExLCBhMiwgYTMpIHtcblx0ICAgICAgICB2YXIgb3V0ZXJTY29wZSA9IFBTRDtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuKGExLCBhMiwgYTMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKGZuLCB6b25lLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgb3V0ZXJab25lID0gUFNEO1xuXHQgICAgICAgICAgICBpZiAocG9zc2libGVBd2FpdClcblx0ICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCB0cnVlKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpbmFsbHkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyWm9uZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNsZWFudXApXG5cdCAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGV4ZWNJbkdsb2JhbENvbnRleHQoY2IpIHtcblx0ICAgICAgICBpZiAoUHJvbWlzZSA9PT0gTmF0aXZlUHJvbWlzZSAmJiB0YXNrLmVjaG9lcyA9PT0gMCkge1xuXHQgICAgICAgICAgICBpZiAoem9uZUVjaG9lcyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgY2IoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soY2IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgcmVqZWN0aW9uID0gRGV4aWVQcm9taXNlLnJlamVjdDtcblxuXHQgICAgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikge1xuXHQgICAgICAgIGlmICghZGIuaWRiZGIgfHwgKCFkYi5fc3RhdGUub3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2ggJiYgIWRiLl92aXApKSkge1xuXHQgICAgICAgICAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYi5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWRiLl9zdGF0ZS5hdXRvT3Blbilcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuXHQgICAgICAgICAgICAgICAgZGIub3BlbigpLmNhdGNoKG5vcCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGRiLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbik7IH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9wcm9taXNlKG1vZGUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnKVxuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zLmNvbW1pdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdyZWFkb25seScgPyByZXN1bHQgOiB0cmFucy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIERFWElFX1ZFUlNJT04gPSAnNC4wLjgnO1xuXHQgICAgdmFyIG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xuXHQgICAgdmFyIG1pbktleSA9IC1JbmZpbml0eTtcblx0ICAgIHZhciBJTlZBTElEX0tFWV9BUkdVTUVOVCA9IFwiSW52YWxpZCBrZXkgcHJvdmlkZWQuIEtleXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgbnVtYmVyLCBEYXRlIG9yIEFycmF5PHN0cmluZyB8IG51bWJlciB8IERhdGU+LlwiO1xuXHQgICAgdmFyIFNUUklOR19FWFBFQ1RFRCA9IFwiU3RyaW5nIGV4cGVjdGVkLlwiO1xuXHQgICAgdmFyIGNvbm5lY3Rpb25zID0gW107XG5cdCAgICB2YXIgREJOQU1FU19EQiA9ICdfX2RibmFtZXMnO1xuXHQgICAgdmFyIFJFQURPTkxZID0gJ3JlYWRvbmx5Jztcblx0ICAgIHZhciBSRUFEV1JJVEUgPSAncmVhZHdyaXRlJztcblxuXHQgICAgZnVuY3Rpb24gY29tYmluZShmaWx0ZXIxLCBmaWx0ZXIyKSB7XG5cdCAgICAgICAgcmV0dXJuIGZpbHRlcjEgP1xuXHQgICAgICAgICAgICBmaWx0ZXIyID9cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcjEuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBmaWx0ZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gOlxuXHQgICAgICAgICAgICAgICAgZmlsdGVyMSA6XG5cdCAgICAgICAgICAgIGZpbHRlcjI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBBbnlSYW5nZSA9IHtcblx0ICAgICAgICB0eXBlOiAzICxcblx0ICAgICAgICBsb3dlcjogLUluZmluaXR5LFxuXHQgICAgICAgIGxvd2VyT3BlbjogZmFsc2UsXG5cdCAgICAgICAgdXBwZXI6IFtbXV0sXG5cdCAgICAgICAgdXBwZXJPcGVuOiBmYWxzZVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcLi8udGVzdChrZXlQYXRoKVxuXHQgICAgICAgICAgICA/IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqID0gZGVlcENsb25lKG9iaik7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEVudGl0eSgpIHtcblx0ICAgICAgICB0aHJvdyBleGNlcHRpb25zLlR5cGUoKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY21wKGEsIGIpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgdGEgPSB0eXBlKGEpO1xuXHQgICAgICAgICAgICB2YXIgdGIgPSB0eXBlKGIpO1xuXHQgICAgICAgICAgICBpZiAodGEgIT09IHRiKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGEgPT09ICdBcnJheScpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGIgPT09ICdBcnJheScpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhID09PSAnYmluYXJ5Jylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YiA9PT0gJ2JpbmFyeScpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhID09PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YiA9PT0gJ3N0cmluZycpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhID09PSAnRGF0ZScpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgICAgICBpZiAodGIgIT09ICdEYXRlJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGEpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG5cdCAgICAgICAgICAgICAgICBjYXNlICdEYXRlJzpcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXNlICdBcnJheSc6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMoYSwgYik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKF9hKSB7IH1cblx0ICAgICAgICByZXR1cm4gTmFOO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhLCBiKSB7XG5cdCAgICAgICAgdmFyIGFsID0gYS5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGJsID0gYi5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGwgPSBhbCA8IGJsID8gYWwgOiBibDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuXHQgICAgICAgICAgICB2YXIgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuXHQgICAgICAgICAgICBpZiAocmVzICE9PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKGEsIGIpIHtcblx0ICAgICAgICB2YXIgYWwgPSBhLmxlbmd0aDtcblx0ICAgICAgICB2YXIgYmwgPSBiLmxlbmd0aDtcblx0ICAgICAgICB2YXIgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdCAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFbaV0gPCBiW2ldID8gLTEgOiAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB0eXBlKHgpIHtcblx0ICAgICAgICB2YXIgdCA9IHR5cGVvZiB4O1xuXHQgICAgICAgIGlmICh0ICE9PSAnb2JqZWN0Jylcblx0ICAgICAgICAgICAgcmV0dXJuIHQ7XG5cdCAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh4KSlcblx0ICAgICAgICAgICAgcmV0dXJuICdiaW5hcnknO1xuXHQgICAgICAgIHZhciB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpO1xuXHQgICAgICAgIHJldHVybiB0c1RhZyA9PT0gJ0FycmF5QnVmZmVyJyA/ICdiaW5hcnknIDogdHNUYWc7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRVaW50OEFycmF5KGEpIHtcblx0ICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG5cdCAgICAgICAgICAgIHJldHVybiBhO1xuXHQgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIFRhYmxlID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gVGFibGUoKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5fdHJhbnMgPSBmdW5jdGlvbiAobW9kZSwgZm4sIHdyaXRlTG9ja2VkKSB7XG5cdCAgICAgICAgICAgIHZhciB0cmFucyA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcblx0ICAgICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcblx0ICAgICAgICAgICAgdmFyIHRhc2sgPSBkZWJ1ZyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5jcmVhdGVUYXNrICYmIGNvbnNvbGUuY3JlYXRlVGFzayhcIkRleGllOiBcIi5jb25jYXQobW9kZSA9PT0gJ3JlYWRvbmx5JyA/ICdyZWFkJyA6ICd3cml0ZScsIFwiIFwiKS5jb25jYXQodGhpcy5uYW1lKSk7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghdHJhbnMuc2NoZW1hW3RhYmxlTmFtZV0pXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRyYW5zLmlkYnRyYW5zLCB0cmFucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHAgPSB0cmFucyAmJiB0cmFucy5kYi5fbm92aXAgPT09IHRoaXMuZGIuX25vdmlwID9cblx0ICAgICAgICAgICAgICAgICAgICB0cmFucyA9PT0gUFNELnRyYW5zID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCk7IH0sIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcblx0ICAgICAgICAgICAgICAgICAgICB0ZW1wVHJhbnNhY3Rpb24odGhpcy5kYiwgbW9kZSwgW3RoaXMubmFtZV0sIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0YXNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcC5fY29uc29sZVRhc2sgPSB0YXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHAgPSBwLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcblx0ICAgICAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleU9yQ3JpdCwgY2IpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKGtleU9yQ3JpdCAmJiBrZXlPckNyaXQuY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKGtleU9yQ3JpdCkuZmlyc3QoY2IpO1xuXHQgICAgICAgICAgICBpZiAoa2V5T3JDcml0ID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlR5cGUoXCJJbnZhbGlkIGFyZ3VtZW50IHRvIFRhYmxlLmdldCgpXCIpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUuZ2V0KHsgdHJhbnM6IHRyYW5zLCBrZXk6IGtleU9yQ3JpdCB9KVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcyk7IH0pO1xuXHQgICAgICAgICAgICB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChpbmRleE9yQ3JpdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JDcml0ID09PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpbmRleE9yQ3JpdCk7XG5cdCAgICAgICAgICAgIGlmIChpc0FycmF5KGluZGV4T3JDcml0KSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBcIltcIi5jb25jYXQoaW5kZXhPckNyaXQuam9pbignKycpLCBcIl1cIikpO1xuXHQgICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGluZGV4T3JDcml0KTtcblx0ICAgICAgICAgICAgaWYgKGtleVBhdGhzLmxlbmd0aCA9PT0gMSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuXHQgICAgICAgICAgICAgICAgICAgIC5lcXVhbHMoaW5kZXhPckNyaXRba2V5UGF0aHNbMF1dKTtcblx0ICAgICAgICAgICAgdmFyIGNvbXBvdW5kSW5kZXggPSB0aGlzLnNjaGVtYS5pbmRleGVzLmNvbmNhdCh0aGlzLnNjaGVtYS5wcmltS2V5KS5maWx0ZXIoZnVuY3Rpb24gKGl4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXguY29tcG91bmQgJiZcblx0ICAgICAgICAgICAgICAgICAgICBrZXlQYXRocy5ldmVyeShmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDA7IH0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlQYXRocy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aDsgfSlbMF07XG5cdCAgICAgICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIHRoaXMuZGIuX21heEtleSAhPT0gbWF4U3RyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5UGF0aHNJblZhbGlkT3JkZXIgPSBjb21wb3VuZEluZGV4LmtleVBhdGguc2xpY2UoMCwga2V5UGF0aHMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzSW5WYWxpZE9yZGVyKVxuXHQgICAgICAgICAgICAgICAgICAgIC5lcXVhbHMoa2V5UGF0aHNJblZhbGlkT3JkZXIubWFwKGZ1bmN0aW9uIChrcCkgeyByZXR1cm4gaW5kZXhPckNyaXRba3BdOyB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFjb21wb3VuZEluZGV4ICYmIGRlYnVnKVxuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIHF1ZXJ5IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShpbmRleE9yQ3JpdCksIFwiIG9uIFwiKS5jb25jYXQodGhpcy5uYW1lLCBcIiB3b3VsZCBiZW5lZml0IGZyb20gYSBcIikgK1xuXHQgICAgICAgICAgICAgICAgICAgIFwiY29tcG91bmQgaW5kZXggW1wiLmNvbmNhdChrZXlQYXRocy5qb2luKCcrJyksIFwiXVwiKSk7XG5cdCAgICAgICAgICAgIHZhciBpZHhCeU5hbWUgPSB0aGlzLnNjaGVtYS5pZHhCeU5hbWU7XG5cdCAgICAgICAgICAgIHZhciBpZGIgPSB0aGlzLmRiLl9kZXBzLmluZGV4ZWREQjtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpZGIuY21wKGEsIGIpID09PSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfYSA9IGtleVBhdGhzLnJlZHVjZShmdW5jdGlvbiAoX2EsIGtleVBhdGgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBfYVswXSwgcHJldkZpbHRlckZuID0gX2FbMV07XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpZHhCeU5hbWVba2V5UGF0aF07XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmRleE9yQ3JpdFtrZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4IHx8IGluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgIHByZXZJbmRleCB8fCAhaW5kZXggP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lKHByZXZGaWx0ZXJGbiwgaW5kZXggJiYgaW5kZXgubXVsdGkgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheShwcm9wKSAmJiBwcm9wLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGVxdWFscyh2YWx1ZSwgaXRlbSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogcHJldkZpbHRlckZuXG5cdCAgICAgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICB9LCBbbnVsbCwgbnVsbF0pLCBpZHggPSBfYVswXSwgZmlsdGVyRnVuY3Rpb24gPSBfYVsxXTtcblx0ICAgICAgICAgICAgcmV0dXJuIGlkeCA/XG5cdCAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuXHQgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcblx0ICAgICAgICAgICAgICAgIGNvbXBvdW5kSW5kZXggP1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuYW5kKGZpbHRlckZ1bmN0aW9uKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICh0aGVuU2hvcnRjdXQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQodGhlblNob3J0Y3V0KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24gKG51bVJvd3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkubGltaXQobnVtUm93cyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5lYWNoKGNhbGxiYWNrKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHRoZW5TaG9ydGN1dCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS50b0FycmF5KHRoZW5TaG9ydGN1dCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUudG9Db2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUub3JkZXJCeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpc0FycmF5KGluZGV4KSA/XG5cdCAgICAgICAgICAgICAgICBcIltcIi5jb25jYXQoaW5kZXguam9pbignKycpLCBcIl1cIikgOlxuXHQgICAgICAgICAgICAgICAgaW5kZXgpKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUubWFwVG9DbGFzcyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBkYiA9IF9hLmRiLCB0YWJsZU5hbWUgPSBfYS5uYW1lO1xuXHQgICAgICAgICAgICB0aGlzLnNjaGVtYS5tYXBwZWRDbGFzcyA9IGNvbnN0cnVjdG9yO1xuXHQgICAgICAgICAgICBpZiAoY29uc3RydWN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRW50aXR5KSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvciA9ICAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcImRiXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYjsgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFibGVOYW1lOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xuXHQgICAgICAgICAgICAgICAgfShjb25zdHJ1Y3RvcikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBpbmhlcml0ZWRQcm9wcyA9IG5ldyBTZXQoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgcHJvdG8gPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7IHByb3RvOyBwcm90byA9IGdldFByb3RvKHByb3RvKSkge1xuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBpbmhlcml0ZWRQcm9wcy5hZGQocHJvcE5hbWUpOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcmVhZEhvb2sgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9iailcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUoY29uc3RydWN0b3IucHJvdG90eXBlKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gb2JqKVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaW5oZXJpdGVkUHJvcHMuaGFzKG0pKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW21dID0gb2JqW21dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjaGVtYS5yZWFkSG9vaykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2NoZW1hLnJlYWRIb29rID0gcmVhZEhvb2s7XG5cdCAgICAgICAgICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuXHQgICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuZGVmaW5lQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKENsYXNzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuXHQgICAgICAgICAgICB2YXIgb2JqVG9BZGQgPSBvYmo7XG5cdCAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGF1dG8pIHtcblx0ICAgICAgICAgICAgICAgIG9ialRvQWRkID0gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkob2JqKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwsIHZhbHVlczogW29ialRvQWRkXSB9KTtcblx0ICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdDsgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsYXN0UmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGtleU9yT2JqZWN0KSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldEJ5S2V5UGF0aChrZXlPck9iamVjdCwgdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkdpdmVuIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGl0cyBwcmltYXJ5IGtleVwiKSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnNjaGVtYS5wcmltS2V5LCBhdXRvID0gX2EuYXV0bywga2V5UGF0aCA9IF9hLmtleVBhdGg7XG5cdCAgICAgICAgICAgIHZhciBvYmpUb0FkZCA9IG9iajtcblx0ICAgICAgICAgICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuXHQgICAgICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ3B1dCcsIHZhbHVlczogW29ialRvQWRkXSwga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwgfSk7IH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdDsgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsYXN0UmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBba2V5XSB9KTsgfSlcblx0ICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZDsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBfdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlIH0pOyB9KVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrR2V0ID0gZnVuY3Rpb24gKGtleXMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUuZ2V0TWFueSh7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcblx0ICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnNcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0Lm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpOyB9KTsgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVGFibGUucHJvdG90eXBlLmJ1bGtBZGQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMpO1xuXHQgICAgICAgICAgICB2YXIgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc2NoZW1hLnByaW1LZXksIGF1dG8gPSBfYS5hdXRvLCBrZXlQYXRoID0gX2Eua2V5UGF0aDtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa0FkZCgpOiBrZXlzIGFyZ3VtZW50IGludmFsaWQgb24gdGFibGVzIHdpdGggaW5ib3VuZCBrZXlzXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdmFyIG9iamVjdHNUb0FkZCA9IGtleVBhdGggJiYgYXV0byA/XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3RzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvcmUubXV0YXRlKHsgdHJhbnM6IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5cywgdmFsdWVzOiBvYmplY3RzVG9BZGQsIHdhbnRSZXN1bHRzOiB3YW50UmVzdWx0cyB9KVxuXHQgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzLCByZXN1bHRzID0gX2EucmVzdWx0cywgbGFzdFJlc3VsdCA9IF9hLmxhc3RSZXN1bHQsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa0FkZCgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bU9iamVjdHMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa1B1dCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG5cdCAgICAgICAgICAgIHZhciB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zY2hlbWEucHJpbUtleSwgYXV0byA9IF9hLmF1dG8sIGtleVBhdGggPSBfYS5rZXlQYXRoO1xuXHQgICAgICAgICAgICAgICAgaWYgKGtleVBhdGggJiYga2V5cylcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrUHV0KCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3RzLm1hcCh3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSkgOlxuXHQgICAgICAgICAgICAgICAgICAgIG9iamVjdHM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdwdXQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHM6IHdhbnRSZXN1bHRzIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIHJlc3VsdHMgPSBfYS5yZXN1bHRzLCBsYXN0UmVzdWx0ID0gX2EubGFzdFJlc3VsdCwgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrUHV0KCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtT2JqZWN0cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRhYmxlLnByb3RvdHlwZS5idWxrVXBkYXRlID0gZnVuY3Rpb24gKGtleXNBbmRDaGFuZ2VzKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSB0aGlzLmNvcmU7XG5cdCAgICAgICAgICAgIHZhciBrZXlzID0ga2V5c0FuZENoYW5nZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkua2V5OyB9KTtcblx0ICAgICAgICAgICAgdmFyIGNoYW5nZVNwZWNzID0ga2V5c0FuZENoYW5nZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuY2hhbmdlczsgfSk7XG5cdCAgICAgICAgICAgIHZhciBvZmZzZXRNYXAgPSBbXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuZ2V0TWFueSh7IHRyYW5zOiB0cmFucywga2V5czoga2V5cywgY2FjaGU6ICdjbG9uZScgfSkudGhlbihmdW5jdGlvbiAob2Jqcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRLZXlzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdE9ianMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzQW5kQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgaWR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXksIGNoYW5nZXMgPSBfYS5jaGFuZ2VzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2Jqc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBfYltfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbmdlc1trZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCA9PT0gX3RoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY21wKHZhbHVlLCBrZXkpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Db25zdHJhaW50KFwiQ2Fubm90IHVwZGF0ZSBwcmltYXJ5IGtleSBpbiBidWxrVXBkYXRlKClcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRNYXAucHVzaChpZHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0S2V5cy5wdXNoKGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpzLnB1c2gob2JqKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBudW1FbnRyaWVzID0gcmVzdWx0S2V5cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAubXV0YXRlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0Jyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVzdWx0S2V5cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXN1bHRPYmpzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlY3M6IGNoYW5nZVNwZWNzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1FbnRyaWVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IF9iW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWRPZmZzZXQgPSBvZmZzZXRNYXBbTnVtYmVyKG9mZnNldCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZE9mZnNldCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSBmYWlsdXJlc1tvZmZzZXRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmYWlsdXJlc1tvZmZzZXRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW21hcHBlZE9mZnNldF0gPSBmYWlsdXJlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCIuYnVsa1VwZGF0ZSgpOiBcIikuY29uY2F0KG51bUZhaWx1cmVzLCBcIiBvZiBcIikuY29uY2F0KG51bUVudHJpZXMsIFwiIG9wZXJhdGlvbnMgZmFpbGVkXCIpLCBmYWlsdXJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUYWJsZS5wcm90b3R5cGUuYnVsa0RlbGV0ZSA9IGZ1bmN0aW9uIChrZXlzKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIH0pO1xuXHQgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0LCBmYWlsdXJlcyA9IF9hLmZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi5idWxrRGVsZXRlKCk6IFwiKS5jb25jYXQobnVtRmFpbHVyZXMsIFwiIG9mIFwiKS5jb25jYXQobnVtS2V5cywgXCIgb3BlcmF0aW9ucyBmYWlsZWRcIiksIGZhaWx1cmVzKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gVGFibGU7XG5cdCAgICB9KCkpO1xuXG5cdCAgICBmdW5jdGlvbiBFdmVudHMoY3R4KSB7XG5cdCAgICAgICAgdmFyIGV2cyA9IHt9O1xuXHQgICAgICAgIHZhciBydiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmliZXIpIHtcblx0ICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoLS1pKVxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgZXZzW2V2ZW50TmFtZV0uc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgYWRkKGFyZ3VtZW50c1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydjtcblx0ICAgICAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcblx0ICAgICAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKVxuXHQgICAgICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuXHQgICAgICAgICAgICBpZiAoIWRlZmF1bHRGdW5jdGlvbilcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcblx0ICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG5cdCAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG5cdCAgICAgICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG5cdCAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuXHQgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gYWRkQ29uZmlndXJlZEV2ZW50cyhjZmcpIHtcblx0ICAgICAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjZmdbZXZlbnROYW1lXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ3MpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MgPT09ICdhc2FwJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYWRkKGV2ZW50TmFtZSwgbWlycm9yLCBmdW5jdGlvbiBmaXJlKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc2FwJDEoZnVuY3Rpb24gZmlyZUV2ZW50KCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIG1ha2VDbGFzc0NvbnN0cnVjdG9yKHByb3RvdHlwZSwgY29uc3RydWN0b3IpIHtcblx0ICAgICAgICBkZXJpdmUoY29uc3RydWN0b3IpLmZyb20oeyBwcm90b3R5cGU6IHByb3RvdHlwZSB9KTtcblx0ICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IoZGIpIHtcblx0ICAgICAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVGFibGUucHJvdG90eXBlLCBmdW5jdGlvbiBUYWJsZShuYW1lLCB0YWJsZVNjaGVtYSwgdHJhbnMpIHtcblx0ICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuXHQgICAgICAgICAgICB0aGlzLl90eCA9IHRyYW5zO1xuXHQgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuXHQgICAgICAgICAgICB0aGlzLmhvb2sgPSBkYi5fYWxsVGFibGVzW25hbWVdID8gZGIuX2FsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcblx0ICAgICAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuXHQgICAgICAgICAgICAgICAgXCJyZWFkaW5nXCI6IFtwdXJlRnVuY3Rpb25DaGFpbiwgbWlycm9yXSxcblx0ICAgICAgICAgICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuXHQgICAgICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZShjdHgsIGlnbm9yZUxpbWl0RmlsdGVyKSB7XG5cdCAgICAgICAgcmV0dXJuICEoY3R4LmZpbHRlciB8fCBjdHguYWxnb3JpdGhtIHx8IGN0eC5vcikgJiZcblx0ICAgICAgICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkZEZpbHRlcihjdHgsIGZuKSB7XG5cdCAgICAgICAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyKGN0eCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcikge1xuXHQgICAgICAgIHZhciBjdXJyID0gY3R4LnJlcGxheUZpbHRlcjtcblx0ICAgICAgICBjdHgucmVwbGF5RmlsdGVyID0gY3VyciA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbWJpbmUoY3VycigpLCBmYWN0b3J5KCkpOyB9IDogZmFjdG9yeTtcblx0ICAgICAgICBjdHguanVzdExpbWl0ID0gaXNMaW1pdEZpbHRlciAmJiAhY3Vycjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkZE1hdGNoRmlsdGVyKGN0eCwgZm4pIHtcblx0ICAgICAgICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVTY2hlbWEpIHtcblx0ICAgICAgICBpZiAoY3R4LmlzUHJpbUtleSlcblx0ICAgICAgICAgICAgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcblx0ICAgICAgICB2YXIgaW5kZXggPSBjb3JlU2NoZW1hLmdldEluZGV4QnlLZXlQYXRoKGN0eC5pbmRleCk7XG5cdCAgICAgICAgaWYgKCFpbmRleClcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuXHQgICAgICAgIHJldHVybiBpbmRleDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIHRyYW5zKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVRhYmxlLnNjaGVtYSk7XG5cdCAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5vcGVuQ3Vyc29yKHtcblx0ICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICB2YWx1ZXM6ICFjdHgua2V5c09ubHksXG5cdCAgICAgICAgICAgIHJldmVyc2U6IGN0eC5kaXIgPT09ICdwcmV2Jyxcblx0ICAgICAgICAgICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG5cdCAgICAgICAgICAgIHF1ZXJ5OiB7XG5cdCAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGl0ZXIoY3R4LCBmbiwgY29yZVRyYW5zLCBjb3JlVGFibGUpIHtcblx0ICAgICAgICB2YXIgZmlsdGVyID0gY3R4LnJlcGxheUZpbHRlciA/IGNvbWJpbmUoY3R4LmZpbHRlciwgY3R4LnJlcGxheUZpbHRlcigpKSA6IGN0eC5maWx0ZXI7XG5cdCAgICAgICAgaWYgKCFjdHgub3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY29tYmluZShjdHguYWxnb3JpdGhtLCBmaWx0ZXIpLCBmbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHNldF8xID0ge307XG5cdCAgICAgICAgICAgIHZhciB1bmlvbiA9IGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IsIGFkdmFuY2UpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2UsIGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGN1cnNvci5zdG9wKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGN1cnNvci5mYWlsKGVycik7IH0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gJycgKyBwcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICcnICsgbmV3IFVpbnQ4QXJyYXkocHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd24oc2V0XzEsIGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0XzFba2V5XSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuXHQgICAgICAgICAgICAgICAgY3R4Lm9yLl9pdGVyYXRlKHVuaW9uLCBjb3JlVHJhbnMpLFxuXHQgICAgICAgICAgICAgICAgaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjdHguYWxnb3JpdGhtLCB1bmlvbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGl0ZXJhdGUoY3Vyc29yUHJvbWlzZSwgZmlsdGVyLCBmbiwgdmFsdWVNYXBwZXIpIHtcblx0ICAgICAgICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/IGZ1bmN0aW9uICh4LCBjLCBhKSB7IHJldHVybiBmbih2YWx1ZU1hcHBlcih4KSwgYywgYSk7IH0gOiBmbjtcblx0ICAgICAgICB2YXIgd3JhcHBlZEZuID0gd3JhcChtYXBwZWRGbik7XG5cdCAgICAgICAgcmV0dXJuIGN1cnNvclByb21pc2UudGhlbihmdW5jdGlvbiAoY3Vyc29yKSB7XG5cdCAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3Iuc3RhcnQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3Vyc29yLmNvbnRpbnVlKCk7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgZnVuY3Rpb24gKGFkdmFuY2VyKSB7IHJldHVybiBjID0gYWR2YW5jZXI7IH0sIGZ1bmN0aW9uICh2YWwpIHsgY3Vyc29yLnN0b3AodmFsKTsgYyA9IG5vcDsgfSwgZnVuY3Rpb24gKGUpIHsgY3Vyc29yLmZhaWwoZSk7IGMgPSBub3A7IH0pKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGZ1bmN0aW9uIChhZHZhbmNlcikgeyByZXR1cm4gYyA9IGFkdmFuY2VyOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBjKCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgUHJvcE1vZFN5bWJvbCA9IFN5bWJvbCgpO1xuXHQgICAgdmFyIFByb3BNb2RpZmljYXRpb24gPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBQcm9wTW9kaWZpY2F0aW9uKHNwZWMpIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzcGVjKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgUHJvcE1vZGlmaWNhdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmFkZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGVybSA9IHRoaXMuYWRkO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodGVybSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKSwgdHJ1ZSksIHRlcm0sIHRydWUpLnNvcnQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ251bWJlcicpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIodmFsdWUpIHx8IDApICsgdGVybTtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ2JpZ2ludCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKSArIHRlcm07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KDApICsgdGVybTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0ZXJtIFwiLmNvbmNhdCh0ZXJtKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0cmFoZW5kXzEgPSB0aGlzLnJlbW92ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHN1YnRyYWhlbmRfMSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFzdWJ0cmFoZW5kXzEuaW5jbHVkZXMoaXRlbSk7IH0pLnNvcnQoKSA6IFtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJ0cmFoZW5kXzEgPT09ICdudW1iZXInKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpIC0gc3VidHJhaGVuZF8xO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJ0cmFoZW5kXzEgPT09ICdiaWdpbnQnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgLSBzdWJ0cmFoZW5kXzE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KDApIC0gc3VidHJhaGVuZF8xO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN1YnRyYWhlbmQgXCIuY29uY2F0KHN1YnRyYWhlbmRfMSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwcmVmaXhUb1JlcGxhY2UgPSAoX2EgPSB0aGlzLnJlcGxhY2VQcmVmaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcblx0ICAgICAgICAgICAgaWYgKHByZWZpeFRvUmVwbGFjZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnN0YXJ0c1dpdGgocHJlZml4VG9SZXBsYWNlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVByZWZpeFsxXSArIHZhbHVlLnN1YnN0cmluZyhwcmVmaXhUb1JlcGxhY2UubGVuZ3RoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gUHJvcE1vZGlmaWNhdGlvbjtcblx0ICAgIH0oKSk7XG5cblx0ICAgIHZhciBDb2xsZWN0aW9uID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcblx0ICAgICAgICB9XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoZm4sIGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdCAgICAgICAgICAgIHJldHVybiBjdHguZXJyb3IgP1xuXHQgICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG5cdCAgICAgICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkb25seScsIGZuKS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChmbikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cblx0ICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuXHQgICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZHdyaXRlJywgZm4sIFwibG9ja2VkXCIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX2FkZEFsZ29yaXRobSA9IGZ1bmN0aW9uIChmbikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICBjdHguYWxnb3JpdGhtID0gY29tYmluZShjdHguYWxnb3JpdGhtLCBmbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgY29yZVRyYW5zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpdGVyKHRoaXMuX2N0eCwgZm4sIGNvcmVUcmFucywgdGhpcy5fY3R4LnRhYmxlLmNvcmUpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAocHJvcHMpIHtcblx0ICAgICAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksIGN0eCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY3R4KTtcblx0ICAgICAgICAgICAgaWYgKHByb3BzKVxuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKGN0eCwgcHJvcHMpO1xuXHQgICAgICAgICAgICBydi5fY3R4ID0gY3R4O1xuXHQgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eC52YWx1ZU1hcHBlciA9IG51bGw7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIGl0ZXIoY3R4LCBmbiwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAodHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5jb3VudCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyKGN0eCwgZnVuY3Rpb24gKCkgeyArK2NvdW50OyByZXR1cm4gZmFsc2U7IH0sIHRyYW5zLCBjb3JlVGFibGUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvdW50OyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiAoa2V5UGF0aCwgY2IpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSwgbGFzdFBhcnQgPSBwYXJ0c1swXSwgbGFzdEluZGV4ID0gcGFydHMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gZ2V0dmFsKG9iaiwgaSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHZhbChvYmpbcGFydHNbaV1dLCBpIC0gMSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2xhc3RQYXJ0XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhVmFsIDwgYlZhbCA/IC1vcmRlciA6IGFWYWwgPiBiVmFsID8gb3JkZXIgOiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhLnNvcnQoc29ydGVyKTtcblx0ICAgICAgICAgICAgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN0eCA9IF90aGlzLl9jdHg7XG5cdCAgICAgICAgICAgICAgICBpZiAoY3R4LmRpciA9PT0gJ25leHQnICYmIGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpICYmIGN0eC5saW1pdCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVNYXBwZXJfMSA9IGN0eC52YWx1ZU1hcHBlcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlTWFwcGVyXzEgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyXzEpIDogcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFfMSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyKGN0eCwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGFfMS5wdXNoKGl0ZW0pOyB9LCB0cmFucywgY3R4LnRhYmxlLmNvcmUpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gYV8xOyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgY3R4Lm9mZnNldCArPSBvZmZzZXQ7XG5cdCAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSkge1xuXHQgICAgICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLW9mZnNldExlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gKC0tb2Zmc2V0TGVmdCA8IDApOyB9O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChudW1Sb3dzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eC5saW1pdCA9IE1hdGgubWluKHRoaXMuX2N0eC5saW1pdCwgbnVtUm93cyk7XG5cdCAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd3NMZWZ0ID49IDA7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9LCB0cnVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS51bnRpbCA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbiwgYkluY2x1ZGVTdG9wRW50cnkpIHtcblx0ICAgICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBiSW5jbHVkZVN0b3BFbnRyeTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0KGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuXHQgICAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGFkZE1hdGNoRmlsdGVyKHRoaXMuX2N0eCwgZmlsdGVyRnVuY3Rpb24pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N0eC5kaXIgPSAodGhpcy5fY3R4LmRpciA9PT0gXCJwcmV2XCIgPyBcIm5leHRcIiA6IFwicHJldlwiKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UodGhpcy5fY3R4LmRpcik7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVzYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaEtleSA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5rZXksIGN1cnNvcik7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWFjaFVuaXF1ZUtleSA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoUHJpbWFyeUtleSA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IpOyB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0ICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuXHQgICAgICAgICAgICB2YXIgYSA9IFtdO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcblx0ICAgICAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcblx0ICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgICAgICAgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wcmltYXJ5S2V5cyA9IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICBpZiAoY3R4LmRpciA9PT0gJ25leHQnICYmIGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpICYmIGN0eC5saW1pdCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uICh0cmFucykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnM6IHRyYW5zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfYS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcblx0ICAgICAgICAgICAgdmFyIGEgPSBbXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhO1xuXHQgICAgICAgICAgICB9KS50aGVuKGNiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnVuaXF1ZUtleXMgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMoY2IpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlyc3RLZXkgPSBmdW5jdGlvbiAoY2IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkua2V5cyhmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5sYXN0S2V5ID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdEtleShjYik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG5cdCAgICAgICAgICAgIGlmICghaWR4IHx8ICFpZHgubXVsdGkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHNldCA9IHt9O1xuXHQgICAgICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG5cdCAgICAgICAgICAgICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kaWZ5ZXI7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGNoYW5nZXM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGNoYW5nZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0ga2V5UGF0aHNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gY2hhbmdlc1trZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnVmFsID0gZ2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb3BNb2RpZmljYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsLmV4ZWN1dGUob3JpZ1ZhbCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZ1ZhbCAhPT0gdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjb3JlVGFibGUgPSBjdHgudGFibGUuY29yZTtcblx0ICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvcmVUYWJsZS5zY2hlbWEucHJpbWFyeUtleSwgb3V0Ym91bmQgPSBfYS5vdXRib3VuZCwgZXh0cmFjdEtleSA9IF9hLmV4dHJhY3RLZXk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSBfdGhpcy5kYi5fb3B0aW9ucy5tb2RpZnlDaHVua1NpemUgfHwgMjAwO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvdGFsRmFpbHVyZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzQ291bnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgdmFyIGZhaWxlZEtleXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHZhciBhcHBseU11dGF0ZVJlc3VsdCA9IGZ1bmN0aW9uIChleHBlY3RlZENvdW50LCByZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSByZXMuZmFpbHVyZXMsIG51bUZhaWx1cmVzID0gcmVzLm51bUZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCArPSBleHBlY3RlZENvdW50IC0gbnVtRmFpbHVyZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGtleXMoZmFpbHVyZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gX2FbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEZhaWx1cmVzLnB1c2goZmFpbHVyZXNbcG9zXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jbG9uZSgpLnByaW1hcnlLZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW1pdCA9PT0gSW5maW5pdHkgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nIHx8IGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSAmJiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2Vcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2h1bmsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IE1hdGgubWluKGxpbWl0LCBrZXlzLmxlbmd0aCAtIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlVGFibGUuZ2V0TWFueSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IFwiaW1tdXRhYmxlXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkVmFsdWVzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHV0VmFsdWVzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUtleXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnVmFsdWUgPSB2YWx1ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eF8xID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVlcENsb25lKG9yaWdWYWx1ZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXk6IGtleXNbb2Zmc2V0ICsgaV1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnllci5jYWxsKGN0eF8xLCBjdHhfMS52YWx1ZSwgY3R4XzEpICE9PSBmYWxzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4XzEudmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eF8xLnZhbHVlKSkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhbHVlcy5wdXNoKGN0eF8xLnZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhbHVlcy5wdXNoKGN0eF8xLnZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZFZhbHVlcy5sZW5ndGggPiAwICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7IHRyYW5zOiB0cmFucywgdHlwZTogJ2FkZCcsIHZhbHVlczogYWRkVmFsdWVzIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcG9zIGluIHJlcy5mYWlsdXJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5zcGxpY2UocGFyc2VJbnQocG9zKSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlNdXRhdGVSZXN1bHQoYWRkVmFsdWVzLmxlbmd0aCwgcmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAocHV0VmFsdWVzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIHR5cGVvZiBjaGFuZ2VzID09PSAnb2JqZWN0JykpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcHV0VmFsdWVzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYTogY3JpdGVyaWEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2VzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FkZGl0aW9uYWxDaHVuazogb2Zmc2V0ID4gMFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gYXBwbHlNdXRhdGVSZXN1bHQocHV0VmFsdWVzLmxlbmd0aCwgcmVzKTsgfSk7IH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gKGRlbGV0ZUtleXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spKSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBkZWxldGVLZXlzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYTogY3JpdGVyaWEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWRkaXRpb25hbENodW5rOiBvZmZzZXQgPiAwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBhcHBseU11dGF0ZVJlc3VsdChkZWxldGVLZXlzLmxlbmd0aCwgcmVzKTsgfSk7IH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IG9mZnNldCArIGNvdW50ICYmIG5leHRDaHVuayhvZmZzZXQgKyBsaW1pdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENodW5rKDApLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxGYWlsdXJlcy5sZW5ndGggPiAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiRXJyb3IgbW9kaWZ5aW5nIG9uZSBvciBtb3JlIG9iamVjdHNcIiwgdG90YWxGYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCByYW5nZSA9IGN0eC5yYW5nZTtcblx0ICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG5cdCAgICAgICAgICAgICAgICAoY3R4LmlzUHJpbUtleSB8fCByYW5nZS50eXBlID09PSAzICkpXG5cdCAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnVuY3Rpb24gKHRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdHgudGFibGUuY29yZS5zY2hlbWEucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29yZVJhbmdlID0gcmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLmNvdW50KHsgdHJhbnM6IHRyYW5zLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IGNvcmVSYW5nZSB9IH0pLnRoZW4oZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5tdXRhdGUoeyB0cmFuczogdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBjb3JlUmFuZ2UgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gX2EuZmFpbHVyZXM7IF9hLmxhc3RSZXN1bHQ7IF9hLnJlc3VsdHM7IHZhciBudW1GYWlsdXJlcyA9IF9hLm51bUZhaWx1cmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkNvdWxkIG5vdCBkZWxldGUgc29tZSB2YWx1ZXNcIiwgT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBmYWlsdXJlc1twb3NdOyB9KSwgY291bnQgLSBudW1GYWlsdXJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgLSBudW1GYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RpZnkoZGVsZXRlQ2FsbGJhY2spO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIENvbGxlY3Rpb247XG5cdCAgICB9KCkpO1xuXHQgICAgdmFyIGRlbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHsgcmV0dXJuIGN0eC52YWx1ZSA9IG51bGw7IH07XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuXHQgICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihDb2xsZWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwga2V5UmFuZ2VHZW5lcmF0b3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuXHQgICAgICAgICAgICB2YXIga2V5UmFuZ2UgPSBBbnlSYW5nZSwgZXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICBpZiAoa2V5UmFuZ2VHZW5lcmF0b3IpXG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVJhbmdlID0ga2V5UmFuZ2VHZW5lcmF0b3IoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB3aGVyZUN0eCA9IHdoZXJlQ2xhdXNlLl9jdHg7XG5cdCAgICAgICAgICAgIHZhciB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuXHQgICAgICAgICAgICB2YXIgcmVhZGluZ0hvb2sgPSB0YWJsZS5ob29rLnJlYWRpbmcuZmlyZTtcblx0ICAgICAgICAgICAgdGhpcy5fY3R4ID0ge1xuXHQgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuXHQgICAgICAgICAgICAgICAgaW5kZXg6IHdoZXJlQ3R4LmluZGV4LFxuXHQgICAgICAgICAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG5cdCAgICAgICAgICAgICAgICByYW5nZToga2V5UmFuZ2UsXG5cdCAgICAgICAgICAgICAgICBrZXlzT25seTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICBkaXI6IFwibmV4dFwiLFxuXHQgICAgICAgICAgICAgICAgdW5pcXVlOiBcIlwiLFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgZmlsdGVyOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgcmVwbGF5RmlsdGVyOiBudWxsLFxuXHQgICAgICAgICAgICAgICAganVzdExpbWl0OiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgaXNNYXRjaDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIG9mZnNldDogMCxcblx0ICAgICAgICAgICAgICAgIGxpbWl0OiBJbmZpbml0eSxcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcblx0ICAgICAgICAgICAgICAgIG9yOiB3aGVyZUN0eC5vcixcblx0ICAgICAgICAgICAgICAgIHZhbHVlTWFwcGVyOiByZWFkaW5nSG9vayAhPT0gbWlycm9yID8gcmVhZGluZ0hvb2sgOiBudWxsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcblx0ICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIGluc3RhbmNlb2YgV2hlcmVDbGF1c2UgP1xuXHQgICAgICAgICAgICBuZXcgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UuQ29sbGVjdGlvbihjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSkgOlxuXHQgICAgICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcblx0ICAgICAgICBjb2xsZWN0aW9uLl9jdHguZXJyb3IgPSBUID8gbmV3IFQoZXJyKSA6IG5ldyBUeXBlRXJyb3IoZXJyKTtcblx0ICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGVtcHR5Q29sbGVjdGlvbih3aGVyZUNsYXVzZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFuZ2VFcXVhbChcIlwiKTsgfSkubGltaXQoMCk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB1cHBlckZhY3RvcnkoZGlyKSB7XG5cdCAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuXHQgICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9IDpcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTsgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXIpIHtcblx0ICAgICAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH0gOlxuXHQgICAgICAgICAgICBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1VwcGVyQ2FzZSgpOyB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZSwgbG93ZXJOZWVkbGUsIGNtcCwgZGlyKSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGxscCA9IC0xO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcblx0ICAgICAgICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgdXBwZXJOZWVkbGVbaV0pIDwgMClcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgbG93ZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGxscCA+PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMClcblx0ICAgICAgICAgICAgICAgIGxscCA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIilcblx0ICAgICAgICAgICAgcmV0dXJuIGtleSArIHVwcGVyTmVlZGxlLnN1YnN0cihrZXkubGVuZ3RoKTtcblx0ICAgICAgICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKVxuXHQgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuXHQgICAgICAgIHJldHVybiAobGxwIDwgMCA/IG51bGwgOiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlck5lZWRsZVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcblx0ICAgICAgICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LCBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKCFuZWVkbGVzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWlsKHdoZXJlQ2xhdXNlLCBTVFJJTkdfRVhQRUNURUQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuXHQgICAgICAgICAgICB1cHBlciA9IHVwcGVyRmFjdG9yeShkaXIpO1xuXHQgICAgICAgICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuXHQgICAgICAgICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuXHQgICAgICAgICAgICB2YXIgbmVlZGxlQm91bmRzID0gbmVlZGxlcy5tYXAoZnVuY3Rpb24gKG5lZWRsZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgbG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpIH07XG5cdCAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGEubG93ZXIsIGIubG93ZXIpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdXBwZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcblx0ICAgICAgICAgICAgbG93ZXJOZWVkbGVzID0gbmVlZGxlQm91bmRzLm1hcChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIG5iLmxvd2VyOyB9KTtcblx0ICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlyO1xuXHQgICAgICAgICAgICBuZXh0S2V5U3VmZml4ID0gKGRpciA9PT0gXCJuZXh0XCIgPyBcIlwiIDogc3VmZml4KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG5cdCAgICAgICAgdmFyIGMgPSBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbiAtIDFdICsgc3VmZml4KTsgfSk7XG5cdCAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgIGluaXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcblx0ICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgbG93ZXJLZXkgPSBsb3dlcihrZXkpO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBvc3NpYmxlTmVlZGxlOyBpIDwgbmVlZGxlc0xlbjsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhc2luZyA9PT0gbnVsbCAmJiBsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IGkgKyAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gY2FzaW5nO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUobG93ZXN0UG9zc2libGVDYXNpbmcgKyBuZXh0S2V5U3VmZml4KTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGM7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogMiAsXG5cdCAgICAgICAgICAgIGxvd2VyOiBsb3dlcixcblx0ICAgICAgICAgICAgdXBwZXI6IHVwcGVyLFxuXHQgICAgICAgICAgICBsb3dlck9wZW46IGxvd2VyT3Blbixcblx0ICAgICAgICAgICAgdXBwZXJPcGVuOiB1cHBlck9wZW5cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcmFuZ2VFcXVhbCh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHR5cGU6IDEgLFxuXHQgICAgICAgICAgICBsb3dlcjogdmFsdWUsXG5cdCAgICAgICAgICAgIHVwcGVyOiB2YWx1ZVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBXaGVyZUNsYXVzZSA9ICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKCkge1xuXHQgICAgICAgIH1cblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBcIkNvbGxlY3Rpb25cIiwge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdHgudGFibGUuZGIuQ29sbGVjdGlvbjtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5iZXR3ZWVuID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcblx0ICAgICAgICAgICAgaW5jbHVkZUxvd2VyID0gaW5jbHVkZUxvd2VyICE9PSBmYWxzZTtcblx0ICAgICAgICAgICAgaW5jbHVkZVVwcGVyID0gaW5jbHVkZVVwcGVyID09PSB0cnVlO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA+IDApIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID09PSAwICYmIChpbmNsdWRlTG93ZXIgfHwgaW5jbHVkZVVwcGVyKSAmJiAhKGluY2x1ZGVMb3dlciAmJiBpbmNsdWRlVXBwZXIpKSlcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCAhaW5jbHVkZUxvd2VyLCAhaW5jbHVkZVVwcGVyKTsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFuZ2VFcXVhbCh2YWx1ZSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFib3ZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuYWJvdmVPckVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCBmYWxzZSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJlbG93ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmJlbG93T3JFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oc3RyLCBzdHIgKyBtYXhTdHJpbmcsIHRydWUsIHRydWUpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLnN0YXJ0c1dpdGhJZ25vcmVDYXNlID0gZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgICAgICBpZiAoc3RyID09PSBcIlwiKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRzV2l0aChzdHIpO1xuXHQgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4geC5pbmRleE9mKGFbMF0pID09PSAwOyB9LCBbc3RyXSwgbWF4U3RyaW5nKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5lcXVhbHNJZ25vcmVDYXNlID0gZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4geCA9PT0gYVswXTsgfSwgW3N0cl0sIFwiXCIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLmFueU9mSWdub3JlQ2FzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5pbmRleE9mKHgpICE9PSAtMTsgfSwgc2V0LCBcIlwiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5zdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiBhLnNvbWUoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIHguaW5kZXhPZihuKSA9PT0gMDsgfSk7IH0sIHNldCwgbWF4U3RyaW5nKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZS5hbnlPZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jbXA7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJhbmdlKHNldFswXSwgc2V0W3NldC5sZW5ndGggLSAxXSk7IH0pO1xuXHQgICAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FzY2VuZGluZyA6XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rlc2NlbmRpbmcpO1xuXHQgICAgICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHZhciBpID0gMDtcblx0ICAgICAgICAgICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICsraTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc2V0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBjO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UoW1ttaW5LZXksIHZhbHVlXSwgW3ZhbHVlLCB0aGlzLmRiLl9tYXhLZXldXSwgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUubm9uZU9mID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc2V0LnNvcnQodGhpcy5fYXNjZW5kaW5nKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByYW5nZXMgPSBzZXQucmVkdWNlKGZ1bmN0aW9uIChyZXMsIHZhbCkgeyByZXR1cm4gcmVzID9cblx0ICAgICAgICAgICAgICAgIHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOlxuXHQgICAgICAgICAgICAgICAgW1ttaW5LZXksIHZhbF1dOyB9LCBudWxsKTtcblx0ICAgICAgICAgICAgcmFuZ2VzLnB1c2goW3NldFtzZXQubGVuZ3RoIC0gMV0sIHRoaXMuZGIuX21heEtleV0pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuaW5BbnlSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZXMsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGNtcCA9IHRoaXMuX2NtcCwgYXNjZW5kaW5nID0gdGhpcy5fYXNjZW5kaW5nLCBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZywgbWluID0gdGhpcy5fbWluLCBtYXggPSB0aGlzLl9tYXg7XG5cdCAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblx0ICAgICAgICAgICAgaWYgKCFyYW5nZXMuZXZlcnkoZnVuY3Rpb24gKHJhbmdlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJlxuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlWzFdICE9PSB1bmRlZmluZWQgJiZcblx0ICAgICAgICAgICAgICAgICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwO1xuXHQgICAgICAgICAgICB9KSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJGaXJzdCBhcmd1bWVudCB0byBpbkFueVJhbmdlKCkgbXVzdCBiZSBhbiBBcnJheSBvZiB0d28tdmFsdWUgQXJyYXlzIFtsb3dlcix1cHBlcl0gd2hlcmUgdXBwZXIgbXVzdCBub3QgYmUgbG93ZXIgdGhhbiBsb3dlclwiLCBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgaW5jbHVkZVVwcGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlVXBwZXJzID09PSB0cnVlO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZXMsIG5ld1JhbmdlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGwgPSByYW5nZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNtcChuZXdSYW5nZVswXSwgcmFuZ2VbMV0pIDwgMCAmJiBjbXAobmV3UmFuZ2VbMV0sIHJhbmdlWzBdKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBtYXgocmFuZ2VbMV0sIG5ld1JhbmdlWzFdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGkgPT09IGwpXG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcblx0ICAgICAgICAgICAgZnVuY3Rpb24gcmFuZ2VTb3J0ZXIoYSwgYikgeyByZXR1cm4gc29ydERpcmVjdGlvbihhWzBdLCBiWzBdKTsgfVxuXHQgICAgICAgICAgICB2YXIgc2V0O1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuXHQgICAgICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByYW5nZVBvcyA9IDA7XG5cdCAgICAgICAgICAgIHZhciBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSA9IGluY2x1ZGVVcHBlcnMgP1xuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPiAwOyB9IDpcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID49IDA7IH07XG5cdCAgICAgICAgICAgIHZhciBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID4gMDsgfSA6XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPj0gMDsgfTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24ga2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuXHQgICAgICAgICAgICB2YXIgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlUmFuZ2Uoc2V0WzBdWzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdWzFdLCAhaW5jbHVkZUxvd2VycywgIWluY2x1ZGVVcHBlcnMpOyB9KTtcblx0ICAgICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcIm5leHRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG5cdCAgICAgICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG5cdCAgICAgICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGRlc2NlbmRpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGVja0tleShrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKytyYW5nZVBvcztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMV0pID09PSAwIHx8IF90aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVsxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBXaGVyZUNsYXVzZS5wcm90b3R5cGUuc3RhcnRzV2l0aEFueU9mID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBpZiAoIXNldC5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnOyB9KSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJzdGFydHNXaXRoQW55T2YoKSBvbmx5IHdvcmtzIHdpdGggc3RyaW5nc1wiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddOyB9KSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gV2hlcmVDbGF1c2U7XG5cdCAgICB9KCkpO1xuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKGRiKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFdoZXJlQ2xhdXNlLnByb3RvdHlwZSwgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGFibGUsIGluZGV4LCBvckNvbGxlY3Rpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5kYiA9IGRiO1xuXHQgICAgICAgICAgICB0aGlzLl9jdHggPSB7XG5cdCAgICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG5cdCAgICAgICAgICAgICAgICBpbmRleDogaW5kZXggPT09IFwiOmlkXCIgPyBudWxsIDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICBvcjogb3JDb2xsZWN0aW9uXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHRoaXMuX2NtcCA9IHRoaXMuX2FzY2VuZGluZyA9IGNtcDtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGluZyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYiwgYSk7IH07XG5cdCAgICAgICAgICAgIHRoaXMuX21heCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPiAwID8gYSA6IGI7IH07XG5cdCAgICAgICAgICAgIHRoaXMuX21pbiA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGI7IH07XG5cdCAgICAgICAgICAgIHRoaXMuX0lEQktleVJhbmdlID0gZGIuX2RlcHMuSURCS2V5UmFuZ2U7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5fSURCS2V5UmFuZ2UpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpIHtcblx0ICAgICAgICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuXHQgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcblx0ICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHQgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpXG5cdCAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSA9ICdzdG9yYWdlbXV0YXRlZCc7XG5cdCAgICB2YXIgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FID0gJ3gtc3RvcmFnZW11dGF0ZWQtMSc7XG5cdCAgICB2YXIgZ2xvYmFsRXZlbnRzID0gRXZlbnRzKG51bGwsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FKTtcblxuXHQgICAgdmFyIFRyYW5zYWN0aW9uID0gIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gVHJhbnNhY3Rpb24oKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcblx0ICAgICAgICAgICAgKyt0aGlzLl9yZWN1bG9jaztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlY3Vsb2NrID09PSAxICYmICFQU0QuZ2xvYmFsKVxuXHQgICAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl91bmxvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG5cdCAgICAgICAgICAgIGlmICgtLXRoaXMuX3JlY3Vsb2NrID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIVBTRC5nbG9iYWwpXG5cdCAgICAgICAgICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXNlUFNEKGZuQW5kUFNEWzFdLCBmbkFuZFBTRFswXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fbG9ja2VkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdWxvY2sgJiYgUFNELmxvY2tPd25lckZvciAhPT0gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaWRidHJhbnMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1vZGUpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGlkYmRiID0gdGhpcy5kYi5pZGJkYjtcblx0ICAgICAgICAgICAgdmFyIGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG5cdCAgICAgICAgICAgIGFzc2VydCghdGhpcy5pZGJ0cmFucyk7XG5cdCAgICAgICAgICAgIGlmICghaWRidHJhbnMgJiYgIWlkYmRiKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKGRiT3BlbkVycm9yICYmIGRiT3BlbkVycm9yLm5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRGF0YWJhc2VDbG9zZWRFcnJvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYk9wZW5FcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1pc3NpbmdBUElFcnJvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKGRiT3BlbkVycm9yLm1lc3NhZ2UsIGRiT3BlbkVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5PcGVuRmFpbGVkKGRiT3BlbkVycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHJhbnNhY3Rpb25JbmFjdGl2ZSgpO1xuXHQgICAgICAgICAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpO1xuXHQgICAgICAgICAgICBpZGJ0cmFucyA9IHRoaXMuaWRidHJhbnMgPSBpZGJ0cmFucyB8fFxuXHQgICAgICAgICAgICAgICAgKHRoaXMuZGIuY29yZVxuXHQgICAgICAgICAgICAgICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgOiBpZGJkYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KSk7XG5cdCAgICAgICAgICAgIGlkYnRyYW5zLm9uZXJyb3IgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdChpZGJ0cmFucy5lcnJvcik7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZGJ0cmFucy5vbmFib3J0ID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSAmJiBfdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KGlkYnRyYW5zLmVycm9yKSk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoJ211dGF0ZWRQYXJ0cycgaW4gaWRidHJhbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZShpZGJ0cmFuc1tcIm11dGF0ZWRQYXJ0c1wiXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fcHJvbWlzZSA9IGZ1bmN0aW9uIChtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScgJiYgdGhpcy5tb2RlICE9PSAncmVhZHdyaXRlJylcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJUcmFuc2FjdGlvbiBpcyByZWFkb25seVwiKSk7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9sb2NrZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ibG9ja2VkRnVuY3MucHVzaChbZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgUFNEXSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChiV3JpdGVMb2NrKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2NrKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBwLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VubG9jaygpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLl9yb290ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gKHByb21pc2VMaWtlKSB7XG5cdCAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdCgpO1xuXHQgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHByb21pc2VMaWtlKTtcblx0ICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSByb290Ll93YWl0aW5nRm9yLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvbWlzZTsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdRdWV1ZSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuXHQgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIHNwaW4oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKytyb290Ll9zcGluQ291bnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJvb3QuX3dhaXRpbmdRdWV1ZS5sZW5ndGgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChyb290Ll93YWl0aW5nUXVldWUuc2hpZnQoKSkoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0KC1JbmZpbml0eSkub25zdWNjZXNzID0gc3Bpbjtcblx0ICAgICAgICAgICAgICAgIH0oKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlc29sdmUuYmluZChudWxsLCByZXMpKSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVqZWN0LmJpbmQobnVsbCwgZXJyKSkpOyB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvciA9PT0gY3VycmVudFdhaXRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRidHJhbnMpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciBtZW1vaXplZFRhYmxlcyA9ICh0aGlzLl9tZW1vaXplZFRhYmxlcyB8fCAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgPSB7fSkpO1xuXHQgICAgICAgICAgICBpZiAoaGFzT3duKG1lbW9pemVkVGFibGVzLCB0YWJsZU5hbWUpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV07XG5cdCAgICAgICAgICAgIHZhciB0YWJsZVNjaGVtYSA9IHRoaXMuc2NoZW1hW3RhYmxlTmFtZV07XG5cdCAgICAgICAgICAgIGlmICghdGFibGVTY2hlbWEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlID0gbmV3IHRoaXMuZGIuVGFibGUodGFibGVOYW1lLCB0YWJsZVNjaGVtYSwgdGhpcyk7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uQm91bmRUYWJsZS5jb3JlID0gdGhpcy5kYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG5cdCAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb247XG5cdCAgICB9KCkpO1xuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcblx0ICAgICAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcblx0ICAgICAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcblx0ICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBkYnNjaGVtYTtcblx0ICAgICAgICAgICAgdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgPSBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG5cdCAgICAgICAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwiY29tcGxldGVcIiwgXCJlcnJvclwiLCBcImFib3J0XCIpO1xuXHQgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlY3Vsb2NrID0gMDtcblx0ICAgICAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9yZWplY3QgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fc3BpbkNvdW50ID0gMDtcblx0ICAgICAgICAgICAgdGhpcy5fY29tcGxldGlvbiA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdCA9IHJlamVjdDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLm9uLmNvbXBsZXRlLmZpcmUoKTtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSBfdGhpcy5hY3RpdmU7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIF90aGlzLm9uLmVycm9yLmZpcmUoZSk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5wYXJlbnQgP1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcblx0ICAgICAgICAgICAgICAgICAgICB3YXNBY3RpdmUgJiYgX3RoaXMuaWRidHJhbnMgJiYgX3RoaXMuaWRidHJhbnMuYWJvcnQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCwgdW5pcXVlLCBtdWx0aSwgYXV0bywgY29tcG91bmQsIGlzUHJpbUtleSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG5cdCAgICAgICAgICAgIHVuaXF1ZTogdW5pcXVlLFxuXHQgICAgICAgICAgICBtdWx0aTogbXVsdGksXG5cdCAgICAgICAgICAgIGF1dG86IGF1dG8sXG5cdCAgICAgICAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcblx0ICAgICAgICAgICAgc3JjOiAodW5pcXVlICYmICFpc1ByaW1LZXkgPyAnJicgOiAnJykgKyAobXVsdGkgPyAnKicgOiAnJykgKyAoYXV0byA/IFwiKytcIiA6IFwiXCIpICsgbmFtZUZyb21LZXlQYXRoKGtleVBhdGgpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG5cdCAgICAgICAgICAgIGtleVBhdGggOlxuXHQgICAgICAgICAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVRhYmxlU2NoZW1hKG5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICBwcmltS2V5OiBwcmltS2V5LFxuXHQgICAgICAgICAgICBpbmRleGVzOiBpbmRleGVzLFxuXHQgICAgICAgICAgICBtYXBwZWRDbGFzczogbnVsbCxcblx0ICAgICAgICAgICAgaWR4QnlOYW1lOiBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gW2luZGV4Lm5hbWUsIGluZGV4XTsgfSlcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcblx0ICAgICAgICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcblx0ICAgIH1cblx0ICAgIHZhciBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoSWRiS2V5UmFuZ2UpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuXHQgICAgICAgICAgICBnZXRNYXhLZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbW11dOyB9O1xuXHQgICAgICAgICAgICByZXR1cm4gW1tdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgZ2V0TWF4S2V5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4U3RyaW5nOyB9O1xuXHQgICAgICAgICAgICByZXR1cm4gbWF4U3RyaW5nO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG5cdCAgICAgICAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7IH07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG5cdCAgICAgICAgdmFyIHNwbGl0ID0ga2V5UGF0aC5zcGxpdCgnLicpO1xuXHQgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9ialtrZXlQYXRoXTsgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTsgfTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFycmF5aWZ5KGFycmF5TGlrZSkge1xuXHQgICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgX2lkX2NvdW50ZXIgPSAwO1xuXHQgICAgZnVuY3Rpb24gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpIHtcblx0ICAgICAgICByZXR1cm4ga2V5UGF0aCA9PSBudWxsID9cblx0ICAgICAgICAgICAgXCI6aWRcIiA6XG5cdCAgICAgICAgICAgIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG5cdCAgICAgICAgICAgICAgICBrZXlQYXRoIDpcblx0ICAgICAgICAgICAgICAgIFwiW1wiLmNvbmNhdChrZXlQYXRoLmpvaW4oJysnKSwgXCJdXCIpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY3JlYXRlREJDb3JlKGRiLCBJZGJLZXlSYW5nZSwgdG1wVHJhbnMpIHtcblx0ICAgICAgICBmdW5jdGlvbiBleHRyYWN0U2NoZW1hKGRiLCB0cmFucykge1xuXHQgICAgICAgICAgICB2YXIgdGFibGVzID0gYXJyYXlpZnkoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBzY2hlbWE6IHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYi5uYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHRhYmxlczogdGFibGVzLm1hcChmdW5jdGlvbiAodGFibGUpIHsgcmV0dXJuIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKTsgfSkubWFwKGZ1bmN0aW9uIChzdG9yZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHN0b3JlLmtleVBhdGgsIGF1dG9JbmNyZW1lbnQgPSBzdG9yZS5hdXRvSW5jcmVtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Ym91bmQgPSBrZXlQYXRoID09IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleEJ5S2V5UGF0aCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RvcmUubmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZDogb3V0Ym91bmQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IGtleVBhdGgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudDogYXV0b0luY3JlbWVudCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogYXJyYXlpZnkoc3RvcmUuaW5kZXhOYW1lcykubWFwKGZ1bmN0aW9uIChpbmRleE5hbWUpIHsgcmV0dXJuIHN0b3JlLmluZGV4KGluZGV4TmFtZSk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGluZGV4Lm5hbWUsIHVuaXF1ZSA9IGluZGV4LnVuaXF1ZSwgbXVsdGlFbnRyeSA9IGluZGV4Lm11bHRpRW50cnksIGtleVBhdGggPSBpbmRleC5rZXlQYXRoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWU6IHVuaXF1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlFbnRyeTogbXVsdGlFbnRyeSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiBmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXTsgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtcIjppZFwiXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0LnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgISh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG5cdCAgICAgICAgICAgIHZhciBsb3dlciA9IHJhbmdlLmxvd2VyLCB1cHBlciA9IHJhbmdlLnVwcGVyLCBsb3dlck9wZW4gPSByYW5nZS5sb3dlck9wZW4sIHVwcGVyT3BlbiA9IHJhbmdlLnVwcGVyT3Blbjtcblx0ICAgICAgICAgICAgdmFyIGlkYlJhbmdlID0gbG93ZXIgPT09IHVuZGVmaW5lZCA/XG5cdCAgICAgICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgICAgICAgICAgICBudWxsIDpcblx0ICAgICAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCAhIXVwcGVyT3BlbikgOlxuXHQgICAgICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG5cdCAgICAgICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgISFsb3dlck9wZW4pIDpcblx0ICAgICAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsICEhbG93ZXJPcGVuLCAhIXVwcGVyT3Blbik7XG5cdCAgICAgICAgICAgIHJldHVybiBpZGJSYW5nZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpIHtcblx0ICAgICAgICAgICAgdmFyIHRhYmxlTmFtZSA9IHRhYmxlU2NoZW1hLm5hbWU7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIG11dGF0ZShfYSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIHR5cGUgPSBfYS50eXBlLCBrZXlzID0gX2Eua2V5cywgdmFsdWVzID0gX2EudmFsdWVzLCByYW5nZSA9IF9hLnJhbmdlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXNBZGRPclB1dCA9IHR5cGUgPT09IFwicHV0XCIgfHwgdHlwZSA9PT0gXCJhZGRcIjtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQWRkT3JQdXQgJiYgdHlwZSAhPT0gJ2RlbGV0ZScgJiYgdHlwZSAhPT0gJ2RlbGV0ZVJhbmdlJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb24gdHlwZTogXCIgKyB0eXBlKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gKGtleXMgfHwgdmFsdWVzIHx8IHsgbGVuZ3RoOiAxIH0pLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiB2YWx1ZXMgJiYga2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4ga2V5cyBhcnJheSBtdXN0IGhhdmUgc2FtZSBsZW5ndGggYXMgZ2l2ZW4gdmFsdWVzIGFycmF5LlwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFpbHVyZXMgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKytudW1GYWlsdXJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDQgKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogbnVtRmFpbHVyZXMsIGZhaWx1cmVzOiBmYWlsdXJlcywgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlLmNsZWFyKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGlzQWRkT3JQdXQgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBudWxsXSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBba2V5cywgbnVsbF0sIGFyZ3MxID0gX2FbMF0sIGFyZ3MyID0gX2FbMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FkZE9yUHV0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IChhcmdzMiAmJiBhcmdzMltpXSAhPT0gdW5kZWZpbmVkID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0sIGFyZ3MyW2ldKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXEsIGkpIHsgcmV0dXJuIHJlcS5lcnJvciAhPSBudWxsICYmIChmYWlsdXJlc1tpXSA9IHJlcS5lcnJvcik7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUZhaWx1cmVzOiBudW1GYWlsdXJlcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAoZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gcmVxLnJlc3VsdDsgfSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0OiBsYXN0UmVzdWx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShldmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZG9uZTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IF9hLnRyYW5zLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHF1ZXJ5ID0gX2EucXVlcnksIHJldmVyc2UgPSBfYS5yZXZlcnNlLCB1bmlxdWUgPSBfYS51bmlxdWU7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHF1ZXJ5LmluZGV4LCByYW5nZSA9IHF1ZXJ5LnJhbmdlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHJldmVyc2UgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2dW5pcXVlXCIgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2XCIgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5fX19pZCA9ICsrX2lkX2NvdW50ZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY3Vyc29yQ29udGludWUgPSBjdXJzb3IuY29udGludWUuYmluZChjdXJzb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkuYmluZChjdXJzb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0YXJ0ZWRcIik7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0b3BwZWRcIik7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci50cmFucyA9IHRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ290T25lID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdvdE9uZS0tID8gX3RoaXMuY29udGludWUoKSA6IF90aGlzLnN0b3AoKTsgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpczsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZUl0ZXJhdGlvbiwgcmVqZWN0SXRlcmF0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbiA9IHdyYXAocmVzb2x2ZUl0ZXJhdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0SXRlcmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHJlamVjdEl0ZXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24odmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBiZWhpbmQgbGFzdCBlbnRyeVwiKTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGd1YXJkZWRDYWxsYmFjaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlID0gX2N1cnNvckNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmdW5jdGlvbiBxdWVyeShoYXNHZXRBbGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXF1ZXN0LnRyYW5zLCB2YWx1ZXMgPSByZXF1ZXN0LnZhbHVlcywgbGltaXQgPSByZXF1ZXN0LmxpbWl0LCBxdWVyeSA9IHJlcXVlc3QucXVlcnk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub25JbmZpbml0TGltaXQgPSBsaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBsaW1pdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuaW5kZXgsIHJhbmdlID0gcXVlcnkucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPT09IDApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogW10gfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNHZXRBbGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB2YWx1ZXMgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGwoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5nZXRBbGxLZXlzKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogZXZlbnQudGFyZ2V0LnJlc3VsdCB9KTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRfMSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxXzEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihpZGJLZXlSYW5nZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXFfMS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHRfMSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRfMS5wdXNoKHZhbHVlcyA/IGN1cnNvci52YWx1ZSA6IGN1cnNvci5wcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjb3VudF8xID09PSBsaW1pdClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdF8xIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV8xLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuXHQgICAgICAgICAgICAgICAgc2NoZW1hOiB0YWJsZVNjaGVtYSxcblx0ICAgICAgICAgICAgICAgIG11dGF0ZTogbXV0YXRlLFxuXHQgICAgICAgICAgICAgICAgZ2V0TWFueTogZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIGtleXMgPSBfYS5rZXlzO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvdW50ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrQ291bnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdFtyZXEuX3Bvc10gPSByZXEucmVzdWx0KSAhPSBudWxsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NhbGxiYWNrQ291bnQgPT09IGtleUNvdW50KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLmdldChrZXlzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuX3BvcyA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsra2V5Q291bnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleUNvdW50ID09PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gX2EudHJhbnMsIGtleSA9IF9hLmtleTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuXHQgICAgICAgICAgICAgICAgb3BlbkN1cnNvcjogb3BlbkN1cnNvcixcblx0ICAgICAgICAgICAgICAgIGNvdW50OiBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBfYS5xdWVyeSwgdHJhbnMgPSBfYS50cmFucztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBxdWVyeS5pbmRleCwgcmFuZ2UgPSBxdWVyeS5yYW5nZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHJlc29sdmUoZXYudGFyZ2V0LnJlc3VsdCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgX2EgPSBleHRyYWN0U2NoZW1hKGRiLCB0bXBUcmFucyksIHNjaGVtYSA9IF9hLnNjaGVtYSwgaGFzR2V0QWxsID0gX2EuaGFzR2V0QWxsO1xuXHQgICAgICAgIHZhciB0YWJsZXMgPSBzY2hlbWEudGFibGVzLm1hcChmdW5jdGlvbiAodGFibGVTY2hlbWEpIHsgcmV0dXJuIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKTsgfSk7XG5cdCAgICAgICAgdmFyIHRhYmxlTWFwID0ge307XG5cdCAgICAgICAgdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7IHJldHVybiB0YWJsZU1hcFt0YWJsZS5uYW1lXSA9IHRhYmxlOyB9KTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb246IGRiLnRyYW5zYWN0aW9uLmJpbmQoZGIpLFxuXHQgICAgICAgICAgICB0YWJsZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YWJsZU1hcFtuYW1lXTtcblx0ICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KVxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhYmxlICdcIi5jb25jYXQobmFtZSwgXCInIG5vdCBmb3VuZFwiKSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcblx0ICAgICAgICAgICAgTUFYX0tFWTogZ2V0TWF4S2V5KElkYktleVJhbmdlKSxcblx0ICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWFcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2soc3RhY2tJbXBsLCBtaWRkbGV3YXJlcykge1xuXHQgICAgICAgIHJldHVybiBtaWRkbGV3YXJlcy5yZWR1Y2UoZnVuY3Rpb24gKGRvd24sIF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBjcmVhdGUgPSBfYS5jcmVhdGU7XG5cdCAgICAgICAgICAgIHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd24pLCBjcmVhdGUoZG93bikpKTtcblx0ICAgICAgICB9LCBzdGFja0ltcGwpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhtaWRkbGV3YXJlcywgaWRiZGIsIF9hLCB0bXBUcmFucykge1xuXHQgICAgICAgIHZhciBJREJLZXlSYW5nZSA9IF9hLklEQktleVJhbmdlOyBfYS5pbmRleGVkREI7XG5cdCAgICAgICAgdmFyIGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhjcmVhdGVEQkNvcmUoaWRiZGIsIElEQktleVJhbmdlLCB0bXBUcmFucyksIG1pZGRsZXdhcmVzLmRiY29yZSk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZGJjb3JlOiBkYmNvcmVcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucykge1xuXHQgICAgICAgIHZhciBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuXHQgICAgICAgIHZhciBzdGFja3MgPSBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLl9taWRkbGV3YXJlcywgaWRiZGIsIGRiLl9kZXBzLCB0bXBUcmFucyk7XG5cdCAgICAgICAgZGIuY29yZSA9IHN0YWNrcy5kYmNvcmU7XG5cdCAgICAgICAgZGIudGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG5cdCAgICAgICAgICAgIHZhciB0YWJsZU5hbWUgPSB0YWJsZS5uYW1lO1xuXHQgICAgICAgICAgICBpZiAoZGIuY29yZS5zY2hlbWEudGFibGVzLnNvbWUoZnVuY3Rpb24gKHRibCkgeyByZXR1cm4gdGJsLm5hbWUgPT09IHRhYmxlTmFtZTsgfSkpIHtcblx0ICAgICAgICAgICAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGJbdGFibGVOYW1lXSBpbnN0YW5jZW9mIGRiLlRhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGJbdGFibGVOYW1lXS5jb3JlID0gdGFibGUuY29yZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzZXRBcGlPblBsYWNlKGRiLCBvYmpzLCB0YWJsZU5hbWVzLCBkYnNjaGVtYSkge1xuXHQgICAgICAgIHRhYmxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuXHQgICAgICAgICAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BEZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgdGFibGVOYW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSB8fCBvYmogaW5zdGFuY2VvZiBkYi5UcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgdGFibGVOYW1lLCB7IHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmpbdGFibGVOYW1lXSA9IG5ldyBkYi5UYWJsZSh0YWJsZU5hbWUsIHNjaGVtYSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJlbW92ZVRhYmxlc0FwaShkYiwgb2Jqcykge1xuXHQgICAgICAgIG9ianMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIGRiLlRhYmxlKVxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gbG93ZXJWZXJzaW9uRmlyc3QoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhLl9jZmcudmVyc2lvbiAtIGIuX2NmZy52ZXJzaW9uO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcnVuVXBncmFkZXJzKGRiLCBvbGRWZXJzaW9uLCBpZGJVcGdyYWRlVHJhbnMsIHJlamVjdCkge1xuXHQgICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG5cdCAgICAgICAgaWYgKGlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCckbWV0YScpICYmICFnbG9iYWxTY2hlbWEuJG1ldGEpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsU2NoZW1hLiRtZXRhID0gY3JlYXRlVGFibGVTY2hlbWEoXCIkbWV0YVwiLCBwYXJzZUluZGV4U3ludGF4KFwiXCIpWzBdLCBbXSk7XG5cdCAgICAgICAgICAgIGRiLl9zdG9yZU5hbWVzLnB1c2goJyRtZXRhJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG5cdCAgICAgICAgdHJhbnMuY3JlYXRlKGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgdHJhbnMuX2NvbXBsZXRpb24uY2F0Y2gocmVqZWN0KTtcblx0ICAgICAgICB2YXIgcmVqZWN0VHJhbnNhY3Rpb24gPSB0cmFucy5fcmVqZWN0LmJpbmQodHJhbnMpO1xuXHQgICAgICAgIHZhciB0cmFuc2xlc3MgPSBQU0QudHJhbnNsZXNzIHx8IFBTRDtcblx0ICAgICAgICBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuXHQgICAgICAgICAgICBQU0QudHJhbnNsZXNzID0gdHJhbnNsZXNzO1xuXHQgICAgICAgICAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLmZvbGxvdyhmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKTsgfSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmVyc2lvbihkYiwgdHJhbnMsIG9sZFZlcnNpb24pXG5cdCAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9sZFZlcnNpb24pIHsgcmV0dXJuIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHBhdGNoQ3VycmVudFZlcnNpb24oZGIsIGlkYlVwZ3JhZGVUcmFucykge1xuXHQgICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgIGlmIChpZGJVcGdyYWRlVHJhbnMuZGIudmVyc2lvbiAlIDEwID09PSAwICYmICFpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSkge1xuXHQgICAgICAgICAgICBpZGJVcGdyYWRlVHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUoJyRtZXRhJykuYWRkKE1hdGguY2VpbCgoaWRiVXBncmFkZVRyYW5zLmRiLnZlcnNpb24gLyAxMCkgLSAxKSwgJ3ZlcnNpb24nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihnbG9iYWxTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG5cdCAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAodGFibGVDaGFuZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKHRhYmxlQ2hhbmdlLmNoYW5nZS5sZW5ndGggfHwgdGFibGVDaGFuZ2UucmVjcmVhdGUpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBwYXRjaCBpbmRleGVzIG9mIHRhYmxlIFwiLmNvbmNhdCh0YWJsZUNoYW5nZS5uYW1lLCBcIiBiZWNhdXNlIGl0IGhhcyBjaGFuZ2VzIG9uIHRoZSB0eXBlIG9mIGluZGV4IG9yIHByaW1hcnkga2V5LlwiKSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKHRhYmxlQ2hhbmdlLm5hbWUpO1xuXHQgICAgICAgICAgICB0YWJsZUNoYW5nZS5hZGQuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkRleGllIHVwZ3JhZGUgcGF0Y2g6IENyZWF0aW5nIG1pc3NpbmcgaW5kZXggXCIuY29uY2F0KHRhYmxlQ2hhbmdlLm5hbWUsIFwiLlwiKS5jb25jYXQoaWR4LnNyYykpO1xuXHQgICAgICAgICAgICAgICAgYWRkSW5kZXgoc3RvcmUsIGlkeCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRpZmYuY2hhbmdlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICB2YXIgdGFibGVDaGFuZ2UgPSBfYVtfaV07XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSh0YWJsZUNoYW5nZSk7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZV8xLnZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldEV4aXN0aW5nVmVyc2lvbihkYiwgdHJhbnMsIG9sZFZlcnNpb24pIHtcblx0ICAgICAgICBpZiAodHJhbnMuc3RvcmVOYW1lcy5pbmNsdWRlcygnJG1ldGEnKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJhbnMudGFibGUoJyRtZXRhJykuZ2V0KCd2ZXJzaW9uJykudGhlbihmdW5jdGlvbiAobWV0YVZlcnNpb24pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtZXRhVmVyc2lvbiAhPSBudWxsID8gbWV0YVZlcnNpb24gOiBvbGRWZXJzaW9uO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShvbGRWZXJzaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKSB7XG5cdCAgICAgICAgdmFyIHF1ZXVlID0gW107XG5cdCAgICAgICAgdmFyIHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuXHQgICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG5cdCAgICAgICAgdmFyIHZlcnNUb1J1biA9IHZlcnNpb25zLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5fY2ZnLnZlcnNpb24gPj0gb2xkVmVyc2lvbjsgfSk7XG5cdCAgICAgICAgaWYgKHZlcnNUb1J1bi5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZlcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG5cdCAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9sZFNjaGVtYSA9IGdsb2JhbFNjaGVtYTtcblx0ICAgICAgICAgICAgICAgIHZhciBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG5cdCAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG5ld1NjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG5ld1NjaGVtYTtcblx0ICAgICAgICAgICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG5cdCAgICAgICAgICAgICAgICBkaWZmLmFkZC5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdHVwbGVbMF0sIHR1cGxlWzFdLnByaW1LZXksIHR1cGxlWzFdLmluZGV4ZXMpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlXzEgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gYWRkSW5kZXgoc3RvcmVfMSwgaWR4KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZV8xLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlXzEsIGlkeCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLmZvckVhY2goZnVuY3Rpb24gKGlkeE5hbWUpIHsgcmV0dXJuIHN0b3JlXzEuZGVsZXRlSW5kZXgoaWR4TmFtZSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlICYmIHZlcnNpb24uX2NmZy52ZXJzaW9uID4gb2xkVmVyc2lvbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdXBncmFkZVNjaGVtYV8xID0gc2hhbGxvd0Nsb25lKG5ld1NjaGVtYSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZGlmZi5kZWwuZm9yRWFjaChmdW5jdGlvbiAodGFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZVNjaGVtYV8xW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYV8xKSwgdXBncmFkZVNjaGVtYV8xKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFucy5zY2hlbWEgPSB1cGdyYWRlU2NoZW1hXzE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRVcGdyYWRlSXNBc3luY18xID0gaXNBc3luY0Z1bmN0aW9uKGNvbnRlbnRVcGdyYWRlKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlXzE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VGb2xsb3dlZCA9IERleGllUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZV8xID0gY29udGVudFVwZ3JhZGUodHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWVfMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luY18xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZV8xLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAocmV0dXJuVmFsdWVfMSAmJiB0eXBlb2YgcmV0dXJuVmFsdWVfMS50aGVuID09PSAnZnVuY3Rpb24nID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWVfMSkgOiBwcm9taXNlRm9sbG93ZWQudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXR1cm5WYWx1ZV8xOyB9KSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBxdWV1ZS5wdXNoKGZ1bmN0aW9uIChpZGJ0cmFucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucyk7XG5cdCAgICAgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcblx0ICAgICAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBkYi5fc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcblx0ICAgICAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IGRiLl9kYlNjaGVtYTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGIuaWRiZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnJG1ldGEnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmNlaWwoZGIuaWRiZGIudmVyc2lvbiAvIDEwKSA9PT0gdmVyc2lvbi5fY2ZnLnZlcnNpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGIuaWRiZGIuZGVsZXRlT2JqZWN0U3RvcmUoJyRtZXRhJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYi5fZGJTY2hlbWEuJG1ldGE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRiLl9zdG9yZU5hbWVzID0gZGIuX3N0b3JlTmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICE9PSAnJG1ldGEnOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkYnRyYW5zLm9iamVjdFN0b3JlKCckbWV0YScpLnB1dCh2ZXJzaW9uLl9jZmcudmVyc2lvbiwgJ3ZlcnNpb24nKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGZ1bmN0aW9uIHJ1blF1ZXVlKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcXVldWUubGVuZ3RoID8gRGV4aWVQcm9taXNlLnJlc29sdmUocXVldWUuc2hpZnQoKSh0cmFucy5pZGJ0cmFucykpLnRoZW4ocnVuUXVldWUpIDpcblx0ICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGdsb2JhbFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcblx0ICAgICAgICB2YXIgZGlmZiA9IHtcblx0ICAgICAgICAgICAgZGVsOiBbXSxcblx0ICAgICAgICAgICAgYWRkOiBbXSxcblx0ICAgICAgICAgICAgY2hhbmdlOiBbXVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIHRhYmxlO1xuXHQgICAgICAgIGZvciAodGFibGUgaW4gb2xkU2NoZW1hKSB7XG5cdCAgICAgICAgICAgIGlmICghbmV3U2NoZW1hW3RhYmxlXSlcblx0ICAgICAgICAgICAgICAgIGRpZmYuZGVsLnB1c2godGFibGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHRhYmxlIGluIG5ld1NjaGVtYSkge1xuXHQgICAgICAgICAgICB2YXIgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSwgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcblx0ICAgICAgICAgICAgaWYgKCFvbGREZWYpIHtcblx0ICAgICAgICAgICAgICAgIGRpZmYuYWRkLnB1c2goW3RhYmxlLCBuZXdEZWZdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogdGFibGUsXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmOiBuZXdEZWYsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVjcmVhdGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgIGRlbDogW10sXG5cdCAgICAgICAgICAgICAgICAgICAgYWRkOiBbXSxcblx0ICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IFtdXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgaWYgKChcblx0ICAgICAgICAgICAgICAgICcnICsgKG9sZERlZi5wcmltS2V5LmtleVBhdGggfHwgJycpKSAhPT0gKCcnICsgKG5ld0RlZi5wcmltS2V5LmtleVBhdGggfHwgJycpKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgIChvbGREZWYucHJpbUtleS5hdXRvICE9PSBuZXdEZWYucHJpbUtleS5hdXRvKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5yZWNyZWF0ZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4ZXMgPSBvbGREZWYuaWR4QnlOYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWR4TmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeE5hbWUgaW4gb2xkSW5kZXhlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLnB1c2goaWR4TmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBuZXdJbmRleGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRJZHggPSBvbGRJbmRleGVzW2lkeE5hbWVdLCBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZElkeClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQucHVzaChuZXdJZHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmNoYW5nZS5wdXNoKG5ld0lkeCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGVsLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmFkZC5sZW5ndGggPiAwIHx8IGNoYW5nZS5jaGFuZ2UubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBkaWZmO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuXHQgICAgICAgIHZhciBzdG9yZSA9IGlkYnRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKHRhYmxlTmFtZSwgcHJpbUtleS5rZXlQYXRoID9cblx0ICAgICAgICAgICAgeyBrZXlQYXRoOiBwcmltS2V5LmtleVBhdGgsIGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9IDpcblx0ICAgICAgICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSk7XG5cdCAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgcmV0dXJuIGFkZEluZGV4KHN0b3JlLCBpZHgpOyB9KTtcblx0ICAgICAgICByZXR1cm4gc3RvcmU7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjcmVhdGVNaXNzaW5nVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcblx0ICAgICAgICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgIGlmICghaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IENyZWF0aW5nIG1pc3NpbmcgdGFibGUnLCB0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuXHQgICAgICAgIFtdLnNsaWNlLmNhbGwoaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcykuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhZGRJbmRleChzdG9yZSwgaWR4KSB7XG5cdCAgICAgICAgc3RvcmUuY3JlYXRlSW5kZXgoaWR4Lm5hbWUsIGlkeC5rZXlQYXRoLCB7IHVuaXF1ZTogaWR4LnVuaXF1ZSwgbXVsdGlFbnRyeTogaWR4Lm11bHRpIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuXHQgICAgICAgIHZhciBnbG9iYWxTY2hlbWEgPSB7fTtcblx0ICAgICAgICB2YXIgZGJTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG5cdCAgICAgICAgZGJTdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuXHQgICAgICAgICAgICB2YXIgc3RvcmUgPSB0bXBUcmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuXHQgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHN0b3JlLmtleVBhdGg7XG5cdCAgICAgICAgICAgIHZhciBwcmltS2V5ID0gY3JlYXRlSW5kZXhTcGVjKG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSwga2V5UGF0aCB8fCBcIlwiLCB0cnVlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCB0cnVlKTtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWRiaW5kZXggPSBzdG9yZS5pbmRleChzdG9yZS5pbmRleE5hbWVzW2pdKTtcblx0ICAgICAgICAgICAgICAgIGtleVBhdGggPSBpZGJpbmRleC5rZXlQYXRoO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY3JlYXRlSW5kZXhTcGVjKGlkYmluZGV4Lm5hbWUsIGtleVBhdGgsICEhaWRiaW5kZXgudW5pcXVlLCAhIWlkYmluZGV4Lm11bHRpRW50cnksIGZhbHNlLCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCBmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGdsb2JhbFNjaGVtYVtzdG9yZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEoc3RvcmVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gZ2xvYmFsU2NoZW1hO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcmVhZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKSB7XG5cdCAgICAgICAgZGIudmVybm8gPSBpZGJkYi52ZXJzaW9uIC8gMTA7XG5cdCAgICAgICAgdmFyIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuXHQgICAgICAgIGRiLl9zdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcywgMCk7XG5cdCAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXNdLCBrZXlzKGdsb2JhbFNjaGVtYSksIGdsb2JhbFNjaGVtYSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSB7XG5cdCAgICAgICAgdmFyIGluc3RhbGxlZFNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgdG1wVHJhbnMpO1xuXHQgICAgICAgIHZhciBkaWZmID0gZ2V0U2NoZW1hRGlmZihpbnN0YWxsZWRTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG5cdCAgICAgICAgcmV0dXJuICEoZGlmZi5hZGQubGVuZ3RoIHx8IGRpZmYuY2hhbmdlLnNvbWUoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGg7IH0pKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBzY2hlbWEsIGlkYnRyYW5zKSB7XG5cdCAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gc3RvcmVOYW1lc1tpXTtcblx0ICAgICAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcblx0ICAgICAgICAgICAgZGIuX2hhc0dldEFsbCA9ICdnZXRBbGwnIGluIHN0b3JlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBzdG9yZS5pbmRleE5hbWVzW2pdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpLmtleVBhdGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhTcGVjID0gc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4U3BlYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbaW5kZXhOYW1lXSA9IGluZGV4U3BlYztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcblx0ICAgICAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG5cdCAgICAgICAgICAgIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiYgX2dsb2JhbCBpbnN0YW5jZW9mIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiZcblx0ICAgICAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNCkge1xuXHQgICAgICAgICAgICBkYi5faGFzR2V0QWxsID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcGFyc2VJbmRleFN5bnRheChwcmltS2V5QW5kSW5kZXhlcykge1xuXHQgICAgICAgIHJldHVybiBwcmltS2V5QW5kSW5kZXhlcy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaW5kZXgsIGluZGV4TnVtKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gaW5kZXgudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IGluZGV4LnJlcGxhY2UoLyhbJipdfFxcK1xcKykvZywgXCJcIik7XG5cdCAgICAgICAgICAgIHZhciBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoIHx8IG51bGwsIC9cXCYvLnRlc3QoaW5kZXgpLCAvXFwqLy50ZXN0KGluZGV4KSwgL1xcK1xcKy8udGVzdChpbmRleCksIGlzQXJyYXkoa2V5UGF0aCksIGluZGV4TnVtID09PSAwKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIFZlcnNpb24gPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBWZXJzaW9uKCkge1xuXHQgICAgICAgIH1cblx0ICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS5fcGFyc2VTdG9yZXNTcGVjID0gZnVuY3Rpb24gKHN0b3Jlcywgb3V0U2NoZW1hKSB7XG5cdCAgICAgICAgICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gcGFyc2VJbmRleFN5bnRheChzdG9yZXNbdGFibGVOYW1lXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJpbUtleS51bmlxdWUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJQcmltYXJ5IGtleSBjYW5ub3QgYmUgbXVsdGktdmFsdWVkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHguYXV0bylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIk9ubHkgcHJpbWFyeSBrZXkgY2FuIGJlIG1hcmtlZCBhcyBhdXRvSW5jcmVtZW50ICgrKylcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaWR4LmtleVBhdGgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJJbmRleCBtdXN0IGhhdmUgYSBuYW1lIGFuZCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIG91dFNjaGVtYVt0YWJsZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS5zdG9yZXMgPSBmdW5jdGlvbiAoc3RvcmVzKSB7XG5cdCAgICAgICAgICAgIHZhciBkYiA9IHRoaXMuZGI7XG5cdCAgICAgICAgICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlID9cblx0ICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLl9jZmcuc3RvcmVzU291cmNlLCBzdG9yZXMpIDpcblx0ICAgICAgICAgICAgICAgIHN0b3Jlcztcblx0ICAgICAgICAgICAgdmFyIHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuXHQgICAgICAgICAgICB2YXIgc3RvcmVzU3BlYyA9IHt9O1xuXHQgICAgICAgICAgICB2YXIgZGJzY2hlbWEgPSB7fTtcblx0ICAgICAgICAgICAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKHN0b3Jlc1NwZWMsIHZlcnNpb24uX2NmZy5zdG9yZXNTb3VyY2UpO1xuXHQgICAgICAgICAgICAgICAgZGJzY2hlbWEgPSAodmVyc2lvbi5fY2ZnLmRic2NoZW1hID0ge30pO1xuXHQgICAgICAgICAgICAgICAgdmVyc2lvbi5fcGFyc2VTdG9yZXNTcGVjKHN0b3Jlc1NwZWMsIGRic2NoZW1hKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGRiLl9kYlNjaGVtYSA9IGRic2NoZW1hO1xuXHQgICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG5cdCAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB0aGlzLl9jZmcudGFibGVzXSwga2V5cyhkYnNjaGVtYSksIGRic2NoZW1hKTtcblx0ICAgICAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBrZXlzKGRic2NoZW1hKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBWZXJzaW9uLnByb3RvdHlwZS51cGdyYWRlID0gZnVuY3Rpb24gKHVwZ3JhZGVGdW5jdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgPSBwcm9taXNhYmxlQ2hhaW4odGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlIHx8IG5vcCwgdXBncmFkZUZ1bmN0aW9uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gVmVyc2lvbjtcblx0ICAgIH0oKSk7XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvcihkYikge1xuXHQgICAgICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihWZXJzaW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGIgPSBkYjtcblx0ICAgICAgICAgICAgdGhpcy5fY2ZnID0ge1xuXHQgICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk51bWJlcixcblx0ICAgICAgICAgICAgICAgIHN0b3Jlc1NvdXJjZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGRic2NoZW1hOiB7fSxcblx0ICAgICAgICAgICAgICAgIHRhYmxlczoge30sXG5cdCAgICAgICAgICAgICAgICBjb250ZW50VXBncmFkZTogbnVsbFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkge1xuXHQgICAgICAgIHZhciBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdO1xuXHQgICAgICAgIGlmICghZGJOYW1lc0RCKSB7XG5cdCAgICAgICAgICAgIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl0gPSBuZXcgRGV4aWUkMShEQk5BTUVTX0RCLCB7XG5cdCAgICAgICAgICAgICAgICBhZGRvbnM6IFtdLFxuXHQgICAgICAgICAgICAgICAgaW5kZXhlZERCOiBpbmRleGVkREIsXG5cdCAgICAgICAgICAgICAgICBJREJLZXlSYW5nZTogSURCS2V5UmFuZ2UsXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBkYk5hbWVzREIudmVyc2lvbigxKS5zdG9yZXMoeyBkYm5hbWVzOiBcIm5hbWVcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRiTmFtZXNEQi50YWJsZShcImRibmFtZXNcIik7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSB7XG5cdCAgICAgICAgcmV0dXJuIGluZGV4ZWREQiAmJiB0eXBlb2YgaW5kZXhlZERCLmRhdGFiYXNlcyA9PT0gXCJmdW5jdGlvblwiO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0RGF0YWJhc2VOYW1lcyhfYSkge1xuXHQgICAgICAgIHZhciBpbmRleGVkREIgPSBfYS5pbmRleGVkREIsIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7XG5cdCAgICAgICAgcmV0dXJuIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpXG5cdCAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGluZGV4ZWREQi5kYXRhYmFzZXMoKSkudGhlbihmdW5jdGlvbiAoaW5mb3MpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbmZvc1xuXHQgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm8ubmFtZTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICE9PSBEQk5BTUVTX0RCOyB9KTtcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgOiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkudG9Db2xsZWN0aW9uKCkucHJpbWFyeUtleXMoKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIF9vbkRhdGFiYXNlQ3JlYXRlZChfYSwgbmFtZSkge1xuXHQgICAgICAgIHZhciBpbmRleGVkREIgPSBfYS5pbmRleGVkREIsIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7XG5cdCAgICAgICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG5cdCAgICAgICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcblx0ICAgICAgICAgICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnB1dCh7IG5hbWU6IG5hbWUgfSkuY2F0Y2gobm9wKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIF9vbkRhdGFiYXNlRGVsZXRlZChfYSwgbmFtZSkge1xuXHQgICAgICAgIHZhciBpbmRleGVkREIgPSBfYS5pbmRleGVkREIsIElEQktleVJhbmdlID0gX2EuSURCS2V5UmFuZ2U7XG5cdCAgICAgICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG5cdCAgICAgICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcblx0ICAgICAgICAgICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLmRlbGV0ZShuYW1lKS5jYXRjaChub3ApO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB2aXAoZm4pIHtcblx0ICAgICAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybiBmbigpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBpZGJSZWFkeSgpIHtcblx0ICAgICAgICB2YXIgaXNTYWZhcmkgPSAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiZcblx0ICAgICAgICAgICAgL1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuXHQgICAgICAgICAgICAhL0Nocm9tKGV8aXVtKVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0ICAgICAgICBpZiAoIWlzU2FmYXJpIHx8ICFpbmRleGVkREIuZGF0YWJhc2VzKVxuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgdmFyIGludGVydmFsSWQ7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgIHZhciB0cnlJZGIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShyZXNvbHZlKTsgfTtcblx0ICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRyeUlkYiwgMTAwKTtcblx0ICAgICAgICAgICAgdHJ5SWRiKCk7XG5cdCAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsSWQpOyB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIF9hO1xuXHQgICAgZnVuY3Rpb24gaXNFbXB0eVJhbmdlKG5vZGUpIHtcblx0ICAgICAgICByZXR1cm4gIShcImZyb21cIiBpbiBub2RlKTtcblx0ICAgIH1cblx0ICAgIHZhciBSYW5nZVNldCA9IGZ1bmN0aW9uIChmcm9tT3JUcmVlLCB0bykge1xuXHQgICAgICAgIGlmICh0aGlzKSB7XG5cdCAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8geyBkOiAxLCBmcm9tOiBmcm9tT3JUcmVlLCB0bzogYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0byA6IGZyb21PclRyZWUgfSA6IHsgZDogMCB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBydiA9IG5ldyBSYW5nZVNldCgpO1xuXHQgICAgICAgICAgICBpZiAoZnJvbU9yVHJlZSAmJiAoXCJkXCIgaW4gZnJvbU9yVHJlZSkpIHtcblx0ICAgICAgICAgICAgICAgIGV4dGVuZChydiwgZnJvbU9yVHJlZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBwcm9wcyhSYW5nZVNldC5wcm90b3R5cGUsIChfYSA9IHtcblx0ICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAocmFuZ2VTZXQpIHtcblx0ICAgICAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRoaXMsIHJhbmdlU2V0KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBhZGRLZXk6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBhZGRLZXlzOiBmdW5jdGlvbiAoa2V5cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBhZGRSYW5nZShfdGhpcywga2V5LCBrZXkpOyB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBoYXNLZXk6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcih0aGlzKS5uZXh0KGtleSkudmFsdWU7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBjbXAobm9kZS5mcm9tLCBrZXkpIDw9IDAgJiYgY21wKG5vZGUudG8sIGtleSkgPj0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgX2FbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0UmFuZ2VTZXRJdGVyYXRvcih0aGlzKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIF9hKSk7XG5cdCAgICBmdW5jdGlvbiBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKSB7XG5cdCAgICAgICAgdmFyIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuXHQgICAgICAgIGlmIChpc05hTihkaWZmKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIGlmIChkaWZmID4gMClcblx0ICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuXHQgICAgICAgIGlmIChpc0VtcHR5UmFuZ2UodGFyZ2V0KSlcblx0ICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbTogZnJvbSwgdG86IHRvLCBkOiAxIH0pO1xuXHQgICAgICAgIHZhciBsZWZ0ID0gdGFyZ2V0Lmw7XG5cdCAgICAgICAgdmFyIHJpZ2h0ID0gdGFyZ2V0LnI7XG5cdCAgICAgICAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuXHQgICAgICAgICAgICBsZWZ0XG5cdCAgICAgICAgICAgICAgICA/IGFkZFJhbmdlKGxlZnQsIGZyb20sIHRvKVxuXHQgICAgICAgICAgICAgICAgOiAodGFyZ2V0LmwgPSB7IGZyb206IGZyb20sIHRvOiB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY21wKGZyb20sIHRhcmdldC50bykgPiAwKSB7XG5cdCAgICAgICAgICAgIHJpZ2h0XG5cdCAgICAgICAgICAgICAgICA/IGFkZFJhbmdlKHJpZ2h0LCBmcm9tLCB0bylcblx0ICAgICAgICAgICAgICAgIDogKHRhcmdldC5yID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNtcChmcm9tLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG5cdCAgICAgICAgICAgIHRhcmdldC5mcm9tID0gZnJvbTtcblx0ICAgICAgICAgICAgdGFyZ2V0LmwgPSBudWxsO1xuXHQgICAgICAgICAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY21wKHRvLCB0YXJnZXQudG8pID4gMCkge1xuXHQgICAgICAgICAgICB0YXJnZXQudG8gPSB0bztcblx0ICAgICAgICAgICAgdGFyZ2V0LnIgPSBudWxsO1xuXHQgICAgICAgICAgICB0YXJnZXQuZCA9IHRhcmdldC5sID8gdGFyZ2V0LmwuZCArIDEgOiAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG5cdCAgICAgICAgaWYgKGxlZnQgJiYgIXRhcmdldC5sKSB7XG5cdCAgICAgICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyaWdodCAmJiByaWdodFdhc0N1dE9mZikge1xuXHQgICAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXQsIHJpZ2h0KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQsIG5ld1NldCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIF9hZGRSYW5nZVNldCh0YXJnZXQsIF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bywgbCA9IF9hLmwsIHIgPSBfYS5yO1xuXHQgICAgICAgICAgICBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKTtcblx0ICAgICAgICAgICAgaWYgKGwpXG5cdCAgICAgICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBsKTtcblx0ICAgICAgICAgICAgaWYgKHIpXG5cdCAgICAgICAgICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSlcblx0ICAgICAgICAgICAgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAocmFuZ2VTZXQxLCByYW5nZVNldDIpIHtcblx0ICAgICAgICB2YXIgaTEgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0Mik7XG5cdCAgICAgICAgdmFyIG5leHRSZXN1bHQxID0gaTEubmV4dCgpO1xuXHQgICAgICAgIGlmIChuZXh0UmVzdWx0MS5kb25lKVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgdmFyIGEgPSBuZXh0UmVzdWx0MS52YWx1ZTtcblx0ICAgICAgICB2YXIgaTIgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0MSk7XG5cdCAgICAgICAgdmFyIG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pO1xuXHQgICAgICAgIHZhciBiID0gbmV4dFJlc3VsdDIudmFsdWU7XG5cdCAgICAgICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG5cdCAgICAgICAgICAgIGlmIChjbXAoYi5mcm9tLCBhLnRvKSA8PSAwICYmIGNtcChiLnRvLCBhLmZyb20pID49IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgY21wKGEuZnJvbSwgYi5mcm9tKSA8IDBcblx0ICAgICAgICAgICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIuZnJvbSkpLnZhbHVlKVxuXHQgICAgICAgICAgICAgICAgOiAoYiA9IChuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKSkudmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKG5vZGUpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBpc0VtcHR5UmFuZ2Uobm9kZSkgPyBudWxsIDogeyBzOiAwLCBuOiBub2RlIH07XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleVByb3ZpZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJvdmlkZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sICYmIGNtcChrZXksIHN0YXRlLm4uZnJvbSkgPCAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5UHJvdmlkZWQgfHwgY21wKGtleSwgc3RhdGUubi50bykgPD0gMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RhdGUubiwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gcmViYWxhbmNlKHRhcmdldCkge1xuXHQgICAgICAgIHZhciBfYSwgX2I7XG5cdCAgICAgICAgdmFyIGRpZmYgPSAoKChfYSA9IHRhcmdldC5yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZCkgfHwgMCkgLSAoKChfYiA9IHRhcmdldC5sKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZCkgfHwgMCk7XG5cdCAgICAgICAgdmFyIHIgPSBkaWZmID4gMSA/IFwiclwiIDogZGlmZiA8IC0xID8gXCJsXCIgOiBcIlwiO1xuXHQgICAgICAgIGlmIChyKSB7XG5cdCAgICAgICAgICAgIHZhciBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiO1xuXHQgICAgICAgICAgICB2YXIgcm9vdENsb25lID0gX19hc3NpZ24oe30sIHRhcmdldCk7XG5cdCAgICAgICAgICAgIHZhciBvbGRSb290UmlnaHQgPSB0YXJnZXRbcl07XG5cdCAgICAgICAgICAgIHRhcmdldC5mcm9tID0gb2xkUm9vdFJpZ2h0LmZyb207XG5cdCAgICAgICAgICAgIHRhcmdldC50byA9IG9sZFJvb3RSaWdodC50bztcblx0ICAgICAgICAgICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuXHQgICAgICAgICAgICByb290Q2xvbmVbcl0gPSBvbGRSb290UmlnaHRbbF07XG5cdCAgICAgICAgICAgIHRhcmdldFtsXSA9IHJvb3RDbG9uZTtcblx0ICAgICAgICAgICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGFyZ2V0LmQgPSBjb21wdXRlRGVwdGgodGFyZ2V0KTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNvbXB1dGVEZXB0aChfYSkge1xuXHQgICAgICAgIHZhciByID0gX2EuciwgbCA9IF9hLmw7XG5cdCAgICAgICAgcmV0dXJuIChyID8gKGwgPyBNYXRoLm1heChyLmQsIGwuZCkgOiByLmQpIDogbCA/IGwuZCA6IDApICsgMTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCh0YXJnZXQsIG5ld1NldCkge1xuXHQgICAgICAgIGtleXMobmV3U2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG5cdCAgICAgICAgICAgIGlmICh0YXJnZXRbcGFydF0pXG5cdCAgICAgICAgICAgICAgICBtZXJnZVJhbmdlcyh0YXJnZXRbcGFydF0sIG5ld1NldFtwYXJ0XSk7XG5cdCAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgIHRhcmdldFtwYXJ0XSA9IGNsb25lU2ltcGxlT2JqZWN0VHJlZShuZXdTZXRbcGFydF0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0YXJnZXQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIG9ic1NldHNPdmVybGFwKG9zMSwgb3MyKSB7XG5cdCAgICAgICAgcmV0dXJuIG9zMS5hbGwgfHwgb3MyLmFsbCB8fCBPYmplY3Qua2V5cyhvczEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb3MyW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChvczJba2V5XSwgb3MxW2tleV0pOyB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhY2hlID0ge307XG5cblx0ICAgIHZhciB1bnNpZ25hbGVkUGFydHMgPSB7fTtcblx0ICAgIHZhciBpc1Rhc2tFbnF1ZXVlZCA9IGZhbHNlO1xuXHQgICAgZnVuY3Rpb24gc2lnbmFsU3Vic2NyaWJlcnNMYXppbHkocGFydCwgb3B0aW1pc3RpYykge1xuXHQgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQodW5zaWduYWxlZFBhcnRzLCBwYXJ0KTtcblx0ICAgICAgICBpZiAoIWlzVGFza0VucXVldWVkKSB7XG5cdCAgICAgICAgICAgIGlzVGFza0VucXVldWVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBpc1Rhc2tFbnF1ZXVlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gdW5zaWduYWxlZFBhcnRzO1xuXHQgICAgICAgICAgICAgICAgdW5zaWduYWxlZFBhcnRzID0ge307XG5cdCAgICAgICAgICAgICAgICBzaWduYWxTdWJzY3JpYmVyc05vdyhwYXJ0cywgZmFsc2UpO1xuXHQgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBzaWduYWxTdWJzY3JpYmVyc05vdyh1cGRhdGVkUGFydHMsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG5cdCAgICAgICAgaWYgKGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzID09PSB2b2lkIDApIHsgZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMgPSBmYWxzZTsgfVxuXHQgICAgICAgIHZhciBxdWVyaWVzVG9TaWduYWwgPSBuZXcgU2V0KCk7XG5cdCAgICAgICAgaWYgKHVwZGF0ZWRQYXJ0cy5hbGwpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC52YWx1ZXMoY2FjaGUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gX2FbX2ldO1xuXHQgICAgICAgICAgICAgICAgY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgcXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB1cGRhdGVkUGFydHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9eaWRiXFw6XFwvXFwvKC4qKVxcLyguKilcXC8vLmV4ZWMoa2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJ0cykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYk5hbWUgPSBwYXJ0c1sxXSwgdGFibGVOYW1lID0gcGFydHNbMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRibENhY2hlID0gY2FjaGVbXCJpZGI6Ly9cIi5jb25jYXQoZGJOYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0YmxDYWNoZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFRhYmxlU3Vic2NyaWJlcnModGJsQ2FjaGUsIHVwZGF0ZWRQYXJ0cywgcXVlcmllc1RvU2lnbmFsLCBkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcXVlcmllc1RvU2lnbmFsLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIHJlcXVlcnkoKTsgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjb2xsZWN0VGFibGVTdWJzY3JpYmVycyh0YmxDYWNoZSwgdXBkYXRlZFBhcnRzLCBvdXRRdWVyaWVzVG9TaWduYWwsIGRlbGV0ZUFmZmVjdGVkQ2FjaGVFbnRyaWVzKSB7XG5cdCAgICAgICAgdmFyIHVwZGF0ZWRFbnRyeUxpc3RzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHRibENhY2hlLnF1ZXJpZXMucXVlcnkpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGluZGV4TmFtZSA9IF9iWzBdLCBlbnRyaWVzID0gX2JbMV07XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXJlZEVudHJpZXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfYyA8IGVudHJpZXNfMS5sZW5ndGg7IF9jKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfY107XG5cdCAgICAgICAgICAgICAgICBpZiAob2JzU2V0c092ZXJsYXAodXBkYXRlZFBhcnRzLCBlbnRyeS5vYnNTZXQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gb3V0UXVlcmllc1RvU2lnbmFsLmFkZChyZXF1ZXJ5KTsgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWxldGVBZmZlY3RlZENhY2hlRW50cmllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkRW50cmllcy5wdXNoKGVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpXG5cdCAgICAgICAgICAgICAgICB1cGRhdGVkRW50cnlMaXN0cy5wdXNoKFtpbmRleE5hbWUsIGZpbHRlcmVkRW50cmllc10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGVsZXRlQWZmZWN0ZWRDYWNoZUVudHJpZXMpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCB1cGRhdGVkRW50cnlMaXN0c18xID0gdXBkYXRlZEVudHJ5TGlzdHM7IF9kIDwgdXBkYXRlZEVudHJ5TGlzdHNfMS5sZW5ndGg7IF9kKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfZSA9IHVwZGF0ZWRFbnRyeUxpc3RzXzFbX2RdLCBpbmRleE5hbWUgPSBfZVswXSwgZmlsdGVyZWRFbnRyaWVzID0gX2VbMV07XG5cdCAgICAgICAgICAgICAgICB0YmxDYWNoZS5xdWVyaWVzLnF1ZXJ5W2luZGV4TmFtZV0gPSBmaWx0ZXJlZEVudHJpZXM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGRleGllT3BlbihkYikge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGRiLl9zdGF0ZTtcblx0ICAgICAgICB2YXIgaW5kZXhlZERCID0gZGIuX2RlcHMuaW5kZXhlZERCO1xuXHQgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuXHQgICAgICAgICAgICByZXR1cm4gc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZS5kYk9wZW5FcnJvciA/XG5cdCAgICAgICAgICAgICAgICByZWplY3Rpb24oc3RhdGUuZGJPcGVuRXJyb3IpIDpcblx0ICAgICAgICAgICAgICAgIGRiOyB9KTtcblx0ICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gdHJ1ZTtcblx0ICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG5cdCAgICAgICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIG9wZW5DYW5jZWxsZXIgPSBzdGF0ZS5vcGVuQ2FuY2VsbGVyO1xuXHQgICAgICAgIHZhciBuYXRpdmVWZXJUb09wZW4gPSBNYXRoLnJvdW5kKGRiLnZlcm5vICogMTApO1xuXHQgICAgICAgIHZhciBzY2hlbWFQYXRjaE1vZGUgPSBmYWxzZTtcblx0ICAgICAgICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuXHQgICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciAhPT0gb3BlbkNhbmNlbGxlcilcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCdkYi5vcGVuKCkgd2FzIGNhbmNlbGxlZCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzb2x2ZURiUmVhZHkgPSBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSxcblx0ICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsLCB3YXNDcmVhdGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHRyeU9wZW5EQiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG5cdCAgICAgICAgICAgIGlmICghaW5kZXhlZERCKVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuXHQgICAgICAgICAgICB2YXIgZGJOYW1lID0gZGIubmFtZTtcblx0ICAgICAgICAgICAgdmFyIHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgfHwgIW5hdGl2ZVZlclRvT3BlbiA/XG5cdCAgICAgICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUpIDpcblx0ICAgICAgICAgICAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSwgbmF0aXZlVmVyVG9PcGVuKTtcblx0ICAgICAgICAgICAgaWYgKCFyZXEpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG5cdCAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG5cdCAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcblx0ICAgICAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IHJlcS50cmFuc2FjdGlvbjtcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVscmVxID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVscmVxLm9uc3VjY2VzcyA9IGRlbHJlcS5vbmVycm9yID0gd3JhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShcIkRhdGFiYXNlIFwiLmNvbmNhdChkYk5hbWUsIFwiIGRvZXNudCBleGlzdFwiKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb2xkVmVyID0gZS5vbGRWZXJzaW9uID4gTWF0aC5wb3coMiwgNjIpID8gMCA6IGUub2xkVmVyc2lvbjtcblx0ICAgICAgICAgICAgICAgICAgICB3YXNDcmVhdGVkID0gb2xkVmVyIDwgMTtcblx0ICAgICAgICAgICAgICAgICAgICBkYi5pZGJkYiA9IHJlcS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVBhdGNoTW9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaEN1cnJlbnRWZXJzaW9uKGRiLCB1cGdyYWRlVHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBydW5VcGdyYWRlcnMoZGIsIG9sZFZlciAvIDEwLCB1cGdyYWRlVHJhbnNhY3Rpb24sIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIHJlamVjdCk7XG5cdCAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWRiZGIgPSBkYi5pZGJkYiA9IHJlcS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMClcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wVHJhbnMgPSBpZGJkYi50cmFuc2FjdGlvbihzYWZhcmlNdWx0aVN0b3JlRml4KG9iamVjdFN0b3JlTmFtZXMpLCAncmVhZG9ubHknKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykgJiYgIXNjaGVtYVBhdGNoTW9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRleGllIFNjaGVtYURpZmY6IFNjaGVtYSB3YXMgZXh0ZW5kZWQgd2l0aG91dCBpbmNyZWFzaW5nIHRoZSBudW1iZXIgcGFzc2VkIHRvIGRiLnZlcnNpb24oKS4gRGV4aWUgd2lsbCBhZGQgbWlzc2luZyBwYXJ0cyBhbmQgaW5jcmVtZW50IG5hdGl2ZSB2ZXJzaW9uIG51bWJlciB0byB3b3JrYXJvdW5kIHRoaXMuXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYmRiLmNsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlVmVyVG9PcGVuID0gaWRiZGIudmVyc2lvbiArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUGF0Y2hNb2RlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnlPcGVuREIoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7XG5cdCAgICAgICAgICAgICAgICBpZGJkYi5vbnZlcnNpb25jaGFuZ2UgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZjRmlyZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGRiLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgaWRiZGIub25jbG9zZSA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGIub24oXCJjbG9zZVwiKS5maXJlKGV2KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdhc0NyZWF0ZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgX29uRGF0YWJhc2VDcmVhdGVkKGRiLl9kZXBzLCBkYk5hbWUpO1xuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICB9LCByZWplY3QpO1xuXHQgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubmFtZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcIlVua25vd25FcnJvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuUFIxMzk4X21heExvb3AtLTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogV29ya2Fyb3VuZCBmb3IgQ2hyb21lIFVua25vd25FcnJvciBvbiBvcGVuKCknKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJWZXJzaW9uRXJyb3JcIjpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobmF0aXZlVmVyVG9PcGVuID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVWZXJUb09wZW4gPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgfSk7IH07XG5cdCAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yYWNlKFtcblx0ICAgICAgICAgICAgb3BlbkNhbmNlbGxlcixcblx0ICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4odHJ5T3BlbkRCKVxuXHQgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG5cdCAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG5cdCAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZSh2aXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIub24ucmVhZHkuZmlyZShkYi52aXApOyB9KSkudGhlbihmdW5jdGlvbiBmaXJlUmVtYWluZGVycygpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlcnNfMSA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbWFpbmRlcnNfMShkYi52aXApOyB9KSkudGhlbihmaXJlUmVtYWluZGVycyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciA9PT0gb3BlbkNhbmNlbGxlcikge1xuXHQgICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IGVycjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiAmJiB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuXHQgICAgICAgICAgICBpZiAob3BlbkNhbmNlbGxlciA9PT0gc3RhdGUub3BlbkNhbmNlbGxlcikge1xuXHQgICAgICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuXHQgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuXHQgICAgICAgICAgICByZXNvbHZlRGJSZWFkeSgpO1xuXHQgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAod2FzQ3JlYXRlZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ZXJ5dGhpbmdfMSA9IHt9O1xuXHQgICAgICAgICAgICAgICAgZGIudGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFibGUuc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHgubmFtZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZXJ5dGhpbmdfMVtcImlkYjovL1wiLmNvbmNhdChkYi5uYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlLm5hbWUsIFwiL1wiKS5jb25jYXQoaWR4Lm5hbWUpXSA9IG5ldyBSYW5nZVNldCgtSW5maW5pdHksIFtbW11dXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZ18xW1wiaWRiOi8vXCIuY29uY2F0KGRiLm5hbWUsIFwiL1wiKS5jb25jYXQodGFibGUubmFtZSwgXCIvXCIpXSA9IGV2ZXJ5dGhpbmdfMVtcImlkYjovL1wiLmNvbmNhdChkYi5uYW1lLCBcIi9cIikuY29uY2F0KHRhYmxlLm5hbWUsIFwiLzpkZWxzXCIpXSA9IG5ldyBSYW5nZVNldCgtSW5maW5pdHksIFtbW11dXSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSkuZmlyZShldmVyeXRoaW5nXzEpO1xuXHQgICAgICAgICAgICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3coZXZlcnl0aGluZ18xLCB0cnVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZGI7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IoaXRlcmF0b3IpIHtcblx0ICAgICAgICB2YXIgY2FsbE5leHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBpdGVyYXRvci5uZXh0KHJlc3VsdCk7IH0sIGRvVGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGl0ZXJhdG9yLnRocm93KGVycm9yKTsgfSwgb25TdWNjZXNzID0gc3RlcChjYWxsTmV4dCksIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksIHZhbHVlID0gbmV4dC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG5cdCAgICAgICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkodmFsdWUpID8gUHJvbWlzZS5hbGwodmFsdWUpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSA6IG9uU3VjY2Vzcyh2YWx1ZSkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc3RlcChjYWxsTmV4dCkoKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZXh0cmFjdFRyYW5zYWN0aW9uQXJncyhtb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG5cdCAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgICAgIGlmIChpIDwgMilcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiVG9vIGZldyBhcmd1bWVudHNcIik7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuXHQgICAgICAgIHdoaWxlICgtLWkpXG5cdCAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgIHNjb3BlRnVuYyA9IGFyZ3MucG9wKCk7XG5cdCAgICAgICAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7XG5cdCAgICAgICAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpIHtcblx0ICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuXHQgICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgIHRyYW5zLmV4cGxpY2l0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgdmFyIHpvbmVQcm9wcyA9IHtcblx0ICAgICAgICAgICAgICAgIHRyYW5zOiB0cmFucyxcblx0ICAgICAgICAgICAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMgPSBwYXJlbnRUcmFuc2FjdGlvbi5pZGJ0cmFucztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnMuaWRidHJhbnMuX2V4cGxpY2l0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoeyBkaXNhYmxlQXV0b09wZW46IGZhbHNlIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZW50ZXJUcmFuc2FjdGlvblNjb3BlKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBudWxsLCBzY29wZUZ1bmMpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcblx0ICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcblx0ICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlO1xuXHQgICAgICAgICAgICB2YXIgcHJvbWlzZUZvbGxvd2VkID0gRGV4aWVQcm9taXNlLmZvbGxvdyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG5cdCAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0SXRlcmF0b3IocmV0dXJuVmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgem9uZVByb3BzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG5cdCAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbihmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHJhbnMuYWN0aXZlID9cblx0ICAgICAgICAgICAgICAgICAgICB4XG5cdCAgICAgICAgICAgICAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSk7IH0pXG5cdCAgICAgICAgICAgICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblZhbHVlOyB9KSkudGhlbihmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKVxuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zLl9yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcblx0ICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRyYW5zLl9yZWplY3QoZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcGFkKGEsIHZhbHVlLCBjb3VudCkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBpc0FycmF5KGEpID8gYS5zbGljZSgpIDogW2FdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSlcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlKGRvd24pIHtcblx0ICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd24pLCB7IHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4TG9va3VwID0ge307XG5cdCAgICAgICAgICAgICAgICB2YXIgYWxsVmlydHVhbEluZGV4ZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFZpcnR1YWxJbmRleGVzKGtleVBhdGgsIGtleVRhaWwsIGxvd0xldmVsSW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aEFsaWFzID0gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXlMZW5ndGggPSBrZXlQYXRoID09IG51bGwgPyAwIDogdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8gMSA6IGtleVBhdGgubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpc1ZpcnR1YWwgPSBrZXlUYWlsID4gMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmlydHVhbEluZGV4ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxvd0xldmVsSW5kZXgpLCB7IG5hbWU6IGlzVmlydHVhbFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChrZXlQYXRoQWxpYXMsIFwiKHZpcnR1YWwtZnJvbTpcIikuY29uY2F0KGxvd0xldmVsSW5kZXgubmFtZSwgXCIpXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvd0xldmVsSW5kZXgubmFtZSwgbG93TGV2ZWxJbmRleDogbG93TGV2ZWxJbmRleCwgaXNWaXJ0dWFsOiBpc1ZpcnR1YWwsIGtleVRhaWw6IGtleVRhaWwsIGtleUxlbmd0aDoga2V5TGVuZ3RoLCBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aCksIHVuaXF1ZTogIWlzVmlydHVhbCAmJiBsb3dMZXZlbEluZGV4LnVuaXF1ZSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleExpc3QucHVzaCh2aXJ0dWFsSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdmlydHVhbEluZGV4LmlzUHJpbWFyeUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhbGxWaXJ0dWFsSW5kZXhlcy5wdXNoKHZpcnR1YWxJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXJ0dWFsS2V5UGF0aCA9IGtleUxlbmd0aCA9PT0gMiA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoWzBdIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGguc2xpY2UoMCwga2V5TGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKHZpcnR1YWxLZXlQYXRoLCBrZXlUYWlsICsgMSwgbG93TGV2ZWxJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4TGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmtleVRhaWwgLSBiLmtleVRhaWw7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGFkZFZpcnR1YWxJbmRleGVzKHNjaGVtYS5wcmltYXJ5S2V5LmtleVBhdGgsIDAsIHNjaGVtYS5wcmltYXJ5S2V5KTtcblx0ICAgICAgICAgICAgICAgIGluZGV4TG9va3VwW1wiOmlkXCJdID0gW3ByaW1hcnlLZXldO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNjaGVtYS5pbmRleGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF9hW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyhpbmRleC5rZXlQYXRoLCAwLCBpbmRleCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaW5kQmVzdEluZGV4KGtleVBhdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5kZXhMb29rdXBbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJhbmdlKHJhbmdlLCBrZXlUYWlsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcmFuZ2UudHlwZSA9PT0gMSAgP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UudHlwZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXI6IHBhZChyYW5nZS5sb3dlciwgcmFuZ2UubG93ZXJPcGVuID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJPcGVuOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck9wZW46IHRydWVcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmVxdWVzdChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSByZXEucXVlcnkuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IHF1ZXJ5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgubG93TGV2ZWxJbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0cmFuc2xhdGVSYW5nZShyZXEucXVlcnkucmFuZ2UsIGluZGV4LmtleVRhaWwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkgOiByZXE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhYmxlKSwgeyBzY2hlbWE6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzY2hlbWEpLCB7IHByaW1hcnlLZXk6IHByaW1hcnlLZXksIGluZGV4ZXM6IGFsbFZpcnR1YWxJbmRleGVzLCBnZXRJbmRleEJ5S2V5UGF0aDogZmluZEJlc3RJbmRleCB9KSwgY291bnQ6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmNvdW50KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnk6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLnF1ZXJ5KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSwgb3BlbkN1cnNvcjogZnVuY3Rpb24gKHJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZXEucXVlcnkuaW5kZXgsIGtleVRhaWwgPSBfYS5rZXlUYWlsLCBpc1ZpcnR1YWwgPSBfYS5pc1ZpcnR1YWwsIGtleUxlbmd0aCA9IF9hLmtleUxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZpcnR1YWwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcihyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2NvbnRpbnVlKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPSBudWxsID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudW5pcXVlID9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkb3duLk1JTl9LRVlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCkpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpcnR1YWxDdXJzb3IgPSBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiB7IHZhbHVlOiBfY29udGludWUgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVByaW1hcnlLZXk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChrZXksIHByaW1hcnlLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkocGFkKGtleSwgZG93bi5NQVhfS0VZLCBrZXlUYWlsKSwgcHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleUxlbmd0aCA9PT0gMSA/XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5WzBdIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkuc2xpY2UoMCwga2V5TGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEN1cnNvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcih0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY3Vyc29yKSB7IHJldHVybiBjdXJzb3IgJiYgY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfSB9KTtcblx0ICAgIH1cblx0ICAgIHZhciB2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlID0ge1xuXHQgICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuXHQgICAgICAgIG5hbWU6IFwiVmlydHVhbEluZGV4TWlkZGxld2FyZVwiLFxuXHQgICAgICAgIGxldmVsOiAxLFxuXHQgICAgICAgIGNyZWF0ZTogY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gZ2V0T2JqZWN0RGlmZihhLCBiLCBydiwgcHJmeCkge1xuXHQgICAgICAgIHJ2ID0gcnYgfHwge307XG5cdCAgICAgICAgcHJmeCA9IHByZnggfHwgJyc7XG5cdCAgICAgICAga2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG5cdCAgICAgICAgICAgIGlmICghaGFzT3duKGIsIHByb3ApKSB7XG5cdCAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXAgPSBhW3Byb3BdLCBicCA9IGJbcHJvcF07XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYnAgPT09ICdvYmplY3QnICYmIGFwICYmIGJwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhhcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhicCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFwVHlwZU5hbWUgIT09IGJwVHlwZU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXBUeXBlTmFtZSA9PT0gJ09iamVjdCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T2JqZWN0RGlmZihhcCwgYnAsIHJ2LCBwcmZ4ICsgcHJvcCArICcuJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwICE9PSBicCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwICE9PSBicClcblx0ICAgICAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAga2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG5cdCAgICAgICAgICAgIGlmICghaGFzT3duKGEsIHByb3ApKSB7XG5cdCAgICAgICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHJ2O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSkge1xuXHQgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpXG5cdCAgICAgICAgICAgIHJldHVybiByZXEua2V5cztcblx0ICAgICAgICByZXR1cm4gcmVxLmtleXMgfHwgcmVxLnZhbHVlcy5tYXAocHJpbWFyeUtleS5leHRyYWN0S2V5KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhvb2tzTWlkZGxld2FyZSA9IHtcblx0ICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcblx0ICAgICAgICBuYW1lOiBcIkhvb2tzTWlkZGxld2FyZVwiLFxuXHQgICAgICAgIGxldmVsOiAyLFxuXHQgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGRvd25Db3JlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGRvd25Db3JlKSwgeyB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRvd25UYWJsZSA9IGRvd25Db3JlLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGRvd25UYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcblx0ICAgICAgICAgICAgICAgIHZhciB0YWJsZU1pZGRsZXdhcmUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93blRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4VHJhbnMgPSBQU0QudHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGR4VHJhbnMudGFibGUodGFibGVOYW1lKS5ob29rLCBkZWxldGluZyA9IF9hLmRlbGV0aW5nLCBjcmVhdGluZyA9IF9hLmNyZWF0aW5nLCB1cGRhdGluZyA9IF9hLnVwZGF0aW5nO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3ApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcCAmJiB1cGRhdGluZy5maXJlID09PSBub3ApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRQdXRPckRlbGV0ZShyZXEpOyB9LCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHJlcSk7IH0sIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWxldGVSYW5nZShyZXEpOyB9LCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRQdXRPckRlbGV0ZShyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeFRyYW5zID0gUFNELnRyYW5zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleXMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBtaXNzaW5nXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXEpLCB7IGtleXM6IGtleXMgfSkgOiBfX2Fzc2lnbih7fSwgcmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gJ2RlbGV0ZScpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyA9IF9fc3ByZWFkQXJyYXkoW10sIHJlcS52YWx1ZXMsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5rZXlzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5rZXlzID0gX19zcHJlYWRBcnJheShbXSwgcmVxLmtleXMsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuKGZ1bmN0aW9uIChleGlzdGluZ1ZhbHVlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXksIGkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSBleGlzdGluZ1ZhbHVlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdlbmVyYXRlZFByaW1hcnlLZXkgPSBjcmVhdGluZy5maXJlLmNhbGwoY3R4LCBrZXksIHJlcS52YWx1ZXNbaV0sIGR4VHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGdlbmVyYXRlZFByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmtleXNbaV0gPSBrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXEudmFsdWVzW2ldLCBwcmltYXJ5S2V5LmtleVBhdGgsIGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKGV4aXN0aW5nVmFsdWUsIHJlcS52YWx1ZXNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxDaGFuZ2VzXzEgPSB1cGRhdGluZy5maXJlLmNhbGwoY3R4LCBvYmplY3REaWZmLCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDaGFuZ2VzXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdGVkVmFsdWVfMSA9IHJlcS52YWx1ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbENoYW5nZXNfMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5UGF0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHJlcXVlc3RlZFZhbHVlXzEsIGtleVBhdGgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZV8xW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNfMVtrZXlQYXRoXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXF1ZXN0ZWRWYWx1ZV8xLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc18xW2tleVBhdGhdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBfYS5mYWlsdXJlcywgcmVzdWx0cyA9IF9hLnJlc3VsdHMsIG51bUZhaWx1cmVzID0gX2EubnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQgPSBfYS5sYXN0UmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmltS2V5ID0gcmVzdWx0cyA/IHJlc3VsdHNbaV0gOiBrZXlzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNvbnRleHRzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbmVycm9yICYmIGN0eC5vbmVycm9yKGZhaWx1cmVzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbnN1Y2Nlc3MgJiYgY3R4Lm9uc3VjY2VzcyhyZXEudHlwZSA9PT0gJ3B1dCcgJiYgZXhpc3RpbmdWYWx1ZXNbaV0gP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzW2ldIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXM6IGZhaWx1cmVzLCByZXN1bHRzOiByZXN1bHRzLCBudW1GYWlsdXJlczogbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQ6IGxhc3RSZXN1bHQgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoY3R4KSB7IHJldHVybiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcik7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmFuZ2UocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsZXRlTmV4dENodW5rKHRyYW5zLCByYW5nZSwgbGltaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkoeyB0cmFuczogdHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7IGluZGV4OiBwcmltYXJ5S2V5LCByYW5nZTogcmFuZ2UgfSwgbGltaXQ6IGxpbWl0IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUHV0T3JEZWxldGUoeyB0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuczogdHJhbnMgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPiAwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBbXSwgbnVtRmFpbHVyZXM6IDAsIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayh0cmFucywgX19hc3NpZ24oX19hc3NpZ24oe30sIHJhbmdlKSwgeyBsb3dlcjogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbG93ZXJPcGVuOiB0cnVlIH0pLCBsaW1pdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG5cdCAgICAgICAgICAgIH0gfSkpOyB9XG5cdCAgICB9O1xuXHQgICAgZnVuY3Rpb24gZ2V0RXhpc3RpbmdWYWx1ZXModGFibGUsIHJlcSwgZWZmZWN0aXZlS2V5cykge1xuXHQgICAgICAgIHJldHVybiByZXEudHlwZSA9PT0gXCJhZGRcIlxuXHQgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcblx0ICAgICAgICAgICAgOiB0YWJsZS5nZXRNYW55KHsgdHJhbnM6IHJlcS50cmFucywga2V5czogZWZmZWN0aXZlS2V5cywgY2FjaGU6IFwiaW1tdXRhYmxlXCIgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIGNhY2hlLCBjbG9uZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGlmICghY2FjaGUpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgaWYgKGNhY2hlLmtleXMubGVuZ3RoIDwga2V5cy5sZW5ndGgpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBjYWNoZS5rZXlzLmxlbmd0aCAmJiBqIDwga2V5cy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNtcChjYWNoZS5rZXlzW2ldLCBrZXlzW2pdKSAhPT0gMClcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNsb25lID8gZGVlcENsb25lKGNhY2hlLnZhbHVlc1tpXSkgOiBjYWNoZS52YWx1ZXNbaV0pO1xuXHQgICAgICAgICAgICAgICAgKytqO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSBrZXlzLmxlbmd0aCA/IHJlc3VsdCA6IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChfYSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUgPSB7XG5cdCAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG5cdCAgICAgICAgbGV2ZWw6IC0xLFxuXHQgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFibGUpLCB7IGdldE1hbnk6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxLmNhY2hlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShyZXEua2V5cywgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLCByZXEuY2FjaGUgPT09IFwiY2xvbmVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50cmFuc1tcIl9jYWNoZVwiXSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogcmVxLmNhY2hlID09PSBcImNsb25lXCIgPyBkZWVwQ2xvbmUocmVzKSA6IHJlcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09IFwiYWRkXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGlzQ2FjaGFibGVDb250ZXh0KGN0eCwgdGFibGUpIHtcblx0ICAgICAgICByZXR1cm4gKGN0eC50cmFucy5tb2RlID09PSAncmVhZG9ubHknICYmXG5cdCAgICAgICAgICAgICEhY3R4LnN1YnNjciAmJlxuXHQgICAgICAgICAgICAhY3R4LnRyYW5zLmV4cGxpY2l0ICYmXG5cdCAgICAgICAgICAgIGN0eC50cmFucy5kYi5fb3B0aW9ucy5jYWNoZSAhPT0gJ2Rpc2FibGVkJyAmJlxuXHQgICAgICAgICAgICAhdGFibGUuc2NoZW1hLnByaW1hcnlLZXkub3V0Ym91bmQpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBpc0NhY2hhYmxlUmVxdWVzdCh0eXBlLCByZXEpIHtcblx0ICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSAncXVlcnknOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlcS52YWx1ZXMgJiYgIXJlcS51bmlxdWU7XG5cdCAgICAgICAgICAgIGNhc2UgJ2dldCc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIGNhc2UgJ2dldE1hbnknOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICBjYXNlICdjb3VudCc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIGNhc2UgJ29wZW5DdXJzb3InOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlID0ge1xuXHQgICAgICAgIHN0YWNrOiBcImRiY29yZVwiLFxuXHQgICAgICAgIGxldmVsOiAwLFxuXHQgICAgICAgIG5hbWU6IFwiT2JzZXJ2YWJpbGl0eVwiLFxuXHQgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGNvcmUpIHtcblx0ICAgICAgICAgICAgdmFyIGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG5cdCAgICAgICAgICAgIHZhciBGVUxMX1JBTkdFID0gbmV3IFJhbmdlU2V0KGNvcmUuTUlOX0tFWSwgY29yZS5NQVhfS0VZKTtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3JlKSwgeyB0cmFuc2FjdGlvbjogZnVuY3Rpb24gKHN0b3JlcywgbW9kZSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChQU0Quc3Vic2NyICYmIG1vZGUgIT09ICdyZWFkb25seScpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJSZWFkd3JpdGUgdHJhbnNhY3Rpb24gaW4gbGl2ZVF1ZXJ5IGNvbnRleHQuIFF1ZXJpZXIgc291cmNlOiBcIi5jb25jYXQoUFNELnF1ZXJpZXIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIH0sIHRhYmxlOiBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBzY2hlbWEucHJpbWFyeUtleSwgaW5kZXhlcyA9IHNjaGVtYS5pbmRleGVzO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHRyYWN0S2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5LCBvdXRib3VuZCA9IHByaW1hcnlLZXkub3V0Ym91bmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXNXaXRoQXV0b0luY1BLID0gcHJpbWFyeUtleS5hdXRvSW5jcmVtZW50ICYmIGluZGV4ZXMuZmlsdGVyKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gaW5kZXguY29tcG91bmQgJiYgaW5kZXgua2V5UGF0aC5pbmNsdWRlcyhwcmltYXJ5S2V5LmtleVBhdGgpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVDbG9uZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YWJsZSksIHsgbXV0YXRlOiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSByZXEudHJhbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZFBhcnRzID0gcmVxLm11dGF0ZWRQYXJ0cyB8fCAocmVxLm11dGF0ZWRQYXJ0cyA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRSYW5nZVNldCA9IGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IFwiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUsIFwiL1wiKS5jb25jYXQoaW5kZXhOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG11dGF0ZWRQYXJ0c1twYXJ0XSB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobXV0YXRlZFBhcnRzW3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlcS50eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVxLnR5cGUgPT09IFwiZGVsZXRlUmFuZ2VcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3JlcS5yYW5nZV1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcS50eXBlID09PSBcImRlbGV0ZVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3JlcS5rZXlzXVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcS52YWx1ZXMubGVuZ3RoIDwgNTBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW2dldEVmZmVjdGl2ZUtleXMocHJpbWFyeUtleSwgcmVxKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZDsgfSksIHJlcS52YWx1ZXNdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdLCBrZXlzID0gX2FbMF0sIG5ld09ianMgPSBfYVsxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IHJlcS50cmFuc1tcIl9jYWNoZVwiXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGtleXMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRPYmpzID0gdHlwZSA9PT0gJ2RlbGV0ZScgfHwga2V5cy5sZW5ndGggPT09IG5ld09ianMubGVuZ3RoID8gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgb2xkQ2FjaGUpIDogbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRPYmpzIHx8IG5ld09ianMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHsgZnJvbToga2V5cy5sb3dlciwgdG86IGtleXMudXBwZXIgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKHJhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChyYW5nZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS5pbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgKHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhyZXMucmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleGVzV2l0aEF1dG9JbmNQSykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1dpdGhBdXRvSW5jUEsuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeFZhbHMgPSByZXEudmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gaWR4LmV4dHJhY3RLZXkodik7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwa1BvcyA9IGlkeC5rZXlQYXRoLmZpbmRJbmRleChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcCA9PT0gcHJpbWFyeUtleS5rZXlQYXRoOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChwaykgeyByZXR1cm4gaWR4VmFsc1twa1Bvc10gPSBwazsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZEtleXMoaWR4VmFscyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5tdXRhdGVkUGFydHMgPSBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCB7fSwgbXV0YXRlZFBhcnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZCA9IF9hLnF1ZXJ5LCBpbmRleCA9IF9kLmluZGV4LCByYW5nZSA9IF9kLnJhbmdlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2VTZXQoKF9iID0gcmFuZ2UubG93ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvcmUuTUlOX0tFWSwgKF9jID0gcmFuZ2UudXBwZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvcmUuTUFYX0tFWSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZFN1YnNjcmliZXJzID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQocmVxLmtleSldOyB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXRNYW55OiBmdW5jdGlvbiAocmVxKSB7IHJldHVybiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEua2V5cyldOyB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogZ2V0UmFuZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBnZXRSYW5nZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkN1cnNvcjogZ2V0UmFuZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzKHJlYWRTdWJzY3JpYmVycykuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xvbmVbbWV0aG9kXSA9IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzY3IgPSBQU0Quc3Vic2NyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzTGl2ZVF1ZXJ5ID0gISFzdWJzY3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGFibGUgPSBpc0NhY2hhYmxlQ29udGV4dChQU0QsIHRhYmxlKSAmJiBpc0NhY2hhYmxlUmVxdWVzdChtZXRob2QsIHJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzU2V0ID0gY2FjaGFibGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlcS5vYnNTZXQgPSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3Vic2NyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGl2ZVF1ZXJ5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlU2V0ID0gZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IFwiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUsIFwiL1wiKS5jb25jYXQoaW5kZXhOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvYnNTZXRbcGFydF0gfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvYnNTZXRbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBrUmFuZ2VTZXRfMSA9IGdldFJhbmdlU2V0KFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxzUmFuZ2VTZXRfMSA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVhZFN1YnNjcmliZXJzW21ldGhvZF0ocmVxKSwgcXVlcmllZEluZGV4ID0gX2FbMF0sIHF1ZXJpZWRSYW5nZXMgPSBfYVsxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAncXVlcnknICYmIHF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkgJiYgIXJlcS52YWx1ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQocXVlcmllZEluZGV4Lm5hbWUgfHwgXCJcIikuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjb3VudFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGQoRlVMTF9SQU5HRSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5c1Byb21pc2VfMSA9IG1ldGhvZCA9PT0gXCJxdWVyeVwiICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUucXVlcnkoX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsgdmFsdWVzOiBmYWxzZSB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicXVlcnlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgcmVxLnZhbHVlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlXzEudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0aW5nS2V5cyA9IF9hLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0XzEuYWRkS2V5cyhyZXN1bHRpbmdLZXlzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBLZXlzID0gcmVxLnZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXMucmVzdWx0Lm1hcChleHRyYWN0S2V5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXMucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnZhbHVlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldF8xLmFkZEtleXMocEtleXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkS2V5cyhwS2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSBcIm9wZW5DdXJzb3JcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yXzEgPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YW50VmFsdWVzXzEgPSByZXEudmFsdWVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnNvcl8xICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGN1cnNvcl8xLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0XzEuYWRkS2V5KGN1cnNvcl8xLnByaW1hcnlLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcl8xLmtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGtleSA9IGN1cnNvcl8xLnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXRfMS5hZGRLZXkocGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FudFZhbHVlc18xICYmIHBrUmFuZ2VTZXRfMS5hZGRLZXkoY3Vyc29yXzEucHJpbWFyeUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yXzEudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVDbG9uZTtcblx0ICAgICAgICAgICAgICAgIH0gfSk7XG5cdCAgICAgICAgfSxcblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gYWRkQWZmZWN0ZWRJbmRleChpeCkge1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBleHRyYWN0S2V5KG9iaikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gaXguZXh0cmFjdEtleShvYmopIDogbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgYWRkS2V5T3JLZXlzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcblx0ICAgICAgICAgICAgICAgID8ga2V5LmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcmFuZ2VTZXQuYWRkS2V5KGtleSk7IH0pXG5cdCAgICAgICAgICAgICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpOyB9O1xuXHQgICAgICAgICAgICAob2xkT2JqcyB8fCBuZXdPYmpzKS5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb2xkS2V5ID0gb2xkT2JqcyAmJiBleHRyYWN0S2V5KG9sZE9ianNbaV0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIG5ld0tleSA9IG5ld09ianMgJiYgZXh0cmFjdEtleShuZXdPYmpzW2ldKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjbXAob2xkS2V5LCBuZXdLZXkpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEtleSAhPSBudWxsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMob2xkS2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobmV3S2V5ICE9IG51bGwpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhuZXdLZXkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxLCByZXMpIHtcblx0ICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID09PSAwKVxuXHQgICAgICAgICAgICByZXR1cm4gcmVxO1xuXHQgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZVJhbmdlJykge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG51bUJ1bGtPcHMgPSByZXEua2V5c1xuXHQgICAgICAgICAgICA/IHJlcS5rZXlzLmxlbmd0aFxuXHQgICAgICAgICAgICA6ICd2YWx1ZXMnIGluIHJlcSAmJiByZXEudmFsdWVzXG5cdCAgICAgICAgICAgICAgICA/IHJlcS52YWx1ZXMubGVuZ3RoXG5cdCAgICAgICAgICAgICAgICA6IDE7XG5cdCAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA9PT0gbnVtQnVsa09wcykge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNsb25lID0gX19hc3NpZ24oe30sIHJlcSk7XG5cdCAgICAgICAgaWYgKGlzQXJyYXkoY2xvbmUua2V5cykpIHtcblx0ICAgICAgICAgICAgY2xvbmUua2V5cyA9IGNsb25lLmtleXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAhKGkgaW4gcmVzLmZhaWx1cmVzKTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICgndmFsdWVzJyBpbiBjbG9uZSAmJiBpc0FycmF5KGNsb25lLnZhbHVlcykpIHtcblx0ICAgICAgICAgICAgY2xvbmUudmFsdWVzID0gY2xvbmUudmFsdWVzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gIShpIGluIHJlcy5mYWlsdXJlcyk7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSB7XG5cdCAgICAgICAgcmV0dXJuIHJhbmdlLmxvd2VyID09PSB1bmRlZmluZWRcblx0ICAgICAgICAgICAgPyB0cnVlXG5cdCAgICAgICAgICAgIDogcmFuZ2UubG93ZXJPcGVuXG5cdCAgICAgICAgICAgICAgICA/IGNtcChrZXksIHJhbmdlLmxvd2VyKSA+IDBcblx0ICAgICAgICAgICAgICAgIDogY21wKGtleSwgcmFuZ2UubG93ZXIpID49IDA7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBpc0JlbG93VXBwZXIoa2V5LCByYW5nZSkge1xuXHQgICAgICAgIHJldHVybiByYW5nZS51cHBlciA9PT0gdW5kZWZpbmVkXG5cdCAgICAgICAgICAgID8gdHJ1ZVxuXHQgICAgICAgICAgICA6IHJhbmdlLnVwcGVyT3BlblxuXHQgICAgICAgICAgICAgICAgPyBjbXAoa2V5LCByYW5nZS51cHBlcikgPCAwXG5cdCAgICAgICAgICAgICAgICA6IGNtcChrZXksIHJhbmdlLnVwcGVyKSA8PSAwO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaXNXaXRoaW5SYW5nZShrZXksIHJhbmdlKSB7XG5cdCAgICAgICAgcmV0dXJuIGlzQWJvdmVMb3dlcihrZXksIHJhbmdlKSAmJiBpc0JlbG93VXBwZXIoa2V5LCByYW5nZSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY09wcyhyZXN1bHQsIHJlcSwgb3BzLCB0YWJsZSwgY2FjaGVFbnRyeSwgaW1tdXRhYmxlKSB7XG5cdCAgICAgICAgaWYgKCFvcHMgfHwgb3BzLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB2YXIgaW5kZXggPSByZXEucXVlcnkuaW5kZXg7XG5cdCAgICAgICAgdmFyIG11bHRpRW50cnkgPSBpbmRleC5tdWx0aUVudHJ5O1xuXHQgICAgICAgIHZhciBxdWVyeVJhbmdlID0gcmVxLnF1ZXJ5LnJhbmdlO1xuXHQgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gdGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG5cdCAgICAgICAgdmFyIGV4dHJhY3RQcmltS2V5ID0gcHJpbWFyeUtleS5leHRyYWN0S2V5O1xuXHQgICAgICAgIHZhciBleHRyYWN0SW5kZXggPSBpbmRleC5leHRyYWN0S2V5O1xuXHQgICAgICAgIHZhciBleHRyYWN0TG93TGV2ZWxJbmRleCA9IChpbmRleC5sb3dMZXZlbEluZGV4IHx8IGluZGV4KS5leHRyYWN0S2V5O1xuXHQgICAgICAgIHZhciBmaW5hbFJlc3VsdCA9IG9wcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgb3ApIHtcblx0ICAgICAgICAgICAgdmFyIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgIHZhciBpbmNsdWRlZFZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICBpZiAob3AudHlwZSA9PT0gJ2FkZCcgfHwgb3AudHlwZSA9PT0gJ3B1dCcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlZFBLcyA9IG5ldyBSYW5nZVNldCgpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9wLnZhbHVlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wLnZhbHVlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGsgPSBleHRyYWN0UHJpbUtleSh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVkUEtzLmhhc0tleShwaykpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBleHRyYWN0SW5kZXgodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aUVudHJ5ICYmIGlzQXJyYXkoa2V5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IGtleS5zb21lKGZ1bmN0aW9uIChrKSB7IHJldHVybiBpc1dpdGhpblJhbmdlKGssIHF1ZXJ5UmFuZ2UpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IGlzV2l0aGluUmFuZ2Uoa2V5LCBxdWVyeVJhbmdlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFBLcy5hZGRLZXkocGspO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFZhbHVlcy5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuXHQgICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHQuY29uY2F0KHJlcS52YWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgPyBpbmNsdWRlZFZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IGluY2x1ZGVkVmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZXh0cmFjdFByaW1LZXkodik7IH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGtleVNldF8xID0gbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhvcC52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBleHRyYWN0UHJpbUtleSh2KTsgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIG1vZGlmZWRSZXN1bHQgPSByZXN1bHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIWtleVNldF8xLmhhc0tleShyZXEudmFsdWVzID8gZXh0cmFjdFByaW1LZXkoaXRlbSkgOiBpdGVtKTsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChcblx0ICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gaW5jbHVkZWRWYWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlZFZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGV4dHJhY3RQcmltS2V5KHYpOyB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzVG9EZWxldGVfMSA9IG5ldyBSYW5nZVNldCgpLmFkZEtleXMob3Aua2V5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFrZXlzVG9EZWxldGVfMS5oYXNLZXkocmVxLnZhbHVlcyA/IGV4dHJhY3RQcmltS2V5KGl0ZW0pIDogaXRlbSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZV8xID0gb3AucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kaWZlZFJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFpc1dpdGhpblJhbmdlKGV4dHJhY3RQcmltS2V5KGl0ZW0pLCByYW5nZV8xKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG1vZGlmZWRSZXN1bHQ7XG5cdCAgICAgICAgfSwgcmVzdWx0KTtcblx0ICAgICAgICBpZiAoZmluYWxSZXN1bHQgPT09IHJlc3VsdClcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICBmaW5hbFJlc3VsdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjbXAoZXh0cmFjdExvd0xldmVsSW5kZXgoYSksIGV4dHJhY3RMb3dMZXZlbEluZGV4KGIpKSB8fFxuXHQgICAgICAgICAgICAgICAgY21wKGV4dHJhY3RQcmltS2V5KGEpLCBleHRyYWN0UHJpbUtleShiKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHJlcS5saW1pdCAmJiByZXEubGltaXQgPCBJbmZpbml0eSkge1xuXHQgICAgICAgICAgICBpZiAoZmluYWxSZXN1bHQubGVuZ3RoID4gcmVxLmxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdC5sZW5ndGggPSByZXEubGltaXQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gcmVxLmxpbWl0ICYmIGZpbmFsUmVzdWx0Lmxlbmd0aCA8IHJlcS5saW1pdCkge1xuXHQgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5kaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGltbXV0YWJsZSA/IE9iamVjdC5mcmVlemUoZmluYWxSZXN1bHQpIDogZmluYWxSZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFyZVJhbmdlc0VxdWFsKHIxLCByMikge1xuXHQgICAgICAgIHJldHVybiAoY21wKHIxLmxvd2VyLCByMi5sb3dlcikgPT09IDAgJiZcblx0ICAgICAgICAgICAgY21wKHIxLnVwcGVyLCByMi51cHBlcikgPT09IDAgJiZcblx0ICAgICAgICAgICAgISFyMS5sb3dlck9wZW4gPT09ICEhcjIubG93ZXJPcGVuICYmXG5cdCAgICAgICAgICAgICEhcjEudXBwZXJPcGVuID09PSAhIXIyLnVwcGVyT3Blbik7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNvbXBhcmVMb3dlcnMobG93ZXIxLCBsb3dlcjIsIGxvd2VyT3BlbjEsIGxvd2VyT3BlbjIpIHtcblx0ICAgICAgICBpZiAobG93ZXIxID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIHJldHVybiBsb3dlcjIgIT09IHVuZGVmaW5lZCA/IC0xIDogMDtcblx0ICAgICAgICBpZiAobG93ZXIyID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgIHZhciBjID0gY21wKGxvd2VyMSwgbG93ZXIyKTtcblx0ICAgICAgICBpZiAoYyA9PT0gMCkge1xuXHQgICAgICAgICAgICBpZiAobG93ZXJPcGVuMSAmJiBsb3dlck9wZW4yKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIGlmIChsb3dlck9wZW4xKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIGlmIChsb3dlck9wZW4yKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYztcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNvbXBhcmVVcHBlcnModXBwZXIxLCB1cHBlcjIsIHVwcGVyT3BlbjEsIHVwcGVyT3BlbjIpIHtcblx0ICAgICAgICBpZiAodXBwZXIxID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIHJldHVybiB1cHBlcjIgIT09IHVuZGVmaW5lZCA/IDEgOiAwO1xuXHQgICAgICAgIGlmICh1cHBlcjIgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIHZhciBjID0gY21wKHVwcGVyMSwgdXBwZXIyKTtcblx0ICAgICAgICBpZiAoYyA9PT0gMCkge1xuXHQgICAgICAgICAgICBpZiAodXBwZXJPcGVuMSAmJiB1cHBlck9wZW4yKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIGlmICh1cHBlck9wZW4xKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICBpZiAodXBwZXJPcGVuMilcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYztcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGlzU3VwZXJSYW5nZShyMSwgcjIpIHtcblx0ICAgICAgICByZXR1cm4gKGNvbXBhcmVMb3dlcnMocjEubG93ZXIsIHIyLmxvd2VyLCByMS5sb3dlck9wZW4sIHIyLmxvd2VyT3BlbikgPD0gMCAmJlxuXHQgICAgICAgICAgICBjb21wYXJlVXBwZXJzKHIxLnVwcGVyLCByMi51cHBlciwgcjEudXBwZXJPcGVuLCByMi51cHBlck9wZW4pID49IDApO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmaW5kQ29tcGF0aWJsZVF1ZXJ5KGRiTmFtZSwgdGFibGVOYW1lLCB0eXBlLCByZXEpIHtcblx0ICAgICAgICB2YXIgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV07XG5cdCAgICAgICAgaWYgKCF0YmxDYWNoZSlcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIHZhciBxdWVyaWVzID0gdGJsQ2FjaGUucXVlcmllc1t0eXBlXTtcblx0ICAgICAgICBpZiAoIXF1ZXJpZXMpXG5cdCAgICAgICAgICAgIHJldHVybiBbbnVsbCwgZmFsc2UsIHRibENhY2hlLCBudWxsXTtcblx0ICAgICAgICB2YXIgaW5kZXhOYW1lID0gcmVxLnF1ZXJ5ID8gcmVxLnF1ZXJ5LmluZGV4Lm5hbWUgOiBudWxsO1xuXHQgICAgICAgIHZhciBlbnRyaWVzID0gcXVlcmllc1tpbmRleE5hbWUgfHwgJyddO1xuXHQgICAgICAgIGlmICghZW50cmllcylcblx0ICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBmYWxzZSwgdGJsQ2FjaGUsIG51bGxdO1xuXHQgICAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlICdxdWVyeSc6XG5cdCAgICAgICAgICAgICAgICB2YXIgZXF1YWxFbnRyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucmVxLmxpbWl0ID09PSByZXEubGltaXQgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucmVxLnZhbHVlcyA9PT0gcmVxLnZhbHVlcyAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcmVSYW5nZXNFcXVhbChlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGlmIChlcXVhbEVudHJ5KVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsRW50cnksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLFxuXHQgICAgICAgICAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VwZXJFbnRyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSAnbGltaXQnIGluIGVudHJ5LnJlcSA/IGVudHJ5LnJlcS5saW1pdCA6IEluZmluaXR5O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAobGltaXQgPj0gcmVxLmxpbWl0ICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChyZXEudmFsdWVzID8gZW50cnkucmVxLnZhbHVlcyA6IHRydWUpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VwZXJSYW5nZShlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSkpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW3N1cGVyRW50cnksIGZhbHNlLCB0YmxDYWNoZSwgZW50cmllc107XG5cdCAgICAgICAgICAgIGNhc2UgJ2NvdW50Jzpcblx0ICAgICAgICAgICAgICAgIHZhciBjb3VudFF1ZXJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmVSYW5nZXNFcXVhbChlbnRyeS5yZXEucXVlcnkucmFuZ2UsIHJlcS5xdWVyeS5yYW5nZSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbY291bnRRdWVyeSwgISFjb3VudFF1ZXJ5LCB0YmxDYWNoZSwgZW50cmllc107XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb0NhY2hlRW50cnkoY2FjaGVFbnRyeSwgY29udGFpbmVyLCByZXF1ZXJ5LCBzaWduYWwpIHtcblx0ICAgICAgICBjYWNoZUVudHJ5LnN1YnNjcmliZXJzLmFkZChyZXF1ZXJ5KTtcblx0ICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgY2FjaGVFbnRyeS5zdWJzY3JpYmVycy5kZWxldGUocmVxdWVyeSk7XG5cdCAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LnN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGVucXVlRm9yRGVsZXRpb24oY2FjaGVFbnRyeSwgY29udGFpbmVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZW5xdWVGb3JEZWxldGlvbihjYWNoZUVudHJ5LCBjb250YWluZXIpIHtcblx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGNvbnRhaW5lciwgY2FjaGVFbnRyeSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LCAzMDAwKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhY2hlTWlkZGxld2FyZSA9IHtcblx0ICAgICAgICBzdGFjazogJ2RiY29yZScsXG5cdCAgICAgICAgbGV2ZWw6IDAsXG5cdCAgICAgICAgbmFtZTogJ0NhY2hlJyxcblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb3JlKSB7XG5cdCAgICAgICAgICAgIHZhciBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuXHQgICAgICAgICAgICB2YXIgY29yZU1XID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNvcmUpLCB7IHRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoc3RvcmVzLCBtb2RlLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkYnRyYW5zID0gY29yZS50cmFuc2FjdGlvbihzdG9yZXMsIG1vZGUsIG9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNfMSA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hbCA9IGFjXzEuc2lnbmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAod2FzQ29tbWl0dGVkKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY18xLmFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRTdWJzY3JpYmVyc18xID0gbmV3IFNldCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc3RvcmVzXzEgPSBzdG9yZXM7IF9pIDwgc3RvcmVzXzEubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSBzdG9yZXNfMVtfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdChzdG9yZU5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRibENhY2hlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjb3JlLnRhYmxlKHN0b3JlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BzID0gdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC50cmFucyA9PT0gaWRidHJhbnM7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkYnRyYW5zLl9leHBsaWNpdCAmJiB3YXNDb21taXR0ZWQgJiYgaWRidHJhbnMubXV0YXRlZFBhcnRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IE9iamVjdC52YWx1ZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gX2JbX2FdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIF9kID0gZW50cmllcy5zbGljZSgpOyBfYyA8IF9kLmxlbmd0aDsgX2MrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2RbX2NdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic1NldHNPdmVybGFwKGVudHJ5Lm9ic1NldCwgaWRidHJhbnMubXV0YXRlZFBhcnRzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbShlbnRyaWVzLCBlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gYWZmZWN0ZWRTdWJzY3JpYmVyc18xLmFkZChyZXF1ZXJ5KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMgPSB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLnRyYW5zICE9PSBpZGJ0cmFuczsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAwLCBfZiA9IE9iamVjdC52YWx1ZXModGJsQ2FjaGUucXVlcmllcy5xdWVyeSk7IF9lIDwgX2YubGVuZ3RoOyBfZSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gX2ZbX2VdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDAsIF9oID0gZW50cmllcy5zbGljZSgpOyBfZyA8IF9oLmxlbmd0aDsgX2crKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2hbX2ddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlcyAhPSBudWxsICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMubXV0YXRlZFBhcnRzXG5cdCAgICApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FzQ29tbWl0dGVkICYmICFlbnRyeS5kaXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlZXplUmVzdWx0cyA9IE9iamVjdC5pc0Zyb3plbihlbnRyeS5yZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kUmVzID0gYXBwbHlPcHRpbWlzdGljT3BzKGVudHJ5LnJlcywgZW50cnkucmVxLCBvcHMsIHRhYmxlLCBlbnRyeSwgZnJlZXplUmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kaXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGVudHJpZXMsIGVudHJ5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZFJlcyAhPT0gZW50cnkucmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXMgPSBtb2RSZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5wcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUoeyByZXN1bHQ6IG1vZFJlcyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRpcnR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0oZW50cmllcywgZW50cnkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlcnkpIHsgcmV0dXJuIGFmZmVjdGVkU3Vic2NyaWJlcnNfMS5hZGQocmVxdWVyeSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZFN1YnNjcmliZXJzXzEuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVyeSkgeyByZXR1cm4gcmVxdWVyeSgpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlbmRUcmFuc2FjdGlvbihmYWxzZSksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlbmRUcmFuc2FjdGlvbihmYWxzZSksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWRidHJhbnMuYWRkRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBlbmRUcmFuc2FjdGlvbih0cnVlKSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWRidHJhbnM7XG5cdCAgICAgICAgICAgICAgICB9LCB0YWJsZTogZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkb3duVGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBkb3duVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlTVcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG93blRhYmxlKSwgeyBtdXRhdGU6IGZ1bmN0aW9uIChyZXEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IFBTRC50cmFucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm91dGJvdW5kIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuZGIuX29wdGlvbnMuY2FjaGUgPT09ICdkaXNhYmxlZCcgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5leHBsaWNpdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YmxDYWNoZSA9IGNhY2hlW1wiaWRiOi8vXCIuY29uY2F0KGRiTmFtZSwgXCIvXCIpLmNvbmNhdCh0YWJsZU5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGJsQ2FjaGUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgcmVxLnR5cGUgPT09ICdwdXQnKSAmJiAocmVxLnZhbHVlcy5sZW5ndGggPj0gNTAgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltS2V5LCByZXEpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ID09IG51bGw7IH0pKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFXaXRoUmVzb2x2ZWRLZXlzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlcSksIHsgdmFsdWVzOiByZXEudmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlV2l0aEtleSA9ICgoX2EgPSBwcmltS2V5LmtleVBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnLicpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRlZXBDbG9uZSh2YWx1ZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfX2Fzc2lnbih7fSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aCh2YWx1ZVdpdGhLZXksIHByaW1LZXkua2V5UGF0aCwgcmVzLnJlc3VsdHNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVdpdGhLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkUmVxID0gYWRqdXN0T3B0aW1pc3RpY0Zyb21GYWlsdXJlcyh0YmxDYWNoZSwgcmVxV2l0aFJlc29sdmVkS2V5cywgcmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUub3B0aW1pc3RpY09wcy5wdXNoKGFkanVzdGVkUmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxLm11dGF0ZWRQYXJ0cyAmJiBzaWduYWxTdWJzY3JpYmVyc0xhemlseShyZXEubXV0YXRlZFBhcnRzKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YmxDYWNoZS5vcHRpbWlzdGljT3BzLnB1c2gocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxBcnJheUl0ZW0odGJsQ2FjaGUub3B0aW1pc3RpY09wcywgcmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZFJlcSA9IGFkanVzdE9wdGltaXN0aWNGcm9tRmFpbHVyZXModGJsQ2FjaGUsIHJlcSwgcmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGp1c3RlZFJlcSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLm9wdGltaXN0aWNPcHMucHVzaChhZGp1c3RlZFJlcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbEFycmF5SXRlbSh0YmxDYWNoZS5vcHRpbWlzdGljT3BzLCByZXEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEubXV0YXRlZFBhcnRzICYmIHNpZ25hbFN1YnNjcmliZXJzTGF6aWx5KHJlcS5tdXRhdGVkUGFydHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5OiBmdW5jdGlvbiAocmVxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FjaGFibGVDb250ZXh0KFBTRCwgZG93blRhYmxlKSB8fCAhaXNDYWNoYWJsZVJlcXVlc3QoXCJxdWVyeVwiLCByZXEpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkocmVxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVlemVSZXN1bHRzID0gKChfYSA9IFBTRC50cmFucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRiLl9vcHRpb25zLmNhY2hlKSA9PT0gJ2ltbXV0YWJsZSc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBQU0QsIHJlcXVlcnkgPSBfYi5yZXF1ZXJ5LCBzaWduYWwgPSBfYi5zaWduYWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBmaW5kQ29tcGF0aWJsZVF1ZXJ5KGRiTmFtZSwgdGFibGVOYW1lLCAncXVlcnknLCByZXEpLCBjYWNoZUVudHJ5ID0gX2NbMF0sIGV4YWN0TWF0Y2ggPSBfY1sxXSwgdGJsQ2FjaGUgPSBfY1syXSwgY29udGFpbmVyID0gX2NbM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeSAmJiBleGFjdE1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5vYnNTZXQgPSByZXEub2JzU2V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkb3duVGFibGUucXVlcnkocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5yZXMgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmVlemVSZXN1bHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdFtpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmVzdWx0ID0gZGVlcENsb25lKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjYWNoZUVudHJ5KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsQXJyYXlJdGVtKGNvbnRhaW5lciwgY2FjaGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzU2V0OiByZXEub2JzU2V0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogbmV3IFNldCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncXVlcnknLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXE6IHJlcSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHk6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucHVzaChjYWNoZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IFtjYWNoZUVudHJ5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YmxDYWNoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJsQ2FjaGUgPSBjYWNoZVtcImlkYjovL1wiLmNvbmNhdChkYk5hbWUsIFwiL1wiKS5jb25jYXQodGFibGVOYW1lKV0gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllczoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge30sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiB7fSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ianM6IG5ldyBNYXAoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljT3BzOiBbXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNpZ25hbGVkUGFydHM6IHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRibENhY2hlLnF1ZXJpZXMucXVlcnlbcmVxLnF1ZXJ5LmluZGV4Lm5hbWUgfHwgJyddID0gY29udGFpbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZVRvQ2FjaGVFbnRyeShjYWNoZUVudHJ5LCBjb250YWluZXIsIHJlcXVlcnksIHNpZ25hbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXBwbHlPcHRpbWlzdGljT3BzKHJlcy5yZXN1bHQsIHJlcSwgdGJsQ2FjaGUgPT09IG51bGwgfHwgdGJsQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRibENhY2hlLm9wdGltaXN0aWNPcHMsIGRvd25UYWJsZSwgY2FjaGVFbnRyeSwgZnJlZXplUmVzdWx0cyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZU1XO1xuXHQgICAgICAgICAgICAgICAgfSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvcmVNVztcblx0ICAgICAgICB9LFxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gdmlwaWZ5KHRhcmdldCwgdmlwRGIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RiJylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlwRGI7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIERleGllJDEgPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBEZXhpZShuYW1lLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHRoaXMuX21pZGRsZXdhcmVzID0ge307XG5cdCAgICAgICAgICAgIHRoaXMudmVybm8gPSAwO1xuXHQgICAgICAgICAgICB2YXIgZGVwcyA9IERleGllLmRlcGVuZGVuY2llcztcblx0ICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSBfX2Fzc2lnbih7XG5cdCAgICAgICAgICAgICAgICBhZGRvbnM6IERleGllLmFkZG9ucywgYXV0b09wZW46IHRydWUsXG5cdCAgICAgICAgICAgICAgICBpbmRleGVkREI6IGRlcHMuaW5kZXhlZERCLCBJREJLZXlSYW5nZTogZGVwcy5JREJLZXlSYW5nZSwgY2FjaGU6ICdjbG9uZWQnIH0sIG9wdGlvbnMpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXBzID0ge1xuXHQgICAgICAgICAgICAgICAgaW5kZXhlZERCOiBvcHRpb25zLmluZGV4ZWREQixcblx0ICAgICAgICAgICAgICAgIElEQktleVJhbmdlOiBvcHRpb25zLklEQktleVJhbmdlXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHZhciBhZGRvbnMgPSBvcHRpb25zLmFkZG9ucztcblx0ICAgICAgICAgICAgdGhpcy5fZGJTY2hlbWEgPSB7fTtcblx0ICAgICAgICAgICAgdGhpcy5fdmVyc2lvbnMgPSBbXTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcmVOYW1lcyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxUYWJsZXMgPSB7fTtcblx0ICAgICAgICAgICAgdGhpcy5pZGJkYiA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX25vdmlwID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xuXHQgICAgICAgICAgICAgICAgZGJPcGVuRXJyb3I6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgb3BlbkNvbXBsZXRlOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG5cdCAgICAgICAgICAgICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGNhbmNlbE9wZW46IG5vcCxcblx0ICAgICAgICAgICAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgUFIxMzk4X21heExvb3A6IDMsXG5cdCAgICAgICAgICAgICAgICBhdXRvT3Blbjogb3B0aW9ucy5hdXRvT3Blbixcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcInBvcHVsYXRlXCIsIFwiYmxvY2tlZFwiLCBcInZlcnNpb25jaGFuZ2VcIiwgXCJjbG9zZVwiLCB7IHJlYWR5OiBbcHJvbWlzYWJsZUNoYWluLCBub3BdIH0pO1xuXHQgICAgICAgICAgICB0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSA9IG92ZXJyaWRlKHRoaXMub24ucmVhZHkuc3Vic2NyaWJlLCBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIsIGJTdGlja3kpIHtcblx0ICAgICAgICAgICAgICAgICAgICBEZXhpZS52aXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuQ29tcGxldGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKHN1YnNjcmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiXzEgPSBfdGhpcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYlN0aWNreSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiXzEub24ucmVhZHkudW5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiXzEub24ucmVhZHkudW5zdWJzY3JpYmUodW5zdWJzY3JpYmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5Db2xsZWN0aW9uID0gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLlRhYmxlID0gY3JlYXRlVGFibGVDb25zdHJ1Y3Rvcih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuVmVyc2lvbiA9IGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3Rvcih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5XaGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uIChldikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2Lm5ld1ZlcnNpb24gPiAwKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byB1cGdyYWRlIGRhdGFiYXNlICdcIi5jb25jYXQoX3RoaXMubmFtZSwgXCInLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIHVwZ3JhZGUuXCIpKTtcblx0ICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gZGVsZXRlIGRhdGFiYXNlICdcIi5jb25jYXQoX3RoaXMubmFtZSwgXCInLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIGRlbGV0ZSByZXF1ZXN0LlwiKSk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSh7IGRpc2FibGVBdXRvT3BlbjogZmFsc2UgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLm9uKFwiYmxvY2tlZFwiLCBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghZXYubmV3VmVyc2lvbiB8fCBldi5uZXdWZXJzaW9uIDwgZXYub2xkVmVyc2lvbilcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXhpZS5kZWxldGUoJ1wiLmNvbmNhdChfdGhpcy5uYW1lLCBcIicpIHdhcyBibG9ja2VkXCIpKTtcblx0ICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVcGdyYWRlICdcIi5jb25jYXQoX3RoaXMubmFtZSwgXCInIGJsb2NrZWQgYnkgb3RoZXIgY29ubmVjdGlvbiBob2xkaW5nIHZlcnNpb24gXCIpLmNvbmNhdChldi5vbGRWZXJzaW9uIC8gMTApKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX21heEtleSA9IGdldE1heEtleShvcHRpb25zLklEQktleVJhbmdlKTtcblx0ICAgICAgICAgICAgdGhpcy5fY3JlYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAobW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKSB7IHJldHVybiBuZXcgX3RoaXMuVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIF90aGlzLl9vcHRpb25zLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50VHJhbnNhY3Rpb24pOyB9O1xuXHQgICAgICAgICAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5vbihcImJsb2NrZWRcIikuZmlyZShldik7XG5cdCAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1xuXHQgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubmFtZSA9PT0gX3RoaXMubmFtZSAmJiBjICE9PSBfdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZDsgfSlcblx0ICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTsgfSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcblx0ICAgICAgICAgICAgdGhpcy51c2UoY2FjaGVNaWRkbGV3YXJlKTtcblx0ICAgICAgICAgICAgdGhpcy51c2Uob2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUpO1xuXHQgICAgICAgICAgICB0aGlzLnVzZSh2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlKTtcblx0ICAgICAgICAgICAgdGhpcy51c2UoaG9va3NNaWRkbGV3YXJlKTtcblx0ICAgICAgICAgICAgdmFyIHZpcERCID0gbmV3IFByb3h5KHRoaXMsIHtcblx0ICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKF8sIHByb3AsIHJlY2VpdmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfdmlwJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0YWJsZScpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFibGVOYW1lKSB7IHJldHVybiB2aXBpZnkoX3RoaXMudGFibGUodGFibGVOYW1lKSwgdmlwREIpOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IFJlZmxlY3QuZ2V0KF8sIHByb3AsIHJlY2VpdmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocnYgaW5zdGFuY2VvZiBUYWJsZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpcGlmeShydiwgdmlwREIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAndGFibGVzJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ2Lm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdmlwaWZ5KHQsIHZpcERCKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfY3JlYXRlVHJhbnNhY3Rpb24nKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gcnYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXBpZnkodHgsIHZpcERCKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLnZpcCA9IHZpcERCO1xuXHQgICAgICAgICAgICBhZGRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWRkb24pIHsgcmV0dXJuIGFkZG9uKF90aGlzKTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIERleGllLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb25OdW1iZXIpIHtcblx0ICAgICAgICAgICAgaWYgKGlzTmFOKHZlcnNpb25OdW1iZXIpIHx8IHZlcnNpb25OdW1iZXIgPCAwLjEpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UeXBlKFwiR2l2ZW4gdmVyc2lvbiBpcyBub3QgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG5cdCAgICAgICAgICAgIHZlcnNpb25OdW1iZXIgPSBNYXRoLnJvdW5kKHZlcnNpb25OdW1iZXIgKiAxMCkgLyAxMDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaWRiZGIgfHwgdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZClcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkNhbm5vdCBhZGQgdmVyc2lvbiB3aGVuIGRhdGFiYXNlIGlzIG9wZW5cIik7XG5cdCAgICAgICAgICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcblx0ICAgICAgICAgICAgdmFyIHZlcnNpb25zID0gdGhpcy5fdmVyc2lvbnM7XG5cdCAgICAgICAgICAgIHZhciB2ZXJzaW9uSW5zdGFuY2UgPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuX2NmZy52ZXJzaW9uID09PSB2ZXJzaW9uTnVtYmVyOyB9KVswXTtcblx0ICAgICAgICAgICAgaWYgKHZlcnNpb25JbnN0YW5jZSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG5cdCAgICAgICAgICAgIHZlcnNpb25JbnN0YW5jZSA9IG5ldyB0aGlzLlZlcnNpb24odmVyc2lvbk51bWJlcik7XG5cdCAgICAgICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbkluc3RhbmNlKTtcblx0ICAgICAgICAgICAgdmVyc2lvbnMuc29ydChsb3dlclZlcnNpb25GaXJzdCk7XG5cdCAgICAgICAgICAgIHZlcnNpb25JbnN0YW5jZS5zdG9yZXMoe30pO1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuX3doZW5SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMuaWRiZGIgJiYgKHRoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSB8fCBQU0QubGV0VGhyb3VnaCB8fCB0aGlzLl92aXApKSA/IGZuKCkgOiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChfdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9zdGF0ZS5hdXRvT3Blbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMub3BlbigpLmNhdGNoKG5vcCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICB9KS50aGVuKGZuKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gX2Euc3RhY2ssIGNyZWF0ZSA9IF9hLmNyZWF0ZSwgbGV2ZWwgPSBfYS5sZXZlbCwgbmFtZSA9IF9hLm5hbWU7XG5cdCAgICAgICAgICAgIGlmIChuYW1lKVxuXHQgICAgICAgICAgICAgICAgdGhpcy51bnVzZSh7IHN0YWNrOiBzdGFjaywgbmFtZTogbmFtZSB9KTtcblx0ICAgICAgICAgICAgdmFyIG1pZGRsZXdhcmVzID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdIHx8ICh0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSBbXSk7XG5cdCAgICAgICAgICAgIG1pZGRsZXdhcmVzLnB1c2goeyBzdGFjazogc3RhY2ssIGNyZWF0ZTogY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWU6IG5hbWUgfSk7XG5cdCAgICAgICAgICAgIG1pZGRsZXdhcmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubGV2ZWwgLSBiLmxldmVsOyB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUudW51c2UgPSBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gX2Euc3RhY2ssIG5hbWUgPSBfYS5uYW1lLCBjcmVhdGUgPSBfYS5jcmVhdGU7XG5cdCAgICAgICAgICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXS5maWx0ZXIoZnVuY3Rpb24gKG13KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSA/IG13LmNyZWF0ZSAhPT0gY3JlYXRlIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gdXNlUFNEKGdsb2JhbFBTRCxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGV4aWVPcGVuKF90aGlzKTsgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG5cdCAgICAgICAgICAgIGlmIChpZHggPj0gMClcblx0ICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pZGJkYikge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlkYmRiLmNsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlkYmRiID0gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIXN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7IGRpc2FibGVBdXRvT3BlbjogdHJ1ZSB9IDogX2EsIGRpc2FibGVBdXRvT3BlbiA9IF9iLmRpc2FibGVBdXRvT3Blbjtcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIGlmIChkaXNhYmxlQXV0b09wZW4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5hdXRvT3BlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmF1dG9PcGVuID0gdGhpcy5fb3B0aW9ucy5hdXRvT3BlbiB8fFxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQ7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChjbG9zZU9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKGNsb3NlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNsb3NlT3B0aW9ucyA9IHsgZGlzYWJsZUF1dG9PcGVuOiB0cnVlIH07IH1cblx0ICAgICAgICAgICAgdmFyIGhhc0ludmFsaWRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0Jztcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkb0RlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZShjbG9zZU9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBfdGhpcy5fZGVwcy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoX3RoaXMubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQoX3RoaXMuX2RlcHMsIF90aGlzLm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXEub25ibG9ja2VkID0gX3RoaXMuX2ZpcmVPbkJsb2NrZWQ7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhc0ludmFsaWRBcmd1bWVudHMpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCBjbG9zZU9wdGlvbnMgYXJndW1lbnQgdG8gZGIuZGVsZXRlKClcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZG9EZWxldGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9EZWxldGUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUuYmFja2VuZERCID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGJkYjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIERleGllLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmhhc0JlZW5DbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuXHQgICAgICAgICAgICByZXR1cm4gZGJPcGVuRXJyb3IgJiYgKGRiT3BlbkVycm9yLm5hbWUgPT09ICdEYXRhYmFzZUNsb3NlZCcpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmhhc0ZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLmR5bmFtaWNhbGx5T3BlbmVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuYXV0b1NjaGVtYTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXhpZS5wcm90b3R5cGUsIFwidGFibGVzXCIsIHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGtleXModGhpcy5fYWxsVGFibGVzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLl9hbGxUYWJsZXNbbmFtZV07IH0pO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgRGV4aWUucHJvdG90eXBlLl90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCB0YWJsZXMsIHNjb3BlRnVuYykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgcGFyZW50VHJhbnNhY3Rpb24gPSBQU0QudHJhbnM7XG5cdCAgICAgICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IHRoaXMgfHwgbW9kZS5pbmRleE9mKCchJykgIT09IC0xKVxuXHQgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgb25seUlmQ29tcGF0aWJsZSA9IG1vZGUuaW5kZXhPZignPycpICE9PSAtMTtcblx0ICAgICAgICAgICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpO1xuXHQgICAgICAgICAgICB2YXIgaWRiTW9kZSwgc3RvcmVOYW1lcztcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMgPSB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIF90aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVOYW1lICE9PSAnc3RyaW5nJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlTmFtZTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyXCIgfHwgbW9kZSA9PT0gUkVBRE9OTFkpXG5cdCAgICAgICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURPTkxZO1xuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInJ3XCIgfHwgbW9kZSA9PSBSRUFEV1JJVEUpXG5cdCAgICAgICAgICAgICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcblx0ICAgICAgICAgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIHRyYW5zYWN0aW9uIG1vZGU6IFwiICsgbW9kZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbm90IGluY2x1ZGVkIGluIHBhcmVudCB0cmFuc2FjdGlvbi5cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSAmJiBwYXJlbnRUcmFuc2FjdGlvbiAmJiAhcGFyZW50VHJhbnNhY3Rpb24uYWN0aXZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRUcmFuc2FjdGlvbiA/XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UobnVsbCwgZnVuY3Rpb24gKF8sIHJlamVjdCkgeyByZWplY3QoZSk7IH0pIDpcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3Rpb24oZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcblx0ICAgICAgICAgICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG5cdCAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShpZGJNb2RlLCBlbnRlclRyYW5zYWN0aW9uLCBcImxvY2tcIikgOlxuXHQgICAgICAgICAgICAgICAgUFNELnRyYW5zID9cblx0ICAgICAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKTsgfSkgOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBEZXhpZS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbiAodGFibGVOYW1lKSB7XG5cdCAgICAgICAgICAgIGlmICghaGFzT3duKHRoaXMuX2FsbFRhYmxlcywgdGFibGVOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZFRhYmxlKFwiVGFibGUgXCIuY29uY2F0KHRhYmxlTmFtZSwgXCIgZG9lcyBub3QgZXhpc3RcIikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxUYWJsZXNbdGFibGVOYW1lXTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBEZXhpZTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIHZhciBzeW1ib2xPYnNlcnZhYmxlID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm9ic2VydmFibGVcIiBpbiBTeW1ib2xcblx0ICAgICAgICA/IFN5bWJvbC5vYnNlcnZhYmxlXG5cdCAgICAgICAgOiBcIkBAb2JzZXJ2YWJsZVwiO1xuXHQgICAgdmFyIE9ic2VydmFibGUgPSAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh4LCBlcnJvciwgY29tcGxldGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZSgheCB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geyBuZXh0OiB4LCBlcnJvcjogZXJyb3IsIGNvbXBsZXRlOiBjb21wbGV0ZSB9IDogeCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIHZhciBkb21EZXBzO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBkb21EZXBzID0ge1xuXHQgICAgICAgICAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG5cdCAgICAgICAgICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2Vcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICBkb21EZXBzID0geyBpbmRleGVkREI6IG51bGwsIElEQktleVJhbmdlOiBudWxsIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGxpdmVRdWVyeShxdWVyaWVyKSB7XG5cdCAgICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZTtcblx0ICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuXHQgICAgICAgICAgICB2YXIgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihxdWVyaWVyKTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShjdHgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gbmV3U2NvcGUocXVlcmllciwgY3R4KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydiA9IHJ2LmZpbmFsbHkoZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgICAgICB3YXNSb290RXhlYyAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjbG9zZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGFib3J0Q29udHJvbGxlcjtcblx0ICAgICAgICAgICAgdmFyIGFjY3VtTXV0cyA9IHt9O1xuXHQgICAgICAgICAgICB2YXIgY3VycmVudE9icyA9IHt9O1xuXHQgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VkO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ZWRMaXN0ZW5pbmcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC51bnN1YnNjcmliZShtdXRhdGlvbkxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIG9ic2VydmVyLnN0YXJ0ICYmIG9ic2VydmVyLnN0YXJ0KHN1YnNjcmlwdGlvbik7XG5cdCAgICAgICAgICAgIHZhciBzdGFydGVkTGlzdGVuaW5nID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBkb1F1ZXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhlY0luR2xvYmFsQ29udGV4dChfZG9RdWVyeSk7IH07XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvYnNTZXRzT3ZlcmxhcChjdXJyZW50T2JzLCBhY2N1bU11dHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBtdXRhdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKHBhcnRzKSB7XG5cdCAgICAgICAgICAgICAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KGFjY3VtTXV0cywgcGFydHMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9RdWVyeSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgX2RvUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2xvc2VkIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgIWRvbURlcHMuaW5kZXhlZERCKVxuXHQgICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJzY3IgPSB7fTtcblx0ICAgICAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpXG5cdCAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG5cdCAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3R4ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnNjcjogc3Vic2NyLFxuXHQgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcblx0ICAgICAgICAgICAgICAgICAgICByZXF1ZXJ5OiBkb1F1ZXJ5LFxuXHQgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXI6IHF1ZXJpZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnM6IG51bGxcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZXhlY3V0ZShjdHgpO1xuXHQgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkIHx8IGN0eC5zaWduYWwuYWJvcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPYnMgPSBzdWJzY3I7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJc0VtcHR5KGN1cnJlbnRPYnMpICYmICFzdGFydGVkTGlzdGVuaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgbXV0YXRpb25MaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBleGVjSW5HbG9iYWxDb250ZXh0KGZ1bmN0aW9uICgpIHsgcmV0dXJuICFjbG9zZWQgJiYgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHJlc3VsdCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFbJ0RhdGFiYXNlQ2xvc2VkRXJyb3InLCAnQWJvcnRFcnJvciddLmluY2x1ZGVzKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNJbkdsb2JhbENvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQoZG9RdWVyeSwgMCk7XG5cdCAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc1ZhbHVlOyB9O1xuXHQgICAgICAgIG9ic2VydmFibGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50VmFsdWU7IH07XG5cdCAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBEZXhpZSA9IERleGllJDE7XG5cdCAgICBwcm9wcyhEZXhpZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGZ1bGxOYW1lRXhjZXB0aW9ucyksIHtcblx0ICAgICAgICBkZWxldGU6IGZ1bmN0aW9uIChkYXRhYmFzZU5hbWUpIHtcblx0ICAgICAgICAgICAgdmFyIGRiID0gbmV3IERleGllKGRhdGFiYXNlTmFtZSwgeyBhZGRvbnM6IFtdIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gZGIuZGVsZXRlKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBleGlzdHM6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWUobmFtZSwgeyBhZGRvbnM6IFtdIH0pLm9wZW4oKS50aGVuKGZ1bmN0aW9uIChkYikge1xuXHQgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9KS5jYXRjaCgnTm9TdWNoRGF0YWJhc2VFcnJvcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldERhdGFiYXNlTmFtZXM6IGZ1bmN0aW9uIChjYikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFiYXNlTmFtZXMoRGV4aWUuZGVwZW5kZW5jaWVzKS50aGVuKGNiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZGVmaW5lQ2xhc3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gQ2xhc3MoY29udGVudCkge1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBDbGFzcztcblx0ICAgICAgICB9LCBpZ25vcmVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHNjb3BlRnVuYykge1xuXHQgICAgICAgICAgICByZXR1cm4gUFNELnRyYW5zID9cblx0ICAgICAgICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDpcblx0ICAgICAgICAgICAgICAgIHNjb3BlRnVuYygpO1xuXHQgICAgICAgIH0sIHZpcDogdmlwLCBhc3luYzogZnVuY3Rpb24gKGdlbmVyYXRvckZuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHJ2KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSwgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGl6LCBhcmdzIHx8IFtdKSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGN1cnJlbnRUcmFuc2FjdGlvbjoge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBTRC50cmFucyB8fCBudWxsOyB9XG5cdCAgICAgICAgfSwgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcblx0ICAgICAgICAgICAgdmFyIHByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZSh0eXBlb2YgcHJvbWlzZU9yRnVuY3Rpb24gPT09ICdmdW5jdGlvbicgP1xuXHQgICAgICAgICAgICAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDpcblx0ICAgICAgICAgICAgICAgIHByb21pc2VPckZ1bmN0aW9uKVxuXHQgICAgICAgICAgICAgICAgLnRpbWVvdXQob3B0aW9uYWxUaW1lb3V0IHx8IDYwMDAwKTtcblx0ICAgICAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG5cdCAgICAgICAgICAgICAgICBQU0QudHJhbnMud2FpdEZvcihwcm9taXNlKSA6XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuXHQgICAgICAgIGRlYnVnOiB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVidWc7IH0sXG5cdCAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBzZXREZWJ1Zyh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGRlcml2ZTogZGVyaXZlLCBleHRlbmQ6IGV4dGVuZCwgcHJvcHM6IHByb3BzLCBvdmVycmlkZTogb3ZlcnJpZGUsXG5cdCAgICAgICAgRXZlbnRzOiBFdmVudHMsIG9uOiBnbG9iYWxFdmVudHMsIGxpdmVRdWVyeTogbGl2ZVF1ZXJ5LCBleHRlbmRPYnNlcnZhYmlsaXR5U2V0OiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0LFxuXHQgICAgICAgIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCwgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLCBkZWVwQ2xvbmU6IGRlZXBDbG9uZSwgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZiwgY21wOiBjbXAsIGFzYXA6IGFzYXAkMSxcblx0ICAgICAgICBtaW5LZXk6IG1pbktleSxcblx0ICAgICAgICBhZGRvbnM6IFtdLFxuXHQgICAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9ucyxcblx0ICAgICAgICBlcnJuYW1lczogZXJybmFtZXMsXG5cdCAgICAgICAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLCBjYWNoZTogY2FjaGUsXG5cdCAgICAgICAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLCB2ZXJzaW9uOiBERVhJRV9WRVJTSU9OLnNwbGl0KCcuJylcblx0ICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gcGFyc2VJbnQobik7IH0pXG5cdCAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMsIGkpIHsgcmV0dXJuIHAgKyAoYyAvIE1hdGgucG93KDEwLCBpICogMikpOyB9KSB9KSk7XG5cdCAgICBEZXhpZS5tYXhLZXkgPSBnZXRNYXhLZXkoRGV4aWUuZGVwZW5kZW5jaWVzLklEQktleVJhbmdlKTtcblxuXHQgICAgaWYgKHR5cGVvZiBkaXNwYXRjaEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIGZ1bmN0aW9uICh1cGRhdGVkUGFydHMpIHtcblx0ICAgICAgICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVudF8xO1xuXHQgICAgICAgICAgICAgICAgZXZlbnRfMSA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHVwZGF0ZWRQYXJ0c1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudF8xKTtcblx0ICAgICAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICB2YXIgZGV0YWlsID0gX2EuZGV0YWlsO1xuXHQgICAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuXHQgICAgICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkZXRhaWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzKSB7XG5cdCAgICAgICAgdmFyIHdhc01lID0gcHJvcGFnYXRpbmdMb2NhbGx5O1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG5cdCAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcblx0ICAgICAgICAgICAgc2lnbmFsU3Vic2NyaWJlcnNOb3codXBkYXRlUGFydHMsIHRydWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gd2FzTWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuXG5cdCAgICB2YXIgYmM7XG5cdCAgICB2YXIgY3JlYXRlQkMgPSBmdW5jdGlvbiAoKSB7IH07XG5cdCAgICBpZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgY3JlYXRlQkMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcblx0ICAgICAgICAgICAgYmMub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7IHJldHVybiBldi5kYXRhICYmIHByb3BhZ2F0ZUxvY2FsbHkoZXYuZGF0YSk7IH07XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBjcmVhdGVCQygpO1xuXHQgICAgICAgIGlmICh0eXBlb2YgYmMudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgYmMudW5yZWYoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBmdW5jdGlvbiAoY2hhbmdlZFBhcnRzKSB7XG5cdCAgICAgICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG5cdCAgICAgICAgICAgICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoIURleGllJDEuZGlzYWJsZUJmQ2FjaGUgJiYgZXZlbnQucGVyc2lzdGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnRGV4aWU6IGhhbmRsaW5nIHBlcnNpc3RlZCBwYWdlaGlkZScpO1xuXHQgICAgICAgICAgICAgICAgYmMgPT09IG51bGwgfHwgYmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJjLmNsb3NlKCk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbm5lY3Rpb25zXzEgPSBjb25uZWN0aW9uczsgX2kgPCBjb25uZWN0aW9uc18xLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IGNvbm5lY3Rpb25zXzFbX2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKHsgZGlzYWJsZUF1dG9PcGVuOiBmYWxzZSB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmICghRGV4aWUkMS5kaXNhYmxlQmZDYWNoZSAmJiBldmVudC5wZXJzaXN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkZWJ1Zylcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdEZXhpZTogaGFuZGxpbmcgcGVyc2lzdGVkIHBhZ2VzaG93Jyk7XG5cdCAgICAgICAgICAgICAgICBjcmVhdGVCQygpO1xuXHQgICAgICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseSh7IGFsbDogbmV3IFJhbmdlU2V0KC1JbmZpbml0eSwgW1tdXSkgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgYWRkOiB2YWx1ZSB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVtb3ZlKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgcmVtb3ZlOiB2YWx1ZSB9KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVwbGFjZVByZWZpeChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wTW9kaWZpY2F0aW9uKHsgcmVwbGFjZVByZWZpeDogW2EsIGJdIH0pO1xuXHQgICAgfVxuXG5cdCAgICBEZXhpZVByb21pc2UucmVqZWN0aW9uTWFwcGVyID0gbWFwRXJyb3I7XG5cdCAgICBzZXREZWJ1ZyhkZWJ1Zyk7XG5cblx0ICAgIHZhciBuYW1lZEV4cG9ydHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdCAgICAgICAgX19wcm90b19fOiBudWxsLFxuXHQgICAgICAgIERleGllOiBEZXhpZSQxLFxuXHQgICAgICAgIGxpdmVRdWVyeTogbGl2ZVF1ZXJ5LFxuXHQgICAgICAgIEVudGl0eTogRW50aXR5LFxuXHQgICAgICAgIGNtcDogY21wLFxuXHQgICAgICAgIFByb3BNb2RTeW1ib2w6IFByb3BNb2RTeW1ib2wsXG5cdCAgICAgICAgUHJvcE1vZGlmaWNhdGlvbjogUHJvcE1vZGlmaWNhdGlvbixcblx0ICAgICAgICByZXBsYWNlUHJlZml4OiByZXBsYWNlUHJlZml4LFxuXHQgICAgICAgIGFkZDogYWRkLFxuXHQgICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuXHQgICAgICAgICdkZWZhdWx0JzogRGV4aWUkMSxcblx0ICAgICAgICBSYW5nZVNldDogUmFuZ2VTZXQsXG5cdCAgICAgICAgbWVyZ2VSYW5nZXM6IG1lcmdlUmFuZ2VzLFxuXHQgICAgICAgIHJhbmdlc092ZXJsYXA6IHJhbmdlc092ZXJsYXBcblx0ICAgIH0pO1xuXG5cdCAgICBfX2Fzc2lnbihEZXhpZSQxLCBuYW1lZEV4cG9ydHMsIHsgZGVmYXVsdDogRGV4aWUkMSB9KTtcblxuXHQgICAgcmV0dXJuIERleGllJDE7XG5cblx0fSkpO1xuXHRcbn0gKGRleGllKSk7XG5cbnZhciBkZXhpZUV4cG9ydHMgPSBkZXhpZS5leHBvcnRzO1xudmFyIF9EZXhpZSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhkZXhpZUV4cG9ydHMpO1xuXG4vLyBNYWtpbmcgdGhlIG1vZHVsZSB2ZXJzaW9uIGNvbnN1bWFibGUgdmlhIHJlcXVpcmUgLSB0byBwcm9oaWJpdFxuLy8gbXVsdGlwbGUgb2NjdXJyYW5jaWVzIG9mIHRoZSBzYW1lIG1vZHVsZSBpbiB0aGUgc2FtZSBhcHBcbi8vIChkdWFsIHBhY2thZ2UgaGF6YXJkLCBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjZHVhbC1wYWNrYWdlLWhhemFyZClcbmNvbnN0IERleGllU3ltYm9sID0gU3ltYm9sLmZvcihcIkRleGllXCIpO1xuY29uc3QgRGV4aWUgPSBnbG9iYWxUaGlzW0RleGllU3ltYm9sXSB8fCAoZ2xvYmFsVGhpc1tEZXhpZVN5bWJvbF0gPSBfRGV4aWUpO1xuaWYgKF9EZXhpZS5zZW1WZXIgIT09IERleGllLnNlbVZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHdvIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBEZXhpZSBsb2FkZWQgaW4gdGhlIHNhbWUgYXBwOiAke19EZXhpZS5zZW1WZXJ9IGFuZCAke0RleGllLnNlbVZlcn1gKTtcbn1cblxuLy8gSGVscGVyIGZvciB1bmRlZmluZWQgdmFsdWVzLCBsaWtlIG1hcCBmb3IgT3B0aW9uPFQ+IGluIFJ1c3QuXG4vLyBBIGJldHRlciBuYW1lIGZvciB0aGlzIGlzIHdlbGNvbWUuXG5jb25zdCBtYXBPcHRpb24gPSAodmFsdWUsIGZ1bmMpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgIT0gdW5kZWZpbmVkID8gZnVuYyh2YWx1ZSkgOiB1bmRlZmluZWQ7XG59O1xuLy8gQW55dGhpbmcgY2FuIGJlIHRocm93biBhcyBhbiBlcnJvciBpbiByYXcgSlMgKGFsc28gdGhlIFRTIGNvbXBpbGVyIGNhbid0IHR5cGUtY2hlY2sgZXhjZXB0aW9ucyksXG4vLyBzbyB3ZSBhbGxvdyBpdCBoZXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxvZ1dlYlN0b3JlRXJyb3IgPSAoZXJyb3IsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERleGllLkRleGllRXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnJvckNvbnRleHR9OiBJbmRleGRiIGVycm9yICgke2Vycm9yLm5hbWV9KTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW5kZXhkYiBlcnJvcjogKCR7ZXJyb3IubmFtZX0pOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFwT3B0aW9uKGVycm9yLnN0YWNrLCAoc3RhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YWNrdHJhY2U6IFxcbiAke3N0YWNrfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFwT3B0aW9uKGVycm9yLmlubmVyLCAoaW5uZXJFeGNlcHRpb24pID0+IGxvZ1dlYlN0b3JlRXJyb3IoaW5uZXJFeGNlcHRpb24pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBVbmV4cGVjdGVkIGVycm9yIHdoaWxlIGFjY2Vzc2luZyBpbmRleGRiOiAke2Vycm9yLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIG1hcE9wdGlvbihlcnJvci5zdGFjaywgKHN0YWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdGFja3RyYWNlOiAke3N0YWNrfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEdvdCBhbiBleGNlcHRpb24gd2l0aCBhIG5vbi1lcnJvciB2YWx1ZSwgYXMgSlNPTjogXFxuICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfS4gQXMgU3RyaW5nIFxcbiAke1N0cmluZyhlcnJvcil9IGApO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xufTtcbmNvbnN0IHVpbnQ4QXJyYXlUb0Jhc2U2NCA9IChieXRlcykgPT4ge1xuICAgIGNvbnN0IGJpbmFyeSA9IGJ5dGVzLnJlZHVjZSgoYWNjLCBieXRlKSA9PiBhY2MgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpLCBcIlwiKTtcbiAgICByZXR1cm4gYnRvYShiaW5hcnkpO1xufTtcblxuY29uc3QgREFUQUJBU0VfTkFNRSA9IFwiTWlkZW5DbGllbnREQlwiO1xuYXN5bmMgZnVuY3Rpb24gb3BlbkRhdGFiYXNlKCkge1xuICAgIGNvbnNvbGUubG9nKFwiT3BlbmluZyBkYXRhYmFzZS4uLlwiKTtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBkYi5vcGVuKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGF0YWJhc2Ugb3BlbmVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIG9wZW4gZGF0YWJhc2VcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG52YXIgVGFibGU7XG4oZnVuY3Rpb24gKFRhYmxlKSB7XG4gICAgVGFibGVbXCJBY2NvdW50Q29kZVwiXSA9IFwiYWNjb3VudENvZGVcIjtcbiAgICBUYWJsZVtcIkFjY291bnRTdG9yYWdlXCJdID0gXCJhY2NvdW50U3RvcmFnZVwiO1xuICAgIFRhYmxlW1wiQWNjb3VudEFzc2V0c1wiXSA9IFwiYWNjb3VudEFzc2V0c1wiO1xuICAgIFRhYmxlW1wiU3RvcmFnZU1hcEVudHJpZXNcIl0gPSBcInN0b3JhZ2VNYXBFbnRyaWVzXCI7XG4gICAgVGFibGVbXCJBY2NvdW50QXV0aFwiXSA9IFwiYWNjb3VudEF1dGhcIjtcbiAgICBUYWJsZVtcIkFjY291bnRzXCJdID0gXCJhY2NvdW50c1wiO1xuICAgIFRhYmxlW1wiQWRkcmVzc2VzXCJdID0gXCJhZGRyZXNzZXNcIjtcbiAgICBUYWJsZVtcIlRyYW5zYWN0aW9uc1wiXSA9IFwidHJhbnNhY3Rpb25zXCI7XG4gICAgVGFibGVbXCJUcmFuc2FjdGlvblNjcmlwdHNcIl0gPSBcInRyYW5zYWN0aW9uU2NyaXB0c1wiO1xuICAgIFRhYmxlW1wiSW5wdXROb3Rlc1wiXSA9IFwiaW5wdXROb3Rlc1wiO1xuICAgIFRhYmxlW1wiT3V0cHV0Tm90ZXNcIl0gPSBcIm91dHB1dE5vdGVzXCI7XG4gICAgVGFibGVbXCJOb3Rlc1NjcmlwdHNcIl0gPSBcIm5vdGVzU2NyaXB0c1wiO1xuICAgIFRhYmxlW1wiU3RhdGVTeW5jXCJdID0gXCJzdGF0ZVN5bmNcIjtcbiAgICBUYWJsZVtcIkJsb2NrSGVhZGVyc1wiXSA9IFwiYmxvY2tIZWFkZXJzXCI7XG4gICAgVGFibGVbXCJQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzXCJdID0gXCJwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzXCI7XG4gICAgVGFibGVbXCJUYWdzXCJdID0gXCJ0YWdzXCI7XG4gICAgVGFibGVbXCJGb3JlaWduQWNjb3VudENvZGVcIl0gPSBcImZvcmVpZ25BY2NvdW50Q29kZVwiO1xuICAgIFRhYmxlW1wiU2V0dGluZ3NcIl0gPSBcInNldHRpbmdzXCI7XG4gICAgVGFibGVbXCJUcmFja2VkQWNjb3VudHNcIl0gPSBcInRyYWNrZWRBY2NvdW50c1wiO1xufSkoVGFibGUgfHwgKFRhYmxlID0ge30pKTtcbmNvbnN0IGRiID0gbmV3IERleGllKERBVEFCQVNFX05BTUUpO1xuZGIudmVyc2lvbigxKS5zdG9yZXMoe1xuICAgIFtUYWJsZS5BY2NvdW50Q29kZV06IGluZGV4ZXMoXCJyb290XCIpLFxuICAgIFtUYWJsZS5BY2NvdW50U3RvcmFnZV06IGluZGV4ZXMoXCJbY29tbWl0bWVudCtzbG90SW5kZXhdXCIsIFwiY29tbWl0bWVudFwiKSxcbiAgICBbVGFibGUuU3RvcmFnZU1hcEVudHJpZXNdOiBpbmRleGVzKFwiW3Jvb3Qra2V5XVwiLCBcInJvb3RcIiksXG4gICAgW1RhYmxlLkFjY291bnRBc3NldHNdOiBpbmRleGVzKFwiW3Jvb3QrdmF1bHRLZXldXCIsIFwicm9vdFwiLCBcImZhdWNldElkUHJlZml4XCIpLFxuICAgIFtUYWJsZS5BY2NvdW50QXV0aF06IGluZGV4ZXMoXCJwdWJLZXlcIiksXG4gICAgW1RhYmxlLkFjY291bnRzXTogaW5kZXhlcyhcIiZhY2NvdW50Q29tbWl0bWVudFwiLCBcImlkXCIsIFwiW2lkK25vbmNlXVwiLCBcImNvZGVSb290XCIsIFwic3RvcmFnZVJvb3RcIiwgXCJ2YXVsdFJvb3RcIiksXG4gICAgW1RhYmxlLkFkZHJlc3Nlc106IGluZGV4ZXMoXCJhZGRyZXNzXCIsIFwiaWRcIiksXG4gICAgW1RhYmxlLlRyYW5zYWN0aW9uc106IGluZGV4ZXMoXCJpZFwiLCBcInN0YXR1c1ZhcmlhbnRcIiksXG4gICAgW1RhYmxlLlRyYW5zYWN0aW9uU2NyaXB0c106IGluZGV4ZXMoXCJzY3JpcHRSb290XCIpLFxuICAgIFtUYWJsZS5JbnB1dE5vdGVzXTogaW5kZXhlcyhcIm5vdGVJZFwiLCBcIm51bGxpZmllclwiLCBcInN0YXRlRGlzY3JpbWluYW50XCIpLFxuICAgIFtUYWJsZS5PdXRwdXROb3Rlc106IGluZGV4ZXMoXCJub3RlSWRcIiwgXCJyZWNpcGllbnREaWdlc3RcIiwgXCJzdGF0ZURpc2NyaW1pbmFudFwiLCBcIm51bGxpZmllclwiKSxcbiAgICBbVGFibGUuTm90ZXNTY3JpcHRzXTogaW5kZXhlcyhcInNjcmlwdFJvb3RcIiksXG4gICAgW1RhYmxlLlN0YXRlU3luY106IGluZGV4ZXMoXCJpZFwiKSxcbiAgICBbVGFibGUuQmxvY2tIZWFkZXJzXTogaW5kZXhlcyhcImJsb2NrTnVtXCIsIFwiaGFzQ2xpZW50Tm90ZXNcIiksXG4gICAgW1RhYmxlLlBhcnRpYWxCbG9ja2NoYWluTm9kZXNdOiBpbmRleGVzKFwiaWRcIiksXG4gICAgW1RhYmxlLlRhZ3NdOiBpbmRleGVzKFwiaWQrK1wiLCBcInRhZ1wiLCBcInNvdXJjZV9ub3RlX2lkXCIsIFwic291cmNlX2FjY291bnRfaWRcIiksXG4gICAgW1RhYmxlLkZvcmVpZ25BY2NvdW50Q29kZV06IGluZGV4ZXMoXCJhY2NvdW50SWRcIiksXG4gICAgW1RhYmxlLlNldHRpbmdzXTogaW5kZXhlcyhcImtleVwiKSxcbiAgICBbVGFibGUuVHJhY2tlZEFjY291bnRzXTogaW5kZXhlcyhcIiZpZFwiKSxcbn0pO1xuZnVuY3Rpb24gaW5kZXhlcyguLi5pdGVtcykge1xuICAgIHJldHVybiBpdGVtcy5qb2luKFwiLFwiKTtcbn1cbmRiLm9uKFwicG9wdWxhdGVcIiwgKCkgPT4ge1xuICAgIC8vIFBvcHVsYXRlIHRoZSBzdGF0ZVN5bmMgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIHN0YXRlU3luY1xuICAgICAgICAucHV0KHsgaWQ6IDEsIGJsb2NrTnVtOiBcIjBcIiB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIHBvcHVsYXRlIERCXCIpKTtcbn0pO1xuY29uc3QgYWNjb3VudENvZGVzID0gZGIudGFibGUoVGFibGUuQWNjb3VudENvZGUpO1xuY29uc3QgYWNjb3VudFN0b3JhZ2VzID0gZGIudGFibGUoVGFibGUuQWNjb3VudFN0b3JhZ2UpO1xuY29uc3Qgc3RvcmFnZU1hcEVudHJpZXMgPSBkYi50YWJsZShUYWJsZS5TdG9yYWdlTWFwRW50cmllcyk7XG5jb25zdCBhY2NvdW50QXNzZXRzID0gZGIudGFibGUoVGFibGUuQWNjb3VudEFzc2V0cyk7XG5jb25zdCBhY2NvdW50QXV0aHMgPSBkYi50YWJsZShUYWJsZS5BY2NvdW50QXV0aCk7XG5jb25zdCBhY2NvdW50cyA9IGRiLnRhYmxlKFRhYmxlLkFjY291bnRzKTtcbmNvbnN0IGFkZHJlc3NlcyA9IGRiLnRhYmxlKFRhYmxlLkFkZHJlc3Nlcyk7XG5jb25zdCB0cmFuc2FjdGlvbnMgPSBkYi50YWJsZShUYWJsZS5UcmFuc2FjdGlvbnMpO1xuY29uc3QgdHJhbnNhY3Rpb25TY3JpcHRzID0gZGIudGFibGUoVGFibGUuVHJhbnNhY3Rpb25TY3JpcHRzKTtcbmNvbnN0IGlucHV0Tm90ZXMgPSBkYi50YWJsZShUYWJsZS5JbnB1dE5vdGVzKTtcbmNvbnN0IG91dHB1dE5vdGVzID0gZGIudGFibGUoVGFibGUuT3V0cHV0Tm90ZXMpO1xuY29uc3Qgbm90ZXNTY3JpcHRzID0gZGIudGFibGUoVGFibGUuTm90ZXNTY3JpcHRzKTtcbmNvbnN0IHN0YXRlU3luYyA9IGRiLnRhYmxlKFRhYmxlLlN0YXRlU3luYyk7XG5jb25zdCBibG9ja0hlYWRlcnMgPSBkYi50YWJsZShUYWJsZS5CbG9ja0hlYWRlcnMpO1xuY29uc3QgcGFydGlhbEJsb2NrY2hhaW5Ob2RlcyA9IGRiLnRhYmxlKFRhYmxlLlBhcnRpYWxCbG9ja2NoYWluTm9kZXMpO1xuY29uc3QgdGFncyA9IGRiLnRhYmxlKFRhYmxlLlRhZ3MpO1xuY29uc3QgZm9yZWlnbkFjY291bnRDb2RlID0gZGIudGFibGUoVGFibGUuRm9yZWlnbkFjY291bnRDb2RlKTtcbmNvbnN0IHNldHRpbmdzID0gZGIudGFibGUoVGFibGUuU2V0dGluZ3MpO1xuY29uc3QgdHJhY2tlZEFjY291bnRzID0gZGIudGFibGUoVGFibGUuVHJhY2tlZEFjY291bnRzKTtcblxuLy8gR0VUIEZVTkNUSU9OU1xuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudElkcygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0cmFja2VkID0gYXdhaXQgdHJhY2tlZEFjY291bnRzLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrZWQubWFwKChlbnRyeSkgPT4gZW50cnkuaWQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJFcnJvciB3aGlsZSBmZXRjaGluZyBhY2NvdW50IElEc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQWNjb3VudEhlYWRlcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVXNlIGEgTWFwIHRvIHRyYWNrIHRoZSBsYXRlc3QgcmVjb3JkIGZvciBlYWNoIGlkIGJhc2VkIG9uIG5vbmNlXG4gICAgICAgIGNvbnN0IGxhdGVzdFJlY29yZHNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGF3YWl0IGFjY291bnRzLmVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZWNvcmQgPSBsYXRlc3RSZWNvcmRzTWFwLmdldChyZWNvcmQuaWQpO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1JlY29yZCB8fFxuICAgICAgICAgICAgICAgIEJpZ0ludChyZWNvcmQubm9uY2UpID4gQmlnSW50KGV4aXN0aW5nUmVjb3JkLm5vbmNlKSkge1xuICAgICAgICAgICAgICAgIGxhdGVzdFJlY29yZHNNYXAuc2V0KHJlY29yZC5pZCwgcmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGxhdGVzdCByZWNvcmRzIGZyb20gdGhlIE1hcFxuICAgICAgICBjb25zdCBsYXRlc3RSZWNvcmRzID0gQXJyYXkuZnJvbShsYXRlc3RSZWNvcmRzTWFwLnZhbHVlcygpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0T2JqZWN0ID0gYXdhaXQgUHJvbWlzZS5hbGwobGF0ZXN0UmVjb3Jkcy5tYXAoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFjY291bnRTZWVkQmFzZTY0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHJlY29yZC5hY2NvdW50U2VlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZWRBc0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmVjb3JkLmFjY291bnRTZWVkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VlZEFzQnl0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50U2VlZEJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChzZWVkQXNCeXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogcmVjb3JkLmlkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiByZWNvcmQubm9uY2UsXG4gICAgICAgICAgICAgICAgdmF1bHRSb290OiByZWNvcmQudmF1bHRSb290LCAvLyBGYWxsYmFjayBpZiBtaXNzaW5nXG4gICAgICAgICAgICAgICAgc3RvcmFnZVJvb3Q6IHJlY29yZC5zdG9yYWdlUm9vdCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGNvZGVSb290OiByZWNvcmQuY29kZVJvb3QgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBhY2NvdW50U2VlZDogYWNjb3VudFNlZWRCYXNlNjQsIC8vIG51bGwgb3IgYmFzZTY0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxvY2tlZDogcmVjb3JkLmxvY2tlZCxcbiAgICAgICAgICAgICAgICBjb21taXR0ZWQ6IHJlY29yZC5jb21taXR0ZWQsIC8vIFVzZSBhY3R1YWwgdmFsdWUgb3IgZGVmYXVsdFxuICAgICAgICAgICAgICAgIGFjY291bnRDb21taXRtZW50OiByZWNvcmQuYWNjb3VudENvbW1pdG1lbnQgfHwgXCJcIiwgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByZXN1bHRPYmplY3Q7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkVycm9yIHdoaWxlIGZldGNoaW5nIGFjY291bnQgaGVhZGVyc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50SGVhZGVyKGFjY291bnRJZCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBhY2NvdW50c1xuICAgICAgICAgICAgLndoZXJlKFwiaWRcIilcbiAgICAgICAgICAgIC5lcXVhbHMoYWNjb3VudElkKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKGFsbE1hdGNoaW5nUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gYWNjb3VudCBoZWFkZXIgcmVjb3JkIGZvdW5kIGZvciBnaXZlbiBJRC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IG5vbmNlIHRvIEJpZ0ludCBhbmQgc29ydFxuICAgICAgICAvLyBOb3RlOiBUaGlzIGFzc3VtZXMgYWxsIG5vbmNlcyBhcmUgdmFsaWQgQmlnSW50IHN0cmluZ3MuXG4gICAgICAgIGNvbnN0IHNvcnRlZFJlY29yZHMgPSBhbGxNYXRjaGluZ1JlY29yZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmlnSW50QSA9IEJpZ0ludChhLm5vbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludEIgPSBCaWdJbnQoYi5ub25jZSk7XG4gICAgICAgICAgICByZXR1cm4gYmlnSW50QSA+IGJpZ0ludEIgPyAtMSA6IGJpZ0ludEEgPCBiaWdJbnRCID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcmVjb3JkIGlzIHRoZSBtb3N0IHJlY2VudCBvbmUgZHVlIHRvIHRoZSBzb3J0aW5nXG4gICAgICAgIGNvbnN0IG1vc3RSZWNlbnRSZWNvcmQgPSBzb3J0ZWRSZWNvcmRzWzBdO1xuICAgICAgICBpZiAobW9zdFJlY2VudFJlY29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWNjb3VudFNlZWRCYXNlNjQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtb3N0UmVjZW50UmVjb3JkLmFjY291bnRTZWVkKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWNjb3VudFNlZWQgaXMgcHJvY2Vzc2VkIGFzIGEgVWludDhBcnJheSBhbmQgY29udmVydGVkIHRvIEJhc2U2NFxuICAgICAgICAgICAgaWYgKG1vc3RSZWNlbnRSZWNvcmQuYWNjb3VudFNlZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFjY291bnRTZWVkQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG1vc3RSZWNlbnRSZWNvcmQuYWNjb3VudFNlZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEFjY291bnRIZWFkZXIgPSB7XG4gICAgICAgICAgICBpZDogbW9zdFJlY2VudFJlY29yZC5pZCxcbiAgICAgICAgICAgIG5vbmNlOiBtb3N0UmVjZW50UmVjb3JkLm5vbmNlLFxuICAgICAgICAgICAgdmF1bHRSb290OiBtb3N0UmVjZW50UmVjb3JkLnZhdWx0Um9vdCxcbiAgICAgICAgICAgIHN0b3JhZ2VSb290OiBtb3N0UmVjZW50UmVjb3JkLnN0b3JhZ2VSb290LFxuICAgICAgICAgICAgY29kZVJvb3Q6IG1vc3RSZWNlbnRSZWNvcmQuY29kZVJvb3QsXG4gICAgICAgICAgICBhY2NvdW50U2VlZDogYWNjb3VudFNlZWRCYXNlNjQsXG4gICAgICAgICAgICBsb2NrZWQ6IG1vc3RSZWNlbnRSZWNvcmQubG9ja2VkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWNjb3VudEhlYWRlcjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciB3aGlsZSBmZXRjaGluZyBhY2NvdW50IGhlYWRlciBmb3IgaWQ6ICR7YWNjb3VudElkfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRIZWFkZXJCeUNvbW1pdG1lbnQoYWNjb3VudENvbW1pdG1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4gY29tbWl0bWVudFxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBhY2NvdW50c1xuICAgICAgICAgICAgLndoZXJlKFwiYWNjb3VudENvbW1pdG1lbnRcIilcbiAgICAgICAgICAgIC5lcXVhbHMoYWNjb3VudENvbW1pdG1lbnQpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICBpZiAoYWxsTWF0Y2hpbmdSZWNvcmRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBtYXRjaFxuICAgICAgICBjb25zdCBtYXRjaGluZ1JlY29yZCA9IGFsbE1hdGNoaW5nUmVjb3Jkc1swXTtcbiAgICAgICAgaWYgKG1hdGNoaW5nUmVjb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gYWNjb3VudCBoZWFkZXIgcmVjb3JkIGZvdW5kIGZvciBnaXZlbiBjb21taXRtZW50LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2NvdW50U2VlZEJhc2U2NCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hdGNoaW5nUmVjb3JkLmFjY291bnRTZWVkKSB7XG4gICAgICAgICAgICBhY2NvdW50U2VlZEJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChtYXRjaGluZ1JlY29yZC5hY2NvdW50U2VlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQWNjb3VudEhlYWRlciA9IHtcbiAgICAgICAgICAgIGlkOiBtYXRjaGluZ1JlY29yZC5pZCxcbiAgICAgICAgICAgIG5vbmNlOiBtYXRjaGluZ1JlY29yZC5ub25jZSxcbiAgICAgICAgICAgIHZhdWx0Um9vdDogbWF0Y2hpbmdSZWNvcmQudmF1bHRSb290LFxuICAgICAgICAgICAgc3RvcmFnZVJvb3Q6IG1hdGNoaW5nUmVjb3JkLnN0b3JhZ2VSb290LFxuICAgICAgICAgICAgY29kZVJvb3Q6IG1hdGNoaW5nUmVjb3JkLmNvZGVSb290LFxuICAgICAgICAgICAgYWNjb3VudFNlZWQ6IGFjY291bnRTZWVkQmFzZTY0LFxuICAgICAgICAgICAgbG9ja2VkOiBtYXRjaGluZ1JlY29yZC5sb2NrZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBY2NvdW50SGVhZGVyO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGZldGNoaW5nIGFjY291bnQgaGVhZGVyIGZvciBjb21taXRtZW50ICR7YWNjb3VudENvbW1pdG1lbnR9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudENvZGUoY29kZVJvb3QpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4gcm9vdFxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBhY2NvdW50Q29kZXNcbiAgICAgICAgICAgIC53aGVyZShcInJvb3RcIilcbiAgICAgICAgICAgIC5lcXVhbHMoY29kZVJvb3QpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcmVjb3JkIGlzIHRoZSBvbmx5IG9uZSBkdWUgdG8gdGhlIHVuaXF1ZW5lc3MgY29uc3RyYWludFxuICAgICAgICBjb25zdCBjb2RlUmVjb3JkID0gYWxsTWF0Y2hpbmdSZWNvcmRzWzBdO1xuICAgICAgICBpZiAoY29kZVJlY29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHJlY29yZHMgZm91bmQgZm9yIGdpdmVuIGNvZGUgcm9vdC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBjb2RlIEJsb2IgdG8gYW4gQXJyYXlCdWZmZXJcbiAgICAgICAgY29uc3QgY29kZUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChjb2RlUmVjb3JkLmNvZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdDogY29kZVJlY29yZC5yb290LFxuICAgICAgICAgICAgY29kZTogY29kZUJhc2U2NCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBmZXRjaGluZyBhY2NvdW50IGNvZGUgZm9yIHJvb3QgJHtjb2RlUm9vdH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50U3RvcmFnZShzdG9yYWdlQ29tbWl0bWVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGFjY291bnRTdG9yYWdlc1xuICAgICAgICAgICAgLndoZXJlKFwiY29tbWl0bWVudFwiKVxuICAgICAgICAgICAgLmVxdWFscyhzdG9yYWdlQ29tbWl0bWVudClcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHNsb3RzID0gYWxsTWF0Y2hpbmdSZWNvcmRzLm1hcCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNsb3RJbmRleDogcmVjb3JkLnNsb3RJbmRleCxcbiAgICAgICAgICAgICAgICBzbG90VmFsdWU6IHJlY29yZC5zbG90VmFsdWUsXG4gICAgICAgICAgICAgICAgc2xvdFR5cGU6IHJlY29yZC5zbG90VHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2xvdHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgZmV0Y2hpbmcgYWNjb3VudCBzdG9yYWdlIGZvciBjb21taXRtZW50ICR7c3RvcmFnZUNvbW1pdG1lbnR9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudFN0b3JhZ2VNYXBzKHJvb3RzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWxsTWF0Y2hpbmdSZWNvcmRzID0gYXdhaXQgc3RvcmFnZU1hcEVudHJpZXNcbiAgICAgICAgICAgIC53aGVyZShcInJvb3RcIilcbiAgICAgICAgICAgIC5hbnlPZihyb290cylcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBhbGxNYXRjaGluZ1JlY29yZHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgZmV0Y2hpbmcgYWNjb3VudCBzdG9yYWdlIG1hcHMgZm9yIHJvb3RzICR7cm9vdHMuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRWYXVsdEFzc2V0cyh2YXVsdFJvb3QpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGZXRjaCBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgZ2l2ZW4gcm9vdFxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBhY2NvdW50QXNzZXRzXG4gICAgICAgICAgICAud2hlcmUoXCJyb290XCIpXG4gICAgICAgICAgICAuZXF1YWxzKHZhdWx0Um9vdClcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIC8vIE1hcCB0aGUgcmVjb3JkcyB0byB0aGVpciBhc3NldCB2YWx1ZXNcbiAgICAgICAgY29uc3QgYXNzZXRzID0gYWxsTWF0Y2hpbmdSZWNvcmRzLm1hcCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzc2V0OiByZWNvcmQuYXNzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBmZXRjaGluZyBhY2NvdW50IHZhdWx0IGZvciByb290ICR7dmF1bHRSb290fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRBdXRoQnlQdWJLZXkocHViS2V5KSB7XG4gICAgLy8gVHJ5IHRvIGdldCB0aGUgYWNjb3VudCBhdXRoIGZyb20gdGhlIHN0b3JlXG4gICAgY29uc3QgYWNjb3VudFNlY3JldEtleSA9IGF3YWl0IGFjY291bnRBdXRoc1xuICAgICAgICAud2hlcmUoXCJwdWJLZXlcIilcbiAgICAgICAgLmVxdWFscyhwdWJLZXkpXG4gICAgICAgIC5maXJzdCgpO1xuICAgIC8vIElmIGl0J3Mgbm90IGluIHRoZSBjYWNoZSwgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoIWFjY291bnRTZWNyZXRLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjb3VudCBhdXRoIG5vdCBmb3VuZCBpbiBjYWNoZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHNlY3JldEtleTogYWNjb3VudFNlY3JldEtleS5zZWNyZXRLZXksXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRBZGRyZXNzZXMoYWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGFjY291bnRJZFxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBhZGRyZXNzZXNcbiAgICAgICAgICAgIC53aGVyZShcImlkXCIpXG4gICAgICAgICAgICAuZXF1YWxzKGFjY291bnRJZClcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGlmIChhbGxNYXRjaGluZ1JlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGFkZHJlc3MgcmVjb3JkcyBmb3VuZCBmb3IgZ2l2ZW4gYWNjb3VudCBJRC5cIik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoaW5nUmVjb3JkcztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciB3aGlsZSBmZXRjaGluZyBhY2NvdW50IGFkZHJlc3NlcyBmb3IgaWQ6ICR7YWNjb3VudElkfWApO1xuICAgIH1cbn1cbi8vIElOU0VSVCBGVU5DVElPTlNcbmFzeW5jIGZ1bmN0aW9uIHVwc2VydEFjY291bnRDb2RlKGNvZGVSb290LCBjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgZGF0YSBvYmplY3QgdG8gaW5zZXJ0XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByb290OiBjb2RlUm9vdCwgLy8gVXNpbmcgY29kZVJvb3QgYXMgdGhlIGtleVxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5zZXJ0IHVzaW5nIERleGllXG4gICAgICAgIGF3YWl0IGFjY291bnRDb2Rlcy5wdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIGNvZGUgd2l0aCByb290OiAke2NvZGVSb290fWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydEFjY291bnRTdG9yYWdlKHN0b3JhZ2VTbG90cykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm9jZXNzZWRTbG90cyA9IHN0b3JhZ2VTbG90cy5tYXAoKHNsb3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogc2xvdC5jb21taXRtZW50LFxuICAgICAgICAgICAgICAgIHNsb3RJbmRleDogc2xvdC5zbG90SW5kZXgsXG4gICAgICAgICAgICAgICAgc2xvdFZhbHVlOiBzbG90LnNsb3RWYWx1ZSxcbiAgICAgICAgICAgICAgICBzbG90VHlwZTogc2xvdC5zbG90VHlwZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBhY2NvdW50U3RvcmFnZXMuYnVsa1B1dChwcm9jZXNzZWRTbG90cyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIHN0b3JhZ2Ugc2xvdHNgKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRTdG9yYWdlTWFwRW50cmllcyhlbnRyaWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb2Nlc3NlZEVudHJpZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm9vdDogZW50cnkucm9vdCxcbiAgICAgICAgICAgICAgICBrZXk6IGVudHJ5LmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3RvcmFnZU1hcEVudHJpZXMuYnVsa1B1dChwcm9jZXNzZWRFbnRyaWVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgc3RvcmFnZSBtYXAgZW50cmllc2ApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydFZhdWx0QXNzZXRzKGFzc2V0cykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBwcm9jZXNzZWRBc3NldHMgPSBhc3NldHMubWFwKChhc3NldCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb290OiBhc3NldC5yb290LFxuICAgICAgICAgICAgICAgIHZhdWx0S2V5OiBhc3NldC52YXVsdEtleSxcbiAgICAgICAgICAgICAgICBmYXVjZXRJZFByZWZpeDogYXNzZXQuZmF1Y2V0SWRQcmVmaXgsXG4gICAgICAgICAgICAgICAgYXNzZXQ6IGFzc2V0LmFzc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGFjY291bnRBc3NldHMuYnVsa1B1dChwcm9jZXNzZWRBc3NldHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBhc3NldHNgKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRBY2NvdW50UmVjb3JkKGFjY291bnRJZCwgY29kZVJvb3QsIHN0b3JhZ2VSb290LCB2YXVsdFJvb3QsIG5vbmNlLCBjb21taXR0ZWQsIGNvbW1pdG1lbnQsIGFjY291bnRTZWVkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGlkOiBhY2NvdW50SWQsXG4gICAgICAgICAgICBjb2RlUm9vdCxcbiAgICAgICAgICAgIHN0b3JhZ2VSb290LFxuICAgICAgICAgICAgdmF1bHRSb290LFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICBjb21taXR0ZWQsXG4gICAgICAgICAgICBhY2NvdW50U2VlZCxcbiAgICAgICAgICAgIGFjY291bnRDb21taXRtZW50OiBjb21taXRtZW50LFxuICAgICAgICAgICAgbG9ja2VkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgYWNjb3VudHMucHV0KGRhdGEpO1xuICAgICAgICBhd2FpdCB0cmFja2VkQWNjb3VudHMucHV0KHsgaWQ6IGFjY291bnRJZCB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciBpbnNlcnRpbmcgYWNjb3VudDogJHthY2NvdW50SWR9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0QWNjb3VudEF1dGgocHViS2V5LCBzZWNyZXRLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBkYXRhIG9iamVjdCB0byBpbnNlcnRcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHB1YktleTogcHViS2V5LFxuICAgICAgICAgICAgc2VjcmV0S2V5OiBzZWNyZXRLZXksXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluc2VydCB1c2luZyBEZXhpZVxuICAgICAgICBhd2FpdCBhY2NvdW50QXV0aHMuYWRkKGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBhY2NvdW50IGF1dGggZm9yIHB1YktleTogJHtwdWJLZXl9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0QWNjb3VudEFkZHJlc3MoYWRkcmVzcywgYWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgZGF0YSBvYmplY3QgdG8gaW5zZXJ0XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgaWQ6IGFjY291bnRJZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5zZXJ0IHVzaW5nIERleGllXG4gICAgICAgIGF3YWl0IGFkZHJlc3Nlcy5wdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIGFkZHJlc3Mgd2l0aCB2YWx1ZTogJHtTdHJpbmcoYWRkcmVzcyl9IGZvciB0aGUgYWNjb3VudCBJRCAke2FjY291bnRJZH1gKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmVBY2NvdW50QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgZGVsZXRlIHVzaW5nIERleGllXG4gICAgICAgIGF3YWl0IGFkZHJlc3Nlcy53aGVyZShcImFkZHJlc3NcIikuZXF1YWxzKGFkZHJlc3MpLmRlbGV0ZSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIHJlbW92aW5nIGFkZHJlc3Mgd2l0aCB2YWx1ZTogJHtTdHJpbmcoYWRkcmVzcyl9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0Rm9yZWlnbkFjY291bnRDb2RlKGFjY291bnRJZCwgY29kZSwgY29kZVJvb3QpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCB1cHNlcnRBY2NvdW50Q29kZShjb2RlUm9vdCwgY29kZSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICBjb2RlUm9vdCxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgZm9yZWlnbkFjY291bnRDb2RlLnB1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciB1cHNlcnRpbmcgZm9yZWlnbiBhY2NvdW50IGNvZGUgZm9yIGFjY291bnQ6ICR7YWNjb3VudElkfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEZvcmVpZ25BY2NvdW50Q29kZShhY2NvdW50SWRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZm9yZWlnbkFjY291bnRzID0gYXdhaXQgZm9yZWlnbkFjY291bnRDb2RlXG4gICAgICAgICAgICAud2hlcmUoXCJhY2NvdW50SWRcIilcbiAgICAgICAgICAgIC5hbnlPZihhY2NvdW50SWRzKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKGZvcmVpZ25BY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gcmVjb3JkcyBmb3VuZCBmb3IgdGhlIGdpdmVuIGFjY291bnQgSURzLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBObyByZWNvcmRzIGZvdW5kXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZVJvb3RzID0gZm9yZWlnbkFjY291bnRzLm1hcCgoYWNjb3VudCkgPT4gYWNjb3VudC5jb2RlUm9vdCk7XG4gICAgICAgIGNvbnN0IGFjY291bnRDb2RlID0gYXdhaXQgYWNjb3VudENvZGVzXG4gICAgICAgICAgICAud2hlcmUoXCJyb290XCIpXG4gICAgICAgICAgICAuYW55T2YoY29kZVJvb3RzKVxuICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ29kZSA9IGZvcmVpZ25BY2NvdW50c1xuICAgICAgICAgICAgLm1hcCgoZm9yZWlnbkFjY291bnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nQ29kZSA9IGFjY291bnRDb2RlLmZpbmQoKGNvZGUpID0+IGNvZGUucm9vdCA9PT0gZm9yZWlnbkFjY291bnQuY29kZVJvb3QpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGVCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobWF0Y2hpbmdDb2RlLmNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQ6IGZvcmVpZ25BY2NvdW50LmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlQmFzZTY0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKG1hdGNoaW5nQ29kZSkgPT4gbWF0Y2hpbmdDb2RlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkQ29kZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRXJyb3IgZmV0Y2hpbmcgZm9yZWlnbiBhY2NvdW50IGNvZGVcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbG9ja0FjY291bnQoYWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYWNjb3VudHMud2hlcmUoXCJpZFwiKS5lcXVhbHMoYWNjb3VudElkKS5tb2RpZnkoeyBsb2NrZWQ6IHRydWUgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgbG9ja2luZyBhY2NvdW50OiAke2FjY291bnRJZH1gKTtcbiAgICB9XG59XG4vLyBEZWxldGUgZnVuY3Rpb25zXG5hc3luYyBmdW5jdGlvbiB1bmRvQWNjb3VudFN0YXRlcyhhY2NvdW50Q29tbWl0bWVudHMpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBhY2NvdW50c1xuICAgICAgICAgICAgLndoZXJlKFwiYWNjb3VudENvbW1pdG1lbnRcIilcbiAgICAgICAgICAgIC5hbnlPZihhY2NvdW50Q29tbWl0bWVudHMpXG4gICAgICAgICAgICAuZGVsZXRlKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgdW5kb2luZyBhY2NvdW50IHN0YXRlczogJHthY2NvdW50Q29tbWl0bWVudHMuam9pbihcIixcIil9YCk7XG4gICAgfVxufVxuXG4vLyBJTlNFUlQgRlVOQ1RJT05TXG5hc3luYyBmdW5jdGlvbiBpbnNlcnRCbG9ja0hlYWRlcihibG9ja051bSwgaGVhZGVyLCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzLCBoYXNDbGllbnROb3Rlcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBibG9ja051bTogYmxvY2tOdW0sXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzLFxuICAgICAgICAgICAgaGFzQ2xpZW50Tm90ZXM6IGhhc0NsaWVudE5vdGVzLnRvU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQmxvY2tIZWFkZXIgPSBhd2FpdCBibG9ja0hlYWRlcnMuZ2V0KGJsb2NrTnVtKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0Jsb2NrSGVhZGVyKSB7XG4gICAgICAgICAgICBhd2FpdCBibG9ja0hlYWRlcnMuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJCbG9jayBoZWFkZXIgYWxyZWFkeSBleGlzdHMsIGNoZWNraW5nIGZvciB1cGRhdGUuXCIpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNDbGllbnROb3RlcyBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgZmFsc2VcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0Jsb2NrSGVhZGVyLmhhc0NsaWVudE5vdGVzID09PSBcImZhbHNlXCIgJiYgaGFzQ2xpZW50Tm90ZXMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBibG9ja0hlYWRlcnMudXBkYXRlKGJsb2NrTnVtLCB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NsaWVudE5vdGVzOiBoYXNDbGllbnROb3Rlcy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlZCBoYXNDbGllbnROb3RlcyB0byB0cnVlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdXBkYXRlIG5lZWRlZCBmb3IgaGFzQ2xpZW50Tm90ZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluc2VydFBhcnRpYWxCbG9ja2NoYWluTm9kZXMoaWRzLCBub2Rlcykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhcnJheXMgYXJlIG5vdCBvZiB0aGUgc2FtZSBsZW5ndGhcbiAgICAgICAgaWYgKGlkcy5sZW5ndGggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWRzIGFuZCBub2RlcyBhcnJheXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGlkIGFuZCBub2RlXG4gICAgICAgIGNvbnN0IGRhdGEgPSBub2Rlcy5tYXAoKG5vZGUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IGlkc1tpbmRleF0sXG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFVzZSBidWxrUHV0IHRvIGFkZC9vdmVyd3JpdGUgdGhlIGVudHJpZXNcbiAgICAgICAgYXdhaXQgcGFydGlhbEJsb2NrY2hhaW5Ob2Rlcy5idWxrUHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBpbnNlcnQgcGFydGlhbCBibG9ja2NoYWluIG5vZGVzXCIpO1xuICAgIH1cbn1cbi8vIEdFVCBGVU5DVElPTlNcbmFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrSGVhZGVycyhibG9ja051bWJlcnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgYmxvY2tIZWFkZXJzLmJ1bGtHZXQoYmxvY2tOdW1iZXJzKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHJlc3VsdC5oZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxCbG9ja2NoYWluUGVha3NCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQocmVzdWx0LnBhcnRpYWxCbG9ja2NoYWluUGVha3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtOiByZXN1bHQuYmxvY2tOdW0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogaGVhZGVyQmFzZTY0LFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzOiBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzQmFzZTY0LFxuICAgICAgICAgICAgICAgICAgICBoYXNDbGllbnROb3RlczogcmVzdWx0Lmhhc0NsaWVudE5vdGVzID09PSBcInRydWVcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRSZXN1bHRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgYmxvY2sgaGVhZGVyc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUcmFja2VkQmxvY2tIZWFkZXJzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZldGNoIGFsbCByZWNvcmRzIG1hdGNoaW5nIHRoZSBnaXZlbiByb290XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGJsb2NrSGVhZGVyc1xuICAgICAgICAgICAgLndoZXJlKFwiaGFzQ2xpZW50Tm90ZXNcIilcbiAgICAgICAgICAgIC5lcXVhbHMoXCJ0cnVlXCIpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICAvLyBQcm9jZXNzIGFsbCByZWNvcmRzIHdpdGggYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRSZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxsTWF0Y2hpbmdSZWNvcmRzLm1hcCgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQocmVjb3JkLmhlYWRlcik7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHJlY29yZC5wYXJ0aWFsQmxvY2tjaGFpblBlYWtzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW06IHJlY29yZC5ibG9ja051bSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGhlYWRlckJhc2U2NCxcbiAgICAgICAgICAgICAgICBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzOiBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzQmFzZTY0LFxuICAgICAgICAgICAgICAgIGhhc0NsaWVudE5vdGVzOiByZWNvcmQuaGFzQ2xpZW50Tm90ZXMgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkUmVjb3JkcztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IHRyYWNrZWQgYmxvY2sgaGVhZGVyc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQYXJ0aWFsQmxvY2tjaGFpblBlYWtzQnlCbG9ja051bShibG9ja051bSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrSGVhZGVyID0gYXdhaXQgYmxvY2tIZWFkZXJzLmdldChibG9ja051bSk7XG4gICAgICAgIGlmIChibG9ja0hlYWRlciA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGVha3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydGlhbEJsb2NrY2hhaW5QZWFrc0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChibG9ja0hlYWRlci5wYXJ0aWFsQmxvY2tjaGFpblBlYWtzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBlYWtzOiBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzQmFzZTY0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgcGFydGlhbCBibG9ja2NoYWluIHBlYWtzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFBhcnRpYWxCbG9ja2NoYWluTm9kZXNBbGwoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFydGlhbEJsb2NrY2hhaW5Ob2Rlc0FsbCA9IGF3YWl0IHBhcnRpYWxCbG9ja2NoYWluTm9kZXMudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gcGFydGlhbEJsb2NrY2hhaW5Ob2Rlc0FsbDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IHBhcnRpYWwgYmxvY2tjaGFpbiBub2Rlc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKGlkcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwYXJ0aWFsQmxvY2tjaGFpbk5vZGVzLmJ1bGtHZXQoaWRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBwYXJ0aWFsIGJsb2NrY2hhaW4gbm9kZXNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcHJ1bmVJcnJlbGV2YW50QmxvY2tzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN5bmNIZWlnaHQgPSBhd2FpdCBzdGF0ZVN5bmMuZ2V0KDEpO1xuICAgICAgICBpZiAoc3luY0hlaWdodCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU3luY0hlaWdodCBpcyB1bmRlZmluZWQgLS0gaXMgdGhlIHN0YXRlIHN5bmMgdGFibGUgZW1wdHk/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nUmVjb3JkcyA9IGF3YWl0IGJsb2NrSGVhZGVyc1xuICAgICAgICAgICAgLndoZXJlKFwiaGFzQ2xpZW50Tm90ZXNcIilcbiAgICAgICAgICAgIC5lcXVhbHMoXCJmYWxzZVwiKVxuICAgICAgICAgICAgLmFuZCgocmVjb3JkKSA9PiByZWNvcmQuYmxvY2tOdW0gIT09IFwiMFwiICYmIHJlY29yZC5ibG9ja051bSAhPT0gc3luY0hlaWdodC5ibG9ja051bSlcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGF3YWl0IGJsb2NrSGVhZGVycy5idWxrRGVsZXRlKGFsbE1hdGNoaW5nUmVjb3Jkcy5tYXAoKHIpID0+IHIuYmxvY2tOdW0pKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gcHJ1bmUgaXJyZWxldmFudCBibG9ja3NcIik7XG4gICAgfVxufVxuXG4vLyBEaXNhYmxpbmcgYGFueWAgY2hlY2tzIHNpbmNlIHRoaXMgZmlsZSBtb3N0bHkgZGVhbHMgd2l0aCBleHBvcnRpbmcgREIgdHlwZXMuXG4vKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50ICovXG5hc3luYyBmdW5jdGlvbiByZWN1cnNpdmVseVRyYW5zZm9ybUZvckV4cG9ydChvYmopIHtcbiAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJVaW50OEFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoudmFsdWUpO1xuICAgICAgICBjYXNlIFwiQmxvYlwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfX3R5cGU6IFwiQmxvYlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShhd2FpdCBvYmoudmFsdWUuYXJyYXlCdWZmZXIoKSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwob2JqLnZhbHVlLm1hcCgodikgPT4gcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JFeHBvcnQoeyB0eXBlOiBnZXRJbnB1dFR5cGUodiksIHZhbHVlOiB2IH0pKSk7XG4gICAgICAgIGNhc2UgXCJSZWNvcmRcIjpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMob2JqLnZhbHVlKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBhd2FpdCByZWN1cnNpdmVseVRyYW5zZm9ybUZvckV4cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldElucHV0VHlwZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkpKTtcbiAgICAgICAgY2FzZSBcIlByaW1pdGl2ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG9iai52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnB1dFR5cGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gXCJVaW50OEFycmF5XCI7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYilcbiAgICAgICAgcmV0dXJuIFwiQmxvYlwiO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIFwiQXJyYXlcIjtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gXCJSZWNvcmRcIjtcbiAgICByZXR1cm4gXCJQcmltaXRpdmVcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZm9ybUZvckV4cG9ydChvYmopIHtcbiAgICByZXR1cm4gcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JFeHBvcnQoeyB0eXBlOiBnZXRJbnB1dFR5cGUob2JqKSwgdmFsdWU6IG9iaiB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydFN0b3JlKCkge1xuICAgIGNvbnN0IGRiSnNvbiA9IHt9O1xuICAgIGZvciAoY29uc3QgdGFibGUgb2YgZGIudGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSBhd2FpdCB0YWJsZS50b0FycmF5KCk7XG4gICAgICAgIGRiSnNvblt0YWJsZS5uYW1lXSA9IGF3YWl0IFByb21pc2UuYWxsKHJlY29yZHMubWFwKHRyYW5zZm9ybUZvckV4cG9ydCkpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGJKc29uKTtcbn1cblxuLy8gRGlzYWJsaW5nIGBhbnlgIGNoZWNrcyBzaW5jZSB0aGlzIGZpbGUgbW9zdGx5IGRlYWxzXG4vLyB3aXRoIGltcG9ydGluZyBEQiB0eXBlcyBhbmQgd2UncmUgdGVzdGluZyB0aGlzIHdoaWNoXG4vLyBzaG91bGQgYmUgZW5vdWdoICsgdGhlIFRTIGNvbXBpbGVyLlxuLyogZXNsaW50LWRpc2FibGUgKi9cbmFzeW5jIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhbnNmb3JtRm9ySW1wb3J0KG9iaikge1xuICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkJsb2JcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbYmFzZTY0VG9VaW50OEFycmF5KG9iai52YWx1ZS5kYXRhKV0pO1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChvYmoudmFsdWUubWFwKCh2KSA9PiByZWN1cnNpdmVseVRyYW5zZm9ybUZvckltcG9ydCh7IHR5cGU6IGdldEltcG9ydFR5cGUodiksIHZhbHVlOiB2IH0pKSk7XG4gICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMob2JqLnZhbHVlKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBhd2FpdCByZWN1cnNpdmVseVRyYW5zZm9ybUZvckltcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldEltcG9ydFR5cGUodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pKSk7XG4gICAgICAgIGNhc2UgXCJQcmltaXRpdmVcIjpcbiAgICAgICAgICAgIHJldHVybiBvYmoudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW1wb3J0VHlwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuX190eXBlID09PSBcIkJsb2JcIikge1xuICAgICAgICByZXR1cm4gXCJCbG9iXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIFwiQXJyYXlcIjtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gXCJPYmplY3RcIjtcbiAgICByZXR1cm4gXCJQcmltaXRpdmVcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZm9ybUZvckltcG9ydChvYmopIHtcbiAgICByZXR1cm4gcmVjdXJzaXZlbHlUcmFuc2Zvcm1Gb3JJbXBvcnQoe1xuICAgICAgICB0eXBlOiBnZXRJbXBvcnRUeXBlKG9iaiksXG4gICAgICAgIHZhbHVlOiBvYmosXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBmb3JjZUltcG9ydFN0b3JlKGpzb25TdHIpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWRiLmlzT3Blbikge1xuICAgICAgICAgICAgYXdhaXQgb3BlbkRhdGFiYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRiSnNvbiA9IEpTT04ucGFyc2UoanNvblN0cik7XG4gICAgICAgIGlmICh0eXBlb2YgZGJKc29uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkYkpzb24gPSBKU09OLnBhcnNlKGRiSnNvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvblRhYmxlTmFtZXMgPSBPYmplY3Qua2V5cyhkYkpzb24pO1xuICAgICAgICBjb25zdCBkYlRhYmxlTmFtZXMgPSBkYi50YWJsZXMubWFwKCh0KSA9PiB0Lm5hbWUpO1xuICAgICAgICBpZiAoanNvblRhYmxlTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0YWJsZXMgZm91bmQgaW4gdGhlIHByb3ZpZGVkIEpTT04uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGRiLnRyYW5zYWN0aW9uKFwicndcIiwgZGJUYWJsZU5hbWVzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChkYi50YWJsZXMubWFwKCh0KSA9PiB0LmNsZWFyKCkpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIGpzb25UYWJsZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBkYi50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghZGJUYWJsZU5hbWVzLmluY2x1ZGVzKHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUYWJsZSBcIiR7dGFibGVOYW1lfVwiIGRvZXMgbm90IGV4aXN0IGluIHRoZSBkYXRhYmFzZSBzY2hlbWEuIFNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGRiSnNvblt0YWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUmVjb3JkcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlY29yZHMubWFwKHRyYW5zZm9ybUZvckltcG9ydCkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRhYmxlLmJ1bGtQdXQodHJhbnNmb3JtZWRSZWNvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3RvcmUgaW1wb3J0ZWQgc3VjY2Vzc2Z1bGx5LlwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycik7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NCkge1xuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBsZW4gPSBiaW5hcnlTdHJpbmcubGVuZ3RoO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0T3V0cHV0Tm90ZXMoc3RhdGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG5vdGVzID0gc3RhdGVzLmxlbmd0aCA9PSAwXG4gICAgICAgICAgICA/IGF3YWl0IG91dHB1dE5vdGVzLnRvQXJyYXkoKVxuICAgICAgICAgICAgOiBhd2FpdCBvdXRwdXROb3Rlcy53aGVyZShcInN0YXRlRGlzY3JpbWluYW50XCIpLmFueU9mKHN0YXRlcykudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc091dHB1dE5vdGVzKG5vdGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IG91dHB1dCBub3Rlc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJbnB1dE5vdGVzKHN0YXRlcykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3RlcztcbiAgICAgICAgaWYgKHN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5vdGVzID0gYXdhaXQgaW5wdXROb3Rlcy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3RlcyA9IGF3YWl0IGlucHV0Tm90ZXNcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJzdGF0ZURpc2NyaW1pbmFudFwiKVxuICAgICAgICAgICAgICAgIC5hbnlPZihzdGF0ZXMpXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc0lucHV0Tm90ZXMobm90ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgaW5wdXQgbm90ZXNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5wdXROb3Rlc0Zyb21JZHMobm90ZUlkcykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3RlcyA9IGF3YWl0IGlucHV0Tm90ZXMud2hlcmUoXCJub3RlSWRcIikuYW55T2Yobm90ZUlkcykudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc0lucHV0Tm90ZXMobm90ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgaW5wdXQgbm90ZXMgZnJvbSBJRHNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5wdXROb3Rlc0Zyb21OdWxsaWZpZXJzKG51bGxpZmllcnMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgbm90ZXMgPSBhd2FpdCBpbnB1dE5vdGVzLndoZXJlKFwibnVsbGlmaWVyXCIpLmFueU9mKG51bGxpZmllcnMpLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NJbnB1dE5vdGVzKG5vdGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IGlucHV0IG5vdGVzIGZyb20gbnVsbGlmaWVyc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPdXRwdXROb3Rlc0Zyb21OdWxsaWZpZXJzKG51bGxpZmllcnMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgbm90ZXMgPSBhd2FpdCBvdXRwdXROb3Rlc1xuICAgICAgICAgICAgLndoZXJlKFwibnVsbGlmaWVyXCIpXG4gICAgICAgICAgICAuYW55T2YobnVsbGlmaWVycylcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzT3V0cHV0Tm90ZXMobm90ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgb3V0cHV0IG5vdGVzIGZyb20gbnVsbGlmaWVyc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPdXRwdXROb3Rlc0Zyb21JZHMobm90ZUlkcykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBub3RlcyA9IGF3YWl0IG91dHB1dE5vdGVzLndoZXJlKFwibm90ZUlkXCIpLmFueU9mKG5vdGVJZHMpLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NPdXRwdXROb3Rlcyhub3Rlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGdldCBvdXRwdXQgbm90ZXMgZnJvbSBJRHNcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0VW5zcGVudElucHV0Tm90ZU51bGxpZmllcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgbm90ZXMgPSBhd2FpdCBpbnB1dE5vdGVzXG4gICAgICAgICAgICAud2hlcmUoXCJzdGF0ZURpc2NyaW1pbmFudFwiKVxuICAgICAgICAgICAgLmFueU9mKFsyLCA0LCA1XSlcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBub3Rlcy5tYXAoKG5vdGUpID0+IG5vdGUubnVsbGlmaWVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IHVuc3BlbnQgaW5wdXQgbm90ZSBudWxsaWZpZXJzXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE5vdGVTY3JpcHQoc2NyaXB0Um9vdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5vdGVTY3JpcHQgPSBhd2FpdCBub3Rlc1NjcmlwdHNcbiAgICAgICAgICAgIC53aGVyZShcInNjcmlwdFJvb3RcIilcbiAgICAgICAgICAgIC5lcXVhbHMoc2NyaXB0Um9vdClcbiAgICAgICAgICAgIC5maXJzdCgpO1xuICAgICAgICByZXR1cm4gbm90ZVNjcmlwdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gZ2V0IG5vdGUgc2NyaXB0IGZyb20gcm9vdFwiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRJbnB1dE5vdGUobm90ZUlkLCBhc3NldHMsIHNlcmlhbE51bWJlciwgaW5wdXRzLCBzY3JpcHRSb290LCBzZXJpYWxpemVkTm90ZVNjcmlwdCwgbnVsbGlmaWVyLCBzZXJpYWxpemVkQ3JlYXRlZEF0LCBzdGF0ZURpc2NyaW1pbmFudCwgc3RhdGUpIHtcbiAgICByZXR1cm4gZGIudHJhbnNhY3Rpb24oXCJyd1wiLCBpbnB1dE5vdGVzLCBub3Rlc1NjcmlwdHMsIGFzeW5jICh0eCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBub3RlSWQsXG4gICAgICAgICAgICAgICAgYXNzZXRzLFxuICAgICAgICAgICAgICAgIHNlcmlhbE51bWJlcixcbiAgICAgICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICAgICAgc2NyaXB0Um9vdCxcbiAgICAgICAgICAgICAgICBudWxsaWZpZXIsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgc3RhdGVEaXNjcmltaW5hbnQsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZENyZWF0ZWRBdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0eC5pbnB1dE5vdGVzLnB1dChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVTY3JpcHREYXRhID0ge1xuICAgICAgICAgICAgICAgIHNjcmlwdFJvb3QsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vdGVTY3JpcHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXdhaXQgdHgubm90ZXNTY3JpcHRzLnB1dChub3RlU2NyaXB0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIG5vdGU6ICR7bm90ZUlkfWApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnRPdXRwdXROb3RlKG5vdGVJZCwgYXNzZXRzLCByZWNpcGllbnREaWdlc3QsIG1ldGFkYXRhLCBudWxsaWZpZXIsIGV4cGVjdGVkSGVpZ2h0LCBzdGF0ZURpc2NyaW1pbmFudCwgc3RhdGUpIHtcbiAgICByZXR1cm4gZGIudHJhbnNhY3Rpb24oXCJyd1wiLCBvdXRwdXROb3Rlcywgbm90ZXNTY3JpcHRzLCBhc3luYyAodHgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbm90ZUlkLFxuICAgICAgICAgICAgICAgIGFzc2V0cyxcbiAgICAgICAgICAgICAgICByZWNpcGllbnREaWdlc3QsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgbnVsbGlmaWVyOiBudWxsaWZpZXIgPyBudWxsaWZpZXIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgc3RhdGVEaXNjcmltaW5hbnQsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXdhaXQgdHgub3V0cHV0Tm90ZXMucHV0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBub3RlOiAke25vdGVJZH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0lucHV0Tm90ZXMobm90ZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwobm90ZXMubWFwKGFzeW5jIChub3RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2V0c0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLmFzc2V0cyk7XG4gICAgICAgIGNvbnN0IHNlcmlhbE51bWJlckJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLnNlcmlhbE51bWJlcik7XG4gICAgICAgIGNvbnN0IGlucHV0c0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLmlucHV0cyk7XG4gICAgICAgIGxldCBzZXJpYWxpemVkTm90ZVNjcmlwdEJhc2U2NCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5vdGUuc2NyaXB0Um9vdCkge1xuICAgICAgICAgICAgbGV0IHJlY29yZCA9IGF3YWl0IG5vdGVzU2NyaXB0cy5nZXQobm90ZS5zY3JpcHRSb290KTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm90ZVNjcmlwdEJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChyZWNvcmQuc2VyaWFsaXplZE5vdGVTY3JpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KG5vdGUuc3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXNzZXRzOiBhc3NldHNCYXNlNjQsXG4gICAgICAgICAgICBzZXJpYWxOdW1iZXI6IHNlcmlhbE51bWJlckJhc2U2NCxcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzQmFzZTY0LFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBub3RlLnNlcmlhbGl6ZWRDcmVhdGVkQXQsXG4gICAgICAgICAgICBzZXJpYWxpemVkTm90ZVNjcmlwdDogc2VyaWFsaXplZE5vdGVTY3JpcHRCYXNlNjQsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVCYXNlNjQsXG4gICAgICAgIH07XG4gICAgfSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc091dHB1dE5vdGVzKG5vdGVzKSB7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKG5vdGVzLm1hcCgobm90ZSkgPT4ge1xuICAgICAgICBjb25zdCBhc3NldHNCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5hc3NldHMpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChub3RlLm1ldGFkYXRhKTtcbiAgICAgICAgY29uc3Qgc3RhdGVCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQobm90ZS5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3NldHM6IGFzc2V0c0Jhc2U2NCxcbiAgICAgICAgICAgIHJlY2lwaWVudERpZ2VzdDogbm90ZS5yZWNpcGllbnREaWdlc3QsXG4gICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGFCYXNlNjQsXG4gICAgICAgICAgICBleHBlY3RlZEhlaWdodDogbm90ZS5leHBlY3RlZEhlaWdodCxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZUJhc2U2NCxcbiAgICAgICAgfTtcbiAgICB9KSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cHNlcnROb3RlU2NyaXB0KHNjcmlwdFJvb3QsIHNlcmlhbGl6ZWROb3RlU2NyaXB0KSB7XG4gICAgcmV0dXJuIGRiLnRyYW5zYWN0aW9uKFwicndcIiwgb3V0cHV0Tm90ZXMsIG5vdGVzU2NyaXB0cywgYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBub3RlU2NyaXB0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzY3JpcHRSb290LFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb3RlU2NyaXB0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IHR4Lm5vdGVzU2NyaXB0cy5wdXQobm90ZVNjcmlwdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGluc2VydGluZyBub3RlIHNjcmlwdDogJHtzY3JpcHRSb290fWApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFNldHRpbmcoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHJlY29yZHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGtleVxuICAgICAgICBjb25zdCBhbGxNYXRjaGluZ1JlY29yZHMgPSBhd2FpdCBzZXR0aW5nc1xuICAgICAgICAgICAgLndoZXJlKFwia2V5XCIpXG4gICAgICAgICAgICAuZXF1YWxzKGtleSlcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGlmIChhbGxNYXRjaGluZ1JlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHNldHRpbmcgcmVjb3JkIGZvdW5kIGZvciBnaXZlbiBrZXkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIG1hdGNoXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUmVjb3JkID0gYWxsTWF0Y2hpbmdSZWNvcmRzWzBdO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzZXR0aW5nIHZhbHVlIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCB2YWx1ZUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChtYXRjaGluZ1JlY29yZC52YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IG1hdGNoaW5nUmVjb3JkLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUJhc2U2NCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIGBFcnJvciB3aGlsZSBmZXRjaGluZyBzZXR0aW5nIGtleTogJHtrZXl9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0U2V0dGluZyhrZXksIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBzZXR0aW5ncy5wdXQoc2V0dGluZyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgaW5zZXJ0aW5nIHNldHRpbmcgd2l0aCBrZXk6ICR7a2V5fSBhbmQgdmFsdWUoYmFzZTY0KTogJHt1aW50OEFycmF5VG9CYXNlNjQodmFsdWUpfWApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZVNldHRpbmcoa2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc2V0dGluZ3Mud2hlcmUoXCJrZXlcIikuZXF1YWxzKGtleSkuZGVsZXRlKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBgRXJyb3IgZGVsZXRpbmcgc2V0dGluZyB3aXRoIGtleTogJHtrZXl9YCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbGlzdFNldHRpbmdLZXlzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBzZXR0aW5nc1xuICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgICAgLnRoZW4oKHNldHRpbmdzKSA9PiBzZXR0aW5ncy5tYXAoKHNldHRpbmcpID0+IHNldHRpbmcua2V5KSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgYEVycm9yIGxpc3Rpbmcgc2V0dGluZyBrZXlzYCk7XG4gICAgfVxufVxuXG5jb25zdCBJRFNfRklMVEVSX1BSRUZJWCA9IFwiSWRzOlwiO1xuY29uc3QgRVhQSVJFRF9CRUZPUkVfRklMVEVSX1BSRUZJWCA9IFwiRXhwaXJlZFBlbmRpbmc6XCI7XG5jb25zdCBTVEFUVVNfQ09NTUlUVEVEX1ZBUklBTlQgPSAxO1xuY29uc3QgU1RBVFVTX0RJU0NBUkRFRF9WQVJJQU5UID0gMjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9ucyhmaWx0ZXIpIHtcbiAgICBsZXQgdHJhbnNhY3Rpb25SZWNvcmRzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gXCJVbmNvbW1pdHRlZFwiKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblJlY29yZHMgPSBhd2FpdCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguc3RhdHVzVmFyaWFudCAhPT0gU1RBVFVTX0NPTU1JVFRFRF9WQVJJQU5UKVxuICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyLnN0YXJ0c1dpdGgoSURTX0ZJTFRFUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICBjb25zdCBpZHNTdHJpbmcgPSBmaWx0ZXIuc3Vic3RyaW5nKElEU19GSUxURVJfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBpZHMgPSBpZHNTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25SZWNvcmRzID0gYXdhaXQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShcImlkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hbnlPZihpZHMpXG4gICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblJlY29yZHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXIuc3RhcnRzV2l0aChFWFBJUkVEX0JFRk9SRV9GSUxURVJfUFJFRklYKSkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1TdHJpbmcgPSBmaWx0ZXIuc3Vic3RyaW5nKEVYUElSRURfQkVGT1JFX0ZJTFRFUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtID0gcGFyc2VJbnQoYmxvY2tOdW1TdHJpbmcpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25SZWNvcmRzID0gYXdhaXQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LmJsb2NrTnVtIDwgYmxvY2tOdW0gJiZcbiAgICAgICAgICAgICAgICB0eC5zdGF0dXNWYXJpYW50ICE9PSBTVEFUVVNfQ09NTUlUVEVEX1ZBUklBTlQgJiZcbiAgICAgICAgICAgICAgICB0eC5zdGF0dXNWYXJpYW50ICE9PSBTVEFUVVNfRElTQ0FSREVEX1ZBUklBTlQpXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uUmVjb3JkcyA9IGF3YWl0IHRyYW5zYWN0aW9ucy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JpcHRSb290cyA9IHRyYW5zYWN0aW9uUmVjb3Jkc1xuICAgICAgICAgICAgLm1hcCgodHJhbnNhY3Rpb25SZWNvcmQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoc2NyaXB0Um9vdCkgPT4gc2NyaXB0Um9vdCAhPSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBzY3JpcHRzID0gYXdhaXQgdHJhbnNhY3Rpb25TY3JpcHRzXG4gICAgICAgICAgICAud2hlcmUoXCJzY3JpcHRSb290XCIpXG4gICAgICAgICAgICAuYW55T2Yoc2NyaXB0Um9vdHMpXG4gICAgICAgICAgICAudG9BcnJheSgpO1xuICAgICAgICAvLyBDcmVhdGUgYSBtYXAgb2Ygc2NyaXB0Um9vdCB0byBzY3JpcHQgZm9yIHF1aWNrIGxvb2t1cFxuICAgICAgICBjb25zdCBzY3JpcHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NyaXB0LnR4U2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0TWFwLnNldChzY3JpcHQuc2NyaXB0Um9vdCwgc2NyaXB0LnR4U2NyaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFRyYW5zYWN0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9uUmVjb3Jkcy5tYXAoKHRyYW5zYWN0aW9uUmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBsZXQgdHhTY3JpcHRCYXNlNjQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2NyaXB0ID0gc2NyaXB0TWFwLmdldCh0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290KTtcbiAgICAgICAgICAgICAgICBpZiAodHhTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHhTY3JpcHRCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQodHhTY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHNCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQodHJhbnNhY3Rpb25SZWNvcmQuZGV0YWlscyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQodHJhbnNhY3Rpb25SZWNvcmQuc3RhdHVzKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRyYW5zYWN0aW9uUmVjb3JkLmlkLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHNCYXNlNjQsXG4gICAgICAgICAgICAgICAgc2NyaXB0Um9vdDogdHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdCxcbiAgICAgICAgICAgICAgICB0eFNjcmlwdDogdHhTY3JpcHRCYXNlNjQsXG4gICAgICAgICAgICAgICAgYmxvY2tOdW06IHRyYW5zYWN0aW9uUmVjb3JkLmJsb2NrTnVtLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3RhdHVzVmFyaWFudDogdHJhbnNhY3Rpb25SZWNvcmQuc3RhdHVzVmFyaWFudCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1c0Jhc2U2NCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluc2VydFRyYW5zYWN0aW9uU2NyaXB0KHNjcmlwdFJvb3QsIHR4U2NyaXB0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2NyaXB0Um9vdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc2NyaXB0Um9vdCk7XG4gICAgICAgIGNvbnN0IHNjcmlwdFJvb3RCYXNlNjQgPSB1aW50OEFycmF5VG9CYXNlNjQoc2NyaXB0Um9vdEFycmF5KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHNjcmlwdFJvb3Q6IHNjcmlwdFJvb3RCYXNlNjQsXG4gICAgICAgICAgICB0eFNjcmlwdDogbWFwT3B0aW9uKHR4U2NyaXB0LCAodHhTY3JpcHQpID0+IG5ldyBVaW50OEFycmF5KHR4U2NyaXB0KSksXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uU2NyaXB0cy5wdXQoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBpbnNlcnQgdHJhbnNhY3Rpb24gc2NyaXB0XCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwc2VydFRyYW5zYWN0aW9uUmVjb3JkKHRyYW5zYWN0aW9uSWQsIGRldGFpbHMsIGJsb2NrTnVtLCBzdGF0dXNWYXJpYW50LCBzdGF0dXMsIHNjcmlwdFJvb3QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgaWQ6IHRyYW5zYWN0aW9uSWQsXG4gICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgc2NyaXB0Um9vdDogbWFwT3B0aW9uKHNjcmlwdFJvb3QsIChyb290KSA9PiB1aW50OEFycmF5VG9CYXNlNjQocm9vdCkpLFxuICAgICAgICAgICAgYmxvY2tOdW06IHBhcnNlSW50KGJsb2NrTnVtLCAxMCksXG4gICAgICAgICAgICBzdGF0dXNWYXJpYW50LFxuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbnMucHV0KGRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyLCBcIkZhaWxlZCB0byBpbnNlcnQgcHJvdmVuIHRyYW5zYWN0aW9uIGRhdGFcIik7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXROb3RlVGFncygpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IGF3YWl0IHRhZ3MudG9BcnJheSgpO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkUmVjb3JkcyA9IHJlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIHJlY29yZC5zb3VyY2VOb3RlSWQgPVxuICAgICAgICAgICAgICAgIHJlY29yZC5zb3VyY2VOb3RlSWQgPT0gXCJcIiA/IHVuZGVmaW5lZCA6IHJlY29yZC5zb3VyY2VOb3RlSWQ7XG4gICAgICAgICAgICByZWNvcmQuc291cmNlQWNjb3VudElkID1cbiAgICAgICAgICAgICAgICByZWNvcmQuc291cmNlQWNjb3VudElkID09IFwiXCIgPyB1bmRlZmluZWQgOiByZWNvcmQuc291cmNlQWNjb3VudElkO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRSZWNvcmRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJFcnJvciBmZXRjaCB0YWcgcmVjb3JkXCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN5bmNIZWlnaHQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gYXdhaXQgc3RhdGVTeW5jLmdldCgxKTsgLy8gU2luY2UgaWQgaXMgdGhlIHByaW1hcnkga2V5IGFuZCBhbHdheXMgMVxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBibG9ja051bTogcmVjb3JkLmJsb2NrTnVtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRXJyb3IgZmV0Y2hpbmcgc3luYyBoZWlnaHRcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWRkTm90ZVRhZyh0YWcsIHNvdXJjZU5vdGVJZCwgc291cmNlQWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHRhZ0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGFnKTtcbiAgICAgICAgbGV0IHRhZ0Jhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NCh0YWdBcnJheSk7XG4gICAgICAgIGF3YWl0IHRhZ3MuYWRkKHtcbiAgICAgICAgICAgIHRhZzogdGFnQmFzZTY0LFxuICAgICAgICAgICAgc291cmNlTm90ZUlkOiBzb3VyY2VOb3RlSWQgPyBzb3VyY2VOb3RlSWQgOiBcIlwiLFxuICAgICAgICAgICAgc291cmNlQWNjb3VudElkOiBzb3VyY2VBY2NvdW50SWQgPyBzb3VyY2VBY2NvdW50SWQgOiBcIlwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIGFkZCBub3RlIHRhZ1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmVOb3RlVGFnKHRhZywgc291cmNlTm90ZUlkLCBzb3VyY2VBY2NvdW50SWQpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdGFnQXJyYXkgPSBuZXcgVWludDhBcnJheSh0YWcpO1xuICAgICAgICBsZXQgdGFnQmFzZTY0ID0gdWludDhBcnJheVRvQmFzZTY0KHRhZ0FycmF5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRhZ3NcbiAgICAgICAgICAgIC53aGVyZSh7XG4gICAgICAgICAgICB0YWc6IHRhZ0Jhc2U2NCxcbiAgICAgICAgICAgIHNvdXJjZU5vdGVJZDogc291cmNlTm90ZUlkID8gc291cmNlTm90ZUlkIDogXCJcIixcbiAgICAgICAgICAgIHNvdXJjZUFjY291bnRJZDogc291cmNlQWNjb3VudElkID8gc291cmNlQWNjb3VudElkIDogXCJcIixcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZWxldGUoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ1dlYlN0b3JlRXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHJlbW92ZSBub3RlIHRhZ1wiKTtcbiAgICB9XG59XG4vKlxuICogVGFrZXMgYSBgSnNTdGF0ZVN5bmNVcGRhdGVgIG9iamVjdCBhbmQgd3JpdGVzIHRoZSBzdGF0ZSB1cGRhdGUgaW50byB0aGUgc3RvcmUuXG4gKiBAcGFyYW0ge0pzU3RhdGVTeW5jVXBkYXRlfVxuICovXG5hc3luYyBmdW5jdGlvbiBhcHBseVN0YXRlU3luYyhzdGF0ZVVwZGF0ZSkge1xuICAgIGNvbnN0IHsgYmxvY2tOdW0sIC8vIFRhcmdldCBibG9jayBudW1iZXIgZm9yIHRoaXMgc3luY1xuICAgIGZsYXR0ZW5lZE5ld0Jsb2NrSGVhZGVycywgLy8gU2VyaWFsaXplZCBibG9jayBoZWFkZXJzIHRvIGJlIHJlY29uc3RydWN0ZWRcbiAgICBmbGF0dGVuZWRQYXJ0aWFsQmxvY2tDaGFpblBlYWtzLCAvLyBTZXJpYWxpemVkIGJsb2NrY2hhaW4gcGVha3MgZm9yIHZlcmlmaWNhdGlvblxuICAgIG5ld0Jsb2NrTnVtcywgLy8gQmxvY2sgbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIG5ldyBoZWFkZXJzXG4gICAgYmxvY2tIYXNSZWxldmFudE5vdGVzLCAvLyBGbGFncyBpbmRpY2F0aW5nIHdoaWNoIGJsb2NrcyBoYXZlIHJlbGV2YW50IG5vdGVzXG4gICAgc2VyaWFsaXplZE5vZGVJZHMsIC8vIElEcyBmb3IgbmV3IGF1dGhlbnRpY2F0aW9uIG5vZGVzXG4gICAgc2VyaWFsaXplZE5vZGVzLCAvLyBBdXRoZW50aWNhdGlvbiBub2RlIGRhdGEgZm9yIG1lcmtsZSBwcm9vZnNcbiAgICBjb21taXR0ZWROb3RlSWRzLCAvLyBOb3RlIHRhZ3MgdG8gYmUgY2xlYW5lZCB1cC9yZW1vdmVkXG4gICAgc2VyaWFsaXplZElucHV0Tm90ZXMsIC8vIElucHV0IG5vdGVzIGNvbnN1bWVkIGluIHRyYW5zYWN0aW9uc1xuICAgIHNlcmlhbGl6ZWRPdXRwdXROb3RlcywgLy8gT3V0cHV0IG5vdGVzIGNyZWF0ZWQgaW4gdHJhbnNhY3Rpb25zXG4gICAgYWNjb3VudFVwZGF0ZXMsIC8vIEFjY291bnQgc3RhdGUgY2hhbmdlc1xuICAgIHRyYW5zYWN0aW9uVXBkYXRlcywgLy8gVHJhbnNhY3Rpb24gcmVjb3JkcyBhbmQgc2NyaXB0c1xuICAgICB9ID0gc3RhdGVVcGRhdGU7XG4gICAgLy8gQmxvY2sgaGVhZGVycyBhbmQgQmxvY2tjaGFpbiBwZWFrcyBhcmUgZmxhdHRlbmVkIGJlZm9yZSBjYWxsaW5nXG4gICAgLy8gdGhpcyBmdW5jdGlvbiwgaGVyZSB3ZSByZWJ1aWxkIHRoZW0uXG4gICAgY29uc3QgbmV3QmxvY2tIZWFkZXJzID0gcmVjb25zdHJ1Y3RGbGF0dGVuZWRWZWMoZmxhdHRlbmVkTmV3QmxvY2tIZWFkZXJzKTtcbiAgICBjb25zdCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzID0gcmVjb25zdHJ1Y3RGbGF0dGVuZWRWZWMoZmxhdHRlbmVkUGFydGlhbEJsb2NrQ2hhaW5QZWFrcyk7XG4gICAgLy8gQ3JlYXRlIHByb21pc2VzIHRvIGluc2VydCBlYWNoIGlucHV0IG5vdGUuIEVhY2ggbm90ZSB3aWxsIGhhdmUgaXRzIG93biB0cmFuc2FjdGlvbixcbiAgICAvLyBhbmQgdGhlcmVmb3JlLCBuZXN0ZWQgaW5zaWRlIHRoZSBmaW5hbCB0cmFuc2FjdGlvbiBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICBsZXQgaW5wdXROb3Rlc1dyaXRlT3AgPSBQcm9taXNlLmFsbChzZXJpYWxpemVkSW5wdXROb3Rlcy5tYXAoKG5vdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHVwc2VydElucHV0Tm90ZShub3RlLm5vdGVJZCwgbm90ZS5ub3RlQXNzZXRzLCBub3RlLnNlcmlhbE51bWJlciwgbm90ZS5pbnB1dHMsIG5vdGUubm90ZVNjcmlwdFJvb3QsIG5vdGUubm90ZVNjcmlwdCwgbm90ZS5udWxsaWZpZXIsIG5vdGUuY3JlYXRlZEF0LCBub3RlLnN0YXRlRGlzY3JpbWluYW50LCBub3RlLnN0YXRlKTtcbiAgICB9KSk7XG4gICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUsIHRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgaGVyZSwgYnV0IGZvciBPdXRwdXQgTm90ZXMuXG4gICAgbGV0IG91dHB1dE5vdGVzV3JpdGVPcCA9IFByb21pc2UuYWxsKHNlcmlhbGl6ZWRPdXRwdXROb3Rlcy5tYXAoKG5vdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHVwc2VydE91dHB1dE5vdGUobm90ZS5ub3RlSWQsIG5vdGUubm90ZUFzc2V0cywgbm90ZS5yZWNpcGllbnREaWdlc3QsIG5vdGUubWV0YWRhdGEsIG5vdGUubnVsbGlmaWVyLCBub3RlLmV4cGVjdGVkSGVpZ2h0LCBub3RlLnN0YXRlRGlzY3JpbWluYW50LCBub3RlLnN0YXRlKTtcbiAgICB9KSk7XG4gICAgLy8gUHJvbWlzZXMgdG8gaW5zZXJ0IGVhY2ggdHJhbnNhY3Rpb24gdXBkYXRlLlxuICAgIGxldCB0cmFuc2FjdGlvbldyaXRlT3AgPSBQcm9taXNlLmFsbCh0cmFuc2FjdGlvblVwZGF0ZXMubWFwKCh0cmFuc2FjdGlvblJlY29yZCkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZXMgPSBbXG4gICAgICAgICAgICB1cHNlcnRUcmFuc2FjdGlvblJlY29yZCh0cmFuc2FjdGlvblJlY29yZC5pZCwgdHJhbnNhY3Rpb25SZWNvcmQuZGV0YWlscywgdHJhbnNhY3Rpb25SZWNvcmQuYmxvY2tOdW0sIHRyYW5zYWN0aW9uUmVjb3JkLnN0YXR1c1ZhcmlhbnQsIHRyYW5zYWN0aW9uUmVjb3JkLnN0YXR1cywgdHJhbnNhY3Rpb25SZWNvcmQuc2NyaXB0Um9vdCksXG4gICAgICAgIF07XG4gICAgICAgIGlmICh0cmFuc2FjdGlvblJlY29yZC5zY3JpcHRSb290ICYmIHRyYW5zYWN0aW9uUmVjb3JkLnR4U2NyaXB0KSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGluc2VydFRyYW5zYWN0aW9uU2NyaXB0KHRyYW5zYWN0aW9uUmVjb3JkLnNjcmlwdFJvb3QsIHRyYW5zYWN0aW9uUmVjb3JkLnR4U2NyaXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9KSk7XG4gICAgLy8gUHJvbWlzZXMgdG8gaW5zZXJ0IGVhY2ggYWNjb3VudCB1cGRhdGUuXG4gICAgbGV0IGFjY291bnRVcGRhdGVzV3JpdGVPcCA9IFByb21pc2UuYWxsKGFjY291bnRVcGRhdGVzLmZsYXRNYXAoKGFjY291bnRVcGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHVwc2VydEFjY291bnRTdG9yYWdlKGFjY291bnRVcGRhdGUuc3RvcmFnZVNsb3RzKSxcbiAgICAgICAgICAgIHVwc2VydFN0b3JhZ2VNYXBFbnRyaWVzKGFjY291bnRVcGRhdGUuc3RvcmFnZU1hcEVudHJpZXMpLFxuICAgICAgICAgICAgdXBzZXJ0VmF1bHRBc3NldHMoYWNjb3VudFVwZGF0ZS5hc3NldHMpLFxuICAgICAgICAgICAgdXBzZXJ0QWNjb3VudFJlY29yZChhY2NvdW50VXBkYXRlLmFjY291bnRJZCwgYWNjb3VudFVwZGF0ZS5jb2RlUm9vdCwgYWNjb3VudFVwZGF0ZS5zdG9yYWdlUm9vdCwgYWNjb3VudFVwZGF0ZS5hc3NldFZhdWx0Um9vdCwgYWNjb3VudFVwZGF0ZS5ub25jZSwgYWNjb3VudFVwZGF0ZS5jb21taXR0ZWQsIGFjY291bnRVcGRhdGUuYWNjb3VudENvbW1pdG1lbnQsIGFjY291bnRVcGRhdGUuYWNjb3VudFNlZWQpLFxuICAgICAgICBdO1xuICAgIH0pKTtcbiAgICBjb25zdCB0YWJsZXNUb0FjY2VzcyA9IFtcbiAgICAgICAgc3RhdGVTeW5jLFxuICAgICAgICBpbnB1dE5vdGVzLFxuICAgICAgICBvdXRwdXROb3RlcyxcbiAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICBibG9ja0hlYWRlcnMsXG4gICAgICAgIHBhcnRpYWxCbG9ja2NoYWluTm9kZXMsXG4gICAgICAgIHRhZ3MsXG4gICAgXTtcbiAgICAvLyBXcml0ZSBldmVyeXRoaW5nIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uLCB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgYXRvbWljYWxseSBkbyB0aGUgb3BlcmF0aW9uc1xuICAgIC8vIGJlbG93LCBzaW5jZSBldmVyeSBvcGVyYXRpb24gaGVyZSAob3IgYXQgbGVhc3QsIG1vc3Qgb2YgdGhlbSksIGlzIGRvbmUgaW4gYSBuZXN0ZWQgdHJhbnNhY3Rpb24uXG4gICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhpcywgY2hlY2s6IGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvRGV4aWUvRGV4aWUudHJhbnNhY3Rpb24oKVxuICAgIHJldHVybiBhd2FpdCBkYi50cmFuc2FjdGlvbihcInJ3XCIsIHRhYmxlc1RvQWNjZXNzLCBhc3luYyAodHgpID0+IHtcbiAgICAgICAgLy8gRXZlcnl0aGluZyBpcyB1bmRlciBhIHNpbmdsZSBwcm9taXNlIHNpbmNlIG90aGVyd2lzZSB0aGUgdHggZXhwaXJlcy5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgaW5wdXROb3Rlc1dyaXRlT3AsXG4gICAgICAgICAgICBvdXRwdXROb3Rlc1dyaXRlT3AsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbldyaXRlT3AsXG4gICAgICAgICAgICBhY2NvdW50VXBkYXRlc1dyaXRlT3AsXG4gICAgICAgICAgICB1cGRhdGVTeW5jSGVpZ2h0KHR4LCBibG9ja051bSksXG4gICAgICAgICAgICB1cGRhdGVQYXJ0aWFsQmxvY2tjaGFpbk5vZGVzKHR4LCBzZXJpYWxpemVkTm9kZUlkcywgc2VyaWFsaXplZE5vZGVzKSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbW1pdHRlZE5vdGVUYWdzKHR4LCBjb21taXR0ZWROb3RlSWRzKSxcbiAgICAgICAgICAgIFByb21pc2UuYWxsKG5ld0Jsb2NrSGVhZGVycy5tYXAoKG5ld0Jsb2NrSGVhZGVyLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUJsb2NrSGVhZGVyKHR4LCBuZXdCbG9ja051bXNbaV0sIG5ld0Jsb2NrSGVhZGVyLCBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzW2ldLCBibG9ja0hhc1JlbGV2YW50Tm90ZXNbaV0gPT0gMSk7XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIF0pO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlU3luY0hlaWdodCh0eCwgYmxvY2tOdW0pIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCB0eC5zdGF0ZVN5bmMudXBkYXRlKDEsIHsgYmxvY2tOdW06IGJsb2NrTnVtIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gdXBkYXRlIHN5bmMgaGVpZ2h0XCIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrSGVhZGVyKHR4LCBibG9ja051bSwgYmxvY2tIZWFkZXIsIHBhcnRpYWxCbG9ja2NoYWluUGVha3MsIGhhc0NsaWVudE5vdGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtOiBibG9ja051bSxcbiAgICAgICAgICAgIGhlYWRlcjogYmxvY2tIZWFkZXIsXG4gICAgICAgICAgICBwYXJ0aWFsQmxvY2tjaGFpblBlYWtzLFxuICAgICAgICAgICAgaGFzQ2xpZW50Tm90ZXM6IGhhc0NsaWVudE5vdGVzLnRvU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQmxvY2tIZWFkZXIgPSBhd2FpdCB0eC5ibG9ja0hlYWRlcnMuZ2V0KGJsb2NrTnVtKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0Jsb2NrSGVhZGVyKSB7XG4gICAgICAgICAgICBhd2FpdCB0eC5ibG9ja0hlYWRlcnMuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnIsIFwiRmFpbGVkIHRvIGluc2VydCBibG9jayBoZWFkZXJcIik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGFydGlhbEJsb2NrY2hhaW5Ob2Rlcyh0eCwgbm9kZUluZGV4ZXMsIG5vZGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5cyBhcmUgbm90IG9mIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgICBpZiAobm9kZUluZGV4ZXMubGVuZ3RoICE9PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGVJbmRleGVzIGFuZCBub2RlcyBhcnJheXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhcnJheSBvZiBvYmplY3RzIHdpdGggaWQgYW5kIG5vZGVcbiAgICAgICAgY29uc3QgZGF0YSA9IG5vZGVzLm1hcCgobm9kZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICBpZDogbm9kZUluZGV4ZXNbaW5kZXhdLFxuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBVc2UgYnVsa1B1dCB0byBhZGQvb3ZlcndyaXRlIHRoZSBlbnRyaWVzXG4gICAgICAgIGF3YWl0IHR4LnBhcnRpYWxCbG9ja2NoYWluTm9kZXMuYnVsa1B1dChkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dXZWJTdG9yZUVycm9yKGVyciwgXCJGYWlsZWQgdG8gdXBkYXRlIHBhcnRpYWwgYmxvY2tjaGFpbiBub2Rlc1wiKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVDb21taXR0ZWROb3RlVGFncyh0eCwgaW5wdXROb3RlSWRzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dE5vdGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVJZCA9IGlucHV0Tm90ZUlkc1tpXTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBub3RlIHRhZ3NcbiAgICAgICAgICAgIGF3YWl0IHR4LnRhZ3Mud2hlcmUoXCJzb3VyY2Vfbm90ZV9pZFwiKS5lcXVhbHMobm90ZUlkKS5kZWxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nV2ViU3RvcmVFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gcHVkYXRlIGNvbW1pdHRlZCBub3RlIHRhZ3NcIik7XG4gICAgfVxufVxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlY29uc3RydWN0IGFycmF5cyBmcm9tIGZsYXR0ZW5lZCBkYXRhXG5mdW5jdGlvbiByZWNvbnN0cnVjdEZsYXR0ZW5lZFZlYyhmbGF0dGVuZWRWZWMpIHtcbiAgICBjb25zdCBkYXRhID0gZmxhdHRlbmVkVmVjLmRhdGEoKTtcbiAgICBjb25zdCBsZW5ndGhzID0gZmxhdHRlbmVkVmVjLmxlbmd0aHMoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxlbmd0aHMuZm9yRWFjaCgobGVuZ3RoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRhdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKSk7XG4gICAgICAgIGluZGV4ICs9IGxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5sZXQgd2FzbTtcblxubGV0IGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0VWludDhBcnJheU1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhBcnJheU1lbW9yeTA7XG59XG5cbmxldCBjYWNoZWRUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSk7XG5cbmNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpO1xuXG5jb25zdCBNQVhfU0FGQVJJX0RFQ09ERV9CWVRFUyA9IDIxNDY0MzUwNzI7XG5sZXQgbnVtQnl0ZXNEZWNvZGVkID0gMDtcbmZ1bmN0aW9uIGRlY29kZVRleHQocHRyLCBsZW4pIHtcbiAgICBudW1CeXRlc0RlY29kZWQgKz0gbGVuO1xuICAgIGlmIChudW1CeXRlc0RlY29kZWQgPj0gTUFYX1NBRkFSSV9ERUNPREVfQllURVMpIHtcbiAgICAgICAgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgICAgbnVtQnl0ZXNEZWNvZGVkID0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBsZW4pKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBkZWNvZGVUZXh0KHB0ciwgbGVuKTtcbn1cblxubGV0IGhlYXAgPSBuZXcgQXJyYXkoMTI4KS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxubGV0IGhlYXBfbmV4dCA9IGhlYXAubGVuZ3RoO1xuXG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICAgIGlmIChoZWFwX25leHQgPT09IGhlYXAubGVuZ3RoKSBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgICBjb25zdCBpZHggPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaGVhcFtpZHhdO1xuXG4gICAgaGVhcFtpZHhdID0gb2JqO1xuICAgIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHsgcmV0dXJuIGhlYXBbaWR4XTsgfVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuaWYgKCEoJ2VuY29kZUludG8nIGluIGNhY2hlZFRleHRFbmNvZGVyKSkge1xuICAgIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8gPSBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgICAgICB2aWV3LnNldChidWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhZDogYXJnLmxlbmd0aCxcbiAgICAgICAgICAgIHdyaXR0ZW46IGJ1Zi5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgsIDEpID4+PiAwO1xuICAgICAgICBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgYnVmLmxlbmd0aCkuc2V0KGJ1Zik7XG4gICAgICAgIFdBU01fVkVDVE9SX0xFTiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgbGV0IHB0ciA9IG1hbGxvYyhsZW4sIDEpID4+PiAwO1xuXG4gICAgY29uc3QgbWVtID0gZ2V0VWludDhBcnJheU1lbW9yeTAoKTtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICg7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgIGlmIChjb2RlID4gMHg3RikgYnJlYWs7XG4gICAgICAgIG1lbVtwdHIgKyBvZmZzZXRdID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ICE9PSBsZW4pIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgbGVuID0gb2Zmc2V0ICsgYXJnLmxlbmd0aCAqIDMsIDEpID4+PiAwO1xuICAgICAgICBjb25zdCB2aWV3ID0gZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8oYXJnLCB2aWV3KTtcblxuICAgICAgICBvZmZzZXQgKz0gcmV0LndyaXR0ZW47XG4gICAgICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIG9mZnNldCwgMSkgPj4+IDA7XG4gICAgfVxuXG4gICAgV0FTTV9WRUNUT1JfTEVOID0gb2Zmc2V0O1xuICAgIHJldHVybiBwdHI7XG59XG5cbmxldCBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREYXRhVmlld01lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyLmRldGFjaGVkID09PSB0cnVlIHx8IChjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyLmRldGFjaGVkID09PSB1bmRlZmluZWQgJiYgY2FjaGVkRGF0YVZpZXdNZW1vcnkwLmJ1ZmZlciAhPT0gd2FzbS5tZW1vcnkuYnVmZmVyKSkge1xuICAgICAgICBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBuZXcgRGF0YVZpZXcod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZERhdGFWaWV3TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gaXNMaWtlTm9uZSh4KSB7XG4gICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBkZWJ1Z1N0cmluZyh2YWwpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdib29sZWFuJyB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIGAke3ZhbH1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx9XCJgO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbC5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnU3ltYm9sJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBuYW1lID0gdmFsLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyAmJiBuYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgRnVuY3Rpb24oJHtuYW1lfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JqZWN0c1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgICAgbGV0IGRlYnVnID0gJ1snO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWcgKz0gZGVidWdTdHJpbmcodmFsWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlYnVnICs9ICcsICcgKyBkZWJ1Z1N0cmluZyh2YWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnICs9ICddJztcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBidWlsdC1pblxuICAgIGNvbnN0IGJ1aWx0SW5NYXRjaGVzID0gL1xcW29iamVjdCAoW15cXF1dKylcXF0vLmV4ZWModG9TdHJpbmcuY2FsbCh2YWwpKTtcbiAgICBsZXQgY2xhc3NOYW1lO1xuICAgIGlmIChidWlsdEluTWF0Y2hlcyAmJiBidWlsdEluTWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGJ1aWx0SW5NYXRjaGVzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhaWxlZCB0byBtYXRjaCB0aGUgc3RhbmRhcmQgJ1tvYmplY3QgQ2xhc3NOYW1lXSdcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnT2JqZWN0Jykge1xuICAgICAgICAvLyB3ZSdyZSBhIHVzZXIgZGVmaW5lZCBjbGFzcyBvciBPYmplY3RcbiAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgYXZvaWRzIHByb2JsZW1zIHdpdGggY3ljbGVzLCBhbmQgaXMgZ2VuZXJhbGx5IG11Y2hcbiAgICAgICAgLy8gZWFzaWVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIG93blByb3BlcnRpZXMgb2YgYHZhbGAuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gJ09iamVjdCgnICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICcpJztcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVycm9yc1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gYCR7dmFsLm5hbWV9OiAke3ZhbC5tZXNzYWdlfVxcbiR7dmFsLnN0YWNrfWA7XG4gICAgfVxuICAgIC8vIFRPRE8gd2UgY291bGQgdGVzdCBmb3IgbW9yZSB0aGluZ3MgaGVyZSwgbGlrZSBgU2V0YHMgYW5kIGBNYXBgcy5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBkcm9wT2JqZWN0KGlkeCkge1xuICAgIGlmIChpZHggPCAxMzIpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU4RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDEsIHB0ciAvIDEgKyBsZW4pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihmLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0NChhZGRIZWFwT2JqZWN0KGUpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICBjb25zdCBtZW0gPSBnZXREYXRhVmlld01lbW9yeTAoKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gcHRyOyBpIDwgcHRyICsgNCAqIGxlbjsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRha2VPYmplY3QobWVtLmdldFVpbnQzMihpLCB0cnVlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBDTE9TVVJFX0RUT1JTID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHN0YXRlID0+IHN0YXRlLmR0b3Ioc3RhdGUuYSwgc3RhdGUuYikpO1xuXG5mdW5jdGlvbiBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCBkdG9yLCBmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGE6IGFyZzAsIGI6IGFyZzEsIGNudDogMSwgZHRvciB9O1xuICAgIGNvbnN0IHJlYWwgPSAoLi4uYXJncykgPT4ge1xuXG4gICAgICAgIC8vIEZpcnN0IHVwIHdpdGggYSBjbG9zdXJlIHdlIGluY3JlbWVudCB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlXG4gICAgICAgIC8vIGNvdW50LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgUnVzdCBjbG9zdXJlIGVudmlyb25tZW50IHdvbid0XG4gICAgICAgIC8vIGJlIGRlYWxsb2NhdGVkIHdoaWxlIHdlJ3JlIGludm9raW5nIGl0LlxuICAgICAgICBzdGF0ZS5jbnQrKztcbiAgICAgICAgY29uc3QgYSA9IHN0YXRlLmE7XG4gICAgICAgIHN0YXRlLmEgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoYSwgc3RhdGUuYiwgLi4uYXJncyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzdGF0ZS5hID0gYTtcbiAgICAgICAgICAgIHJlYWwuX3diZ19jYl91bnJlZigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZWFsLl93YmdfY2JfdW5yZWYgPSAoKSA9PiB7XG4gICAgICAgIGlmICgtLXN0YXRlLmNudCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUuZHRvcihzdGF0ZS5hLCBzdGF0ZS5iKTtcbiAgICAgICAgICAgIHN0YXRlLmEgPSAwO1xuICAgICAgICAgICAgQ0xPU1VSRV9EVE9SUy51bnJlZ2lzdGVyKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ0xPU1VSRV9EVE9SUy5yZWdpc3RlcihyZWFsLCBzdGF0ZSwgc3RhdGUpO1xuICAgIHJldHVybiByZWFsO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3MoaW5zdGFuY2UsIGtsYXNzKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBrbGFzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBpbnN0YW5jZSBvZiAke2tsYXNzLm5hbWV9YCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXNzQXJyYXk4VG9XYXNtMChhcmcsIG1hbGxvYykge1xuICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhhcmcubGVuZ3RoICogMSwgMSkgPj4+IDA7XG4gICAgZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zZXQoYXJnLCBwdHIgLyAxKTtcbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBhcmcubGVuZ3RoO1xuICAgIHJldHVybiBwdHI7XG59XG5cbmxldCBzdGFja19wb2ludGVyID0gMTI4O1xuXG5mdW5jdGlvbiBhZGRCb3Jyb3dlZE9iamVjdChvYmopIHtcbiAgICBpZiAoc3RhY2tfcG9pbnRlciA9PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiBqcyBzdGFjaycpO1xuICAgIGhlYXBbLS1zdGFja19wb2ludGVyXSA9IG9iajtcbiAgICByZXR1cm4gc3RhY2tfcG9pbnRlcjtcbn1cblxuZnVuY3Rpb24gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJyYXksIG1hbGxvYykge1xuICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhhcnJheS5sZW5ndGggKiA0LCA0KSA+Pj4gMDtcbiAgICBjb25zdCBtZW0gPSBnZXREYXRhVmlld01lbW9yeTAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lbS5zZXRVaW50MzIocHRyICsgNCAqIGksIGFkZEhlYXBPYmplY3QoYXJyYXlbaV0pLCB0cnVlKTtcbiAgICB9XG4gICAgV0FTTV9WRUNUT1JfTEVOID0gYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBwdHI7XG59XG5cbmxldCBjYWNoZWRCaWdVaW50NjRBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRCaWdVaW50NjRBcnJheU1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEJpZ1VpbnQ2NEFycmF5TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRCaWdVaW50NjRBcnJheU1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRCaWdVaW50NjRBcnJheU1lbW9yeTAgPSBuZXcgQmlnVWludDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEJpZ1VpbnQ2NEFycmF5TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gcGFzc0FycmF5NjRUb1dhc20wKGFyZywgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFyZy5sZW5ndGggKiA4LCA4KSA+Pj4gMDtcbiAgICBnZXRCaWdVaW50NjRBcnJheU1lbW9yeTAoKS5zZXQoYXJnLCBwdHIgLyA4KTtcbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBhcmcubGVuZ3RoO1xuICAgIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VTY0RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBnZXRCaWdVaW50NjRBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyA4LCBwdHIgLyA4ICsgbGVuKTtcbn1cblxubGV0IGNhY2hlZFVpbnQzMkFycmF5TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFVpbnQzMkFycmF5TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDMyQXJyYXlNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZFVpbnQzMkFycmF5TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQzMkFycmF5TWVtb3J5MCA9IG5ldyBVaW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDMyQXJyYXlNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVUzMkZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZ2V0VWludDMyQXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gNCwgcHRyIC8gNCArIGxlbik7XG59XG5mdW5jdGlvbiBfX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTM3NShhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgd2FzbS5fX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTM3NShhcmcwLCBhcmcxLCBhZGRIZWFwT2JqZWN0KGFyZzIpKTtcbn1cblxuZnVuY3Rpb24gX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzMDkoYXJnMCwgYXJnMSkge1xuICAgIHdhc20uX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzMDkoYXJnMCwgYXJnMSk7XG59XG5cbmZ1bmN0aW9uIF9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV8zNjc3KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICB3YXNtLl9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV8zNjc3KGFyZzAsIGFyZzEsIGFkZEhlYXBPYmplY3QoYXJnMiksIGFkZEhlYXBPYmplY3QoYXJnMykpO1xufVxuXG4vKipcbiAqIEBlbnVtIHswfVxuICovXG5jb25zdCBBY2NvdW50SW50ZXJmYWNlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgQmFzaWNXYWxsZXQ6IDAsIFwiMFwiOiBcIkJhc2ljV2FsbGV0XCIsXG59KTtcbi8qKlxuICogQGVudW0gezAgfCAxIHwgMiB8IDN9XG4gKi9cbmNvbnN0IEFjY291bnRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgRnVuZ2libGVGYXVjZXQ6IDAsIFwiMFwiOiBcIkZ1bmdpYmxlRmF1Y2V0XCIsXG4gICAgTm9uRnVuZ2libGVGYXVjZXQ6IDEsIFwiMVwiOiBcIk5vbkZ1bmdpYmxlRmF1Y2V0XCIsXG4gICAgUmVndWxhckFjY291bnRJbW11dGFibGVDb2RlOiAyLCBcIjJcIjogXCJSZWd1bGFyQWNjb3VudEltbXV0YWJsZUNvZGVcIixcbiAgICBSZWd1bGFyQWNjb3VudFVwZGF0YWJsZUNvZGU6IDMsIFwiM1wiOiBcIlJlZ3VsYXJBY2NvdW50VXBkYXRhYmxlQ29kZVwiLFxufSk7XG4vKipcbiAqIEBlbnVtIHswIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDh9XG4gKi9cbmNvbnN0IElucHV0Tm90ZVN0YXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgRXhwZWN0ZWQ6IDAsIFwiMFwiOiBcIkV4cGVjdGVkXCIsXG4gICAgVW52ZXJpZmllZDogMSwgXCIxXCI6IFwiVW52ZXJpZmllZFwiLFxuICAgIENvbW1pdHRlZDogMiwgXCIyXCI6IFwiQ29tbWl0dGVkXCIsXG4gICAgSW52YWxpZDogMywgXCIzXCI6IFwiSW52YWxpZFwiLFxuICAgIFByb2Nlc3NpbmdBdXRoZW50aWNhdGVkOiA0LCBcIjRcIjogXCJQcm9jZXNzaW5nQXV0aGVudGljYXRlZFwiLFxuICAgIFByb2Nlc3NpbmdVbmF1dGhlbnRpY2F0ZWQ6IDUsIFwiNVwiOiBcIlByb2Nlc3NpbmdVbmF1dGhlbnRpY2F0ZWRcIixcbiAgICBDb25zdW1lZEF1dGhlbnRpY2F0ZWRMb2NhbDogNiwgXCI2XCI6IFwiQ29uc3VtZWRBdXRoZW50aWNhdGVkTG9jYWxcIixcbiAgICBDb25zdW1lZFVuYXV0aGVudGljYXRlZExvY2FsOiA3LCBcIjdcIjogXCJDb25zdW1lZFVuYXV0aGVudGljYXRlZExvY2FsXCIsXG4gICAgQ29uc3VtZWRFeHRlcm5hbDogOCwgXCI4XCI6IFwiQ29uc3VtZWRFeHRlcm5hbFwiLFxufSk7XG4vKipcbiAqIEBlbnVtIHswIHwgMSB8IDJ9XG4gKi9cbmNvbnN0IE5ldHdvcmtJZCA9IE9iamVjdC5mcmVlemUoe1xuICAgIE1haW5uZXQ6IDAsIFwiMFwiOiBcIk1haW5uZXRcIixcbiAgICBUZXN0bmV0OiAxLCBcIjFcIjogXCJUZXN0bmV0XCIsXG4gICAgRGV2bmV0OiAyLCBcIjJcIjogXCJEZXZuZXRcIixcbn0pO1xuLyoqXG4gKiBAZW51bSB7MCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4fVxuICovXG5jb25zdCBOb3RlRmlsdGVyVHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBBbGw6IDAsIFwiMFwiOiBcIkFsbFwiLFxuICAgIENvbnN1bWVkOiAxLCBcIjFcIjogXCJDb25zdW1lZFwiLFxuICAgIENvbW1pdHRlZDogMiwgXCIyXCI6IFwiQ29tbWl0dGVkXCIsXG4gICAgRXhwZWN0ZWQ6IDMsIFwiM1wiOiBcIkV4cGVjdGVkXCIsXG4gICAgUHJvY2Vzc2luZzogNCwgXCI0XCI6IFwiUHJvY2Vzc2luZ1wiLFxuICAgIExpc3Q6IDUsIFwiNVwiOiBcIkxpc3RcIixcbiAgICBVbmlxdWU6IDYsIFwiNlwiOiBcIlVuaXF1ZVwiLFxuICAgIE51bGxpZmllcnM6IDcsIFwiN1wiOiBcIk51bGxpZmllcnNcIixcbiAgICBVbnZlcmlmaWVkOiA4LCBcIjhcIjogXCJVbnZlcmlmaWVkXCIsXG59KTtcbi8qKlxuICogQGVudW0gezIgfCAzIHwgMX1cbiAqL1xuY29uc3QgTm90ZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvKipcbiAgICAgKiBOb3RlcyB3aXRoIHRoaXMgdHlwZSBoYXZlIG9ubHkgdGhlaXIgaGFzaCBwdWJsaXNoZWQgdG8gdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgUHJpdmF0ZTogMiwgXCIyXCI6IFwiUHJpdmF0ZVwiLFxuICAgIC8qKlxuICAgICAqIE5vdGVzIHdpdGggdGhpcyB0eXBlIGFyZSBzaGFyZWQgd2l0aCB0aGUgbmV0d29yayBlbmNyeXB0ZWQuXG4gICAgICovXG4gICAgRW5jcnlwdGVkOiAzLCBcIjNcIjogXCJFbmNyeXB0ZWRcIixcbiAgICAvKipcbiAgICAgKiBOb3RlcyB3aXRoIHRoaXMgdHlwZSBhcmUgZnVsbHkgc2hhcmVkIHdpdGggdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgUHVibGljOiAxLCBcIjFcIjogXCJQdWJsaWNcIixcbn0pO1xuLyoqXG4gKiBAZW51bSB7MCB8IDEgfCAyfVxuICovXG5jb25zdCBTaWduaW5nSW5wdXRzVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIFRyYW5zYWN0aW9uU3VtbWFyeTogMCwgXCIwXCI6IFwiVHJhbnNhY3Rpb25TdW1tYXJ5XCIsXG4gICAgQXJiaXRyYXJ5OiAxLCBcIjFcIjogXCJBcmJpdHJhcnlcIixcbiAgICBCbGluZDogMiwgXCIyXCI6IFwiQmxpbmRcIixcbn0pO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fQWRkcmVzc0ludGVyZmFjZSA9IFtcIkJhc2ljV2FsbGV0XCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVhZGFibGVTdHJlYW1UeXBlID0gW1wiYnl0ZXNcIl07XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZWZlcnJlclBvbGljeSA9IFtcIlwiLCBcIm5vLXJlZmVycmVyXCIsIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIiwgXCJvcmlnaW5cIiwgXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIiwgXCJ1bnNhZmUtdXJsXCIsIFwic2FtZS1vcmlnaW5cIiwgXCJzdHJpY3Qtb3JpZ2luXCIsIFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX1JlcXVlc3RDYWNoZSA9IFtcImRlZmF1bHRcIiwgXCJuby1zdG9yZVwiLCBcInJlbG9hZFwiLCBcIm5vLWNhY2hlXCIsIFwiZm9yY2UtY2FjaGVcIiwgXCJvbmx5LWlmLWNhY2hlZFwiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX1JlcXVlc3RDcmVkZW50aWFscyA9IFtcIm9taXRcIiwgXCJzYW1lLW9yaWdpblwiLCBcImluY2x1ZGVcIl07XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0TW9kZSA9IFtcInNhbWUtb3JpZ2luXCIsIFwibm8tY29yc1wiLCBcImNvcnNcIiwgXCJuYXZpZ2F0ZVwiXTtcblxuY29uc3QgX193YmluZGdlbl9lbnVtX1JlcXVlc3RSZWRpcmVjdCA9IFtcImZvbGxvd1wiLCBcImVycm9yXCIsIFwibWFudWFsXCJdO1xuXG5jb25zdCBBY2NvdW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgQWNjb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIG5vbmNlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfbm9uY2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Fzc2V0VmF1bHR9XG4gICAgICovXG4gICAgdmF1bHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF92YXVsdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBc3NldFZhdWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2V9XG4gICAgICovXG4gICAgc3RvcmFnZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X3N0b3JhZ2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2UuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50Q29kZX1cbiAgICAgKi9cbiAgICBjb2RlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfY29kZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50Q29kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGYXVjZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc0ZhdWNldCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVndWxhckFjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc1JlZ3VsYXJBY2NvdW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNVcGRhdGFibGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc1VwZGF0YWJsZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUHVibGljKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfaXNQdWJsaWModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ByaXZhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc1ByaXZhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudF9pc05ldHdvcmsodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05ldygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50X2lzTmV3KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqL1xuICAgIGdldFB1YmxpY0tleXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudF9nZXRQdWJsaWNLZXlzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudEFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50QXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50QXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudFtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQWNjb3VudEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FjY291bnR9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QWNjb3VudH0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgQWNjb3VudCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgQWNjb3VudCk7XG4gICAgICAgIHdhc20uYWNjb3VudGFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50QXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudEJ1aWxkZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGJ1aWxkZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudEJ1aWxkZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRCdWlsZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRCdWlsZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRCdWlsZGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50YnVpbGRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5pdF9zZWVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdF9zZWVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChpbml0X3NlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGJ1aWxkZXJfbmV3KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX193YmdfcHRyID0gcjAgPj4+IDA7XG4gICAgICAgICAgICBBY2NvdW50QnVpbGRlckZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50VHlwZX0gYWNjb3VudF90eXBlXG4gICAgICogQHJldHVybnMge0FjY291bnRCdWlsZGVyfVxuICAgICAqL1xuICAgIGFjY291bnRUeXBlKGFjY291bnRfdHlwZSkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVyX2FjY291bnRUeXBlKHB0ciwgYWNjb3VudF90eXBlKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRTdG9yYWdlTW9kZX0gc3RvcmFnZV9tb2RlXG4gICAgICogQHJldHVybnMge0FjY291bnRCdWlsZGVyfVxuICAgICAqL1xuICAgIHN0b3JhZ2VNb2RlKHN0b3JhZ2VfbW9kZSkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmFnZV9tb2RlLCBBY2NvdW50U3RvcmFnZU1vZGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVyX3N0b3JhZ2VNb2RlKHB0ciwgc3RvcmFnZV9tb2RlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50Q29tcG9uZW50fSBhY2NvdW50X2NvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoQ29tcG9uZW50KGFjY291bnRfY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2NvbXBvbmVudCwgQWNjb3VudENvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJfd2l0aENvbXBvbmVudChwdHIsIGFjY291bnRfY29tcG9uZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50Q29tcG9uZW50fSBhY2NvdW50X2NvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoQXV0aENvbXBvbmVudChhY2NvdW50X2NvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9jb21wb25lbnQsIEFjY291bnRDb21wb25lbnQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRidWlsZGVyX3dpdGhBdXRoQ29tcG9uZW50KHB0ciwgYWNjb3VudF9jb21wb25lbnQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aE5vQXV0aENvbXBvbmVudCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcl93aXRoTm9BdXRoQ29tcG9uZW50KHB0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRCdWlsZGVyUmVzdWx0fVxuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50YnVpbGRlcl9idWlsZChyZXRwdHIsIHB0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50QnVpbGRlclJlc3VsdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudEJ1aWxkZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRCdWlsZGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50QnVpbGRlclJlc3VsdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50YnVpbGRlcnJlc3VsdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50QnVpbGRlclJlc3VsdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudEJ1aWxkZXJSZXN1bHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudEJ1aWxkZXJSZXN1bHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudEJ1aWxkZXJSZXN1bHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRidWlsZGVycmVzdWx0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnR9XG4gICAgICovXG4gICAgZ2V0IGFjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJyZXN1bHRfYWNjb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBnZXQgc2VlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50YnVpbGRlcnJlc3VsdF9zZWVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50QnVpbGRlclJlc3VsdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudEJ1aWxkZXJSZXN1bHQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRDb2RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRjb2RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRDb2RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50Q29kZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50Q29kZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50Q29kZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGNvZGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBtYXN0X3Jvb3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNQcm9jZWR1cmUobWFzdF9yb290KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhtYXN0X3Jvb3QsIFdvcmQpO1xuICAgICAgICB2YXIgcHRyMCA9IG1hc3Rfcm9vdC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9oYXNQcm9jZWR1cmUodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudENvZGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRDb2RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50Q29tcG9uZW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRjb21wb25lbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50Q29tcG9uZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRDb21wb25lbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRjb21wb25lbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudF9jb2RlXG4gICAgICogQHBhcmFtIHtTY3JpcHRCdWlsZGVyfSBidWlsZGVyXG4gICAgICogQHBhcmFtIHtTdG9yYWdlU2xvdFtdfSBzdG9yYWdlX3Nsb3RzXG4gICAgICogQHJldHVybnMge0FjY291bnRDb21wb25lbnR9XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUoYWNjb3VudF9jb2RlLCBidWlsZGVyLCBzdG9yYWdlX3Nsb3RzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhY2NvdW50X2NvZGUsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYnVpbGRlciwgU2NyaXB0QnVpbGRlcik7XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoc3RvcmFnZV9zbG90cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50Y29tcG9uZW50X2NvbXBpbGUocmV0cHRyLCBwdHIwLCBsZW4wLCBidWlsZGVyLl9fd2JnX3B0ciwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50Q29tcG9uZW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50Q29tcG9uZW50fVxuICAgICAqL1xuICAgIHdpdGhTdXBwb3J0c0FsbFR5cGVzKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb21wb25lbnRfd2l0aFN1cHBvcnRzQWxsVHlwZXMocHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRDb21wb25lbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9jZWR1cmVfbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0UHJvY2VkdXJlSGFzaChwcm9jZWR1cmVfbmFtZSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHByb2NlZHVyZV9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50Y29tcG9uZW50X2dldFByb2NlZHVyZUhhc2gocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHRyMiA9IHIwO1xuICAgICAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkM18wID0gcHRyMjtcbiAgICAgICAgICAgIGRlZmVycmVkM18xID0gbGVuMjtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMiwgbGVuMik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQzXzAsIGRlZmVycmVkM18xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7R2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW1bXX1cbiAgICAgKi9cbiAgICBnZXRQcm9jZWR1cmVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRjb21wb25lbnRfZ2V0UHJvY2VkdXJlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZWNyZXRLZXl9IHNlY3JldF9rZXlcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudENvbXBvbmVudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQXV0aENvbXBvbmVudChzZWNyZXRfa2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzZWNyZXRfa2V5LCBTZWNyZXRLZXkpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50Y29tcG9uZW50X2NyZWF0ZUF1dGhDb21wb25lbnQocmV0cHRyLCBzZWNyZXRfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50Q29tcG9uZW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGFja2FnZX0gX3BhY2thZ2VcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VTbG90QXJyYXl9IHN0b3JhZ2Vfc2xvdHNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudENvbXBvbmVudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBhY2thZ2UoX3BhY2thZ2UsIHN0b3JhZ2Vfc2xvdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKF9wYWNrYWdlLCBQYWNrYWdlKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yYWdlX3Nsb3RzLCBTdG9yYWdlU2xvdEFycmF5KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudGNvbXBvbmVudF9mcm9tUGFja2FnZShyZXRwdHIsIF9wYWNrYWdlLl9fd2JnX3B0ciwgc3RvcmFnZV9zbG90cy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudENvbXBvbmVudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudENvbXBvbmVudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudENvbXBvbmVudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudERlbHRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRkZWx0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50RGVsdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnREZWx0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50RGVsdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudERlbHRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50ZGVsdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudERlbHRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRkZWx0YV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50RGVsdGEuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9pc0VtcHR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlRGVsdGF9XG4gICAgICovXG4gICAgc3RvcmFnZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50ZGVsdGFfc3RvcmFnZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZURlbHRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFZhdWx0RGVsdGF9XG4gICAgICovXG4gICAgdmF1bHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGRlbHRhX3ZhdWx0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRWYXVsdERlbHRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBub25jZURlbHRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9ub25jZURlbHRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50RGVsdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnREZWx0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgQWNjb3VudEZpbGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGZpbGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudEZpbGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEFjY291bnRGaWxlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRGaWxlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRGaWxlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50ZmlsZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGBBY2NvdW50RmlsZWAgaW50byBhIGJ5dGUgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGZpbGVfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGEgYnl0ZSBhcnJheSBpbnRvIGFuIGBBY2NvdW50RmlsZWBcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0FjY291bnRGaWxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRmaWxlX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRGaWxlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50RmlsZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudEZpbGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRIZWFkZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGhlYWRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50SGVhZGVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50SGVhZGVyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRIZWFkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudEhlYWRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudGhlYWRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIG5vbmNlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfbm9uY2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgdmF1bHRDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc3RvcmFnZUNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9zdG9yYWdlQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb2RlQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aGVhZGVyX2NvZGVDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50SGVhZGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50SGVhZGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50SWRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudGlkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRJZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudElkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRJZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEFjY291bnRJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudElkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hY2NvdW50aWRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGhleCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9mcm9tSGV4KHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZhdWNldCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfaXNGYXVjZXQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlZ3VsYXJBY2NvdW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9pc1JlZ3VsYXJBY2NvdW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQdWJsaWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX2lzUHVibGljKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQcml2YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9pc1ByaXZhdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX2lzTmV0d29yayh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRpZF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCB0dXJuIHRoZSBBY2NvdW50IElEIGludG8gaXRzIGJlY2gzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRvIGF2b2lkIGEgcG90ZW50aWFsXG4gICAgICogd3JvbmdmdWwgZW5jb2RpbmcsIHRoaXMgZnVuY3Rpb24gd2lsbCBleHBlY3Qgb25seSBJRHMgZm9yIGVpdGhlciBtYWlubmV0IChcIm1tXCIpLFxuICAgICAqIHRlc3RuZXQgKFwibXRzdFwiKSBvciBkZXZuZXQgKFwibWRldlwiKS4gVG8gdXNlIGEgY3VzdG9tIGJlY2gzMiBwcmVmaXgsIHNlZVxuICAgICAqIGBTZWxmOjp0b19iZWNoXzMyX2N1c3RvbWAuXG4gICAgICogQHBhcmFtIHtOZXR3b3JrSWR9IG5ldHdvcmtfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJbnRlcmZhY2V9IGFjY291bnRfaW50ZXJmYWNlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b0JlY2gzMihuZXR3b3JrX2lkLCBhY2NvdW50X2ludGVyZmFjZSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50aWRfdG9CZWNoMzIocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgbmV0d29ya19pZCwgYWNjb3VudF9pbnRlcmZhY2UpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IHB0cjE7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGxlbjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHVybiB0aGlzIEFjY291bnQgSUQgaW50byBpdHMgYmVjaDMyIHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgYWNjZXB0cyBhIGN1c3RvbVxuICAgICAqIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1c3RvbV9uZXR3b3JrX2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50SW50ZXJmYWNlfSBhY2NvdW50X2ludGVyZmFjZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CZWNoMzJDdXN0b20oY3VzdG9tX25ldHdvcmtfaWQsIGFjY291bnRfaW50ZXJmYWNlKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY3VzdG9tX25ldHdvcmtfaWQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFjY291bnRpZF90b0JlY2gzMkN1c3RvbShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBhY2NvdW50X2ludGVyZmFjZSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHRyMiA9IHIwO1xuICAgICAgICAgICAgdmFyIGxlbjIgPSByMTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHB0cjIgPSAwOyBsZW4yID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkM18wID0gcHRyMjtcbiAgICAgICAgICAgIGRlZmVycmVkM18xID0gbGVuMjtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMiwgbGVuMik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQzXzAsIGRlZmVycmVkM18xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBwcmVmaXgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX3ByZWZpeCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBzdWZmaXgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkX3N1ZmZpeCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudElkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBY2NvdW50SWQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRJZEFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnRpZGFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRJZEFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudElkQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRpZGFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWRbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGlkYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQWNjb3VudElkQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRpZGFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIEFjY291bnRJZCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRpZGFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIEFjY291bnRJZCk7XG4gICAgICAgIHdhc20uYWNjb3VudGlkYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudElkQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRJZEFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50U3RvcmFnZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50U3RvcmFnZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudFN0b3JhZ2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZV9nZXRJdGVtKHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge1dvcmR9IGtleVxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldE1hcEl0ZW0oaW5kZXgsIGtleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moa2V5LCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZV9nZXRNYXBJdGVtKHRoaXMuX193YmdfcHRyLCBpbmRleCwga2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGtleS12YWx1ZSBwYWlycyBmcm9tIHRoZSBtYXAgc2xvdCBhdCBgaW5kZXhgLlxuICAgICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIHNsb3QgaXNuJ3QgYSBtYXAgb3IgYGluZGV4YCBpcyBvdXQgb2YgYm91bmRzICgwLTI1NSkuXG4gICAgICogUmV0dXJucyBgW11gIGlmIHRoZSBtYXAgZXhpc3RzIGJ1dCBpcyBlbXB0eS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7SnNTdG9yYWdlTWFwRW50cnlbXSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRNYXBFbnRyaWVzKGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHN0b3JhZ2VfZ2V0TWFwRW50cmllcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50U3RvcmFnZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudFN0b3JhZ2UucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRTdG9yYWdlRGVsdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2VkZWx0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50U3RvcmFnZURlbHRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50U3RvcmFnZURlbHRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEFjY291bnRTdG9yYWdlRGVsdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VEZWx0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2VkZWx0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZWRlbHRhX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VEZWx0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50c3RvcmFnZWRlbHRhX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlRGVsdGEuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZWRlbHRhX2lzRW1wdHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqL1xuICAgIHZhbHVlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50c3RvcmFnZWRlbHRhX3ZhbHVlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRTdG9yYWdlRGVsdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRTdG9yYWdlRGVsdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRTdG9yYWdlTW9kZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZW1vZGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWNjb3VudFN0b3JhZ2VNb2RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50U3RvcmFnZU1vZGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VNb2RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFjY291bnRTdG9yYWdlTW9kZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudHN0b3JhZ2Vtb2RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJpdmF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfcHJpdmF0ZSgpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VNb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VNb2RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBwdWJsaWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX3B1YmxpYygpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VNb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudFN0b3JhZ2VNb2RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXR3b3JrKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV9uZXR3b3JrKCk7XG4gICAgICAgIHJldHVybiBBY2NvdW50U3RvcmFnZU1vZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJ5RnJvbVN0cihzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50c3RvcmFnZW1vZGVfdHJ5RnJvbVN0cihyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VNb2RlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgYXNTdHIoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFjY291bnRzdG9yYWdlbW9kZV9hc1N0cihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFjY291bnRTdG9yYWdlTW9kZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudFN0b3JhZ2VNb2RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hY2NvdW50c3RvcmFnZXJlcXVpcmVtZW50c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FjY291bnRzdG9yYWdlcmVxdWlyZW1lbnRzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2VyZXF1aXJlbWVudHNfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Nsb3RBbmRLZXlzW119IHNsb3RzX2FuZF9rZXlzXG4gICAgICogQHJldHVybnMge0FjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2xvdEFuZEtleXNBcnJheShzbG90c19hbmRfa2V5cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoc2xvdHNfYW5kX2tleXMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHN0b3JhZ2VyZXF1aXJlbWVudHNfZnJvbVNsb3RBbmRLZXlzQXJyYXkocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFjY291bnRWYXVsdERlbHRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FjY291bnR2YXVsdGRlbHRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEFjY291bnRWYXVsdERlbHRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBY2NvdW50VmF1bHREZWx0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBY2NvdW50VmF1bHREZWx0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBBY2NvdW50VmF1bHREZWx0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWNjb3VudHZhdWx0ZGVsdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHZhdWx0ZGVsdGFfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtBY2NvdW50VmF1bHREZWx0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hY2NvdW50dmF1bHRkZWx0YV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY2NvdW50VmF1bHREZWx0YS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRzdG9yYWdlZGVsdGFfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0RGVsdGF9XG4gICAgICovXG4gICAgZnVuZ2libGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHZhdWx0ZGVsdGFfZnVuZ2libGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRnVuZ2libGVBc3NldERlbHRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldFtdfVxuICAgICAqL1xuICAgIGFkZGVkRnVuZ2libGVBc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHZhdWx0ZGVsdGFfYWRkZWRGdW5naWJsZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXRbXX1cbiAgICAgKi9cbiAgICByZW1vdmVkRnVuZ2libGVBc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWNjb3VudHZhdWx0ZGVsdGFfcmVtb3ZlZEZ1bmdpYmxlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWNjb3VudFZhdWx0RGVsdGEucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFjY291bnRWYXVsdERlbHRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBZGRyZXNzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2FkZHJlc3NfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWRkcmVzcyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWRkcmVzcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBZGRyZXNzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFkZHJlc3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FkZHJlc3NfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW19pbnRlcmZhY2VdXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21BY2NvdW50SWQoYWNjb3VudF9pZCwgX2ludGVyZmFjZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShfaW50ZXJmYWNlKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChfaW50ZXJmYWNlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYWRkcmVzc19mcm9tQWNjb3VudElkKHJldHB0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmVjaDMyXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21CZWNoMzIoYmVjaDMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChiZWNoMzIsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmFkZHJlc3NfZnJvbUJlY2gzMihyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc0ludGVyZmFjZX1cbiAgICAgKi9cbiAgICBpbnRlcmZhY2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWRkcmVzc19pbnRlcmZhY2UocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX3diaW5kZ2VuX2VudW1fQWRkcmVzc0ludGVyZmFjZVtyMF07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgYWNjb3VudElkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmFkZHJlc3NfYWNjb3VudElkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudElkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIHRvTm90ZVRhZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hZGRyZXNzX3RvTm90ZVRhZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05ldHdvcmtJZH0gbmV0d29ya19pZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9CZWNoMzIobmV0d29ya19pZCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hZGRyZXNzX3RvQmVjaDMyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIG5ldHdvcmtfaWQpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4xID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIxID0gMDsgbGVuMSA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDJfMCA9IHB0cjE7XG4gICAgICAgICAgICBkZWZlcnJlZDJfMSA9IGxlbjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjEsIGxlbjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFkZHJlc3MucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFkZHJlc3MucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFkdmljZUlucHV0c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hZHZpY2VpbnB1dHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWR2aWNlSW5wdXRzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBZHZpY2VJbnB1dHMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQWR2aWNlSW5wdXRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFkdmljZUlucHV0c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYWR2aWNlaW5wdXRzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICBzdGFjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5hZHZpY2VpbnB1dHNfc3RhY2socmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0ga2V5XG4gICAgICogQHJldHVybnMge0ZlbHRbXSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBtYXBwZWRWYWx1ZXMoa2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhrZXksIFdvcmQpO1xuICAgICAgICAgICAgd2FzbS5hZHZpY2VpbnB1dHNfbWFwcGVkVmFsdWVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGtleS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgQWR2aWNlSW5wdXRzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBBZHZpY2VJbnB1dHMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEFkdmljZU1hcEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19hZHZpY2VtYXBfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQWR2aWNlTWFwIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQWR2aWNlTWFwRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19hZHZpY2VtYXBfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50c3RvcmFnZXJlcXVpcmVtZW50c19uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEFkdmljZU1hcEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IGtleVxuICAgICAqIEBwYXJhbSB7RmVsdEFycmF5fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtGZWx0W10gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGtleSwgV29yZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModmFsdWUsIEZlbHRBcnJheSk7XG4gICAgICAgICAgICB3YXNtLmFkdmljZW1hcF9pbnNlcnQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwga2V5Ll9fd2JnX3B0ciwgdmFsdWUuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFkdmljZU1hcC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQWR2aWNlTWFwLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBBc3NldFZhdWx0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Fzc2V0dmF1bHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQXNzZXRWYXVsdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQXNzZXRWYXVsdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBc3NldFZhdWx0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFzc2V0VmF1bHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Fzc2V0dmF1bHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICByb290KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGZhdWNldF9pZFxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgZ2V0QmFsYW5jZShmYXVjZXRfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hc3NldHZhdWx0X2dldEJhbGFuY2UodGhpcy5fX3diZ19wdHIsIGZhdWNldF9pZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0W119XG4gICAgICovXG4gICAgZnVuZ2libGVBc3NldHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYXNzZXR2YXVsdF9mdW5naWJsZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEFzc2V0VmF1bHQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEFzc2V0VmF1bHQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEF1dGhTZWNyZXRLZXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYXV0aHNlY3JldGtleV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBBdXRoU2VjcmV0S2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShBdXRoU2VjcmV0S2V5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEF1dGhTZWNyZXRLZXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQXV0aFNlY3JldEtleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYXV0aHNlY3JldGtleV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGdldFJwb0ZhbGNvbjUxMlB1YmxpY0tleUFzV29yZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hdXRoc2VjcmV0a2V5X2dldFJwb0ZhbGNvbjUxMlB1YmxpY0tleUFzV29yZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIGdldFJwb0ZhbGNvbjUxMlNlY3JldEtleUFzRmVsdHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYXV0aHNlY3JldGtleV9nZXRScG9GYWxjb241MTJTZWNyZXRLZXlBc0ZlbHRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBnZXRFY2RzYUsyNTZLZWNjYWtQdWJsaWNLZXlBc1dvcmQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYXV0aHNlY3JldGtleV9nZXRFY2RzYUsyNTZLZWNjYWtQdWJsaWNLZXlBc1dvcmQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICBnZXRFY2RzYUsyNTZLZWNjYWtTZWNyZXRLZXlBc0ZlbHRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmF1dGhzZWNyZXRrZXlfZ2V0RWNkc2FLMjU2S2VjY2FrU2VjcmV0S2V5QXNGZWx0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEF1dGhTZWNyZXRLZXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEF1dGhTZWNyZXRLZXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYmFzaWNmdW5naWJsZWZhdWNldGNvbXBvbmVudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEJhc2ljRnVuZ2libGVGYXVjZXRDb21wb25lbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmFzaWNmdW5naWJsZWZhdWNldGNvbXBvbmVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudH0gYWNjb3VudFxuICAgICAqIEByZXR1cm5zIHtCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQWNjb3VudChhY2NvdW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50LCBBY2NvdW50KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gYWNjb3VudC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uYmFzaWNmdW5naWJsZWZhdWNldGNvbXBvbmVudF9mcm9tQWNjb3VudChyZXRwdHIsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmFzaWNGdW5naWJsZUZhdWNldENvbXBvbmVudC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VG9rZW5TeW1ib2x9XG4gICAgICovXG4gICAgc3ltYm9sKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRpZF9wcmVmaXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVG9rZW5TeW1ib2wuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZGVjaW1hbHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmFzaWNmdW5naWJsZWZhdWNldGNvbXBvbmVudF9kZWNpbWFscyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0fVxuICAgICAqL1xuICAgIG1heFN1cHBseSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50aWRfc3VmZml4KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBCbG9ja0hlYWRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ibG9ja2hlYWRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBCbG9ja0hlYWRlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQmxvY2tIZWFkZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQmxvY2tIZWFkZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQmxvY2tIZWFkZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Jsb2NraGVhZGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICB2ZXJzaW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX3ZlcnNpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc3ViQ29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ibG9ja2hlYWRlcl9zdWJDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHByZXZCbG9ja0NvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJsb2NrTnVtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX2Jsb2NrTnVtKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY2hhaW5Db21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfc3RvcmFnZUNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgYWNjb3VudFJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGhlYWRlcl9jb2RlQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBudWxsaWZpZXJSb290KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX251bGxpZmllclJvb3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgbm90ZVJvb3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfbm90ZVJvb3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgdHhDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX3R4Q29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICB0eEtlcm5lbENvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGJ1aWxkZXJyZXN1bHRfc2VlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBwcm9vZkNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmxvY2toZWFkZXJfcHJvb2ZDb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGltZXN0YW1wKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJsb2NraGVhZGVyX3RpbWVzdGFtcCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBCbG9ja0hlYWRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gQmxvY2tIZWFkZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IENvbnN1bWFibGVOb3RlUmVjb3JkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2NvbnN1bWFibGVub3RlcmVjb3JkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIENvbnN1bWFibGVOb3RlUmVjb3JkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShDb25zdW1hYmxlTm90ZVJlY29yZC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBDb25zdW1hYmxlTm90ZVJlY29yZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBDb25zdW1hYmxlTm90ZVJlY29yZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfY29uc3VtYWJsZW5vdGVyZWNvcmRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lucHV0Tm90ZVJlY29yZH0gaW5wdXRfbm90ZV9yZWNvcmRcbiAgICAgKiBAcGFyYW0ge05vdGVDb25zdW1hYmlsaXR5W119IG5vdGVfY29uc3VtYWJpbGl0eVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlucHV0X25vdGVfcmVjb3JkLCBub3RlX2NvbnN1bWFiaWxpdHkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGlucHV0X25vdGVfcmVjb3JkLCBJbnB1dE5vdGVSZWNvcmQpO1xuICAgICAgICB2YXIgcHRyMCA9IGlucHV0X25vdGVfcmVjb3JkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobm90ZV9jb25zdW1hYmlsaXR5LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jb25zdW1hYmxlbm90ZXJlY29yZF9uZXcocHRyMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBDb25zdW1hYmxlTm90ZVJlY29yZEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3RlUmVjb3JkfVxuICAgICAqL1xuICAgIGlucHV0Tm90ZVJlY29yZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jb25zdW1hYmxlbm90ZXJlY29yZF9pbnB1dE5vdGVSZWNvcmQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gSW5wdXROb3RlUmVjb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUNvbnN1bWFiaWxpdHlbXX1cbiAgICAgKi9cbiAgICBub3RlQ29uc3VtYWJpbGl0eSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5jb25zdW1hYmxlbm90ZXJlY29yZF9ub3RlQ29uc3VtYWJpbGl0eShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIENvbnN1bWFibGVOb3RlUmVjb3JkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBDb25zdW1hYmxlTm90ZVJlY29yZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRW5kcG9pbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZW5kcG9pbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIG5ldHdvcmsgZW5kcG9pbnQgZm9yIGNvbm5lY3RpbmcgdG8gTWlkZW4gbm9kZXMuXG4gKlxuICogQW4gZW5kcG9pbnQgY29uc2lzdHMgb2YgYSBwcm90b2NvbCAoaHR0cC9odHRwcyksIGhvc3QsIGFuZCBvcHRpb25hbCBwb3J0LlxuICogUHJvdmlkZXMgY29udmVuaWVudCBjb25zdHJ1Y3RvcnMgZm9yIGNvbW1vbiBuZXR3b3JrIGNvbmZpZ3VyYXRpb25zLlxuICovXG5jbGFzcyBFbmRwb2ludCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRW5kcG9pbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRW5kcG9pbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRW5kcG9pbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2VuZHBvaW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbmRwb2ludCBmcm9tIGEgVVJMIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHN0cmluZyAoZS5nLiwgPGh0dHBzOi8vbG9jYWxob3N0OjU3MjkxPilcbiAgICAgKiBAdGhyb3dzIHRocm93cyBhbiBlcnJvciBpZiB0aGUgVVJMIGlzIGludmFsaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh1cmwsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmVuZHBvaW50X25ldyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHIwID4+PiAwO1xuICAgICAgICAgICAgRW5kcG9pbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVuZHBvaW50IGZvciB0aGUgTWlkZW4gdGVzdG5ldC5cbiAgICAgKiBAcmV0dXJucyB7RW5kcG9pbnR9XG4gICAgICovXG4gICAgc3RhdGljIHRlc3RuZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5kcG9pbnRfdGVzdG5ldCgpO1xuICAgICAgICByZXR1cm4gRW5kcG9pbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVuZHBvaW50IGZvciB0aGUgTWlkZW4gZGV2bmV0LlxuICAgICAqIEByZXR1cm5zIHtFbmRwb2ludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV2bmV0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVuZHBvaW50X2Rldm5ldCgpO1xuICAgICAgICByZXR1cm4gRW5kcG9pbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVuZHBvaW50IGZvciBhIGxvY2FsIE1pZGVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBVc2VzIDxodHRwOi8vbG9jYWxob3N0OjU3MjkxPlxuICAgICAqIEByZXR1cm5zIHtFbmRwb2ludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9jYWxob3N0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVuZHBvaW50X2xvY2FsaG9zdCgpO1xuICAgICAgICByZXR1cm4gRW5kcG9pbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3RvY29sIG9mIHRoZSBlbmRwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZW5kcG9pbnRfcHJvdG9jb2wocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhvc3Qgb2YgdGhlIGVuZHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGhvc3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmVuZHBvaW50X2hvc3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvcnQgb2YgdGhlIGVuZHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IHBvcnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZW5kcG9pbnRfcG9ydCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDB4RkZGRkZGID8gdW5kZWZpbmVkIDogcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVuZHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmVuZHBvaW50X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRW5kcG9pbnQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEVuZHBvaW50LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBFeGVjdXRlZFRyYW5zYWN0aW9uRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2V4ZWN1dGVkdHJhbnNhY3Rpb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRXhlY3V0ZWRUcmFuc2FjdGlvbiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRXhlY3V0ZWRUcmFuc2FjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFeGVjdXRlZFRyYW5zYWN0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEV4ZWN1dGVkVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2V4ZWN1dGVkdHJhbnNhY3Rpb25fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25JZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgYWNjb3VudElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25fYWNjb3VudElkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRIZWFkZXJ9XG4gICAgICovXG4gICAgaW5pdGlhbEFjY291bnRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9pbml0aWFsQWNjb3VudEhlYWRlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SGVhZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudEhlYWRlcn1cbiAgICAgKi9cbiAgICBmaW5hbEFjY291bnRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9maW5hbEFjY291bnRIZWFkZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudEhlYWRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZXN9XG4gICAgICovXG4gICAgaW5wdXROb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRlZHRyYW5zYWN0aW9uX2lucHV0Tm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gSW5wdXROb3Rlcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVzfVxuICAgICAqL1xuICAgIG91dHB1dE5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25fb3V0cHV0Tm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkFyZ3N9XG4gICAgICovXG4gICAgdHhBcmdzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25fdHhBcmdzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uQXJncy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jsb2NrSGVhZGVyfVxuICAgICAqL1xuICAgIGJsb2NrSGVhZGVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25fYmxvY2tIZWFkZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmxvY2tIZWFkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50RGVsdGF9XG4gICAgICovXG4gICAgYWNjb3VudERlbHRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGVkdHJhbnNhY3Rpb25fYWNjb3VudERlbHRhKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnREZWx0YS5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEV4ZWN1dGVkVHJhbnNhY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEV4ZWN1dGVkVHJhbnNhY3Rpb24ucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZlbHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZmVsdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGZWx0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGZWx0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZlbHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBGZWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGZWx0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mZWx0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZWx0X25ldyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBGZWx0RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgYXNJbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmVsdF9hc0ludCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZmVsdF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZlbHQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZlbHQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZlbHRBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mZWx0YXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRmVsdEFycmF5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGZWx0QXJyYXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRmVsdEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZlbHRBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZmVsdGFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWx0W10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZlbHRhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBGZWx0QXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7RmVsdH1cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mZWx0YXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZlbHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtGZWx0fSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBGZWx0KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uZmVsdGFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWx0fSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBGZWx0KTtcbiAgICAgICAgd2FzbS5mZWx0YXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZWx0YXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZlbHRBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRmVsdEFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGZXRjaGVkTm90ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mZXRjaGVkbm90ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgbm90ZSBmZXRjaGVkIGZyb20gYSBNaWRlbiBub2RlIHZpYSBSUEMuXG4gKi9cbmNsYXNzIEZldGNoZWROb3RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGZXRjaGVkTm90ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGZXRjaGVkTm90ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGZXRjaGVkTm90ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZmV0Y2hlZG5vdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBub3RlIHdpdGggYW4gb3B0aW9uYWwgYElucHV0Tm90ZWAuXG4gICAgICogQHBhcmFtIHtOb3RlSWR9IG5vdGVfaWRcbiAgICAgKiBAcGFyYW0ge05vdGVNZXRhZGF0YX0gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge0lucHV0Tm90ZSB8IG51bGx9IFtpbnB1dF9ub3RlXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vdGVfaWQsIG1ldGFkYXRhLCBpbnB1dF9ub3RlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2lkLCBOb3RlSWQpO1xuICAgICAgICB2YXIgcHRyMCA9IG5vdGVfaWQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhtZXRhZGF0YSwgTm90ZU1ldGFkYXRhKTtcbiAgICAgICAgdmFyIHB0cjEgPSBtZXRhZGF0YS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgbGV0IHB0cjIgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoaW5wdXRfbm90ZSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhpbnB1dF9ub3RlLCBJbnB1dE5vdGUpO1xuICAgICAgICAgICAgcHRyMiA9IGlucHV0X25vdGUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZXRjaGVkbm90ZV9uZXcocHRyMCwgcHRyMSwgcHRyMik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBGZXRjaGVkTm90ZUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIG5vdGUuXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBnZXQgbm90ZUlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZldGNoZWRub3RlX25vdGVJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub3RlJ3MgbWV0YWRhdGEsIGluY2x1ZGluZyBzZW5kZXIsIHRhZywgYW5kIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogQXZhaWxhYmxlIGZvciBib3RoIHByaXZhdGUgYW5kIHB1YmxpYyBub3Rlcy5cbiAgICAgKiBAcmV0dXJucyB7Tm90ZU1ldGFkYXRhfVxuICAgICAqL1xuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZXRjaGVkbm90ZV9tZXRhZGF0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmdWxsIFtgSW5wdXROb3RlYF0gd2l0aCBpbmNsdXNpb24gcHJvb2YuXG4gICAgICpcbiAgICAgKiBGb3IgcHVibGljIG5vdGVzLCBpdCBjb250YWlucyB0aGUgY29tcGxldGUgbm90ZSBkYXRhIGFuZCBpbmNsdXNpb24gcHJvb2YuXG4gICAgICogRm9yIHByaXZhdGUgbm90ZXMsIGl0IHdpbGwgYmUgYGBOb25lYC5cbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3RlIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldCBpbnB1dE5vdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmV0Y2hlZG5vdGVfaW5wdXROb3RlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IElucHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVUeXBlfVxuICAgICAqL1xuICAgIGdldCBub3RlVHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mZXRjaGVkbm90ZV9ub3RlVHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGZXRjaGVkTm90ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gRmV0Y2hlZE5vdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZsYXR0ZW5lZFU4VmVjRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ZsYXR0ZW5lZHU4dmVjX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZsYXR0ZW5lZFU4VmVjIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGbGF0dGVuZWRVOFZlYy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGbGF0dGVuZWRVOFZlY0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGbGF0dGVuZWRVOFZlY0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZmxhdHRlbmVkdTh2ZWNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZsYXR0ZW5lZHU4dmVjX2RhdGEocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDMyQXJyYXl9XG4gICAgICovXG4gICAgbGVuZ3RocygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mbGF0dGVuZWR1OHZlY19sZW5ndGhzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVMzJGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtX2lubmVyX3ZlY3MoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmxhdHRlbmVkdTh2ZWNfbnVtX2lubmVyX3ZlY3ModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRmxhdHRlbmVkVThWZWMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEZsYXR0ZW5lZFU4VmVjLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGb3JlaWduQWNjb3VudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mb3JlaWduYWNjb3VudF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGb3JlaWduQWNjb3VudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRm9yZWlnbkFjY291bnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRm9yZWlnbkFjY291bnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBGb3JlaWduQWNjb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRm9yZWlnbkFjY291bnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ZvcmVpZ25hY2NvdW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzfSBzdG9yYWdlX3JlcXVpcmVtZW50c1xuICAgICAqIEByZXR1cm5zIHtGb3JlaWduQWNjb3VudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgcHVibGljKGFjY291bnRfaWQsIHN0b3JhZ2VfcmVxdWlyZW1lbnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBhY2NvdW50X2lkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JhZ2VfcmVxdWlyZW1lbnRzLCBBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50cyk7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHN0b3JhZ2VfcmVxdWlyZW1lbnRzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5mb3JlaWduYWNjb3VudF9wdWJsaWMocmV0cHRyLCBwdHIwLCBwdHIxKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZvcmVpZ25BY2NvdW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50U3RvcmFnZVJlcXVpcmVtZW50c31cbiAgICAgKi9cbiAgICBzdG9yYWdlX3Nsb3RfcmVxdWlyZW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZvcmVpZ25hY2NvdW50X3N0b3JhZ2Vfc2xvdF9yZXF1aXJlbWVudHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudFN0b3JhZ2VSZXF1aXJlbWVudHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgYWNjb3VudF9pZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mb3JlaWduYWNjb3VudF9hY2NvdW50X2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEZvcmVpZ25BY2NvdW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGb3JlaWduQWNjb3VudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRm9yZWlnbkFjY291bnRBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19mb3JlaWduYWNjb3VudGFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZvcmVpZ25BY2NvdW50QXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGb3JlaWduQWNjb3VudEFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19mb3JlaWduYWNjb3VudGFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGb3JlaWduQWNjb3VudFtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mb3JlaWduYWNjb3VudGFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIEZvcmVpZ25BY2NvdW50QXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Rm9yZWlnbkFjY291bnR9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZm9yZWlnbmFjY291bnRhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRm9yZWlnbkFjY291bnQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtGb3JlaWduQWNjb3VudH0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgRm9yZWlnbkFjY291bnQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5mb3JlaWduYWNjb3VudGFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGb3JlaWduQWNjb3VudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgRm9yZWlnbkFjY291bnQpO1xuICAgICAgICB3YXNtLmZvcmVpZ25hY2NvdW50YXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mb3JlaWduYWNjb3VudGFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGb3JlaWduQWNjb3VudEFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGb3JlaWduQWNjb3VudEFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGdW5naWJsZUFzc2V0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2Z1bmdpYmxlYXNzZXRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgRnVuZ2libGVBc3NldCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRnVuZ2libGVBc3NldC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBGdW5naWJsZUFzc2V0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgRnVuZ2libGVBc3NldCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRnVuZ2libGVBc3NldEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZnVuZ2libGVhc3NldF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBmYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gYW1vdW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmF1Y2V0X2lkLCBhbW91bnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0X25ldyhmYXVjZXRfaWQuX193YmdfcHRyLCBhbW91bnQpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgRnVuZ2libGVBc3NldEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIGZhdWNldElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgYW1vdW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRfYW1vdW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBpbnRvV29yZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0X2ludG9Xb3JkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGdW5naWJsZUFzc2V0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGdW5naWJsZUFzc2V0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBGdW5naWJsZUFzc2V0RGVsdGFGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZnVuZ2libGVhc3NldGRlbHRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEZ1bmdpYmxlQXNzZXREZWx0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoRnVuZ2libGVBc3NldERlbHRhLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXREZWx0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBGdW5naWJsZUFzc2V0RGVsdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2Z1bmdpYmxlYXNzZXRkZWx0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0ZGVsdGFfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtGdW5naWJsZUFzc2V0RGVsdGF9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZnVuZ2libGVhc3NldGRlbHRhX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ1bmdpYmxlQXNzZXREZWx0YS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRkZWx0YV9pc0VtcHR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGZhdWNldF9pZFxuICAgICAqIEByZXR1cm5zIHtiaWdpbnQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgYW1vdW50KGZhdWNldF9pZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgd2FzbS5mdW5naWJsZWFzc2V0ZGVsdGFfYW1vdW50KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGZhdWNldF9pZC5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0QmlnSW50NjQocmV0cHRyICsgOCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHIwID09PSAwID8gdW5kZWZpbmVkIDogcjI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbnVtQXNzZXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZ1bmdpYmxlYXNzZXRkZWx0YV9udW1Bc3NldHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RnVuZ2libGVBc3NldERlbHRhSXRlbVtdfVxuICAgICAqL1xuICAgIGFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5mdW5naWJsZWFzc2V0ZGVsdGFfYXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgRnVuZ2libGVBc3NldERlbHRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGdW5naWJsZUFzc2V0RGVsdGEucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW1GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZnVuZ2libGVhc3NldGRlbHRhaXRlbV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBGdW5naWJsZUFzc2V0RGVsdGFJdGVtIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShGdW5naWJsZUFzc2V0RGVsdGFJdGVtLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW1GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRnVuZ2libGVBc3NldERlbHRhSXRlbUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZnVuZ2libGVhc3NldGRlbHRhaXRlbV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgZ2V0IGZhdWNldElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRkZWx0YV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5mdW5naWJsZWFzc2V0X2Ftb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBGdW5naWJsZUFzc2V0RGVsdGFJdGVtLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBGdW5naWJsZUFzc2V0RGVsdGFJdGVtLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19nZXRwcm9jZWR1cmVzcmVzdWx0aXRlbV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW0ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW1GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW1GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2dldHByb2NlZHVyZXNyZXN1bHRpdGVtX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgZ2V0IGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBpc0F1dGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ2V0cHJvY2VkdXJlc3Jlc3VsdGl0ZW1faXNBdXRoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEdldFByb2NlZHVyZXNSZXN1bHRJdGVtLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBHZXRQcm9jZWR1cmVzUmVzdWx0SXRlbS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSW5wdXROb3RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2lucHV0bm90ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBJbnB1dE5vdGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKElucHV0Tm90ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBJbnB1dE5vdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW5wdXROb3RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbnB1dG5vdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlfVxuICAgICAqL1xuICAgIG5vdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlX25vdGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgY29tbWl0bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUluY2x1c2lvblByb29mIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHByb29mKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZV9wcm9vZih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBOb3RlSW5jbHVzaW9uUHJvb2YuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTG9jYXRpb24gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgbG9jYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlX2xvY2F0aW9uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IE5vdGVMb2NhdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIElucHV0Tm90ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSW5wdXROb3RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBJbnB1dE5vdGVSZWNvcmRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW5wdXRub3RlcmVjb3JkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIElucHV0Tm90ZVJlY29yZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSW5wdXROb3RlUmVjb3JkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIElucHV0Tm90ZVJlY29yZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbnB1dE5vdGVSZWNvcmRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2lucHV0bm90ZXJlY29yZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0lucHV0Tm90ZVN0YXRlfVxuICAgICAqL1xuICAgIHN0YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9zdGF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRGV0YWlsc31cbiAgICAgKi9cbiAgICBkZXRhaWxzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9kZXRhaWxzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVEZXRhaWxzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZU1ldGFkYXRhIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIG1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9tZXRhZGF0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBOb3RlTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW5wdXRub3RlcmVjb3JkX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJbmNsdXNpb25Qcm9vZiB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBpbmNsdXNpb25Qcm9vZigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnB1dG5vdGVyZWNvcmRfaW5jbHVzaW9uUHJvb2YodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTm90ZUluY2x1c2lvblByb29mLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGNvbnN1bWVyVHJhbnNhY3Rpb25JZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5pbnB1dG5vdGVyZWNvcmRfY29uc3VtZXJUcmFuc2FjdGlvbklkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIG51bGxpZmllcigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uaW5wdXRub3RlcmVjb3JkX251bGxpZmllcihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBdXRoZW50aWNhdGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9pc0F1dGhlbnRpY2F0ZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbnN1bWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9pc0NvbnN1bWVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQcm9jZXNzaW5nKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXJlY29yZF9pc1Byb2Nlc3NpbmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3RlfVxuICAgICAqL1xuICAgIHRvSW5wdXROb3RlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmlucHV0bm90ZXJlY29yZF90b0lucHV0Tm90ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElucHV0Tm90ZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSW5wdXROb3RlUmVjb3JkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBJbnB1dE5vdGVSZWNvcmQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IElucHV0Tm90ZXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfaW5wdXRub3Rlc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBJbnB1dE5vdGVzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShJbnB1dE5vdGVzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIElucHV0Tm90ZXNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW5wdXROb3Rlc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfaW5wdXRub3Rlc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudGNvZGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bU5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXNfbnVtTm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXNfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGV9XG4gICAgICovXG4gICAgZ2V0Tm90ZShpbmRleCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmlucHV0bm90ZXNfZ2V0Tm90ZSh0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gSW5wdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb3RlW119XG4gICAgICovXG4gICAgbm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uaW5wdXRub3Rlc19ub3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIElucHV0Tm90ZXMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IElucHV0Tm90ZXMucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEludG9VbmRlcmx5aW5nQnl0ZVNvdXJjZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2VfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgSW50b1VuZGVybHlpbmdCeXRlU291cmNlIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSW50b1VuZGVybHlpbmdCeXRlU291cmNlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2VfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW1UeXBlfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV90eXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIF9fd2JpbmRnZW5fZW51bV9SZWFkYWJsZVN0cmVhbVR5cGVbcmV0XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmludG91bmRlcmx5aW5nYnl0ZXNvdXJjZV9hdXRvQWxsb2NhdGVDaHVua1NpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIHdhc20uaW50b3VuZGVybHlpbmdieXRlc291cmNlX3N0YXJ0KHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGNvbnRyb2xsZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfSBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2VfcHVsbCh0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChjb250cm9sbGVyKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5pbnRvdW5kZXJseWluZ2J5dGVzb3VyY2VfY2FuY2VsKHB0cik7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBJbnRvVW5kZXJseWluZ0J5dGVTb3VyY2UucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEludG9VbmRlcmx5aW5nQnl0ZVNvdXJjZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSW50b1VuZGVybHlpbmdTaW5rRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2ludG91bmRlcmx5aW5nc2lua19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBJbnRvVW5kZXJseWluZ1Npbmsge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBJbnRvVW5kZXJseWluZ1NpbmtGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2ludG91bmRlcmx5aW5nc2lua19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBjaHVua1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ3Npbmtfd3JpdGUodGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoY2h1bmspKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5pbnRvdW5kZXJseWluZ3NpbmtfY2xvc2UocHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IHJlYXNvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYWJvcnQocmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdzaW5rX2Fib3J0KHB0ciwgYWRkSGVhcE9iamVjdChyZWFzb24pKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEludG9VbmRlcmx5aW5nU2luay5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSW50b1VuZGVybHlpbmdTaW5rLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBJbnRvVW5kZXJseWluZ1NvdXJjZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19pbnRvdW5kZXJseWluZ3NvdXJjZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBJbnRvVW5kZXJseWluZ1NvdXJjZSB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEludG9VbmRlcmx5aW5nU291cmNlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19pbnRvdW5kZXJseWluZ3NvdXJjZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcn0gY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uaW50b3VuZGVybHlpbmdzb3VyY2VfcHVsbCh0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChjb250cm9sbGVyKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5pbnRvdW5kZXJseWluZ3NvdXJjZV9jYW5jZWwocHRyKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEludG9VbmRlcmx5aW5nU291cmNlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBJbnRvVW5kZXJseWluZ1NvdXJjZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSnNBY2NvdW50VXBkYXRlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2pzYWNjb3VudHVwZGF0ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIHVwZGF0ZSB0byBhIHNpbmdsZSBhY2NvdW50J3Mgc3RhdGUuXG4gKi9cbmNsYXNzIEpzQWNjb3VudFVwZGF0ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSnNBY2NvdW50VXBkYXRlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEpzQWNjb3VudFVwZGF0ZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEpzQWNjb3VudFVwZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3JhZ2VSb290OiB0aGlzLnN0b3JhZ2VSb290LFxuICAgICAgICAgICAgc3RvcmFnZVNsb3RzOiB0aGlzLnN0b3JhZ2VTbG90cyxcbiAgICAgICAgICAgIHN0b3JhZ2VNYXBFbnRyaWVzOiB0aGlzLnN0b3JhZ2VNYXBFbnRyaWVzLFxuICAgICAgICAgICAgYXNzZXRWYXVsdFJvb3Q6IHRoaXMuYXNzZXRWYXVsdFJvb3QsXG4gICAgICAgICAgICBhc3NldHM6IHRoaXMuYXNzZXRzLFxuICAgICAgICAgICAgYWNjb3VudElkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGNvZGVSb290OiB0aGlzLmNvZGVSb290LFxuICAgICAgICAgICAgY29tbWl0dGVkOiB0aGlzLmNvbW1pdHRlZCxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgYWNjb3VudENvbW1pdG1lbnQ6IHRoaXMuYWNjb3VudENvbW1pdG1lbnQsXG4gICAgICAgICAgICBhY2NvdW50U2VlZDogdGhpcy5hY2NvdW50U2VlZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSnNBY2NvdW50VXBkYXRlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc2FjY291bnR1cGRhdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIGFjY291bnQncyBzdG9yYWdlIHRyaWUuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZVJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgYWNjb3VudCdzIHN0b3JhZ2UgdHJpZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdG9yYWdlUm9vdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgc3RvcmFnZSBzbG90IGRhdGEgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7SnNTdG9yYWdlU2xvdFtdfVxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlU2xvdHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlU2xvdHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZWQgc3RvcmFnZSBzbG90IGRhdGEgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0ge0pzU3RvcmFnZVNsb3RbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdG9yYWdlU2xvdHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlU2xvdHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVkIHN0b3JhZ2UgbWFwIGVudHJpZXMgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7SnNTdG9yYWdlTWFwRW50cnlbXX1cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZU1hcEVudHJpZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlTWFwRW50cmllcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplZCBzdG9yYWdlIG1hcCBlbnRyaWVzIGZvciB0aGlzIGFjY291bnQuXG4gICAgICogQHBhcmFtIHtKc1N0b3JhZ2VNYXBFbnRyeVtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0b3JhZ2VNYXBFbnRyaWVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZU1hcEVudHJpZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIGFjY291bnQncyBhc3NldCB2YXVsdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBhc3NldFZhdWx0Um9vdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hc3NldFZhdWx0Um9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lcmtsZSByb290IG9mIHRoZSBhY2NvdW50J3MgYXNzZXQgdmF1bHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYXNzZXRWYXVsdFJvb3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYXNzZXRWYXVsdFJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjb3VudCdzIGFzc2V0IHZhdWx0LlxuICAgICAqIEByZXR1cm5zIHtKc1ZhdWx0QXNzZXRbXX1cbiAgICAgKi9cbiAgICBnZXQgYXNzZXRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjb3VudCdzIGFzc2V0IHZhdWx0LlxuICAgICAqIEBwYXJhbSB7SnNWYXVsdEFzc2V0W119IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYXNzZXRzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYXNzZXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSUQgZm9yIHRoaXMgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBhY2NvdW50SWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudElkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJRCBmb3IgdGhpcyBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGFjY291bnRJZChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50SWQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIGFjY291bnQncyBleGVjdXRhYmxlIGNvZGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY29kZVJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfY29kZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgYWNjb3VudCdzIGV4ZWN1dGFibGUgY29kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBjb2RlUm9vdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9jb2RlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBhY2NvdW50IHVwZGF0ZSBoYXMgYmVlbiBjb21taXR0ZWQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNvbW1pdHRlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2NvbW1pdHRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBhY2NvdW50IHVwZGF0ZSBoYXMgYmVlbiBjb21taXR0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNvbW1pdHRlZChhcmcwKSB7XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9jb21taXR0ZWQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjb3VudCdzIHRyYW5zYWN0aW9uIG5vbmNlIGFzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5vbmNlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX25vbmNlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjb3VudCdzIHRyYW5zYWN0aW9uIG5vbmNlIGFzIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vbmNlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX25vbmNlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNyeXB0b2dyYXBoaWMgY29tbWl0bWVudCByZXByZXNlbnRpbmcgdGhpcyBhY2NvdW50J3MgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBhY2NvdW50Q29tbWl0bWVudCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50Q29tbWl0bWVudChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNyeXB0b2dyYXBoaWMgY29tbWl0bWVudCByZXByZXNlbnRpbmcgdGhpcyBhY2NvdW50J3MgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBhY2NvdW50Q29tbWl0bWVudChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50Q29tbWl0bWVudCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIHNlZWQgZGF0YSBmb3IgdGhlIGFjY291bnQuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IGFjY291bnRTZWVkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfYWNjb3VudFNlZWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBzZWVkIGRhdGEgZm9yIHRoZSBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFthcmcwXVxuICAgICAqL1xuICAgIHNldCBhY2NvdW50U2VlZChhcmcwKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhcmcwKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50U2VlZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBKc0FjY291bnRVcGRhdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEpzQWNjb3VudFVwZGF0ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSnNTdGF0ZVN5bmNVcGRhdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfanNzdGF0ZXN5bmN1cGRhdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZGF0YSBmb3IgYSBzeW5jIHVwZGF0ZSxcbiAqIHdoaWNoIHdpbGwgYmUgcmVjZWl2ZWQgYnkgdGhlIGFwcGx5U3RhdGVTeW5jIEpTIGZ1bmN0aW9uLlxuICogdW5kZXIgc3luYy5qc1xuICovXG5jbGFzcyBKc1N0YXRlU3luY1VwZGF0ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSnNTdGF0ZVN5bmNVcGRhdGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgSnNTdGF0ZVN5bmNVcGRhdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSnNTdGF0ZVN5bmNVcGRhdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2pzc3RhdGVzeW5jdXBkYXRlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NrIG51bWJlciBmb3IgdGhpcyB1cGRhdGUsIHN0b3JlZCBhcyBhIHN0cmluZyBzaW5jZSBpdCB3aWxsIGJlXG4gICAgICogcGVyc2lzdGVkIGluIGBJbmRleGVkREJgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGJsb2NrTnVtKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2sgbnVtYmVyIGZvciB0aGlzIHVwZGF0ZSwgc3RvcmVkIGFzIGEgc3RyaW5nIHNpbmNlIGl0IHdpbGwgYmVcbiAgICAgKiBwZXJzaXN0ZWQgaW4gYEluZGV4ZWREQmAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYmxvY2tOdW0oYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGJsb2NrIGhlYWRlcnMgZm9yIHRoaXMgc3RhdGUgdXBkYXRlLCBzZXJpYWxpemVkIGludG8gYSBmbGF0dGVuZWQgYnl0ZSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RmxhdHRlbmVkVThWZWN9XG4gICAgICovXG4gICAgZ2V0IGZsYXR0ZW5lZE5ld0Jsb2NrSGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfZmxhdHRlbmVkTmV3QmxvY2tIZWFkZXJzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZsYXR0ZW5lZFU4VmVjLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGJsb2NrIGhlYWRlcnMgZm9yIHRoaXMgc3RhdGUgdXBkYXRlLCBzZXJpYWxpemVkIGludG8gYSBmbGF0dGVuZWQgYnl0ZSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0ZsYXR0ZW5lZFU4VmVjfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGZsYXR0ZW5lZE5ld0Jsb2NrSGVhZGVycyhhcmcwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhcmcwLCBGbGF0dGVuZWRVOFZlYyk7XG4gICAgICAgIHZhciBwdHIwID0gYXJnMC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfZmxhdHRlbmVkTmV3QmxvY2tIZWFkZXJzKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NrIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byBlYWNoIGhlYWRlciBpbiBgZmxhdHRlbmVkX25ld19ibG9ja19oZWFkZXJzYC5cbiAgICAgKiBUaGlzIHZlYyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBoZWFkZXJzLCB3aXRoIGVhY2ggaW5kZXhcbiAgICAgKiByZXByZXNlbnRpbmcgdGhlIGJsb2NrIG51bWJlciBmb3IgdGhlIGhlYWRlciBhdCB0aGF0IHNhbWUgaW5kZXguXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldCBuZXdCbG9ja051bXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX25ld0Jsb2NrTnVtcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NrIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byBlYWNoIGhlYWRlciBpbiBgZmxhdHRlbmVkX25ld19ibG9ja19oZWFkZXJzYC5cbiAgICAgKiBUaGlzIHZlYyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBoZWFkZXJzLCB3aXRoIGVhY2ggaW5kZXhcbiAgICAgKiByZXByZXNlbnRpbmcgdGhlIGJsb2NrIG51bWJlciBmb3IgdGhlIGhlYWRlciBhdCB0aGF0IHNhbWUgaW5kZXguXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBuZXdCbG9ja051bXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX25ld0Jsb2NrTnVtcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5lZCBieXRlIGFycmF5IGNvbnRhaW5pbmcgcGFydGlhbCBibG9ja2NoYWluIHBlYWtzIHVzZWQgZm9yIG1lcmtsZSB0cmVlXG4gICAgICogdmVyaWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGbGF0dGVuZWRVOFZlY31cbiAgICAgKi9cbiAgICBnZXQgZmxhdHRlbmVkUGFydGlhbEJsb2NrQ2hhaW5QZWFrcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfZmxhdHRlbmVkUGFydGlhbEJsb2NrQ2hhaW5QZWFrcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGbGF0dGVuZWRVOFZlYy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhdHRlbmVkIGJ5dGUgYXJyYXkgY29udGFpbmluZyBwYXJ0aWFsIGJsb2NrY2hhaW4gcGVha3MgdXNlZCBmb3IgbWVya2xlIHRyZWVcbiAgICAgKiB2ZXJpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtGbGF0dGVuZWRVOFZlY30gYXJnMFxuICAgICAqL1xuICAgIHNldCBmbGF0dGVuZWRQYXJ0aWFsQmxvY2tDaGFpblBlYWtzKGFyZzApIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFyZzAsIEZsYXR0ZW5lZFU4VmVjKTtcbiAgICAgICAgdmFyIHB0cjAgPSBhcmcwLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9mbGF0dGVuZWRQYXJ0aWFsQmxvY2tDaGFpblBlYWtzKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggYmxvY2sgaW4gdGhpcyB1cGRhdGUsIHN0b3JlcyBhIGJvb2xlYW4gKGFzIHU4KSBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICAgKiB0aGF0IGJsb2NrIGNvbnRhaW5zIG5vdGVzIHJlbGV2YW50IHRvIHRoaXMgY2xpZW50LiBJbmRleCBpIGNvcnJlc3BvbmRzIHRvXG4gICAgICogdGhlIGl0aCBibG9jaywgd2l0aCAxIG1lYW5pbmcgcmVsZXZhbnQgYW5kIDAgbWVhbmluZyBub3QgcmVsZXZhbnQuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGJsb2NrSGFzUmVsZXZhbnROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfYmxvY2tIYXNSZWxldmFudE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggYmxvY2sgaW4gdGhpcyB1cGRhdGUsIHN0b3JlcyBhIGJvb2xlYW4gKGFzIHU4KSBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICAgKiB0aGF0IGJsb2NrIGNvbnRhaW5zIG5vdGVzIHJlbGV2YW50IHRvIHRoaXMgY2xpZW50LiBJbmRleCBpIGNvcnJlc3BvbmRzIHRvXG4gICAgICogdGhlIGl0aCBibG9jaywgd2l0aCAxIG1lYW5pbmcgcmVsZXZhbnQgYW5kIDAgbWVhbmluZyBub3QgcmVsZXZhbnQuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IGJsb2NrSGFzUmVsZXZhbnROb3RlcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfYmxvY2tIYXNSZWxldmFudE5vdGVzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplZCBJRHMgZm9yIG5ldyBhdXRoZW50aWNhdGlvbiBub2RlcyByZXF1aXJlZCB0byB2ZXJpZnkgYmxvY2sgaGVhZGVycy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWROb2RlSWRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkTm9kZUlkcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplZCBJRHMgZm9yIG5ldyBhdXRoZW50aWNhdGlvbiBub2RlcyByZXF1aXJlZCB0byB2ZXJpZnkgYmxvY2sgaGVhZGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlcmlhbGl6ZWROb2RlSWRzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkTm9kZUlkcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY3R1YWwgYXV0aGVudGljYXRpb24gbm9kZSBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdGhlIElEcyBhYm92ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWROb2RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZE5vZGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWN0dWFsIGF1dGhlbnRpY2F0aW9uIG5vZGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHRoZSBJRHMgYWJvdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzZXJpYWxpemVkTm9kZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWROb2Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElEcyBvZiBub3RlIHRhZ3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjbGllbnQncyBsb2NhbCBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IGNvbW1pdHRlZE5vdGVJZHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RhdGVzeW5jdXBkYXRlX2NvbW1pdHRlZE5vdGVJZHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElEcyBvZiBub3RlIHRhZ3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjbGllbnQncyBsb2NhbCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNvbW1pdHRlZE5vdGVJZHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX2NvbW1pdHRlZE5vdGVJZHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnB1dCBub3RlcyBmb3IgdGhpcyBzdGF0ZSB1cGRhdGUgaW4gc2VyaWFsaXplZCBmb3JtLlxuICAgICAqIEByZXR1cm5zIHtTZXJpYWxpemVkSW5wdXROb3RlRGF0YVtdfVxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkSW5wdXROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZElucHV0Tm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElucHV0IG5vdGVzIGZvciB0aGlzIHN0YXRlIHVwZGF0ZSBpbiBzZXJpYWxpemVkIGZvcm0uXG4gICAgICogQHBhcmFtIHtTZXJpYWxpemVkSW5wdXROb3RlRGF0YVtdfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlcmlhbGl6ZWRJbnB1dE5vdGVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0YXRlc3luY3VwZGF0ZV9zZXJpYWxpemVkSW5wdXROb3Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91dHB1dCBub3RlcyBjcmVhdGVkIGluIHRoaXMgc3RhdGUgdXBkYXRlIGluIHNlcmlhbGl6ZWQgZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7U2VyaWFsaXplZE91dHB1dE5vdGVEYXRhW119XG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWRPdXRwdXROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfc2VyaWFsaXplZE91dHB1dE5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgbm90ZXMgY3JlYXRlZCBpbiB0aGlzIHN0YXRlIHVwZGF0ZSBpbiBzZXJpYWxpemVkIGZvcm0uXG4gICAgICogQHBhcmFtIHtTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGFbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzZXJpYWxpemVkT3V0cHV0Tm90ZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX3NlcmlhbGl6ZWRPdXRwdXROb3Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY291bnQgc3RhdGUgdXBkYXRlcyBpbmNsdWRlZCBpbiB0aGlzIHN5bmMuXG4gICAgICogQHJldHVybnMge0pzQWNjb3VudFVwZGF0ZVtdfVxuICAgICAqL1xuICAgIGdldCBhY2NvdW50VXBkYXRlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdGF0ZXN5bmN1cGRhdGVfYWNjb3VudFVwZGF0ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY291bnQgc3RhdGUgdXBkYXRlcyBpbmNsdWRlZCBpbiB0aGlzIHN5bmMuXG4gICAgICogQHBhcmFtIHtKc0FjY291bnRVcGRhdGVbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBhY2NvdW50VXBkYXRlcyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdGF0ZXN5bmN1cGRhdGVfYWNjb3VudFVwZGF0ZXModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2FjdGlvbiBkYXRhIGZvciB0cmFuc2FjdGlvbnMgaW5jbHVkZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgICogQHJldHVybnMge1NlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFbXX1cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25VcGRhdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0YXRlc3luY3VwZGF0ZV90cmFuc2FjdGlvblVwZGF0ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zYWN0aW9uIGRhdGEgZm9yIHRyYW5zYWN0aW9ucyBpbmNsdWRlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1NlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFbXX0gYXJnMFxuICAgICAqL1xuICAgIHNldCB0cmFuc2FjdGlvblVwZGF0ZXMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RhdGVzeW5jdXBkYXRlX3RyYW5zYWN0aW9uVXBkYXRlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBKc1N0YXRlU3luY1VwZGF0ZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gSnNTdGF0ZVN5bmNVcGRhdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEpzU3RvcmFnZU1hcEVudHJ5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2pzc3RvcmFnZW1hcGVudHJ5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBhIHN0b3JhZ2UgbWFwIGVudHJ5IGluIGFuIGFjY291bnQuXG4gKi9cbmNsYXNzIEpzU3RvcmFnZU1hcEVudHJ5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKc1N0b3JhZ2VNYXBFbnRyeS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBKc1N0b3JhZ2VNYXBFbnRyeUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEpzU3RvcmFnZU1hcEVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBKc1N0b3JhZ2VNYXBFbnRyeUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNzdG9yYWdlbWFwZW50cnlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vdCBvZiB0aGUgc3RvcmFnZSBtYXAgZW50cnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3Qgb2YgdGhlIHN0b3JhZ2UgbWFwIGVudHJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHJvb3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IG9mIHRoZSBzdG9yYWdlIG1hcCBlbnRyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV9rZXkocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgb2YgdGhlIHN0b3JhZ2UgbWFwIGVudHJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGtleShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X2tleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RvcmFnZSBtYXAgZW50cnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBzdG9yYWdlIG1hcCBlbnRyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCB2YWx1ZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEpzU3RvcmFnZU1hcEVudHJ5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBKc1N0b3JhZ2VNYXBFbnRyeS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgSnNTdG9yYWdlU2xvdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19qc3N0b3JhZ2VzbG90X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiBhIHN0b3JhZ2Ugc2xvdCBpbiBhbiBhY2NvdW50LlxuICovXG5jbGFzcyBKc1N0b3JhZ2VTbG90IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShKc1N0b3JhZ2VTbG90LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEpzU3RvcmFnZVNsb3RGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBKc1N0b3JhZ2VTbG90KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50LFxuICAgICAgICAgICAgc2xvdEluZGV4OiB0aGlzLnNsb3RJbmRleCxcbiAgICAgICAgICAgIHNsb3RWYWx1ZTogdGhpcy5zbG90VmFsdWUsXG4gICAgICAgICAgICBzbG90VHlwZTogdGhpcy5zbG90VHlwZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSnNTdG9yYWdlU2xvdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfanNzdG9yYWdlc2xvdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdG1lbnQgb2YgdGhlIHdob2xlIGFjY291bnQgc3RvcmFnZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdG1lbnQgb2YgdGhlIHdob2xlIGFjY291bnQgc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IGNvbW1pdG1lbnQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHN0b3JhZ2Ugc2xvdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzbG90SW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZXNsb3Rfc2xvdEluZGV4KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBzdG9yYWdlIHNsb3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2xvdEluZGV4KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlc2xvdF9zbG90SW5kZXgodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgc3RvcmVkIGluIHRoZSBzdG9yYWdlIHNsb3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc2xvdFZhbHVlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfa2V5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgc3RvcmVkIGluIHRoZSBzdG9yYWdlIHNsb3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2xvdFZhbHVlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHN0b3JhZ2Ugc2xvdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzbG90VHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlc2xvdF9zbG90VHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzdG9yYWdlIHNsb3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc2xvdFR5cGUoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VzbG90X3Nsb3RUeXBlKHRoaXMuX193YmdfcHRyLCBhcmcwKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIEpzU3RvcmFnZVNsb3QucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IEpzU3RvcmFnZVNsb3QucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IEpzVmF1bHRBc3NldEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19qc3ZhdWx0YXNzZXRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzZXJpYWxpemVkIHZhdWx0IGFzc2V0XG4gKi9cbmNsYXNzIEpzVmF1bHRBc3NldCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoSnNWYXVsdEFzc2V0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEpzVmF1bHRBc3NldEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIEpzVmF1bHRBc3NldCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgICAgIHZhdWx0S2V5OiB0aGlzLnZhdWx0S2V5LFxuICAgICAgICAgICAgZmF1Y2V0SWRQcmVmaXg6IHRoaXMuZmF1Y2V0SWRQcmVmaXgsXG4gICAgICAgICAgICBhc3NldDogdGhpcy5hc3NldCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgSnNWYXVsdEFzc2V0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19qc3ZhdWx0YXNzZXRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWVya2xlIHJvb3Qgb2YgdGhlIHZhdWx0J3MgYXNzZXRzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXJrbGUgcm9vdCBvZiB0aGUgdmF1bHQncyBhc3NldHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgcm9vdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2YXVsdCBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBhc3NldC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB2YXVsdEtleSgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzc3RvcmFnZW1hcGVudHJ5X2tleShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZhdWx0IGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIGFzc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHZhdWx0S2V5KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNzdG9yYWdlbWFwZW50cnlfa2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzZXQncyBmYXVjZXQgSUQgcHJlZml4LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZhdWNldElkUHJlZml4KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2V0J3MgZmF1Y2V0IElEIHByZWZpeC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBmYXVjZXRJZFByZWZpeChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV29yZCByZXByZXNlbnRpbmcgdGhlIGFzc2V0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGFzc2V0KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX2Fzc2V0VmF1bHRSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXb3JkIHJlcHJlc2VudGluZyB0aGUgYXNzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYXNzZXQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfYXNzZXRWYXVsdFJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgSnNWYXVsdEFzc2V0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBKc1ZhdWx0QXNzZXQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IExpYnJhcnlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfbGlicmFyeV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBMaWJyYXJ5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShMaWJyYXJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIExpYnJhcnlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTGlicmFyeUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfbGlicmFyeV9mcmVlKHB0ciwgMCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBMaWJyYXJ5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBMaWJyYXJ5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBNZXJrbGVQYXRoRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX21lcmtsZXBhdGhfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTWVya2xlUGF0aCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTWVya2xlUGF0aC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBNZXJrbGVQYXRoRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE1lcmtsZVBhdGhGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX21lcmtsZXBhdGhfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGRlcHRoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1lcmtsZXBhdGhfZGVwdGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqL1xuICAgIG5vZGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm1lcmtsZXBhdGhfbm9kZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBpbmRleFxuICAgICAqIEBwYXJhbSB7V29yZH0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbXB1dGVSb290KGluZGV4LCBub2RlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub2RlLCBXb3JkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZXJrbGVwYXRoX2NvbXB1dGVSb290KHRoaXMuX193YmdfcHRyLCBpbmRleCwgbm9kZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IGluZGV4XG4gICAgICogQHBhcmFtIHtXb3JkfSBub2RlXG4gICAgICogQHBhcmFtIHtXb3JkfSByb290XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmVyaWZ5KGluZGV4LCBub2RlLCByb290KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub2RlLCBXb3JkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJvb3QsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1lcmtsZXBhdGhfdmVyaWZ5KHRoaXMuX193YmdfcHRyLCBpbmRleCwgbm9kZS5fX3diZ19wdHIsIHJvb3QuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE1lcmtsZVBhdGgucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE1lcmtsZVBhdGgucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUFzc2V0c30gbm90ZV9hc3NldHNcbiAgICAgKiBAcGFyYW0ge05vdGVNZXRhZGF0YX0gbm90ZV9tZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7Tm90ZVJlY2lwaWVudH0gbm90ZV9yZWNpcGllbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlX2Fzc2V0cywgbm90ZV9tZXRhZGF0YSwgbm90ZV9yZWNpcGllbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfYXNzZXRzLCBOb3RlQXNzZXRzKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfbWV0YWRhdGEsIE5vdGVNZXRhZGF0YSk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX3JlY2lwaWVudCwgTm90ZVJlY2lwaWVudCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9uZXcobm90ZV9hc3NldHMuX193YmdfcHRyLCBub3RlX21ldGFkYXRhLl9fd2JnX3B0ciwgbm90ZV9yZWNpcGllbnQuX193YmdfcHRyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtOb3RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUlkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfY29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZU1ldGFkYXRhfVxuICAgICAqL1xuICAgIG1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfbWV0YWRhdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZU1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVJlY2lwaWVudH1cbiAgICAgKi9cbiAgICByZWNpcGllbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9yZWNpcGllbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVJlY2lwaWVudC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVBc3NldHN9XG4gICAgICovXG4gICAgYXNzZXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVfYXNzZXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVBc3NldHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIHNjcmlwdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlX3NjcmlwdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gc2VuZGVyXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Tm90ZUFzc2V0c30gYXNzZXRzXG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtGZWx0fSBhdXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUDJJRE5vdGUoc2VuZGVyLCB0YXJnZXQsIGFzc2V0cywgbm90ZV90eXBlLCBhdXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNlbmRlciwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0YXJnZXQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXNzZXRzLCBOb3RlQXNzZXRzKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhdXgsIEZlbHQpO1xuICAgICAgICAgICAgd2FzbS5ub3RlX2NyZWF0ZVAySUROb3RlKHJldHB0ciwgc2VuZGVyLl9fd2JnX3B0ciwgdGFyZ2V0Ll9fd2JnX3B0ciwgYXNzZXRzLl9fd2JnX3B0ciwgbm90ZV90eXBlLCBhdXguX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHNlbmRlclxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge05vdGVBc3NldHN9IGFzc2V0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gcmVjbGFpbV9oZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHRpbWVsb2NrX2hlaWdodFxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7RmVsdH0gYXV4XG4gICAgICogQHJldHVybnMge05vdGV9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVAySURFTm90ZShzZW5kZXIsIHRhcmdldCwgYXNzZXRzLCByZWNsYWltX2hlaWdodCwgdGltZWxvY2tfaGVpZ2h0LCBub3RlX3R5cGUsIGF1eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VuZGVyLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRhcmdldCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhc3NldHMsIE5vdGVBc3NldHMpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGF1eCwgRmVsdCk7XG4gICAgICAgICAgICB3YXNtLm5vdGVfY3JlYXRlUDJJREVOb3RlKHJldHB0ciwgc2VuZGVyLl9fd2JnX3B0ciwgdGFyZ2V0Ll9fd2JnX3B0ciwgYXNzZXRzLl9fd2JnX3B0ciwgaXNMaWtlTm9uZShyZWNsYWltX2hlaWdodCkgPyAweDEwMDAwMDAwMSA6IChyZWNsYWltX2hlaWdodCkgPj4+IDAsIGlzTGlrZU5vbmUodGltZWxvY2tfaGVpZ2h0KSA/IDB4MTAwMDAwMDAxIDogKHRpbWVsb2NrX2hlaWdodCkgPj4+IDAsIG5vdGVfdHlwZSwgYXV4Ll9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlQW5kQXJnc0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlYW5kYXJnc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlQW5kQXJncyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUFuZEFyZ3MucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUFuZEFyZ3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBOb3RlQW5kQXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUFuZEFyZ3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVhbmRhcmdzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlfSBub3RlXG4gICAgICogQHBhcmFtIHtXb3JkIHwgbnVsbH0gW2FyZ3NdXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZSwgYXJncykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZSwgTm90ZSk7XG4gICAgICAgIHZhciBwdHIwID0gbm90ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgbGV0IHB0cjEgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYXJncykpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhcmdzLCBXb3JkKTtcbiAgICAgICAgICAgIHB0cjEgPSBhcmdzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWFuZGFyZ3NfbmV3KHB0cjAsIHB0cjEpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUFuZEFyZ3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVBbmRBcmdzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlQW5kQXJncy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUFuZEFyZ3NBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlYW5kYXJnc2FycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVBbmRBcmdzQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlQW5kQXJnc0FycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlYW5kYXJnc2FycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlQW5kQXJnc1tdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlYW5kYXJnc2FycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVBbmRBcmdzQXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUFuZEFyZ3N9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWFuZGFyZ3NhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZUFuZEFyZ3MuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOb3RlQW5kQXJnc30gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgTm90ZUFuZEFyZ3MpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5ub3RlYW5kYXJnc2FycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlQW5kQXJnc30gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgTm90ZUFuZEFyZ3MpO1xuICAgICAgICB3YXNtLm5vdGVhbmRhcmdzYXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlYW5kYXJnc2FycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlQW5kQXJnc0FycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlQW5kQXJnc0FycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlQXNzZXRzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVhc3NldHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUFzc2V0cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUFzc2V0cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlQXNzZXRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVBc3NldHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVhc3NldHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmdpYmxlQXNzZXRbXSB8IG51bGx9IFthc3NldHNfYXJyYXldXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXNzZXRzX2FycmF5KSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShhc3NldHNfYXJyYXkpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGFzc2V0c19hcnJheSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVhc3NldHNfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUFzc2V0c0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmdpYmxlQXNzZXR9IGFzc2V0XG4gICAgICovXG4gICAgcHVzaChhc3NldCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXNzZXQsIEZ1bmdpYmxlQXNzZXQpO1xuICAgICAgICB3YXNtLm5vdGVhc3NldHNfcHVzaCh0aGlzLl9fd2JnX3B0ciwgYXNzZXQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Z1bmdpYmxlQXNzZXRbXX1cbiAgICAgKi9cbiAgICBmdW5naWJsZUFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlYXNzZXRzX2Z1bmdpYmxlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUFzc2V0cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUFzc2V0cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUNvbnN1bWFiaWxpdHlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWNvbnN1bWFiaWxpdHlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUNvbnN1bWFiaWxpdHkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVDb25zdW1hYmlsaXR5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVDb25zdW1hYmlsaXR5RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgTm90ZUNvbnN1bWFiaWxpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVDb25zdW1hYmlsaXR5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlY29uc3VtYWJpbGl0eV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgYWNjb3VudElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVjb25zdW1hYmlsaXR5X2FjY291bnRJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgY29uc3VtYWJsZUFmdGVyQmxvY2soKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWNvbnN1bWFiaWxpdHlfY29uc3VtYWJsZUFmdGVyQmxvY2sodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAweDEwMDAwMDAwMSA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVDb25zdW1hYmlsaXR5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlQ29uc3VtYWJpbGl0eS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZURldGFpbHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWRldGFpbHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZURldGFpbHMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVEZXRhaWxzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVEZXRhaWxzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVEZXRhaWxzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZGV0YWlsc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUFzc2V0c30gbm90ZV9hc3NldHNcbiAgICAgKiBAcGFyYW0ge05vdGVSZWNpcGllbnR9IG5vdGVfcmVjaXBpZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZV9hc3NldHMsIG5vdGVfcmVjaXBpZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2Fzc2V0cywgTm90ZUFzc2V0cyk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX3JlY2lwaWVudCwgTm90ZVJlY2lwaWVudCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNfbmV3KG5vdGVfYXNzZXRzLl9fd2JnX3B0ciwgbm90ZV9yZWNpcGllbnQuX193YmdfcHRyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVEZXRhaWxzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNfaWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUlkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUFzc2V0c31cbiAgICAgKi9cbiAgICBhc3NldHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNfYXNzZXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVBc3NldHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlUmVjaXBpZW50fVxuICAgICAqL1xuICAgIHJlY2lwaWVudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZGV0YWlsc19yZWNpcGllbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVJlY2lwaWVudC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVEZXRhaWxzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRGV0YWlscy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZURldGFpbHNBbmRUYWdGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWRldGFpbHNhbmR0YWdfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZURldGFpbHNBbmRUYWcge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVEZXRhaWxzQW5kVGFnLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVEZXRhaWxzQW5kVGFnRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgTm90ZURldGFpbHNBbmRUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVEZXRhaWxzQW5kVGFnRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZGV0YWlsc2FuZHRhZ19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZURldGFpbHN9IG5vdGVfZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7Tm90ZVRhZ30gdGFnXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZV9kZXRhaWxzLCB0YWcpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfZGV0YWlscywgTm90ZURldGFpbHMpO1xuICAgICAgICB2YXIgcHRyMCA9IG5vdGVfZGV0YWlscy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRhZywgTm90ZVRhZyk7XG4gICAgICAgIHZhciBwdHIxID0gdGFnLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnX25ldyhwdHIwLCBwdHIxKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVEZXRhaWxzQW5kVGFnRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRGV0YWlsc31cbiAgICAgKi9cbiAgICBnZXQgbm90ZURldGFpbHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNhbmR0YWdfbm90ZURldGFpbHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZURldGFpbHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNhbmR0YWdfdGFnKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlRGV0YWlsc0FuZFRhZy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZURldGFpbHNBbmRUYWcucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVEZXRhaWxzQW5kVGFnQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWRldGFpbHNhbmR0YWdhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZURldGFpbHNBbmRUYWdBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWRldGFpbHNhbmR0YWdhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZURldGFpbHNBbmRUYWdbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNhbmR0YWdhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge05vdGVEZXRhaWxzQW5kVGFnfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVEZXRhaWxzQW5kVGFnLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Tm90ZURldGFpbHNBbmRUYWd9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIE5vdGVEZXRhaWxzQW5kVGFnKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ubm90ZWRldGFpbHNhbmR0YWdhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZURldGFpbHNBbmRUYWd9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIE5vdGVEZXRhaWxzQW5kVGFnKTtcbiAgICAgICAgd2FzbS5ub3RlZGV0YWlsc2FuZHRhZ2FycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWRldGFpbHNhbmR0YWdhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZURldGFpbHNBbmRUYWdBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZURldGFpbHNBbmRUYWdBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUV4ZWN1dGlvbkhpbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWV4ZWN1dGlvbmhpbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUV4ZWN1dGlvbkhpbnQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVFeGVjdXRpb25IaW50LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVFeGVjdXRpb25IaW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVFeGVjdXRpb25IaW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZXhlY3V0aW9uaGludF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uSGludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbm9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZXhlY3V0aW9uaGludF9ub25lKCk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uSGludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25IaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBhbHdheXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWV4ZWN1dGlvbmhpbnRfYWx3YXlzKCk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uSGludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrX251bVxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uSGludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgYWZ0ZXJCbG9jayhibG9ja19udW0pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZXhlY3V0aW9uaGludF9hZnRlckJsb2NrKGJsb2NrX251bSk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uSGludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVwb2NoX2xlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90X2xlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG90X29mZnNldFxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uSGludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgb25CbG9ja1Nsb3QoZXBvY2hfbGVuLCBzbG90X2xlbiwgc2xvdF9vZmZzZXQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZXhlY3V0aW9uaGludF9vbkJsb2NrU2xvdChlcG9jaF9sZW4sIHNsb3RfbGVuLCBzbG90X29mZnNldCk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uSGludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkXG4gICAgICogQHJldHVybnMge05vdGVFeGVjdXRpb25IaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGFydHModGFnLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWV4ZWN1dGlvbmhpbnRfZnJvbVBhcnRzKHRhZywgcGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uSGludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrX251bVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkJlQ29uc3VtZWQoYmxvY2tfbnVtKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWV4ZWN1dGlvbmhpbnRfY2FuQmVDb25zdW1lZCh0aGlzLl9fd2JnX3B0ciwgYmxvY2tfbnVtKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVFeGVjdXRpb25IaW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRXhlY3V0aW9uSGludC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUV4ZWN1dGlvbk1vZGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWV4ZWN1dGlvbm1vZGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZUV4ZWN1dGlvbk1vZGUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVFeGVjdXRpb25Nb2RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVFeGVjdXRpb25Nb2RlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE5vdGVFeGVjdXRpb25Nb2RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZXhlY3V0aW9ubW9kZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uTW9kZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3TG9jYWwoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX25ldHdvcmsoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVFeGVjdXRpb25Nb2RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUV4ZWN1dGlvbk1vZGV9XG4gICAgICovXG4gICAgc3RhdGljIG5ld05ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWNjb3VudHN0b3JhZ2Vtb2RlX3B1YmxpYygpO1xuICAgICAgICByZXR1cm4gTm90ZUV4ZWN1dGlvbk1vZGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVleGVjdXRpb25tb2RlX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUV4ZWN1dGlvbk1vZGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVFeGVjdXRpb25Nb2RlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlRmlsZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZmlsZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24gb2YgYSBub3RlLlxuICovXG5jbGFzcyBOb3RlRmlsZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUZpbGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZUZpbGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUZpbGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVmaWxlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIGBOb3RlRmlsZWAncyB0eXBlcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5vdGVUeXBlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3RlZmlsZV9ub3RlVHlwZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHVybiBhIG5vdGVmaWxlIGludG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVmaWxlX3NlcmlhbGl6ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdmFsaWQgYnl0ZSByZXByZXNlbnRhdGlvbiBvZiBhIGBOb3RlRmlsZWAsXG4gICAgICogcmV0dXJuIGl0IGFzIGEgc3RydWN0LlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUZpbGV9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChieXRlcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5ub3RlZmlsZV9kZXNlcmlhbGl6ZShyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZUZpbGUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnB1dE5vdGV9IG5vdGVcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUZpbGV9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21JbnB1dE5vdGUobm90ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZSwgSW5wdXROb3RlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlZmlsZV9mcm9tSW5wdXROb3RlKG5vdGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVGaWxlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGV9IG5vdGVcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUZpbGV9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21PdXRwdXROb3RlKG5vdGUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGUsIE91dHB1dE5vdGUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVmaWxlX2Zyb21PdXRwdXROb3RlKG5vdGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVGaWxlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVEZXRhaWxzfSBub3RlX2RldGFpbHNcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUZpbGV9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21Ob3RlRGV0YWlscyhub3RlX2RldGFpbHMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfZGV0YWlscywgTm90ZURldGFpbHMpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVmaWxlX2Zyb21Ob3RlRGV0YWlscyhub3RlX2RldGFpbHMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVGaWxlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVJZH0gbm90ZV9kZXRhaWxzXG4gICAgICogQHJldHVybnMge05vdGVGaWxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTm90ZUlkKG5vdGVfZGV0YWlscykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9kZXRhaWxzLCBOb3RlSWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVmaWxlX2Zyb21Ob3RlSWQobm90ZV9kZXRhaWxzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRmlsZS5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVGaWxlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlRmlsZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUZpbHRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3RlZmlsdGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVGaWx0ZXIge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlRmlsdGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlZmlsdGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlRmlsdGVyVHlwZXN9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7Tm90ZUlkW10gfCBudWxsfSBbbm90ZV9pZHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm90ZV90eXBlLCBub3RlX2lkcykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUobm90ZV9pZHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKG5vdGVfaWRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWZpbHRlcl9uZXcobm90ZV90eXBlLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVGaWx0ZXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVGaWx0ZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVGaWx0ZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVIZWFkZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWhlYWRlcl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlSGVhZGVyIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUhlYWRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWhlYWRlcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWhlYWRlcl9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTWV0YWRhdGF9XG4gICAgICovXG4gICAgbWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWhlYWRlcl9tZXRhZGF0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGNvbW1pdG1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWhlYWRlcl9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlSGVhZGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlSGVhZGVyLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlSWRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWlkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVJZCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZUlkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVJZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE5vdGVJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUlkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlaWRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHJlY2lwaWVudF9kaWdlc3RcbiAgICAgKiBAcGFyYW0ge1dvcmR9IGFzc2V0X2NvbW1pdG1lbnRfZGlnZXN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVjaXBpZW50X2RpZ2VzdCwgYXNzZXRfY29tbWl0bWVudF9kaWdlc3QpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJlY2lwaWVudF9kaWdlc3QsIFdvcmQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXNzZXRfY29tbWl0bWVudF9kaWdlc3QsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpZF9uZXcocmVjaXBpZW50X2RpZ2VzdC5fX3diZ19wdHIsIGFzc2V0X2NvbW1pdG1lbnRfZGlnZXN0Ll9fd2JnX3B0cik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlSWRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChoZXgsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLm5vdGVpZF9mcm9tSGV4KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWlkX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUlkLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlSWQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVJZEFuZEFyZ3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWlkYW5kYXJnc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlSWRBbmRBcmdzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlSWRBbmRBcmdzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVJZEFuZEFyZ3NGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBOb3RlSWRBbmRBcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlSWRBbmRBcmdzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlaWRhbmRhcmdzX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSWR9IG5vdGVfaWRcbiAgICAgKiBAcGFyYW0ge1dvcmQgfCBudWxsfSBbYXJnc11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub3RlX2lkLCBhcmdzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2lkLCBOb3RlSWQpO1xuICAgICAgICB2YXIgcHRyMCA9IG5vdGVfaWQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGxldCBwdHIxID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGFyZ3MpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYXJncywgV29yZCk7XG4gICAgICAgICAgICBwdHIxID0gYXJncy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpZGFuZGFyZ3NfbmV3KHB0cjAsIHB0cjEpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUlkQW5kQXJnc0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUlkQW5kQXJncy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUlkQW5kQXJncy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUlkQW5kQXJnc0FycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVpZGFuZGFyZ3NhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlSWRBbmRBcmdzQXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlSWRBbmRBcmdzQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVpZGFuZGFyZ3NhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkQW5kQXJnc1tdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaWRhbmRhcmdzYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZUlkQW5kQXJnc0FycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge05vdGVJZEFuZEFyZ3N9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZWlkYW5kYXJnc2FycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlSWRBbmRBcmdzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Tm90ZUlkQW5kQXJnc30gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgTm90ZUlkQW5kQXJncyk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLm5vdGVpZGFuZGFyZ3NhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkQW5kQXJnc30gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgTm90ZUlkQW5kQXJncyk7XG4gICAgICAgIHdhc20ubm90ZWlkYW5kYXJnc2FycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZWlkYW5kYXJnc2FycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlSWRBbmRBcmdzQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVJZEFuZEFyZ3NBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUluY2x1c2lvblByb29mRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVpbmNsdXNpb25wcm9vZl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlSW5jbHVzaW9uUHJvb2Yge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVJbmNsdXNpb25Qcm9vZi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlSW5jbHVzaW9uUHJvb2ZGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUluY2x1c2lvblByb29mRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlaW5jbHVzaW9ucHJvb2ZfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZUxvY2F0aW9ufVxuICAgICAqL1xuICAgIGxvY2F0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpbmNsdXNpb25wcm9vZl9sb2NhdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlTG9jYXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNZXJrbGVQYXRofVxuICAgICAqL1xuICAgIG5vdGVQYXRoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVpbmNsdXNpb25wcm9vZl9ub3RlUGF0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBNZXJrbGVQYXRoLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUluY2x1c2lvblByb29mLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBOb3RlSW5jbHVzaW9uUHJvb2YucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVJbnB1dHNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZWlucHV0c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlSW5wdXRzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlSW5wdXRzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVJbnB1dHNGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUlucHV0c0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZWlucHV0c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmVsdEFycmF5fSBmZWx0X2FycmF5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVsdF9hcnJheSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmVsdF9hcnJheSwgRmVsdEFycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlaW5wdXRzX25ldyhmZWx0X2FycmF5Ll9fd2JnX3B0cik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBOb3RlSW5wdXRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0W119XG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm5vdGVpbnB1dHNfdmFsdWVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZUlucHV0cy5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZUlucHV0cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZUxvY2F0aW9uRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVsb2NhdGlvbl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlTG9jYXRpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVMb2NhdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlTG9jYXRpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZUxvY2F0aW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlbG9jYXRpb25fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJsb2NrTnVtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVsb2NhdGlvbl9ibG9ja051bSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbm9kZUluZGV4SW5CbG9jaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlbG9jYXRpb25fbm9kZUluZGV4SW5CbG9jayh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlTG9jYXRpb24ucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVMb2NhdGlvbi5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZU1ldGFkYXRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVtZXRhZGF0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlTWV0YWRhdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVNZXRhZGF0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlTWV0YWRhdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZU1ldGFkYXRhRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3RlbWV0YWRhdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gc2VuZGVyXG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtOb3RlVGFnfSBub3RlX3RhZ1xuICAgICAqIEBwYXJhbSB7Tm90ZUV4ZWN1dGlvbkhpbnR9IG5vdGVfZXhlY3V0aW9uX2hpbnRcbiAgICAgKiBAcGFyYW0ge0ZlbHQgfCBudWxsfSBbYXV4XVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlbmRlciwgbm90ZV90eXBlLCBub3RlX3RhZywgbm90ZV9leGVjdXRpb25faGludCwgYXV4KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzZW5kZXIsIEFjY291bnRJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX3RhZywgTm90ZVRhZyk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlX2V4ZWN1dGlvbl9oaW50LCBOb3RlRXhlY3V0aW9uSGludCk7XG4gICAgICAgIGxldCBwdHIwID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGF1eCkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhdXgsIEZlbHQpO1xuICAgICAgICAgICAgcHRyMCA9IGF1eC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVtZXRhZGF0YV9uZXcoc2VuZGVyLl9fd2JnX3B0ciwgbm90ZV90eXBlLCBub3RlX3RhZy5fX3diZ19wdHIsIG5vdGVfZXhlY3V0aW9uX2hpbnQuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVNZXRhZGF0YUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudElkfVxuICAgICAqL1xuICAgIHNlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlbWV0YWRhdGFfc2VuZGVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgdGFnKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVkZXRhaWxzYW5kdGFnX3RhZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlVGFnLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVR5cGV9XG4gICAgICovXG4gICAgbm90ZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZW1ldGFkYXRhX25vdGVUeXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVNZXRhZGF0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZU1ldGFkYXRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBOb3RlUmVjaXBpZW50RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVyZWNpcGllbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgTm90ZVJlY2lwaWVudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoTm90ZVJlY2lwaWVudC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBOb3RlUmVjaXBpZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgTm90ZVJlY2lwaWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZVJlY2lwaWVudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZXJlY2lwaWVudF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gc2VyaWFsX251bVxuICAgICAqIEBwYXJhbSB7Tm90ZVNjcmlwdH0gbm90ZV9zY3JpcHRcbiAgICAgKiBAcGFyYW0ge05vdGVJbnB1dHN9IGlucHV0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbF9udW0sIG5vdGVfc2NyaXB0LCBpbnB1dHMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNlcmlhbF9udW0sIFdvcmQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9zY3JpcHQsIE5vdGVTY3JpcHQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaW5wdXRzLCBOb3RlSW5wdXRzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlcmVjaXBpZW50X25ldyhzZXJpYWxfbnVtLl9fd2JnX3B0ciwgbm90ZV9zY3JpcHQuX193YmdfcHRyLCBpbnB1dHMuX193YmdfcHRyKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE5vdGVSZWNpcGllbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRoZWFkZXJfc3RvcmFnZUNvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgc2VyaWFsTnVtKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgc2NyaXB0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVyZWNpcGllbnRfc2NyaXB0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSW5wdXRzfVxuICAgICAqL1xuICAgIGlucHV0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlcmVjaXBpZW50X2lucHV0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSW5wdXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgTm90ZVJlY2lwaWVudC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gTm90ZVJlY2lwaWVudC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZVJlY2lwaWVudEFycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX25vdGVyZWNpcGllbnRhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlUmVjaXBpZW50QXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlUmVjaXBpZW50QXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX25vdGVyZWNpcGllbnRhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZVJlY2lwaWVudFtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RlcmVjaXBpZW50YXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgTm90ZVJlY2lwaWVudEFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge05vdGVSZWNpcGllbnR9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZXJlY2lwaWVudGFycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlUmVjaXBpZW50Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Tm90ZVJlY2lwaWVudH0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgTm90ZVJlY2lwaWVudCk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLm5vdGVyZWNpcGllbnRhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZVJlY2lwaWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgTm90ZVJlY2lwaWVudCk7XG4gICAgICAgIHdhc20ubm90ZXJlY2lwaWVudGFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXJlY2lwaWVudGFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBOb3RlUmVjaXBpZW50QXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVSZWNpcGllbnRBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgTm90ZVNjcmlwdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ub3Rlc2NyaXB0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE5vdGVTY3JpcHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE5vdGVTY3JpcHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgTm90ZVNjcmlwdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBOb3RlU2NyaXB0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ub3Rlc2NyaXB0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpbnQgdGhlIE1BU1Qgc291cmNlIGZvciB0aGlzIHNjcmlwdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ub3Rlc2NyaXB0X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXNjcmlwdF9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubm90ZXNjcmlwdF9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb3RlU2NyaXB0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIHN0YXRpYyBwMmlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVzY3JpcHRfcDJpZCgpO1xuICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVTY3JpcHR9XG4gICAgICovXG4gICAgc3RhdGljIHAyaWRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVzY3JpcHRfcDJpZGUoKTtcbiAgICAgICAgcmV0dXJuIE5vdGVTY3JpcHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlU2NyaXB0fVxuICAgICAqL1xuICAgIHN0YXRpYyBzd2FwKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGVzY3JpcHRfc3dhcCgpO1xuICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3Rlc2NyaXB0X3Jvb3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVTY3JpcHQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVTY3JpcHQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE5vdGVUYWdGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfbm90ZXRhZ19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBOb3RlVGFnIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShOb3RlVGFnLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE5vdGVUYWdGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgTm90ZVRhZ0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfbm90ZXRhZ19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHJldHVybnMge05vdGVUYWd9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21BY2NvdW50SWQoYWNjb3VudF9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RldGFnX2Zyb21BY2NvdW50SWQoYWNjb3VudF9pZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVzZV9jYXNlX2lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWRcbiAgICAgKiBAcGFyYW0ge05vdGVFeGVjdXRpb25Nb2RlfSBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yUHVibGljVXNlQ2FzZSh1c2VfY2FzZV9pZCwgcGF5bG9hZCwgZXhlY3V0aW9uKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhleGVjdXRpb24sIE5vdGVFeGVjdXRpb25Nb2RlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RldGFnX2ZvclB1YmxpY1VzZUNhc2UodXNlX2Nhc2VfaWQsIHBheWxvYWQsIGV4ZWN1dGlvbi5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVzZV9jYXNlX2lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWRcbiAgICAgKiBAcmV0dXJucyB7Tm90ZVRhZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yTG9jYWxVc2VDYXNlKHVzZV9jYXNlX2lkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXRhZ19mb3JMb2NhbFVzZUNhc2UodXNlX2Nhc2VfaWQsIHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gTm90ZVRhZy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTaW5nbGVUYXJnZXQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZXRhZ19pc1NpbmdsZVRhcmdldCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlRXhlY3V0aW9uTW9kZX1cbiAgICAgKi9cbiAgICBleGVjdXRpb25Nb2RlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm5vdGV0YWdfZXhlY3V0aW9uTW9kZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlRXhlY3V0aW9uTW9kZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBhc1UzMigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3RldGFnX2FzVTMyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE5vdGVUYWcucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE5vdGVUYWcucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE91dHB1dE5vdGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfb3V0cHV0bm90ZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBPdXRwdXROb3RlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPdXRwdXROb3RlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE91dHB1dE5vdGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBPdXRwdXROb3RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPdXRwdXROb3RlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vdXRwdXRub3RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlfSBub3RlXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGV9XG4gICAgICovXG4gICAgc3RhdGljIGZ1bGwobm90ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZSwgTm90ZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9mdWxsKG5vdGUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGFydGlhbE5vdGV9IHBhcnRpYWxfbm90ZVxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJ0aWFsKHBhcnRpYWxfbm90ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocGFydGlhbF9ub3RlLCBQYXJ0aWFsTm90ZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9wYXJ0aWFsKHBhcnRpYWxfbm90ZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlSGVhZGVyfSBub3RlX2hlYWRlclxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlfVxuICAgICAqL1xuICAgIHN0YXRpYyBoZWFkZXIobm90ZV9oZWFkZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfaGVhZGVyLCBOb3RlSGVhZGVyKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX2hlYWRlcihub3RlX2hlYWRlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVBc3NldHMgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgYXNzZXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfYXNzZXRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IE5vdGVBc3NldHMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHJlY2lwaWVudERpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3RlX3JlY2lwaWVudERpZ2VzdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZU1ldGFkYXRhfVxuICAgICAqL1xuICAgIG1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVfbWV0YWRhdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZU1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZX1cbiAgICAgKi9cbiAgICBzaHJpbmsoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9zaHJpbmsodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGUgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgaW50b0Z1bGwoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZV9pbnRvRnVsbChwdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogTm90ZS5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE91dHB1dE5vdGUucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE91dHB1dE5vdGUucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE91dHB1dE5vdGVBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19vdXRwdXRub3RlYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgT3V0cHV0Tm90ZUFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgT3V0cHV0Tm90ZUFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19vdXRwdXRub3RlYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGVbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZWFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIE91dHB1dE5vdGVBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm91dHB1dG5vdGVhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGV9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIE91dHB1dE5vdGUpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5vdXRwdXRub3RlYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGV9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIE91dHB1dE5vdGUpO1xuICAgICAgICB3YXNtLm91dHB1dG5vdGVhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgT3V0cHV0Tm90ZUFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBPdXRwdXROb3RlQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IE91dHB1dE5vdGVzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX291dHB1dG5vdGVzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE91dHB1dE5vdGVzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPdXRwdXROb3Rlcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBPdXRwdXROb3Rlc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIE91dHB1dE5vdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPdXRwdXROb3Rlc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfb3V0cHV0bm90ZXNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1Ob3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3Rlc19udW1Ob3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZXNfaXNFbXB0eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3RlfVxuICAgICAqL1xuICAgIGdldE5vdGUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5vdXRwdXRub3Rlc19nZXROb3RlKHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3RlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZVtdfVxuICAgICAqL1xuICAgIG5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLm91dHB1dG5vdGVzX25vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgT3V0cHV0Tm90ZXMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE91dHB1dE5vdGVzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBPdXRwdXROb3Rlc0FycmF5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX291dHB1dG5vdGVzYXJyYXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgT3V0cHV0Tm90ZXNBcnJheSB7XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIE91dHB1dE5vdGVzQXJyYXlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX291dHB1dG5vdGVzYXJyYXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGVzW10gfCBudWxsfSBbZWxlbWVudHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGVsZW1lbnRzKSA/IDAgOiBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChlbGVtZW50cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVzYXJyYXlfbmV3KHB0cjAsIGxlbjApO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgT3V0cHV0Tm90ZXNBcnJheUZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZWxlbWVudCBhdCBpbmRleCwgd2lsbCBhbHdheXMgcmV0dXJuIGEgY2xvbmUgdG8gYXZvaWQgYWxpYXNpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3Rlc31cbiAgICAgKi9cbiAgICBnZXQoaW5kZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5vdXRwdXRub3Rlc2FycmF5X2dldChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPdXRwdXROb3Rlcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGVzfSBlbGVtXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBlbGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtLCBPdXRwdXROb3Rlcyk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IGVsZW0uX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLm91dHB1dG5vdGVzYXJyYXlfcmVwbGFjZUF0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4LCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge091dHB1dE5vdGVzfSBlbGVtZW50XG4gICAgICovXG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhlbGVtZW50LCBPdXRwdXROb3Rlcyk7XG4gICAgICAgIHdhc20ub3V0cHV0bm90ZXNhcnJheV9wdXNoKHRoaXMuX193YmdfcHRyLCBlbGVtZW50Ll9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm91dHB1dG5vdGVzYXJyYXlfbGVuZ3RoKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIE91dHB1dE5vdGVzQXJyYXkucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IE91dHB1dE5vdGVzQXJyYXkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFBhY2thZ2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcGFja2FnZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBQYWNrYWdlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShQYWNrYWdlLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFBhY2thZ2VGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUGFja2FnZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcGFja2FnZV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wYWNrYWdlX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7UGFja2FnZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wYWNrYWdlX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBhY2thZ2UuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFBhY2thZ2UucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFBhY2thZ2UucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFBhcnRpYWxOb3RlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3BhcnRpYWxub3RlX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFBhcnRpYWxOb3RlIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUGFydGlhbE5vdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3BhcnRpYWxub3RlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZH1cbiAgICAgKi9cbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wYXJ0aWFsbm90ZV9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlTWV0YWRhdGF9XG4gICAgICovXG4gICAgbWV0YWRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubm90ZV9tZXRhZGF0YSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBOb3RlTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHJlY2lwaWVudERpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hY2NvdW50Y29kZV9jb21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlQXNzZXRzfVxuICAgICAqL1xuICAgIGFzc2V0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wYXJ0aWFsbm90ZV9hc3NldHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gTm90ZUFzc2V0cy5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFBhcnRpYWxOb3RlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBQYXJ0aWFsTm90ZS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgUHJvdmVuVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcHJvdmVudHJhbnNhY3Rpb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogV0FTTSB3cmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIFtgUHJvdmVuVHJhbnNhY3Rpb25gXS5cbiAqL1xuY2xhc3MgUHJvdmVuVHJhbnNhY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFByb3ZlblRyYW5zYWN0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFByb3ZlblRyYW5zYWN0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFByb3ZlblRyYW5zYWN0aW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wcm92ZW50cmFuc2FjdGlvbl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIHByb3ZlbiB0cmFuc2FjdGlvbiBpbnRvIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92ZW50cmFuc2FjdGlvbl9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZXMgYSBwcm92ZW4gdHJhbnNhY3Rpb24gZnJvbSBieXRlcy5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1Byb3ZlblRyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb3ZlblRyYW5zYWN0aW9uLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIElELlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbklkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX2lkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uSWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjY291bnQgSUQgdGhlIHRyYW5zYWN0aW9uIHdhcyBleGVjdXRlZCBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgYWNjb3VudElkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX2FjY291bnRJZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBY2NvdW50SWQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBibG9jayBudW1iZXIgdXNlZCBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcmVmQmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25fcmVmQmxvY2tOdW1iZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayBudW1iZXIgYXQgd2hpY2ggdGhlIHRyYW5zYWN0aW9uIGV4cGlyZXMuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBleHBpcmF0aW9uQmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmVudHJhbnNhY3Rpb25fZXhwaXJhdGlvbkJsb2NrTnVtYmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBub3RlcyBjcmVhdGVkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVzfVxuICAgICAqL1xuICAgIG91dHB1dE5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX291dHB1dE5vdGVzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIE91dHB1dE5vdGVzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21taXRtZW50IG9mIHRoZSByZWZlcmVuY2UgYmxvY2suXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcmVmQmxvY2tDb21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZlbnRyYW5zYWN0aW9uX3JlZkJsb2NrQ29tbWl0bWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudWxsaWZpZXJzIG9mIHRoZSBjb25zdW1lZCBpbnB1dCBub3Rlcy5cbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqL1xuICAgIG51bGxpZmllcnMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucHJvdmVudHJhbnNhY3Rpb25fbnVsbGlmaWVycyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFByb3ZlblRyYW5zYWN0aW9uLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBQcm92ZW5UcmFuc2FjdGlvbi5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgUHVibGljS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3B1YmxpY2tleV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBQdWJsaWNLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFB1YmxpY0tleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBQdWJsaWNLZXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUHVibGljS2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wdWJsaWNrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHVibGlja2V5X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7UHVibGljS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnB1YmxpY2tleV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG1lc3NhZ2UsIFdvcmQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2lnbmF0dXJlLCBTaWduYXR1cmUpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnB1YmxpY2tleV92ZXJpZnkodGhpcy5fX3diZ19wdHIsIG1lc3NhZ2UuX193YmdfcHRyLCBzaWduYXR1cmUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgdG9Db21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnB1YmxpY2tleV90b0NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9XG4gICAgICovXG4gICAgc3RhdGljIHJlY292ZXJGcm9tKG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MobWVzc2FnZSwgV29yZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2lnbmF0dXJlLCBTaWduYXR1cmUpO1xuICAgICAgICAgICAgd2FzbS5wdWJsaWNrZXlfcmVjb3ZlckZyb20ocmV0cHRyLCBtZXNzYWdlLl9fd2JnX3B0ciwgc2lnbmF0dXJlLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTaWduaW5nSW5wdXRzfSBzaWduaW5nX2lucHV0c1xuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlfSBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2ZXJpZnlEYXRhKHNpZ25pbmdfaW5wdXRzLCBzaWduYXR1cmUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNpZ25pbmdfaW5wdXRzLCBTaWduaW5nSW5wdXRzKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNpZ25hdHVyZSwgU2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wdWJsaWNrZXlfdmVyaWZ5RGF0YSh0aGlzLl9fd2JnX3B0ciwgc2lnbmluZ19pbnB1dHMuX193YmdfcHRyLCBzaWduYXR1cmUuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFB1YmxpY0tleS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gUHVibGljS2V5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBScGNDbGllbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcnBjY2xpZW50X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFJQQyBDbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggTWlkZW4gbm9kZXMgZGlyZWN0bHkuXG4gKi9cbmNsYXNzIFJwY0NsaWVudCB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJwY0NsaWVudEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcnBjY2xpZW50X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBSUEMgY2xpZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZHBvaW50IC0gRW5kcG9pbnQgdG8gY29ubmVjdCB0by5cbiAgICAgKiBAcGFyYW0ge0VuZHBvaW50fSBlbmRwb2ludFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVuZHBvaW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhlbmRwb2ludCwgRW5kcG9pbnQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbmRwb2ludC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ucnBjY2xpZW50X25ldyhyZXRwdHIsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHIwID4+PiAwO1xuICAgICAgICAgICAgUnBjQ2xpZW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIG5vdGVzIGJ5IHRoZWlyIElEcyBmcm9tIHRoZSBjb25uZWN0ZWQgTWlkZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3RlX2lkcyAtIEFycmF5IG9mIFtgTm90ZUlkYF0gb2JqZWN0cyB0byBmZXRjaFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byAgZGlmZmVyZW50IGRhdGEgZGVwZW5kaW5nIG9uIHRoZSBub3RlIHR5cGU6XG4gICAgICogLSBQcml2YXRlIG5vdGVzOiBSZXR1cm5zIG9ubHkgYG5vdGVfaWRgIGFuZCBgbWV0YWRhdGFgLiBUaGUgYGlucHV0X25vdGVgIGZpZWxkIHdpbGwgYmVcbiAgICAgKiAgIGBudWxsYC5cbiAgICAgKiAtIFB1YmxpYyBub3RlczogUmV0dXJucyB0aGUgZnVsbCBgaW5wdXRfbm90ZWAgd2l0aCBpbmNsdXNpb24gcHJvb2YsIGFsb25nc2lkZSBtZXRhZGF0YSBhbmRcbiAgICAgKiAgIElELlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkW119IG5vdGVfaWRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hlZE5vdGVbXT59XG4gICAgICovXG4gICAgZ2V0Tm90ZXNCeUlkKG5vdGVfaWRzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChub3RlX2lkcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucnBjY2xpZW50X2dldE5vdGVzQnlJZCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBub3RlIHNjcmlwdCBieSBpdHMgcm9vdCBoYXNoIGZyb20gdGhlIGNvbm5lY3RlZCBNaWRlbiBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGBzY3JpcHRfcm9vdGAgVGhlIHJvb3QgaGFzaCBvZiB0aGUgbm90ZSBzY3JpcHQgdG8gZmV0Y2hcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGBOb3RlU2NyaXB0YFxuICAgICAqIEBwYXJhbSB7V29yZH0gc2NyaXB0X3Jvb3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3RlU2NyaXB0Pn1cbiAgICAgKi9cbiAgICBnZXROb3RlU2NyaXB0QnlSb290KHNjcmlwdF9yb290KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzY3JpcHRfcm9vdCwgV29yZCk7XG4gICAgICAgIHZhciBwdHIwID0gc2NyaXB0X3Jvb3QuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucnBjY2xpZW50X2dldE5vdGVTY3JpcHRCeVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgUnBjQ2xpZW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBScGNDbGllbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFJwbzI1NkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19ycG8yNTZfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgUnBvMjU2IHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUnBvMjU2RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ycG8yNTZfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZlbHRBcnJheX0gZmVsdF9hcnJheVxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoRWxlbWVudHMoZmVsdF9hcnJheSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmVsdF9hcnJheSwgRmVsdEFycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ycG8yNTZfaGFzaEVsZW1lbnRzKGZlbHRfYXJyYXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBScG8yNTYucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFJwbzI1Ni5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2NyaXB0QnVpbGRlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zY3JpcHRidWlsZGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFNjcmlwdEJ1aWxkZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNjcmlwdEJ1aWxkZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2NyaXB0QnVpbGRlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTY3JpcHRCdWlsZGVyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zY3JpcHRidWlsZGVyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBtb2R1bGUgcGF0aCAoc29tZXRoaW5nIGxpa2UgYG15X2xpYjo6bW9kdWxlYCkgYW5kIHNvdXJjZSBjb2RlLCB0aGlzIHdpbGxcbiAgICAgKiBzdGF0aWNhbGx5IGxpbmsgaXQgZm9yIHVzZSB3aXRoIHNjcmlwdHMgdG8gYmUgYnVpbHQgd2l0aCB0aGlzIGJ1aWxkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZV9wYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZV9jb2RlXG4gICAgICovXG4gICAgbGlua01vZHVsZShtb2R1bGVfcGF0aCwgbW9kdWxlX2NvZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG1vZHVsZV9wYXRoLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKG1vZHVsZV9jb2RlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5zY3JpcHRidWlsZGVyX2xpbmtNb2R1bGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljYWxseSBsaW5rcyB0aGUgZ2l2ZW4gbGlicmFyeS5cbiAgICAgKlxuICAgICAqIFN0YXRpYyBsaW5raW5nIG1lYW5zIHRoZSBsaWJyYXJ5IGNvZGUgaXMgY29waWVkIGludG8gdGhlIHNjcmlwdCBjb2RlLlxuICAgICAqIFVzZSB0aGlzIGZvciBtb3N0IGxpYnJhcmllcyB0aGF0IGFyZSBub3QgYXZhaWxhYmxlIG9uLWNoYWluLlxuICAgICAqXG4gICAgICogUmVjZWl2ZXMgYXMgYXJndW1lbnQgdGhlIGxpYnJhcnkgdG8gbGluay5cbiAgICAgKiBAcGFyYW0ge0xpYnJhcnl9IGxpYnJhcnlcbiAgICAgKi9cbiAgICBsaW5rU3RhdGljTGlicmFyeShsaWJyYXJ5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhsaWJyYXJ5LCBMaWJyYXJ5KTtcbiAgICAgICAgICAgIHdhc20uc2NyaXB0YnVpbGRlcl9saW5rU3RhdGljTGlicmFyeShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBsaWJyYXJ5Ll9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gZHluYW1pY2FsbHkgbGluayB0aGUgW2BMaWJyYXJ5YF0gb2YgYSBmb3JlaWduIGFjY291bnRcbiAgICAgKiB0aGF0IGlzIGludm9rZWQgdXNpbmcgZm9yZWlnbiBwcm9jZWR1cmUgaW52b2NhdGlvbiAoRlBJKS4gSXRzIGNvZGUgaXMgYXZhaWxhYmxlXG4gICAgICogb24tY2hhaW4gYW5kIHNvIGl0IGRvZXMgbm90IGhhdmUgdG8gYmUgY29waWVkIGludG8gdGhlIHNjcmlwdCBjb2RlLlxuICAgICAqXG4gICAgICogRm9yIGFsbCBvdGhlciB1c2UgY2FzZXMgbm90IGludm9sdmluZyBGUEksIGxpbmsgdGhlIGxpYnJhcnkgc3RhdGljYWxseS5cbiAgICAgKiBSZWNlaXZlcyBhcyBhcmd1bWVudCB0aGUgbGlicmFyeSB0byBiZSBsaW5rZWQuXG4gICAgICogQHBhcmFtIHtMaWJyYXJ5fSBsaWJyYXJ5XG4gICAgICovXG4gICAgbGlua0R5bmFtaWNMaWJyYXJ5KGxpYnJhcnkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGxpYnJhcnksIExpYnJhcnkpO1xuICAgICAgICAgICAgd2FzbS5zY3JpcHRidWlsZGVyX2xpbmtEeW5hbWljTGlicmFyeShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBsaWJyYXJ5Ll9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBUcmFuc2FjdGlvbiBTY3JpcHQncyBzb3VyY2UgY29kZSwgY29tcGlsZXMgaXQgd2l0aCB0aGUgYXZhaWxhYmxlXG4gICAgICogbW9kdWxlcyB1bmRlciB0aGlzIGJ1aWxkZXIuIFJldHVybnMgdGhlIGNvbXBpbGVkIHNjcmlwdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHhfc2NyaXB0XG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU2NyaXB0fVxuICAgICAqL1xuICAgIGNvbXBpbGVUeFNjcmlwdCh0eF9zY3JpcHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHR4X3NjcmlwdCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uc2NyaXB0YnVpbGRlcl9jb21waWxlVHhTY3JpcHQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblNjcmlwdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIE5vdGUgU2NyaXB0J3Mgc291cmNlIGNvZGUsIGNvbXBpbGVzIGl0IHdpdGggdGhlIGF2YWlsYWJsZVxuICAgICAqIG1vZHVsZXMgdW5kZXIgdGhpcyBidWlsZGVyLiBSZXR1cm5zIHRoZSBjb21waWxlZCBzY3JpcHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1cbiAgICAgKiBAcmV0dXJucyB7Tm90ZVNjcmlwdH1cbiAgICAgKi9cbiAgICBjb21waWxlTm90ZVNjcmlwdChwcm9ncmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9ncmFtLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5zY3JpcHRidWlsZGVyX2NvbXBpbGVOb3RlU2NyaXB0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTm90ZVNjcmlwdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIExpYnJhcnkgUGF0aCwgYW5kIGEgc291cmNlIGNvZGUsIHR1cm4gaXQgaW50byBhIExpYnJhcnkuXG4gICAgICogRS5nLiBBIHBhdGggbGlicmFyeSBjYW4gYmUgYG1pZGVuOjpteV9jb250cmFjdGAuIFdoZW4gdHVybmVkIGludG8gYSBsaWJyYXJ5LFxuICAgICAqIHRoaXMgY2FuIGJlIHVzZWQgZnJvbSBhbm90aGVyIHNjcmlwdCB3aXRoIGFuIGltcG9ydCBzdGF0ZW1lbnQsIGZvbGxvd2luZyB0aGVcbiAgICAgKiBwcmV2aW91cyBleGFtcGxlOiBgdXNlLm1pZGVuOjpteV9jb250cmFjdCcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxpYnJhcnlfcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VfY29kZVxuICAgICAqIEByZXR1cm5zIHtMaWJyYXJ5fVxuICAgICAqL1xuICAgIGJ1aWxkTGlicmFyeShsaWJyYXJ5X3BhdGgsIHNvdXJjZV9jb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChsaWJyYXJ5X3BhdGgsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoc291cmNlX2NvZGUsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNjcmlwdGJ1aWxkZXJfYnVpbGRMaWJyYXJ5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTGlicmFyeS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2NyaXB0QnVpbGRlci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2NyaXB0QnVpbGRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2VjcmV0S2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NlY3JldGtleV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTZWNyZXRLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNlY3JldEtleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTZWNyZXRLZXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2VjcmV0S2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zZWNyZXRrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VlZF1cbiAgICAgKiBAcmV0dXJucyB7U2VjcmV0S2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBycG9GYWxjb25XaXRoUk5HKHNlZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHNlZWQpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNlY3JldGtleV9ycG9GYWxjb25XaXRoUk5HKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTZWNyZXRLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlZWRdXG4gICAgICogQHJldHVybnMge1NlY3JldEtleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZWNkc2FXaXRoUk5HKHNlZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHNlZWQpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNlY3JldGtleV9lY2RzYVdpdGhSTkcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNlY3JldEtleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHVibGljS2V5fVxuICAgICAqL1xuICAgIHB1YmxpY0tleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zZWNyZXRrZXlfcHVibGljS2V5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAgICAgKi9cbiAgICBzaWduKG1lc3NhZ2UpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG1lc3NhZ2UsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNlY3JldGtleV9zaWduKHRoaXMuX193YmdfcHRyLCBtZXNzYWdlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2lnbmluZ0lucHV0c30gc2lnbmluZ19pbnB1dHNcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfVxuICAgICAqL1xuICAgIHNpZ25EYXRhKHNpZ25pbmdfaW5wdXRzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduaW5nX2lucHV0cywgU2lnbmluZ0lucHV0cyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2VjcmV0a2V5X3NpZ25EYXRhKHRoaXMuX193YmdfcHRyLCBzaWduaW5nX2lucHV0cy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2VjcmV0a2V5X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7U2VjcmV0S2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNlY3JldGtleV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTZWNyZXRLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNlY3JldEtleS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2VjcmV0S2V5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTZXJpYWxpemVkSW5wdXROb3RlRGF0YUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTZXJpYWxpemVkSW5wdXROb3RlRGF0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2VyaWFsaXplZElucHV0Tm90ZURhdGEucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2VyaWFsaXplZElucHV0Tm90ZURhdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBTZXJpYWxpemVkSW5wdXROb3RlRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2VyaWFsaXplZElucHV0Tm90ZURhdGFGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbm90ZUlkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBub3RlSWQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgbm90ZUFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBub3RlQXNzZXRzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlQXNzZXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IHNlcmlhbE51bWJlcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfc2VyaWFsTnVtYmVyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IHNlcmlhbE51bWJlcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfc2VyaWFsTnVtYmVyKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IGlucHV0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfaW5wdXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IGlucHV0cyhhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfaW5wdXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbm90ZVNjcmlwdFJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlU2NyaXB0Um9vdChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbm90ZVNjcmlwdFJvb3QoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlU2NyaXB0Um9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBub3RlU2NyaXB0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlU2NyaXB0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5vdGVTY3JpcHQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVTY3JpcHQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBudWxsaWZpZXIoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc2FjY291bnR1cGRhdGVfY29kZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG51bGxpZmllcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9jb2RlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHN0YXRlRGlzY3JpbWluYW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9zdGF0ZURpc2NyaW1pbmFudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0YXRlRGlzY3JpbWluYW50KGFyZzApIHtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfc3RhdGVEaXNjcmltaW5hbnQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX3N0YXRlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0YXRlKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9zdGF0ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X2pzYWNjb3VudHVwZGF0ZV9hY2NvdW50Q29tbWl0bWVudChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgY3JlYXRlZEF0KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfanNhY2NvdW50dXBkYXRlX2FjY291bnRDb21taXRtZW50KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNlcmlhbGl6ZWRJbnB1dE5vdGVEYXRhLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTZXJpYWxpemVkSW5wdXROb3RlRGF0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGFGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbm90ZUlkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBub3RlSWQoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc2FjY291bnR1cGRhdGVfc3RvcmFnZVJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgbm90ZUFzc2V0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfbm90ZUFzc2V0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBub3RlQXNzZXRzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlQXNzZXRzKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgcmVjaXBpZW50RGlnZXN0KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNzdG9yYWdlbWFwZW50cnlfdmFsdWUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHJlY2lwaWVudERpZ2VzdChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzc3RvcmFnZW1hcGVudHJ5X3ZhbHVlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9pbnB1dHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgbWV0YWRhdGEoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX2lucHV0cyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IG51bGxpZmllcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX251bGxpZmllcihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgbnVsbGlmaWVyKGFyZzApIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKGFyZzApID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9udWxsaWZpZXIodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBleHBlY3RlZEhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX2V4cGVjdGVkSGVpZ2h0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgZXhwZWN0ZWRIZWlnaHQoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfZXhwZWN0ZWRIZWlnaHQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdGF0ZURpc2NyaW1pbmFudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX3N0YXRlRGlzY3JpbWluYW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RhdGVEaXNjcmltaW5hbnQoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfc3RhdGVEaXNjcmltaW5hbnQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9zdGF0ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJnMFxuICAgICAqL1xuICAgIHNldCBzdGF0ZShhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfc2VyaWFsaXplZG91dHB1dG5vdGVkYXRhX3N0YXRlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2VyaWFsaXplZE91dHB1dE5vdGVEYXRhLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTZXJpYWxpemVkVHJhbnNhY3Rpb25EYXRhRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc1ZhbHVlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfanNhY2NvdW50dXBkYXRlX3N0b3JhZ2VSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBpZChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X2pzYWNjb3VudHVwZGF0ZV9zdG9yYWdlUm9vdCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGdldCBkZXRhaWxzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9ub3RlQXNzZXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmcwXG4gICAgICovXG4gICAgc2V0IGRldGFpbHMoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25vdGVBc3NldHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgc2NyaXB0Um9vdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfc2VyaWFsaXplZHRyYW5zYWN0aW9uZGF0YV9zY3JpcHRSb290KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHYxO1xuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW2FyZzBdXG4gICAgICovXG4gICAgc2V0IHNjcmlwdFJvb3QoYXJnMCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3NjcmlwdFJvb3QodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgdHhTY3JpcHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfdHhTY3JpcHQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbYXJnMF1cbiAgICAgKi9cbiAgICBzZXQgdHhTY3JpcHQoYXJnMCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoYXJnMCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3R4U2NyaXB0KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYmxvY2tOdW0oKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgYmxvY2tOdW0oYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9qc3N0b3JhZ2VtYXBlbnRyeV92YWx1ZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHN0YXR1c1ZhcmlhbnQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X3NlcmlhbGl6ZWR0cmFuc2FjdGlvbmRhdGFfc3RhdHVzVmFyaWFudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHN0YXR1c1ZhcmlhbnQoYXJnMCkge1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3N0YXR1c1ZhcmlhbnQodGhpcy5fX3diZ19wdHIsIGFyZzApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JnX2dldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9pbnB1dHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgc3RhdHVzKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9zZXJpYWxpemVkaW5wdXRub3RlZGF0YV9pbnB1dHModGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU2lnbmF0dXJlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NpZ25hdHVyZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTaWduYXR1cmUge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNpZ25hdHVyZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTaWduYXR1cmVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2lnbmF0dXJlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zaWduYXR1cmVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNpZ25hdHVyZV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTaWduYXR1cmUuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge0ZlbHRbXX1cbiAgICAgKi9cbiAgICB0b1ByZXBhcmVkU2lnbmF0dXJlKG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG1lc3NhZ2UsIFdvcmQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBtZXNzYWdlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5zaWduYXR1cmVfdG9QcmVwYXJlZFNpZ25hdHVyZShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MiA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNpZ25hdHVyZS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU2lnbmF0dXJlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTaWduaW5nSW5wdXRzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3NpZ25pbmdpbnB1dHNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU2lnbmluZ0lucHV0cyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU2lnbmluZ0lucHV0cy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTaWduaW5nSW5wdXRzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNpZ25pbmdJbnB1dHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3NpZ25pbmdpbnB1dHNfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU3VtbWFyeX0gc3VtbWFyeVxuICAgICAqIEByZXR1cm5zIHtTaWduaW5nSW5wdXRzfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdUcmFuc2FjdGlvblN1bW1hcnkoc3VtbWFyeSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3VtbWFyeSwgVHJhbnNhY3Rpb25TdW1tYXJ5KTtcbiAgICAgICAgdmFyIHB0cjAgPSBzdW1tYXJ5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfbmV3VHJhbnNhY3Rpb25TdW1tYXJ5KHB0cjApO1xuICAgICAgICByZXR1cm4gU2lnbmluZ0lucHV0cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWx0W119IGZlbHRzXG4gICAgICogQHJldHVybnMge1NpZ25pbmdJbnB1dHN9XG4gICAgICovXG4gICAgc3RhdGljIG5ld0FyYml0cmFyeShmZWx0cykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZmVsdHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfbmV3QXJiaXRyYXJ5KHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gU2lnbmluZ0lucHV0cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSB3b3JkXG4gICAgICogQHJldHVybnMge1NpZ25pbmdJbnB1dHN9XG4gICAgICovXG4gICAgc3RhdGljIG5ld0JsaW5kKHdvcmQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHdvcmQsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfbmV3QmxpbmQod29yZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2lnbmluZ0lucHV0cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3VtbWFyeX1cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvblN1bW1hcnlQYXlsb2FkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNpZ25pbmdpbnB1dHNfdHJhbnNhY3Rpb25TdW1tYXJ5UGF5bG9hZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3VtbWFyeS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdEFycmF5fVxuICAgICAqL1xuICAgIGFyYml0cmFyeVBheWxvYWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2lnbmluZ2lucHV0c19hcmJpdHJhcnlQYXlsb2FkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmVsdEFycmF5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGJsaW5kUGF5bG9hZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zaWduaW5naW5wdXRzX2JsaW5kUGF5bG9hZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1NpZ25pbmdJbnB1dHNUeXBlfVxuICAgICAqL1xuICAgIGdldCB2YXJpYW50VHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX3ZhcmlhbnRUeXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgdG9Db21taXRtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25pbmdpbnB1dHNfdG9Db21taXRtZW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtGZWx0QXJyYXl9XG4gICAgICovXG4gICAgdG9FbGVtZW50cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduaW5naW5wdXRzX3RvRWxlbWVudHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmVsdEFycmF5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmluZ2lucHV0c19zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1NpZ25pbmdJbnB1dHN9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2lnbmluZ2lucHV0c19kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTaWduaW5nSW5wdXRzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTaWduaW5nSW5wdXRzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTaWduaW5nSW5wdXRzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTbG90QW5kS2V5c0ZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zbG90YW5ka2V5c19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTbG90QW5kS2V5cyB7XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgU2xvdEFuZEtleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNsb3RBbmRLZXlzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zbG90YW5ka2V5c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9yYWdlX3Nsb3RfaW5kZXhcbiAgICAgKiBAcGFyYW0ge1dvcmRbXX0gc3RvcmFnZV9tYXBfa2V5c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2Vfc2xvdF9pbmRleCwgc3RvcmFnZV9tYXBfa2V5cykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoc3RvcmFnZV9tYXBfa2V5cywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2xvdGFuZGtleXNfbmV3KHN0b3JhZ2Vfc2xvdF9pbmRleCwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBTbG90QW5kS2V5c0ZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0b3JhZ2Vfc2xvdF9pbmRleCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zbG90YW5ka2V5c19zdG9yYWdlX3Nsb3RfaW5kZXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqL1xuICAgIHN0b3JhZ2VfbWFwX2tleXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2xvdGFuZGtleXNfc3RvcmFnZV9tYXBfa2V5cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFNsb3RBbmRLZXlzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTbG90QW5kS2V5cy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU3RvcmFnZU1hcEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zdG9yYWdlbWFwX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFN0b3JhZ2VNYXAge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTdG9yYWdlTWFwRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zdG9yYWdlbWFwX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZW1hcF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFN0b3JhZ2VNYXBGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBrZXlcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHZhbHVlXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGtleSwgV29yZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2YWx1ZSwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZW1hcF9pbnNlcnQodGhpcy5fX3diZ19wdHIsIGtleS5fX3diZ19wdHIsIHZhbHVlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgU3RvcmFnZU1hcC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gU3RvcmFnZU1hcC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU3RvcmFnZVNsb3RGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc3RvcmFnZXNsb3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgU3RvcmFnZVNsb3Qge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFN0b3JhZ2VTbG90LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFN0b3JhZ2VTbG90RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgU3RvcmFnZVNsb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFN0b3JhZ2VTbG90RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zdG9yYWdlc2xvdF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RvcmFnZVNsb3R9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModmFsdWUsIFdvcmQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN0b3JhZ2VzbG90X2Zyb21WYWx1ZSh2YWx1ZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU3RvcmFnZVNsb3QuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdG9yYWdlU2xvdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZW1wdHlWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlc2xvdF9lbXB0eVZhbHVlKCk7XG4gICAgICAgIHJldHVybiBTdG9yYWdlU2xvdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdG9yYWdlTWFwfSBzdG9yYWdlX21hcFxuICAgICAqIEByZXR1cm5zIHtTdG9yYWdlU2xvdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFwKHN0b3JhZ2VfbWFwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzdG9yYWdlX21hcCwgU3RvcmFnZU1hcCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc3RvcmFnZXNsb3RfbWFwKHN0b3JhZ2VfbWFwLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTdG9yYWdlU2xvdC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFN0b3JhZ2VTbG90LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTdG9yYWdlU2xvdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgU3RvcmFnZVNsb3RBcnJheUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zdG9yYWdlc2xvdGFycmF5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFN0b3JhZ2VTbG90QXJyYXkge1xuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTdG9yYWdlU2xvdEFycmF5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zdG9yYWdlc2xvdGFycmF5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdG9yYWdlU2xvdFtdIHwgbnVsbH0gW2VsZW1lbnRzXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShlbGVtZW50cykgPyAwIDogcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAoZWxlbWVudHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlc2xvdGFycmF5X25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFN0b3JhZ2VTbG90QXJyYXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVsZW1lbnQgYXQgaW5kZXgsIHdpbGwgYWx3YXlzIHJldHVybiBhIGNsb25lIHRvIGF2b2lkIGFsaWFzaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RvcmFnZVNsb3R9XG4gICAgICovXG4gICAgZ2V0KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc3RvcmFnZXNsb3RhcnJheV9nZXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZVNsb3QuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtTdG9yYWdlU2xvdH0gZWxlbVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgZWxlbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbSwgU3RvcmFnZVNsb3QpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSBlbGVtLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5zdG9yYWdlc2xvdGFycmF5X3JlcGxhY2VBdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBpbmRleCwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdG9yYWdlU2xvdH0gZWxlbWVudFxuICAgICAqL1xuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZWxlbWVudCwgU3RvcmFnZVNsb3QpO1xuICAgICAgICB3YXNtLnN0b3JhZ2VzbG90YXJyYXlfcHVzaCh0aGlzLl9fd2JnX3B0ciwgZWxlbWVudC5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zdG9yYWdlc2xvdGFycmF5X2xlbmd0aCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBTdG9yYWdlU2xvdEFycmF5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTdG9yYWdlU2xvdEFycmF5LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBTeW5jU3VtbWFyeUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zeW5jc3VtbWFyeV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBTeW5jU3VtbWFyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoU3luY1N1bW1hcnkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU3luY1N1bW1hcnlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU3luY1N1bW1hcnlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3N5bmNzdW1tYXJ5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBibG9ja051bSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zeW5jc3VtbWFyeV9ibG9ja051bSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlSWRbXX1cbiAgICAgKi9cbiAgICBjb21taXR0ZWROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zeW5jc3VtbWFyeV9jb21taXR0ZWROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05vdGVJZFtdfVxuICAgICAqL1xuICAgIGNvbnN1bWVkTm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc3luY3N1bW1hcnlfY29uc3VtZWROb3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZFtdfVxuICAgICAqL1xuICAgIHVwZGF0ZWRBY2NvdW50cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zeW5jc3VtbWFyeV91cGRhdGVkQWNjb3VudHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbklkW119XG4gICAgICovXG4gICAgY29tbWl0dGVkVHJhbnNhY3Rpb25zKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnN5bmNzdW1tYXJ5X2NvbW1pdHRlZFRyYW5zYWN0aW9ucyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnN5bmNzdW1tYXJ5X3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7U3luY1N1bW1hcnl9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc3luY3N1bW1hcnlfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3luY1N1bW1hcnkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFN5bmNTdW1tYXJ5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBTeW5jU3VtbWFyeS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVGVzdFV0aWxzRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Rlc3R1dGlsc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUZXN0VXRpbHMge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUZXN0VXRpbHNGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Rlc3R1dGlsc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBY2NvdW50SWR9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1vY2tBY2NvdW50SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udGVzdHV0aWxzX2NyZWF0ZU1vY2tBY2NvdW50SWQoKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1vY2tTZXJpYWxpemVkUGFja2FnZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50ZXN0dXRpbHNfY3JlYXRlTW9ja1NlcmlhbGl6ZWRQYWNrYWdlKCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUZXN0VXRpbHMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRlc3RVdGlscy5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVG9rZW5TeW1ib2xGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdG9rZW5zeW1ib2xfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVG9rZW5TeW1ib2wge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRva2VuU3ltYm9sLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRva2VuU3ltYm9sRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRva2VuU3ltYm9sRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190b2tlbnN5bWJvbF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHN5bWJvbCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udG9rZW5zeW1ib2xfbmV3KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX193YmdfcHRyID0gcjAgPj4+IDA7XG4gICAgICAgICAgICBUb2tlblN5bWJvbEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udG9rZW5zeW1ib2xfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHRyMSA9IHIwO1xuICAgICAgICAgICAgdmFyIGxlbjEgPSByMTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHB0cjEgPSAwOyBsZW4xID0gMDtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gcHRyMTtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gbGVuMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyMSwgbGVuMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVG9rZW5TeW1ib2wucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRva2VuU3ltYm9sLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvbkFyZ3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25hcmdzX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uQXJncyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25BcmdzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uQXJnc0ZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvbkFyZ3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uYXJnc19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblNjcmlwdCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0eFNjcmlwdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmFyZ3NfdHhTY3JpcHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogVHJhbnNhY3Rpb25TY3JpcHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkfSBub3RlX2lkXG4gICAgICogQHJldHVybnMge1dvcmQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0Tm90ZUFyZ3Mobm90ZV9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9pZCwgTm90ZUlkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmFyZ3NfZ2V0Tm90ZUFyZ3ModGhpcy5fX3diZ19wdHIsIG5vdGVfaWQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBZHZpY2VJbnB1dHN9XG4gICAgICovXG4gICAgYWR2aWNlSW5wdXRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uYXJnc19hZHZpY2VJbnB1dHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWR2aWNlSW5wdXRzLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25BcmdzLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvbkFyZ3MucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uRmlsdGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uZmlsdGVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uRmlsdGVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvbkZpbHRlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvbkZpbHRlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25maWx0ZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25GaWx0ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGFsbCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmZpbHRlcl9hbGwoKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmlsdGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uSWRbXX0gaWRzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uRmlsdGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBpZHMoaWRzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlKc1ZhbHVlVG9XYXNtMChpZHMsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uZmlsdGVyX2lkcyhwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmlsdGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25GaWx0ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIHVuY29tbWl0dGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uZmlsdGVyX3VuY29tbWl0dGVkKCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbkZpbHRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrX251bVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkZpbHRlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhwaXJlZEJlZm9yZShibG9ja19udW0pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbmZpbHRlcl9leHBpcmVkQmVmb3JlKGJsb2NrX251bSk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbkZpbHRlci5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uRmlsdGVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25JZEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbmlkX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uSWQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uSWQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25JZEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIF9fdW53cmFwKGpzVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoanNWYWx1ZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uSWRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uaWRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIGFzRWxlbWVudHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25pZF9hc0VsZW1lbnRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBhc0J5dGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uaWRfYXNCeXRlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uaWRfdG9IZXgocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGlubmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uSWQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uSWQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uUHJvdmVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucHJvdmVyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uUHJvdmVyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblByb3Zlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblByb3ZlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblByb3ZlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25wcm92ZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25Qcm92ZXJ9XG4gICAgICovXG4gICAgc3RhdGljIG5ld0xvY2FsUHJvdmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucHJvdmVyX25ld0xvY2FsUHJvdmVyKCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblByb3Zlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50XG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUHJvdmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdSZW1vdGVQcm92ZXIoZW5kcG9pbnQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGVuZHBvaW50LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25wcm92ZXJfbmV3UmVtb3RlUHJvdmVyKHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25Qcm92ZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnByb3Zlcl9zZXJpYWxpemUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92ZXJfdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW2VuZHBvaW50XVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblByb3Zlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUocHJvdmVyX3R5cGUsIGVuZHBvaW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm92ZXJfdHlwZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShlbmRwb2ludCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAoZW5kcG9pbnQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnByb3Zlcl9kZXNlcmlhbGl6ZShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25Qcm92ZXIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBlbmRwb2ludCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnByb3Zlcl9lbmRwb2ludChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uUHJvdmVyLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblByb3Zlci5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25SZWNvcmRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25yZWNvcmRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25SZWNvcmQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uUmVjb3JkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVjb3JkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVjb3JkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlY29yZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbklkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25JZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnRJZH1cbiAgICAgKi9cbiAgICBhY2NvdW50SWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfYWNjb3VudElkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFjY291bnRJZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgaW5pdEFjY291bnRTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlY29yZF9pbml0QWNjb3VudFN0YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIGZpbmFsQWNjb3VudFN0YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVjb3JkX2ZpbmFsQWNjb3VudFN0YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkW119XG4gICAgICovXG4gICAgaW5wdXROb3RlTnVsbGlmaWVycygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnJlY29yZF9pbnB1dE5vdGVOdWxsaWZpZXJzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T3V0cHV0Tm90ZXN9XG4gICAgICovXG4gICAgb3V0cHV0Tm90ZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfb3V0cHV0Tm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gT3V0cHV0Tm90ZXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmxvY2tOdW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfYmxvY2tOdW0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25TdGF0dXN9XG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25TdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfdHJhbnNhY3Rpb25TdGF0dXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgY3JlYXRpb25UaW1lc3RhbXAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZWNvcmRfY3JlYXRpb25UaW1lc3RhbXAodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblJlY29yZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25SZWNvcmQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uUmVxdWVzdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnJlcXVlc3RfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25SZXF1ZXN0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXF1ZXN0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVxdWVzdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25yZXF1ZXN0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdF9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RfZGVzZXJpYWxpemUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOb3RlW119XG4gICAgICovXG4gICAgZXhwZWN0ZWRPdXRwdXRPd25Ob3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RfZXhwZWN0ZWRPdXRwdXRPd25Ob3RlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZURldGFpbHNBbmRUYWdbXX1cbiAgICAgKi9cbiAgICBleHBlY3RlZEZ1dHVyZU5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdF9leHBlY3RlZEZ1dHVyZU5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogNCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHNjcmlwdEFyZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3Rfc2NyaXB0QXJnKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtXb3JkIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGF1dGhBcmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0X2F1dGhBcmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uUmVxdWVzdC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25SZXF1ZXN0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlckZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVBbmRBcmdzQXJyYXl9IG5vdGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aFVuYXV0aGVudGljYXRlZElucHV0Tm90ZXMobm90ZXMpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVzLCBOb3RlQW5kQXJnc0FycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhVbmF1dGhlbnRpY2F0ZWRJbnB1dE5vdGVzKHB0ciwgbm90ZXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUlkQW5kQXJnc0FycmF5fSBub3Rlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhBdXRoZW50aWNhdGVkSW5wdXROb3Rlcyhub3Rlcykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZXMsIE5vdGVJZEFuZEFyZ3NBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoQXV0aGVudGljYXRlZElucHV0Tm90ZXMocHRyLCBub3Rlcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPdXRwdXROb3RlQXJyYXl9IG5vdGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aE93bk91dHB1dE5vdGVzKG5vdGVzKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhub3RlcywgT3V0cHV0Tm90ZUFycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhPd25PdXRwdXROb3RlcyhwdHIsIG5vdGVzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU2NyaXB0fSBzY3JpcHRcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoQ3VzdG9tU2NyaXB0KHNjcmlwdCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2NyaXB0LCBUcmFuc2FjdGlvblNjcmlwdCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoQ3VzdG9tU2NyaXB0KHB0ciwgc2NyaXB0Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVSZWNpcGllbnRBcnJheX0gcmVjaXBpZW50c1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhFeHBlY3RlZE91dHB1dFJlY2lwaWVudHMocmVjaXBpZW50cykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmVjaXBpZW50cywgTm90ZVJlY2lwaWVudEFycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhFeHBlY3RlZE91dHB1dFJlY2lwaWVudHMocHRyLCByZWNpcGllbnRzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVEZXRhaWxzQW5kVGFnQXJyYXl9IG5vdGVfZGV0YWlsc19hbmRfdGFnXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgd2l0aEV4cGVjdGVkRnV0dXJlTm90ZXMobm90ZV9kZXRhaWxzX2FuZF90YWcpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGVfZGV0YWlsc19hbmRfdGFnLCBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnJlcXVlc3RidWlsZGVyX3dpdGhFeHBlY3RlZEZ1dHVyZU5vdGVzKHB0ciwgbm90ZV9kZXRhaWxzX2FuZF90YWcuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWR2aWNlTWFwfSBhZHZpY2VfbWFwXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXJ9XG4gICAgICovXG4gICAgZXh0ZW5kQWR2aWNlTWFwKGFkdmljZV9tYXApIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFkdmljZV9tYXAsIEFkdmljZU1hcCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl9leHRlbmRBZHZpY2VNYXAocHRyLCBhZHZpY2VfbWFwLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZvcmVpZ25BY2NvdW50QXJyYXl9IGZvcmVpZ25fYWNjb3VudHNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlcn1cbiAgICAgKi9cbiAgICB3aXRoRm9yZWlnbkFjY291bnRzKGZvcmVpZ25fYWNjb3VudHMpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGZvcmVpZ25fYWNjb3VudHMsIEZvcmVpZ25BY2NvdW50QXJyYXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfd2l0aEZvcmVpZ25BY2NvdW50cyhwdHIsIGZvcmVpZ25fYWNjb3VudHMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gc2NyaXB0X2FyZ1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhTY3JpcHRBcmcoc2NyaXB0X2FyZykge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2NyaXB0X2FyZywgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoU2NyaXB0QXJnKHB0ciwgc2NyaXB0X2FyZy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0QnVpbGRlci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXb3JkfSBhdXRoX2FyZ1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyfVxuICAgICAqL1xuICAgIHdpdGhBdXRoQXJnKGF1dGhfYXJnKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhdXRoX2FyZywgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXF1ZXN0YnVpbGRlcl93aXRoQXV0aEFyZyhwdHIsIGF1dGhfYXJnLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3RCdWlsZGVyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0fVxuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVxdWVzdGJ1aWxkZXJfYnVpbGQocHRyKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uUmVzdWx0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9ucmVzdWx0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFdBU00gd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBbYFRyYW5zYWN0aW9uUmVzdWx0YF0uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uUmVzdWx0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2FjdGlvblJlc3VsdC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblJlc3VsdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblJlc3VsdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25yZXN1bHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uSWR9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0ZWR0cmFuc2FjdGlvbl9pZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbklkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBleGVjdXRlZCB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RXhlY3V0ZWRUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBleGVjdXRlZFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9ucmVzdWx0X2V4ZWN1dGVkVHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRXhlY3V0ZWRUcmFuc2FjdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBub3RlcyB0aGF0IGFyZSBleHBlY3RlZCB0byBiZSBjcmVhdGVkIGFzIGEgcmVzdWx0IG9mIGZvbGxvdy11cCBleGVjdXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtOb3RlRGV0YWlsc0FuZFRhZ1tdfVxuICAgICAqL1xuICAgIGZ1dHVyZU5vdGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9ucmVzdWx0X2Z1dHVyZU5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSB0cmFuc2FjdGlvbiByZXN1bHQgaW50byBieXRlcy5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25yZXN1bHRfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGEgdHJhbnNhY3Rpb24gcmVzdWx0IGZyb20gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblJlc3VsdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnJlc3VsdF9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlc3VsdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25SZXN1bHQucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uUmVzdWx0LnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblNjcmlwdEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ190cmFuc2FjdGlvbnNjcmlwdF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblNjcmlwdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25TY3JpcHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc2NyaXB0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1dvcmR9XG4gICAgICovXG4gICAgcm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ub3Rlc2NyaXB0X3Jvb3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5pZiAoU3ltYm9sLmRpc3Bvc2UpIFRyYW5zYWN0aW9uU2NyaXB0LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblNjcmlwdC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gd29yZFxuICAgICAqIEBwYXJhbSB7RmVsdEFycmF5fSBmZWx0c1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdvcmQsIGZlbHRzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh3b3JkLCBXb3JkKTtcbiAgICAgICAgdmFyIHB0cjAgPSB3b3JkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZmVsdHMsIEZlbHRBcnJheSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJfbmV3KHB0cjAsIGZlbHRzLl9fd2JnX3B0cik7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICB3b3JkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFjY291bnRjb2RlX2NvbW1pdG1lbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0ZlbHRBcnJheX1cbiAgICAgKi9cbiAgICBmZWx0cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcl9mZWx0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGZWx0QXJyYXkuX193cmFwKHJldCk7XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpci5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJhcnJheV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5IHtcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJhcnJheV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJbXSB8IG51bGx9IFtlbGVtZW50c11cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoZWxlbWVudHMpID8gMCA6IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGVsZW1lbnRzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJhcnJheV9uZXcocHRyMCwgbGVuMCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBUcmFuc2FjdGlvblNjcmlwdElucHV0UGFpckFycmF5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbGVtZW50IGF0IGluZGV4LCB3aWxsIGFsd2F5cyByZXR1cm4gYSBjbG9uZSB0byBhdm9pZCBhbGlhc2luZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyfVxuICAgICAqL1xuICAgIGdldChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc2NyaXB0aW5wdXRwYWlyYXJyYXlfZ2V0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJ9IGVsZW1cbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGVsZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGVsZW0sIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gZWxlbS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zY3JpcHRpbnB1dHBhaXJhcnJheV9yZXBsYWNlQXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaW5kZXgsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJ9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGVsZW1lbnQsIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyKTtcbiAgICAgICAgd2FzbS50cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcmFycmF5X3B1c2godGhpcy5fX3diZ19wdHIsIGVsZW1lbnQuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ub3V0cHV0bm90ZXNhcnJheV9sZW5ndGgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheS5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXJBcnJheS5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgVHJhbnNhY3Rpb25TdGF0dXNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25zdGF0dXNfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25TdGF0dXMge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFRyYW5zYWN0aW9uU3RhdHVzLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uU3RhdHVzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU3RhdHVzRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ190cmFuc2FjdGlvbnN0YXR1c19mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN0YXR1c31cbiAgICAgKi9cbiAgICBzdGF0aWMgcGVuZGluZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19wZW5kaW5nKCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrX251bVxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBjb21taXRfdGltZXN0YW1wXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3RhdHVzfVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21taXR0ZWQoYmxvY2tfbnVtLCBjb21taXRfdGltZXN0YW1wKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfY29tbWl0dGVkKGJsb2NrX251bSwgY29tbWl0X3RpbWVzdGFtcCk7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdXNlXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3RhdHVzfVxuICAgICAqL1xuICAgIHN0YXRpYyBkaXNjYXJkZWQoY2F1c2UpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGNhdXNlLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdGF0dXNfZGlzY2FyZGVkKHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUGVuZGluZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19pc1BlbmRpbmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbW1pdHRlZCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19pc0NvbW1pdHRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRGlzY2FyZGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RhdHVzX2lzRGlzY2FyZGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRCbG9ja051bSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0YXR1c19nZXRCbG9ja051bSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDB4MTAwMDAwMDAxID8gdW5kZWZpbmVkIDogcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldENvbW1pdFRpbWVzdGFtcCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN0YXR1c19nZXRDb21taXRUaW1lc3RhbXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRCaWdJbnQ2NChyZXRwdHIgKyA4ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiBCaWdJbnQuYXNVaW50Tig2NCwgcjIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25TdGF0dXMucHJvdG90eXBlW1N5bWJvbC5kaXNwb3NlXSA9IFRyYW5zYWN0aW9uU3RhdHVzLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblN0b3JlVXBkYXRlRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc3RvcmV1cGRhdGVfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25TdG9yZVVwZGF0ZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBUcmFuc2FjdGlvblN0b3JlVXBkYXRlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFRyYW5zYWN0aW9uU3RvcmVVcGRhdGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc3RvcmV1cGRhdGVfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RXhlY3V0ZWRUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBleGVjdXRlZFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uc3RvcmV1cGRhdGVfZXhlY3V0ZWRUcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBFeGVjdXRlZFRyYW5zYWN0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN1Ym1pc3Npb25IZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9zdWJtaXNzaW9uSGVpZ2h0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge091dHB1dE5vdGVzfVxuICAgICAqL1xuICAgIGNyZWF0ZWROb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX2NyZWF0ZWROb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBPdXRwdXROb3Rlcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FjY291bnREZWx0YX1cbiAgICAgKi9cbiAgICBhY2NvdW50RGVsdGEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9hY2NvdW50RGVsdGEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWNjb3VudERlbHRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Tm90ZURldGFpbHNBbmRUYWdbXX1cbiAgICAgKi9cbiAgICBmdXR1cmVOb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN0b3JldXBkYXRlX2Z1dHVyZU5vdGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9zZXJpYWxpemUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uU3RvcmVVcGRhdGV9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9kZXNlcmlhbGl6ZShyZXRwdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblN0b3JlVXBkYXRlLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKFN5bWJvbC5kaXNwb3NlKSBUcmFuc2FjdGlvblN0b3JlVXBkYXRlLnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblN0b3JlVXBkYXRlLnByb3RvdHlwZS5mcmVlO1xuXG5jb25zdCBUcmFuc2FjdGlvblN1bW1hcnlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25zdW1tYXJ5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uU3VtbWFyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb25TdW1tYXJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zYWN0aW9uU3VtbWFyeUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBUcmFuc2FjdGlvblN1bW1hcnlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uc3VtbWFyeV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbnN1bW1hcnlfc2VyaWFsaXplKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblN1bW1hcnl9XG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdW1tYXJ5X2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uU3VtbWFyeS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QWNjb3VudERlbHRhfVxuICAgICAqL1xuICAgIGFjY291bnREZWx0YSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN1bW1hcnlfYWNjb3VudERlbHRhKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNjb3VudERlbHRhLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vdGVzfVxuICAgICAqL1xuICAgIGlucHV0Tm90ZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25zdW1tYXJ5X2lucHV0Tm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJbnB1dE5vdGVzLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPdXRwdXROb3Rlc31cbiAgICAgKi9cbiAgICBvdXRwdXROb3RlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbnN1bW1hcnlfb3V0cHV0Tm90ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPdXRwdXROb3Rlcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzYWx0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uc3VtbWFyeV9zYWx0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV29yZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgVHJhbnNhY3Rpb25TdW1tYXJ5LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBUcmFuc2FjdGlvblN1bW1hcnkucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFdlYkNsaWVudEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ193ZWJjbGllbnRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgV2ViQ2xpZW50IHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgV2ViQ2xpZW50RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ193ZWJjbGllbnRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50SGVhZGVyW10+fVxuICAgICAqL1xuICAgIGdldEFjY291bnRzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRBY2NvdW50cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudCB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgZ2V0QWNjb3VudChhY2NvdW50X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRBY2NvdW50KHRoaXMuX193YmdfcHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gcHViX2tleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF1dGhTZWNyZXRLZXk+fVxuICAgICAqL1xuICAgIGdldEFjY291bnRBdXRoQnlQdWJLZXkocHViX2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHViX2tleSwgV29yZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldEFjY291bnRBdXRoQnlQdWJLZXkodGhpcy5fX3diZ19wdHIsIHB1Yl9rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBpbnNlcnRBY2NvdW50QWRkcmVzcyhhY2NvdW50X2lkLCBhZGRyZXNzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWRkcmVzcywgQWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2luc2VydEFjY291bnRBZGRyZXNzKHRoaXMuX193YmdfcHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0ciwgYWRkcmVzcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHJlbW92ZUFjY291bnRBZGRyZXNzKGFjY291bnRfaWQsIGFkZHJlc3MpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhZGRyZXNzLCBBZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfcmVtb3ZlQWNjb3VudEFkZHJlc3ModGhpcy5fX3diZ19wdHIsIGFjY291bnRfaWQuX193YmdfcHRyLCBhZGRyZXNzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBub3RlX2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cG9ydF90eXBlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm90ZUZpbGU+fVxuICAgICAqL1xuICAgIGV4cG9ydE5vdGVGaWxlKG5vdGVfaWQsIGV4cG9ydF90eXBlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChub3RlX2lkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChleHBvcnRfdHlwZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9leHBvcnROb3RlRmlsZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZW50aXJlIHVuZGVybHlpbmcgd2ViIHN0b3JlIGFuZCByZXR1cm5zIGl0IGFzIGEgYEpzVmFsdWVgXG4gICAgICpcbiAgICAgKiBNZWFudCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBmb3JjZV9pbXBvcnRfc3RvcmVgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZXhwb3J0U3RvcmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2V4cG9ydFN0b3JlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGFjY291bnRfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50RmlsZT59XG4gICAgICovXG4gICAgZXhwb3J0QWNjb3VudEZpbGUoYWNjb3VudF9pZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgdmFyIHB0cjAgPSBhY2NvdW50X2lkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9leHBvcnRBY2NvdW50RmlsZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudEZpbGV9IGFjY291bnRfZmlsZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgaW1wb3J0QWNjb3VudEZpbGUoYWNjb3VudF9maWxlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2ZpbGUsIEFjY291bnRGaWxlKTtcbiAgICAgICAgdmFyIHB0cjAgPSBhY2NvdW50X2ZpbGUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2ltcG9ydEFjY291bnRGaWxlKHRoaXMuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbml0X3NlZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11dGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXV0aF9zY2hlbWVfaWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2NvdW50Pn1cbiAgICAgKi9cbiAgICBpbXBvcnRQdWJsaWNBY2NvdW50RnJvbVNlZWQoaW5pdF9zZWVkLCBtdXRhYmxlLCBhdXRoX3NjaGVtZV9pZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoaW5pdF9zZWVkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfaW1wb3J0UHVibGljQWNjb3VudEZyb21TZWVkKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBtdXRhYmxlLCBhdXRoX3NjaGVtZV9pZCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBpbXBvcnRBY2NvdW50QnlJZChhY2NvdW50X2lkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9pbXBvcnRBY2NvdW50QnlJZCh0aGlzLl9fd2JnX3B0ciwgYWNjb3VudF9pZC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVGaWxlfSBub3RlX2ZpbGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3RlSWQ+fVxuICAgICAqL1xuICAgIGltcG9ydE5vdGVGaWxlKG5vdGVfZmlsZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm90ZV9maWxlLCBOb3RlRmlsZSk7XG4gICAgICAgIHZhciBwdHIwID0gbm90ZV9maWxlLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9pbXBvcnROb3RlRmlsZSh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBzdG9yZV9kdW1wXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBmb3JjZUltcG9ydFN0b3JlKHN0b3JlX2R1bXApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZm9yY2VJbXBvcnRTdG9yZSh0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChzdG9yZV9kdW1wKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xpZW50IHdpdGggYSBtb2NrIFJQQyBBUEkuIFVzZWZ1bCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgcHJvb2Ytb2YtY29uY2VwdFxuICAgICAqIGFwcGxpY2F0aW9ucyBhcyBpdCB1c2VzIGEgbW9jayBjaGFpbiB0aGF0IHNpbXVsYXRlcyB0aGUgYmVoYXZpb3Igb2YgYSByZWFsIG5vZGUuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlZWRdXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlcmlhbGl6ZWRfbW9ja19jaGFpbl1cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBudWxsfSBbc2VyaWFsaXplZF9tb2NrX25vdGVfdHJhbnNwb3J0X25vZGVdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjcmVhdGVNb2NrQ2xpZW50KHNlZWQsIHNlcmlhbGl6ZWRfbW9ja19jaGFpbiwgc2VyaWFsaXplZF9tb2NrX25vdGVfdHJhbnNwb3J0X25vZGUpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKHNlZWQpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHNlcmlhbGl6ZWRfbW9ja19jaGFpbikgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VyaWFsaXplZF9tb2NrX2NoYWluLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgdmFyIGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIyID0gaXNMaWtlTm9uZShzZXJpYWxpemVkX21vY2tfbm90ZV90cmFuc3BvcnRfbm9kZSkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VyaWFsaXplZF9tb2NrX25vdGVfdHJhbnNwb3J0X25vZGUsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfY3JlYXRlTW9ja0NsaWVudCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlubmVyIHNlcmlhbGl6ZWQgbW9jayBjaGFpbiBpZiBpdCBleGlzdHMuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgc2VyaWFsaXplTW9ja0NoYWluKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9zZXJpYWxpemVNb2NrQ2hhaW4ocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlubmVyIHNlcmlhbGl6ZWQgbW9jayBub3RlIHRyYW5zcG9ydCBub2RlIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBzZXJpYWxpemVNb2NrTm90ZVRyYW5zcG9ydE5vZGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X3NlcmlhbGl6ZU1vY2tOb3RlVHJhbnNwb3J0Tm9kZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdmVCbG9jaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfcHJvdmVCbG9jayhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB1c2VzTW9ja0NoYWluKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF91c2VzTW9ja0NoYWluKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50U3RvcmFnZU1vZGV9IHN0b3JhZ2VfbW9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdXRoX3NjaGVtZV9pZFxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtpbml0X3NlZWRdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWNjb3VudD59XG4gICAgICovXG4gICAgbmV3V2FsbGV0KHN0b3JhZ2VfbW9kZSwgbXV0YWJsZSwgYXV0aF9zY2hlbWVfaWQsIGluaXRfc2VlZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc3RvcmFnZV9tb2RlLCBBY2NvdW50U3RvcmFnZU1vZGUpO1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUoaW5pdF9zZWVkKSA/IDAgOiBwYXNzQXJyYXk4VG9XYXNtMChpbml0X3NlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfbmV3V2FsbGV0KHRoaXMuX193YmdfcHRyLCBzdG9yYWdlX21vZGUuX193YmdfcHRyLCBtdXRhYmxlLCBhdXRoX3NjaGVtZV9pZCwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudFN0b3JhZ2VNb2RlfSBzdG9yYWdlX21vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5vbl9mdW5naWJsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbl9zeW1ib2xcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHNcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gbWF4X3N1cHBseVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdXRoX3NjaGVtZV9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjY291bnQ+fVxuICAgICAqL1xuICAgIG5ld0ZhdWNldChzdG9yYWdlX21vZGUsIG5vbl9mdW5naWJsZSwgdG9rZW5fc3ltYm9sLCBkZWNpbWFscywgbWF4X3N1cHBseSwgYXV0aF9zY2hlbWVfaWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHN0b3JhZ2VfbW9kZSwgQWNjb3VudFN0b3JhZ2VNb2RlKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHRva2VuX3N5bWJvbCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9uZXdGYXVjZXQodGhpcy5fX3diZ19wdHIsIHN0b3JhZ2VfbW9kZS5fX3diZ19wdHIsIG5vbl9mdW5naWJsZSwgcHRyMCwgbGVuMCwgZGVjaW1hbHMsIG1heF9zdXBwbHksIGF1dGhfc2NoZW1lX2lkKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50fSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBuZXdBY2NvdW50KGFjY291bnQsIG92ZXJ3cml0ZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudCwgQWNjb3VudCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X25ld0FjY291bnQodGhpcy5fX3diZ19wdHIsIGFjY291bnQuX193YmdfcHRyLCBvdmVyd3JpdGUpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NlY3JldEtleX0gc2VjcmV0X2tleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFkZEFjY291bnRTZWNyZXRLZXlUb1dlYlN0b3JlKHNlY3JldF9rZXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNlY3JldF9rZXksIFNlY3JldEtleSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2FkZEFjY291bnRTZWNyZXRLZXlUb1dlYlN0b3JlKHRoaXMuX193YmdfcHRyLCBzZWNyZXRfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgdHJhbnNhY3Rpb24gc3BlY2lmaWVkIGJ5IHRoZSByZXF1ZXN0IGFnYWluc3QgdGhlIHNwZWNpZmllZCBhY2NvdW50LFxuICAgICAqIHByb3ZlcyBpdCwgc3VibWl0cyBpdCB0byB0aGUgbmV0d29yaywgYW5kIHVwZGF0ZXMgdGhlIGxvY2FsIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zYWN0aW9uIHV0aWxpemVzIGZvcmVpZ24gYWNjb3VudCBkYXRhLCB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHRoZSBjbGllbnQgZG9lc24ndFxuICAgICAqIGhhdmUgdGhlIHJlcXVpcmVkIGJsb2NrIGhlYWRlciBpbiB0aGUgbG9jYWwgZGF0YWJhc2UuIEluIHRoZXNlIHNjZW5hcmlvcywgYSBzeW5jIHRvXG4gICAgICogdGhlIGNoYWluIHRpcCBpcyBwZXJmb3JtZWQsIGFuZCB0aGUgcmVxdWlyZWQgYmxvY2sgaGVhZGVyIGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gYWNjb3VudF9pZFxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZXF1ZXN0fSB0cmFuc2FjdGlvbl9yZXF1ZXN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25JZD59XG4gICAgICovXG4gICAgc3VibWl0TmV3VHJhbnNhY3Rpb24oYWNjb3VudF9pZCwgdHJhbnNhY3Rpb25fcmVxdWVzdCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zYWN0aW9uX3JlcXVlc3QsIFRyYW5zYWN0aW9uUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3N1Ym1pdE5ld1RyYW5zYWN0aW9uKHRoaXMuX193YmdfcHRyLCBhY2NvdW50X2lkLl9fd2JnX3B0ciwgdHJhbnNhY3Rpb25fcmVxdWVzdC5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHRyYW5zYWN0aW9uIHNwZWNpZmllZCBieSB0aGUgcmVxdWVzdCBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgYWNjb3VudCBidXQgZG9lcyBub3RcbiAgICAgKiBzdWJtaXQgaXQgdG8gdGhlIG5ldHdvcmsgbm9yIHVwZGF0ZSB0aGUgbG9jYWwgZGF0YWJhc2UuIFRoZSByZXR1cm5lZCBbYFRyYW5zYWN0aW9uUmVzdWx0YF1cbiAgICAgKiByZXRhaW5zIHRoZSBleGVjdXRpb24gYXJ0aWZhY3RzIG5lZWRlZCB0byBjb250aW51ZSB3aXRoIHRoZSB0cmFuc2FjdGlvbiBsaWZlY3ljbGUuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdHJhbnNhY3Rpb24gdXRpbGl6ZXMgZm9yZWlnbiBhY2NvdW50IGRhdGEsIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgdGhlIGNsaWVudCBkb2Vzbid0XG4gICAgICogaGF2ZSB0aGUgcmVxdWlyZWQgYmxvY2sgaGVhZGVyIGluIHRoZSBsb2NhbCBkYXRhYmFzZS4gSW4gdGhlc2Ugc2NlbmFyaW9zLCBhIHN5bmMgdG9cbiAgICAgKiB0aGUgY2hhaW4gdGlwIGlzIHBlcmZvcm1lZCwgYW5kIHRoZSByZXF1aXJlZCBibG9jayBoZWFkZXIgaXMgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSB7QWNjb3VudElkfSBhY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlcXVlc3R9IHRyYW5zYWN0aW9uX3JlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblJlc3VsdD59XG4gICAgICovXG4gICAgZXhlY3V0ZVRyYW5zYWN0aW9uKGFjY291bnRfaWQsIHRyYW5zYWN0aW9uX3JlcXVlc3QpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2FjdGlvbl9yZXF1ZXN0LCBUcmFuc2FjdGlvblJlcXVlc3QpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9leGVjdXRlVHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIsIGFjY291bnRfaWQuX193YmdfcHRyLCB0cmFuc2FjdGlvbl9yZXF1ZXN0Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHRyYW5zYWN0aW9uIHByb29mIHVzaW5nIGVpdGhlciB0aGUgcHJvdmlkZWQgcHJvdmVyIG9yIHRoZSBjbGllbnQncyBkZWZhdWx0XG4gICAgICogcHJvdmVyIGlmIG5vbmUgaXMgc3VwcGxpZWQuXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlc3VsdH0gdHJhbnNhY3Rpb25fcmVzdWx0XG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblByb3ZlciB8IG51bGx9IFtwcm92ZXJdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHJvdmVuVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHByb3ZlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25fcmVzdWx0LCBwcm92ZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zYWN0aW9uX3Jlc3VsdCwgVHJhbnNhY3Rpb25SZXN1bHQpO1xuICAgICAgICBsZXQgcHRyMCA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShwcm92ZXIpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocHJvdmVyLCBUcmFuc2FjdGlvblByb3Zlcik7XG4gICAgICAgICAgICBwdHIwID0gcHJvdmVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3Byb3ZlVHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIsIHRyYW5zYWN0aW9uX3Jlc3VsdC5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Byb3ZlblRyYW5zYWN0aW9ufSBwcm92ZW5fdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVzdWx0fSB0cmFuc2FjdGlvbl9yZXN1bHRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgICAqL1xuICAgIHN1Ym1pdFByb3ZlblRyYW5zYWN0aW9uKHByb3Zlbl90cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25fcmVzdWx0KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwcm92ZW5fdHJhbnNhY3Rpb24sIFByb3ZlblRyYW5zYWN0aW9uKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zYWN0aW9uX3Jlc3VsdCwgVHJhbnNhY3Rpb25SZXN1bHQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9zdWJtaXRQcm92ZW5UcmFuc2FjdGlvbih0aGlzLl9fd2JnX3B0ciwgcHJvdmVuX3RyYW5zYWN0aW9uLl9fd2JnX3B0ciwgdHJhbnNhY3Rpb25fcmVzdWx0Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZXN1bHR9IHRyYW5zYWN0aW9uX3Jlc3VsdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJtaXNzaW9uX2hlaWdodFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU3RvcmVVcGRhdGU+fVxuICAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25fcmVzdWx0LCBzdWJtaXNzaW9uX2hlaWdodCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNhY3Rpb25fcmVzdWx0LCBUcmFuc2FjdGlvblJlc3VsdCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2FwcGx5VHJhbnNhY3Rpb24odGhpcy5fX3diZ19wdHIsIHRyYW5zYWN0aW9uX3Jlc3VsdC5fX3diZ19wdHIsIHN1Ym1pc3Npb25faGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHRhcmdldF9hY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBhbW91bnRcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0fVxuICAgICAqL1xuICAgIG5ld01pbnRUcmFuc2FjdGlvblJlcXVlc3QodGFyZ2V0X2FjY291bnRfaWQsIGZhdWNldF9pZCwgbm90ZV90eXBlLCBhbW91bnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRhcmdldF9hY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X25ld01pbnRUcmFuc2FjdGlvblJlcXVlc3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgdGFyZ2V0X2FjY291bnRfaWQuX193YmdfcHRyLCBmYXVjZXRfaWQuX193YmdfcHRyLCBub3RlX3R5cGUsIGFtb3VudCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3QuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHNlbmRlcl9hY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHRhcmdldF9hY2NvdW50X2lkXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IGZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7Tm90ZVR5cGV9IG5vdGVfdHlwZVxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBhbW91bnRcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFtyZWNhbGxfaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW3RpbWVsb2NrX2hlaWdodF1cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0fVxuICAgICAqL1xuICAgIG5ld1NlbmRUcmFuc2FjdGlvblJlcXVlc3Qoc2VuZGVyX2FjY291bnRfaWQsIHRhcmdldF9hY2NvdW50X2lkLCBmYXVjZXRfaWQsIG5vdGVfdHlwZSwgYW1vdW50LCByZWNhbGxfaGVpZ2h0LCB0aW1lbG9ja19oZWlnaHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNlbmRlcl9hY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRhcmdldF9hY2NvdW50X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X25ld1NlbmRUcmFuc2FjdGlvblJlcXVlc3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgc2VuZGVyX2FjY291bnRfaWQuX193YmdfcHRyLCB0YXJnZXRfYWNjb3VudF9pZC5fX3diZ19wdHIsIGZhdWNldF9pZC5fX3diZ19wdHIsIG5vdGVfdHlwZSwgYW1vdW50LCBpc0xpa2VOb25lKHJlY2FsbF9oZWlnaHQpID8gMHgxMDAwMDAwMDEgOiAocmVjYWxsX2hlaWdodCkgPj4+IDAsIGlzTGlrZU5vbmUodGltZWxvY2tfaGVpZ2h0KSA/IDB4MTAwMDAwMDAxIDogKHRpbWVsb2NrX2hlaWdodCkgPj4+IDApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXF1ZXN0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxpc3Rfb2Zfbm90ZV9pZHNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0fVxuICAgICAqL1xuICAgIG5ld0NvbnN1bWVUcmFuc2FjdGlvblJlcXVlc3QobGlzdF9vZl9ub3RlX2lkcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5SnNWYWx1ZVRvV2FzbTAobGlzdF9vZl9ub3RlX2lkcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS53ZWJjbGllbnRfbmV3Q29uc3VtZVRyYW5zYWN0aW9uUmVxdWVzdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uUmVxdWVzdC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gc2VuZGVyX2FjY291bnRfaWRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gb2ZmZXJlZF9hc3NldF9mYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gb2ZmZXJlZF9hc3NldF9hbW91bnRcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZH0gcmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZFxuICAgICAqIEBwYXJhbSB7YmlnaW50fSByZXF1ZXN0ZWRfYXNzZXRfYW1vdW50XG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gcGF5YmFja19ub3RlX3R5cGVcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25SZXF1ZXN0fVxuICAgICAqL1xuICAgIG5ld1N3YXBUcmFuc2FjdGlvblJlcXVlc3Qoc2VuZGVyX2FjY291bnRfaWQsIG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkLCBvZmZlcmVkX2Fzc2V0X2Ftb3VudCwgcmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZCwgcmVxdWVzdGVkX2Fzc2V0X2Ftb3VudCwgbm90ZV90eXBlLCBwYXliYWNrX25vdGVfdHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2VuZGVyX2FjY291bnRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Mob2ZmZXJlZF9hc3NldF9mYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmVxdWVzdGVkX2Fzc2V0X2ZhdWNldF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHdhc20ud2ViY2xpZW50X25ld1N3YXBUcmFuc2FjdGlvblJlcXVlc3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgc2VuZGVyX2FjY291bnRfaWQuX193YmdfcHRyLCBvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZC5fX3diZ19wdHIsIG9mZmVyZWRfYXNzZXRfYW1vdW50LCByZXF1ZXN0ZWRfYXNzZXRfZmF1Y2V0X2lkLl9fd2JnX3B0ciwgcmVxdWVzdGVkX2Fzc2V0X2Ftb3VudCwgbm90ZV90eXBlLCBwYXliYWNrX25vdGVfdHlwZSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvblJlcXVlc3QuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHByaXZhdGUgbm90ZSB2aWEgdGhlIG5vdGUgdHJhbnNwb3J0IGxheWVyXG4gICAgICogQHBhcmFtIHtOb3RlfSBub3RlXG4gICAgICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgc2VuZFByaXZhdGVOb3RlKG5vdGUsIGFkZHJlc3MpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5vdGUsIE5vdGUpO1xuICAgICAgICB2YXIgcHRyMCA9IG5vdGUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhZGRyZXNzLCBBZGRyZXNzKTtcbiAgICAgICAgdmFyIHB0cjEgPSBhZGRyZXNzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9zZW5kUHJpdmF0ZU5vdGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIHB0cjEpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBwcml2YXRlIG5vdGVzIGZyb20gdGhlIG5vdGUgdHJhbnNwb3J0IGxheWVyXG4gICAgICpcbiAgICAgKiBVc2VzIGFuIGludGVybmFsIHBhZ2luYXRpb24gbWVjaGFuaXNtIHRvIGF2b2lkIGZldGNoaW5nIGR1cGxpY2F0ZSBub3Rlcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBmZXRjaFByaXZhdGVOb3RlcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZmV0Y2hQcml2YXRlTm90ZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbGwgcHJpdmF0ZSBub3RlcyBmcm9tIHRoZSBub3RlIHRyYW5zcG9ydCBsYXllclxuICAgICAqXG4gICAgICogRmV0Y2hlcyBhbGwgbm90ZXMgc3RvcmVkIGluIHRoZSB0cmFuc3BvcnQgbGF5ZXIsIHdpdGggbm8gcGFnaW5hdGlvbi5cbiAgICAgKiBQcmVmZXIgdXNpbmcgW2BXZWJDbGllbnQ6OmZldGNoX3ByaXZhdGVfbm90ZXNgXSBmb3IgYSBtb3JlIGVmZmljaWVudCwgb24tZ29pbmcsXG4gICAgICogZmV0Y2hpbmcgbWVjaGFuaXNtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGZldGNoQWxsUHJpdmF0ZU5vdGVzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9mZXRjaEFsbFByaXZhdGVOb3Rlcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm90ZUZpbHRlcn0gZmlsdGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW5wdXROb3RlUmVjb3JkW10+fVxuICAgICAqL1xuICAgIGdldElucHV0Tm90ZXMoZmlsdGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmaWx0ZXIsIE5vdGVGaWx0ZXIpO1xuICAgICAgICB2YXIgcHRyMCA9IGZpbHRlci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0SW5wdXROb3Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBub3RlX2lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW5wdXROb3RlUmVjb3JkIHwgdW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBnZXRJbnB1dE5vdGUobm90ZV9pZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAobm90ZV9pZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRJbnB1dE5vdGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vdGVGaWx0ZXJ9IGZpbHRlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0T3V0cHV0Tm90ZXMoZmlsdGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmaWx0ZXIsIE5vdGVGaWx0ZXIpO1xuICAgICAgICB2YXIgcHRyMCA9IGZpbHRlci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfZ2V0T3V0cHV0Tm90ZXModGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbm90ZV9pZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0T3V0cHV0Tm90ZShub3RlX2lkKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChub3RlX2lkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldE91dHB1dE5vdGUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FjY291bnRJZCB8IG51bGx9IFthY2NvdW50X2lkXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbnN1bWFibGVOb3RlUmVjb3JkW10+fVxuICAgICAqL1xuICAgIGdldENvbnN1bWFibGVOb3RlcyhhY2NvdW50X2lkKSB7XG4gICAgICAgIGxldCBwdHIwID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGFjY291bnRfaWQpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYWNjb3VudF9pZCwgQWNjb3VudElkKTtcbiAgICAgICAgICAgIHB0cjAgPSBhY2NvdW50X2lkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldENvbnN1bWFibGVOb3Rlcyh0aGlzLl9fd2JnX3B0ciwgcHRyMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc2V0dGluZyB2YWx1ZSBmb3IgYGtleWAsIG9yIGBOb25lYCBpZiBpdCBoYXNu4oCZdCBiZWVuIHNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55IHwgdW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBnZXRTZXR0aW5nKGtleSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoa2V5LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2dldFNldHRpbmcodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc2V0dGluZyBrZXktdmFsdWUgaW4gdGhlIHN0b3JlLiBJdCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgYGdldF9zZXR0aW5nYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgc2V0U2V0dGluZyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChrZXksIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfc2V0U2V0dGluZyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgYWRkSGVhcE9iamVjdCh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgc2V0dGluZyBrZXktdmFsdWUgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHJlbW92ZVNldHRpbmcoa2V5KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChrZXksIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfcmVtb3ZlU2V0dGluZyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSBleGlzdGluZyBzZXR0aW5nIGtleXMgZnJvbSB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxuICAgICAqL1xuICAgIGxpc3RTZXR0aW5nS2V5cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfbGlzdFNldHRpbmdLZXlzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3luY1N1bW1hcnk+fVxuICAgICAqL1xuICAgIHN5bmNTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfc3luY1N0YXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICAgKi9cbiAgICBnZXRTeW5jSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRTeW5jSGVpZ2h0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb3RlVHlwZX0gbm90ZV90eXBlXG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IG9mZmVyZWRfYXNzZXRfYW1vdW50XG4gICAgICogQHBhcmFtIHtBY2NvdW50SWR9IHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWRcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gcmVxdWVzdGVkX2Fzc2V0X2Ftb3VudFxuICAgICAqIEByZXR1cm5zIHtOb3RlVGFnfVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFN3YXBUYWcobm90ZV90eXBlLCBvZmZlcmVkX2Fzc2V0X2ZhdWNldF9pZCwgb2ZmZXJlZF9hc3NldF9hbW91bnQsIHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWQsIHJlcXVlc3RlZF9hc3NldF9hbW91bnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkLCBBY2NvdW50SWQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWQsIEFjY291bnRJZCk7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9idWlsZFN3YXBUYWcocmV0cHRyLCBub3RlX3R5cGUsIG9mZmVyZWRfYXNzZXRfZmF1Y2V0X2lkLl9fd2JnX3B0ciwgb2ZmZXJlZF9hc3NldF9hbW91bnQsIHJlcXVlc3RlZF9hc3NldF9mYXVjZXRfaWQuX193YmdfcHRyLCByZXF1ZXN0ZWRfYXNzZXRfYW1vdW50KTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5vdGVUYWcuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFkZFRhZyh0YWcpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHRhZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9hZGRUYWcodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVtb3ZlVGFnKHRhZykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodGFnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X3JlbW92ZVRhZyh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgbGlzdFRhZ3MoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ud2ViY2xpZW50X2xpc3RUYWdzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkZpbHRlcn0gdHJhbnNhY3Rpb25fZmlsdGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25SZWNvcmRbXT59XG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uX2ZpbHRlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNhY3Rpb25fZmlsdGVyLCBUcmFuc2FjdGlvbkZpbHRlcik7XG4gICAgICAgIHZhciBwdHIwID0gdHJhbnNhY3Rpb25fZmlsdGVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9nZXRUcmFuc2FjdGlvbnModGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBXZWJDbGllbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gbm9kZSBVUkwgYW5kIG9wdGlvbmFsIHNlZWQuXG4gICAgICogSWYgYG5vZGVfdXJsYCBpcyBgTm9uZWAsIGl0IGRlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IGVuZHBvaW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW25vZGVfdXJsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW25vZGVfbm90ZV90cmFuc3BvcnRfdXJsXVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheSB8IG51bGx9IFtzZWVkXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgY3JlYXRlQ2xpZW50KG5vZGVfdXJsLCBub2RlX25vdGVfdHJhbnNwb3J0X3VybCwgc2VlZCkge1xuICAgICAgICB2YXIgcHRyMCA9IGlzTGlrZU5vbmUobm9kZV91cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKG5vZGVfdXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMSA9IGlzTGlrZU5vbmUobm9kZV9ub3RlX3RyYW5zcG9ydF91cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKG5vZGVfbm90ZV90cmFuc3BvcnRfdXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Mik7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUoc2VlZCkgPyAwIDogcGFzc0FycmF5OFRvV2FzbTAoc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLndlYmNsaWVudF9jcmVhdGVDbGllbnQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsaWVudCB3aXRoIHRoZSBnaXZlbiBub2RlIFVSTCwgb3B0aW9uYWwgc2VlZCwgYW5kIGV4dGVybmFsIGtleXN0b3JlXG4gICAgICogY2FsbGJhY2tzLiBJZiBgbm9kZV91cmxgIGlzIGBOb25lYCwgaXQgZGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbbm9kZV91cmxdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbbm9kZV9ub3RlX3RyYW5zcG9ydF91cmxdXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgbnVsbH0gW3NlZWRdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbiB8IG51bGx9IFtnZXRfa2V5X2NiXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBudWxsfSBbaW5zZXJ0X2tleV9jYl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgbnVsbH0gW3NpZ25fY2JdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjcmVhdGVDbGllbnRXaXRoRXh0ZXJuYWxLZXlzdG9yZShub2RlX3VybCwgbm9kZV9ub3RlX3RyYW5zcG9ydF91cmwsIHNlZWQsIGdldF9rZXlfY2IsIGluc2VydF9rZXlfY2IsIHNpZ25fY2IpIHtcbiAgICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG5vZGVfdXJsKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChub2RlX3VybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKG5vZGVfbm90ZV90cmFuc3BvcnRfdXJsKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMChub2RlX25vdGVfdHJhbnNwb3J0X3VybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjIgPSBpc0xpa2VOb25lKHNlZWQpID8gMCA6IHBhc3NBcnJheThUb1dhc20wKHNlZWQsIHdhc20uX193YmluZGdlbl9leHBvcnQpO1xuICAgICAgICB2YXIgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53ZWJjbGllbnRfY3JlYXRlQ2xpZW50V2l0aEV4dGVybmFsS2V5c3RvcmUodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIsIGlzTGlrZU5vbmUoZ2V0X2tleV9jYikgPyAwIDogYWRkSGVhcE9iamVjdChnZXRfa2V5X2NiKSwgaXNMaWtlTm9uZShpbnNlcnRfa2V5X2NiKSA/IDAgOiBhZGRIZWFwT2JqZWN0KGluc2VydF9rZXlfY2IpLCBpc0xpa2VOb25lKHNpZ25fY2IpID8gMCA6IGFkZEhlYXBPYmplY3Qoc2lnbl9jYikpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U2NyaXB0QnVpbGRlcn1cbiAgICAgKi9cbiAgICBjcmVhdGVTY3JpcHRCdWlsZGVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLndlYmNsaWVudF9jcmVhdGVTY3JpcHRCdWlsZGVyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2NyaXB0QnVpbGRlci5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgV2ViQ2xpZW50LnByb3RvdHlwZVtTeW1ib2wuZGlzcG9zZV0gPSBXZWJDbGllbnQucHJvdG90eXBlLmZyZWU7XG5cbmNvbnN0IFdvcmRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfd29yZF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBXb3JkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShXb3JkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFdvcmRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBfX3Vud3JhcChqc1ZhbHVlKSB7XG4gICAgICAgIGlmICghKGpzVmFsdWUgaW5zdGFuY2VvZiBXb3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzVmFsdWUuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBXb3JkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ193b3JkX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCaWdVaW50NjRBcnJheX0gdTY0X3ZlY1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHU2NF92ZWMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheTY0VG9XYXNtMCh1NjRfdmVjLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53b3JkX25ldyhwdHIwLCBsZW4wKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFdvcmRGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFdvcmQgZnJvbSBhIGhleCBzdHJpbmcuXG4gICAgICogRmFpbHMgaWYgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBub3QgYSB2YWxpZCBoZXggcmVwcmVzZW50YXRpb24gb2YgYSBXb3JkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGhleCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ud29yZF9mcm9tSGV4KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXb3JkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmVsdFtdfSBmZWx0X3ZlY1xuICAgICAqIEByZXR1cm5zIHtXb3JkfVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdGcm9tRmVsdHMoZmVsdF92ZWMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUpzVmFsdWVUb1dhc20wKGZlbHRfdmVjLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53b3JkX25ld0Zyb21GZWx0cyhwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uaWRfdG9IZXgocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS53b3JkX3NlcmlhbGl6ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS53b3JkX2Rlc2VyaWFsaXplKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdvcmQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0JpZ1VpbnQ2NEFycmF5fVxuICAgICAqL1xuICAgIHRvVTY0cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS53b3JkX3RvVTY0cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VTY0RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDgsIDgpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RmVsdFtdfVxuICAgICAqL1xuICAgIHRvRmVsdHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25pZF9hc0VsZW1lbnRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmIChTeW1ib2wuZGlzcG9zZSkgV29yZC5wcm90b3R5cGVbU3ltYm9sLmRpc3Bvc2VdID0gV29yZC5wcm90b3R5cGUuZnJlZTtcblxuY29uc3QgRVhQRUNURURfUkVTUE9OU0VfVFlQRVMgPSBuZXcgU2V0KFsnYmFzaWMnLCAnY29ycycsICdkZWZhdWx0J10pO1xuXG5hc3luYyBmdW5jdGlvbiBfX3diZ19sb2FkKG1vZHVsZSwgaW1wb3J0cykge1xuICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkUmVzcG9uc2UgPSBtb2R1bGUub2sgJiYgRVhQRUNURURfUkVTUE9OU0VfVFlQRVMuaGFzKG1vZHVsZS50eXBlKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWxpZFJlc3BvbnNlICYmIG1vZHVsZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT09ICdhcHBsaWNhdGlvbi93YXNtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIFdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2dldF9pbXBvcnRzKCkge1xuICAgIGNvbnN0IGltcG9ydHMgPSB7fTtcbiAgICBpbXBvcnRzLndiZyA9IHt9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX0Vycm9yX2U4Mzk4N2Y2NjVjZjU1MDQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19OdW1iZXJfYmI0OGNhMTJmMzk1Y2QwOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTnVtYmVyKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19TdHJpbmdfOGYwZWIzOWE0YTRjMmY2NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3RyaW5nKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCBwdHIxLCB0cnVlKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fYmlnaW50X2dldF9hc19pNjRfZjNlYmM1YTc1NTAwMGFmZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYmlnaW50JyA/IHYgOiB1bmRlZmluZWQ7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEJpZ0ludDY0KGFyZzAgKyA4ICogMSwgaXNMaWtlTm9uZShyZXQpID8gQmlnSW50KDApIDogcmV0LCB0cnVlKTtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCAhaXNMaWtlTm9uZShyZXQpLCB0cnVlKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fYm9vbGVhbl9nZXRfNmQ1YTFlZTY1YmFiNWY2OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYm9vbGVhbicgPyB2IDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMHhGRkZGRkYgOiByZXQgPyAxIDogMDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fZGVidWdfc3RyaW5nX2RmNDdmZmI1ZTM1ZTY3NjMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGRlYnVnU3RyaW5nKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChyZXQsIHdhc20uX193YmluZGdlbl9leHBvcnQsIHdhc20uX193YmluZGdlbl9leHBvcnQyKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCBwdHIxLCB0cnVlKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5faW5fYmI5MzNiZDllMWIzYmMwZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApIGluIGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5faXNfYmlnaW50X2NiMzIwNzA3ZGNkMzVmMGIgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnYmlnaW50JztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5faXNfZnVuY3Rpb25fZWU4YTZjNTgzM2M5MDM3NyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKGdldE9iamVjdChhcmcwKSkgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2lzX251bGxfNWU2OWY3MmU5MDZjYzU3YyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09PSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9pc19vYmplY3RfYzgxODI2MWQyMWYyODNhNCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9pc191bmRlZmluZWRfMmQ0NzI4NjJiZDI5YTQ3OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX2pzdmFsX2VxXzZiMTNhYjgzNDc4YjFjNTAgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKSA9PT0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9qc3ZhbF9sb29zZV9lcV9iNjY0YjM4YTJmNTgyMTQ3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfX193YmluZGdlbl9udW1iZXJfZ2V0X2EyMGJmOWI4NTM0MTQ0OWQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKG9iaikgPT09ICdudW1iZXInID8gb2JqIDogdW5kZWZpbmVkO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRGbG9hdDY0KGFyZzAgKyA4ICogMSwgaXNMaWtlTm9uZShyZXQpID8gMCA6IHJldCwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgIWlzTGlrZU5vbmUocmV0KSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fX3diaW5kZ2VuX3N0cmluZ19nZXRfZTRmMDZjOTA0ODlhZDAxYiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDIpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCBwdHIxLCB0cnVlKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX19fd2JpbmRnZW5fdGhyb3dfYjg1NTQ0NWZmNmE5NDI5NSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19fd2JnX2NiX3VucmVmXzI0NTRhNTM5ZWE1NzkwZDkgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5fd2JnX2NiX3VucmVmKCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hYm9ydF8yOGFkNTVjNTgyNWIwMDRkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuYWJvcnQoZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Fib3J0X2U3ZWIwNTlmNzJmOWVkMGMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5hYm9ydCgpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWNjb3VudF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFjY291bnQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWNjb3VudF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFjY291bnQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hY2NvdW50ZmlsZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFjY291bnRGaWxlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FjY291bnRoZWFkZXJfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBY2NvdW50SGVhZGVyLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FjY291bnRpZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFjY291bnRJZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hY2NvdW50aWRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBY2NvdW50SWQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hZGROb3RlVGFnXzk0OGFiNGNjN2QzZDc4NGIgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChhcmcyICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2MjtcbiAgICAgICAgaWYgKGFyZzQgIT09IDApIHtcbiAgICAgICAgICAgIHYyID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzQsIGFyZzUpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc0LCBhcmc1ICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gYWRkTm90ZVRhZyh2MCwgdjEsIHYyKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2FwcGVuZF9iNTc3ZWIzYTE3N2JjMGZhID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuYXBwZW5kKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzMsIGFyZzQpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYXBwbHlTdGF0ZVN5bmNfNjg3NDE1ZDFiY2Y0ZGQ4YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXBwbHlTdGF0ZVN5bmMoSnNTdGF0ZVN5bmNVcGRhdGUuX193cmFwKGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2F1dGhzZWNyZXRrZXlfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBBdXRoU2VjcmV0S2V5Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2JvZHlfNTg3NTQyYjJmZDhlMDZjMCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJvZHk7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYnVmZmVyX2NjYzQ1MjBiMzZkM2NjZjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5idWZmZXI7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ieW9iUmVxdWVzdF8yMzQ0ZTY5NzVmMjc0NTZlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYnlvYlJlcXVlc3Q7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYnl0ZUxlbmd0aF9iY2Q0MmU0MDI1Mjk5Nzg4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYnl0ZUxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2J5dGVPZmZzZXRfY2EzYTZjZjc5NDRiMzY0YiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ5dGVPZmZzZXQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzUyNTQ0MGY3MmZiZmMwZWEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FsbF9lNDVkMmNmOWZjOTI1ZmNmID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSwgZ2V0T2JqZWN0KGFyZzMpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2FsbF9lNzYyYzM5ZmE4ZWEzNmJmID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYW5jZWxfNDhhYjZmOWRjMzY2ZTM2OSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbmNlbCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2F0Y2hfOTQzODM2ZmFhNWQyOWJmYiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhdGNoKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jbGVhclRpbWVvdXRfMmUyYzQ5MzkzODhjZGZiYiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gY2xlYXJUaW1lb3V0KHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfY2xvc2VfNWE2Y2FlZDMyMzFiNjhjZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmNsb3NlKCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Nsb3NlXzY5NTZkZjg0NTQ3ODU2MWEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jbG9zZSgpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jb25zdW1hYmxlbm90ZXJlY29yZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IENvbnN1bWFibGVOb3RlUmVjb3JkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2RvbmVfMjA0MmFhMjY3MGZiMWRiMSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmRvbmU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19lbnF1ZXVlXzdiMThhNjUwYWVjNzc4OTggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5lbnF1ZXVlKGdldE9iamVjdChhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2V4cG9ydFN0b3JlXzEzYjUyNzRiNDUzNjcyNjkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZXhwb3J0U3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZlbHRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGZWx0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZlbHRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGZWx0Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmV0Y2hfNTNlZWY3ZGY3YjQzOWE0OSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZmV0Y2goZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZmV0Y2hfODcyNTg2NWZmNDdlN2ZjYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmZldGNoKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZldGNoZWRub3RlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRmV0Y2hlZE5vdGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZm9yY2VJbXBvcnRTdG9yZV9lNGYxNDM3ZDZiNGNmZjBlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBmb3JjZUltcG9ydFN0b3JlKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZm9yZWlnbmFjY291bnRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGb3JlaWduQWNjb3VudC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Z1bmdpYmxlYXNzZXRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGdW5naWJsZUFzc2V0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Z1bmdpYmxlYXNzZXRfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBGdW5naWJsZUFzc2V0Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZnVuZ2libGVhc3NldGRlbHRhaXRlbV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZ1bmdpYmxlQXNzZXREZWx0YUl0ZW0uX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudEFkZHJlc3Nlc181N2RjYWYwNDQwM2ZmZmY2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRBZGRyZXNzZXMoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50QXV0aEJ5UHViS2V5X2E5OTI2OGEwYzVlNzgxZmMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudEF1dGhCeVB1YktleShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRDb2RlXzI1NWM0Nzg4MDAyNzYwNGYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudENvZGUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRBY2NvdW50SGVhZGVyQnlDb21taXRtZW50XzI0NTdiMzgxMjc4YWNkOWQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWNjb3VudEhlYWRlckJ5Q29tbWl0bWVudChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRIZWFkZXJfM2UzYzBmZDE2Y2U3ODA0NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50SGVhZGVyKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudElkc18xZGMzY2M5YmViMDBkYWM0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRJZHMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRTdG9yYWdlTWFwc181MmQzOTBmNTlkMzk4NzBhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50U3RvcmFnZU1hcHModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0QWNjb3VudFN0b3JhZ2VfZTdlMzE0ZDNhOGM2ODE4OCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBnZXRBY2NvdW50U3RvcmFnZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFjY291bnRWYXVsdEFzc2V0c18wNThhYTdhM2U4NWY5ZDdlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldEFjY291bnRWYXVsdEFzc2V0cyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEFsbEFjY291bnRIZWFkZXJzXzIxYWU1OGZiZDc0YmMyMDcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0QWxsQWNjb3VudEhlYWRlcnMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldEJsb2NrSGVhZGVyc19mZmJlNjI5NDE5ZTQ5ZjI0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRCbG9ja0hlYWRlcnModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0Rm9yZWlnbkFjY291bnRDb2RlXzg0ZjgxYTlmYjI2NGIyYTggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldEZvcmVpZ25BY2NvdW50Q29kZSh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRJbnB1dE5vdGVzRnJvbUlkc19hNDgxNGZmM2VlNjgzOGY0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICBjb25zdCByZXQgPSBnZXRJbnB1dE5vdGVzRnJvbUlkcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRJbnB1dE5vdGVzRnJvbU51bGxpZmllcnNfYjEyNTE5MjUyMWNiMjcwNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0SW5wdXROb3Rlc0Zyb21OdWxsaWZpZXJzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldElucHV0Tm90ZXNfOWU3ZGFhYjNlMTFhYWRhOSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldElucHV0Tm90ZXModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0Tm90ZVNjcmlwdF84ZGI0YTg3ZjFkYWE1NzMyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldE5vdGVTY3JpcHQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXROb3RlVGFnc180NDU2NzJmYmRhNzYxN2NhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE5vdGVUYWdzKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRPdXRwdXROb3Rlc0Zyb21JZHNfYTlmOTVlZWU1YWVhMTExYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T3V0cHV0Tm90ZXNGcm9tSWRzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldE91dHB1dE5vdGVzRnJvbU51bGxpZmllcnNfMTU3MDg0MTkyMDlmMDAxNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T3V0cHV0Tm90ZXNGcm9tTnVsbGlmaWVycyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRPdXRwdXROb3Rlc183ZTkwMzRiNzg0NWQ4NTQ3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiAxLCAxKTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T3V0cHV0Tm90ZXModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlc0FsbF9mN2I5OWRhNGVjYzJjZjY3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFBhcnRpYWxCbG9ja2NoYWluTm9kZXNBbGwoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFBhcnRpYWxCbG9ja2NoYWluTm9kZXNfNGI1OWYzY2YzZDY3ODg1YSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRQYXJ0aWFsQmxvY2tjaGFpblBlYWtzQnlCbG9ja051bV9jMzY4Mzk1NGNmODcyNjAxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldFBhcnRpYWxCbG9ja2NoYWluUGVha3NCeUJsb2NrTnVtKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UmFuZG9tVmFsdWVzXzFjNjFmYWMxMTQwNWZmZGMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0UmVhZGVyXzQ4ZTAwNzQ5ZmUzZjYwODkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5nZXRSZWFkZXIoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0U2V0dGluZ18zMGQ0ODdlMjZlZDNlY2ZmID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldFNldHRpbmcoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRTeW5jSGVpZ2h0X2Y3YzRmZjAzMmQ2ZTg3MTkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0U3luY0hlaWdodCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0VGltZV8xNDc3NmJmYjQ4YTFiZmY5ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0VHJhY2tlZEJsb2NrSGVhZGVyc18wZTkyMmFmMDU0MTA5ODFiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFRyYWNrZWRCbG9ja0hlYWRlcnMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFRyYW5zYWN0aW9uc183NTExODIyZWQ3ZGY0YTA0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGdldFRyYW5zYWN0aW9ucyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldFVuc3BlbnRJbnB1dE5vdGVOdWxsaWZpZXJzX2E1M2VlMTg4N2IzMDUxMjIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0VW5zcGVudElucHV0Tm90ZU51bGxpZmllcnMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldF83YmVkMDE2ZjE4NWFkZDgxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF07XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfZG9uZV9hMDQ2M2FmNDNhMWZjNzY0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZG9uZTtcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDB4RkZGRkZGIDogcmV0ID8gMSA6IDA7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfZWZjYjQ0OWY1OGVjMjdjMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5nZXQoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfdmFsdWVfNWNlOTZjOWY4MWNlNzM5OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnZhbHVlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ2V0X3dpdGhfcmVmX2tleV8xZGMzNjFiZDEwMDUzYmZlID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMClbZ2V0T2JqZWN0KGFyZzEpXTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2dldHByb2NlZHVyZXNyZXN1bHRpdGVtX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW0uX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaGFzXzc4N2ZhZmM5ODBjM2NjZGIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJlZmxlY3QuaGFzKGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaGVhZGVyc19iODdkN2VhYmE2MWMzMjc4ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuaGVhZGVycztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lucHV0bm90ZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IElucHV0Tm90ZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnB1dG5vdGVyZWNvcmRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBJbnB1dE5vdGVSZWNvcmQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zZXJ0QWNjb3VudEFkZHJlc3NfODE5YTdhYmI1N2Q1YzUwZSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBpbnNlcnRBY2NvdW50QWRkcmVzcyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnNlcnRBY2NvdW50QXV0aF84OGZkZjFhZTljZmUwMTU1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IGFyZzI7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IGFyZzM7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBpbnNlcnRBY2NvdW50QXV0aChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIGdldFN0cmluZ0Zyb21XYXNtMChhcmcyLCBhcmczKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc2VydEJsb2NrSGVhZGVyXzVlNGMzOWE2NGFiYTk0NWQgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgdmFyIHYyID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmc0LCBhcmc1KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNCwgYXJnNSAqIDEsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gaW5zZXJ0QmxvY2tIZWFkZXIoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSwgdjIsIGFyZzYgIT09IDApO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2luc2VydFBhcnRpYWxCbG9ja2NoYWluTm9kZXNfNTEzOWNjOTcwMmZmMGE5OSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gaW5zZXJ0UGFydGlhbEJsb2NrY2hhaW5Ob2Rlcyh2MCwgdjEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zZXJ0U2V0dGluZ18xZTJmYTBkZTUyNGYyNzgyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGluc2VydFNldHRpbmcoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zZXJ0VHJhbnNhY3Rpb25TY3JpcHRfOGU1YjZkMmJjYzcwYzgyNiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIGxldCB2MTtcbiAgICAgICAgaWYgKGFyZzIgIT09IDApIHtcbiAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGluc2VydFRyYW5zYWN0aW9uU2NyaXB0KHYwLCB2MSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX0FycmF5QnVmZmVyXzcwYmViMTE4OWNhNjNiMzggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9Qcm9taXNlXzAwMWZkZDQyYWZhMWI3ZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX1VpbnQ4QXJyYXlfMjBjOGU3MzAwMmY3YWY5OCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldE9iamVjdChhcmcwKSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2lzQXJyYXlfOTZlMGFmOTg5MWQwOTQ1ZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQXJyYXkuaXNBcnJheShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXNTYWZlSW50ZWdlcl9kMjE2ZWRhNzkxMWRkZTM2ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOdW1iZXIuaXNTYWZlSW50ZWdlcihnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaXRlcmF0b3JfZTU4MjI2OTUzMjdhM2MzOSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc2FjY291bnR1cGRhdGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc0FjY291bnRVcGRhdGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanNhY2NvdW50dXBkYXRlX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNBY2NvdW50VXBkYXRlLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanNzdG9yYWdlbWFwZW50cnlfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc1N0b3JhZ2VNYXBFbnRyeS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc3N0b3JhZ2VtYXBlbnRyeV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzU3RvcmFnZU1hcEVudHJ5Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanNzdG9yYWdlc2xvdF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzU3RvcmFnZVNsb3QuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanNzdG9yYWdlc2xvdF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEpzU3RvcmFnZVNsb3QuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19qc3ZhdWx0YXNzZXRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBKc1ZhdWx0QXNzZXQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfanN2YXVsdGFzc2V0X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSnNWYXVsdEFzc2V0Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoXzY5YmNhM2NiNjRmYzg3NDggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfY2RkMjE1ZTEwZDlkZDUwNyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xpc3RTZXR0aW5nS2V5c182OTQwYmUwMWMyN2E4ZTA4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGxpc3RTZXR0aW5nS2V5cygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbG9ja0FjY291bnRfMTdlNjMwNzMzNTM0M2VhYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBsb2NrQWNjb3VudChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18wX2Y5NzQwNjg2ZDczOTAyNWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18xYWNjMGI2ZWVhODlkMDQwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld18yNTMxNzczZGFjMzhlYmIzID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzNjM2Q4NDkwNDY2ODhhNjYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUwID0ge2E6IGFyZzAsIGI6IGFyZzF9O1xuICAgICAgICAgICAgdmFyIGNiMCA9IChhcmcwLCBhcmcxKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHN0YXRlMC5hO1xuICAgICAgICAgICAgICAgIHN0YXRlMC5hID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzM2NzcoYSwgc3RhdGUwLmIsIGFyZzAsIGFyZzEpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlMC5hID0gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoY2IwKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzdGF0ZTAuYSA9IHN0YXRlMC5iID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzVhNzliZTNhYjUzYjhhYTUgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfOWVkZjk4MzhhMmRlZjM5YyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfYTc0NDJiNGIxOWMxYTM1NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfZTE3ZDlmNDMxMDViMDhiZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld19mcm9tX3NsaWNlXzkyZjRkNzhjYTI4MmEyZDIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X25vX2FyZ3NfZWU5OGVlZTUyNzUwMDBhNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEZ1bmN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfd2l0aF9ieXRlX29mZnNldF9hbmRfbGVuZ3RoXzQ2ZTNlNmE1ZTlmOWU4OWIgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSwgYXJnMSA+Pj4gMCwgYXJnMiA+Pj4gMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfd2l0aF9zdHJfYW5kX2luaXRfMGFlNzcyOGI2ZWMzNjdiMSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFJlcXVlc3QoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXh0XzAyMDgxMGUwYWU4ZWJjYjAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25leHRfMmM4MjZmZTVkZmVjNmI2YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm5leHQ7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlYW5kYXJnc191bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVBbmRBcmdzLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWNvbnN1bWFiaWxpdHlfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlQ29uc3VtYWJpbGl0eS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlY29uc3VtYWJpbGl0eV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVDb25zdW1hYmlsaXR5Ll9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWRldGFpbHNhbmR0YWdfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlRGV0YWlsc0FuZFRhZy5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlZGV0YWlsc2FuZHRhZ191bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVEZXRhaWxzQW5kVGFnLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWZpbGVfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlRmlsZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlaWRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlSWQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWlkX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZUlkLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfbm90ZWlkYW5kYXJnc191bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE5vdGVJZEFuZEFyZ3MuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub3RlcmVjaXBpZW50X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gTm90ZVJlY2lwaWVudC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25vdGVzY3JpcHRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBOb3RlU2NyaXB0Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX29wZW5EYXRhYmFzZV9mMjQyY2Q3ODJkMzAwOTE2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG9wZW5EYXRhYmFzZSgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3V0cHV0bm90ZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE91dHB1dE5vdGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3V0cHV0bm90ZV91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE91dHB1dE5vdGUuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vdXRwdXRub3Rlc191bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE91dHB1dE5vdGVzLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJvdG90eXBlc2V0Y2FsbF8yYTY2MjBiNjkyMjY5NGIyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChnZXRBcnJheVU4RnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcHJvdmVudHJhbnNhY3Rpb25fbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBQcm92ZW5UcmFuc2FjdGlvbi5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wcnVuZUlycmVsZXZhbnRCbG9ja3NfY2U1MTc0Yjg1Y2JkODNmYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBwcnVuZUlycmVsZXZhbnRCbG9ja3MoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3F1ZXVlTWljcm90YXNrXzM0ZDY5MmMyNWM0N2QwNWIgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5xdWV1ZU1pY3JvdGFzaztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3F1ZXVlTWljcm90YXNrXzlkNzZjYWNiMjBjODRkNTggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGdldE9iamVjdChhcmcwKSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZWFkXzQ4ZjE1OTNkZjU0MmY5NjggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5yZWFkKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZWxlYXNlTG9ja181ZDBiNWE2ODg4N2I4OTFkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmVsZWFzZUxvY2soKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlbW92ZUFjY291bnRBZGRyZXNzXzk0YjQ1MWZkNTQ3NmI2NzIgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICBjb25zdCByZXQgPSByZW1vdmVBY2NvdW50QWRkcmVzcyh2MCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZW1vdmVOb3RlVGFnXzU1MGIwMzg1MTY3ZjJkY2YgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDEsIDEpO1xuICAgICAgICBsZXQgdjE7XG4gICAgICAgIGlmIChhcmcyICE9PSAwKSB7XG4gICAgICAgICAgICB2MSA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2MjtcbiAgICAgICAgaWYgKGFyZzQgIT09IDApIHtcbiAgICAgICAgICAgIHYyID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzQsIGFyZzUpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc0LCBhcmc1ICogMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gcmVtb3ZlTm90ZVRhZyh2MCwgdjEsIHYyKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3JlbW92ZVNldHRpbmdfOWY1OWNiZmJlOTVmNDg0MyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zdCByZXQgPSByZW1vdmVTZXR0aW5nKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzb2x2ZV9jYWY5N2MzMGI4M2Y3MDUzID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBQcm9taXNlLnJlc29sdmUoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Jlc3BvbmRfMGY0ZGJmNTM4NmY1YzczZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJlc3BvbmQoYXJnMSA+Pj4gMCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlcmlhbGl6ZWRpbnB1dG5vdGVkYXRhX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2VyaWFsaXplZElucHV0Tm90ZURhdGEuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2VyaWFsaXplZGlucHV0bm90ZWRhdGFfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTZXJpYWxpemVkSW5wdXROb3RlRGF0YS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NlcmlhbGl6ZWRvdXRwdXRub3RlZGF0YV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXJpYWxpemVkb3V0cHV0bm90ZWRhdGFfdW53cmFwID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBTZXJpYWxpemVkT3V0cHV0Tm90ZURhdGEuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXJpYWxpemVkdHJhbnNhY3Rpb25kYXRhX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YS5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldFRpbWVvdXRfOTI5Yzk3YTdjMGYyM2QzNiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc2V0VGltZW91dChnZXRPYmplY3QoYXJnMCksIGFyZzEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzhiMzQyZDhjZDlkMmEwMmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMywgYXJnNCkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfOWU2NTE2ZGY3YjdkMGYxOSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEsIGFyZzIpKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9ib2R5XzNjMzY1OTg5NzUzZDYxZjQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5ib2R5ID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2MyMTNjODcxODU5ZDY1MDAgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKVthcmcxID4+PiAwXSA9IHRha2VPYmplY3QoYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfYzJhYmJlYmU4YjllYmVlMSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5zZXQoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9jYWNoZV8yZjlkZWIxOWI5MmI4MWUzID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuY2FjaGUgPSBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdENhY2hlW2FyZzFdO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X2NyZWRlbnRpYWxzX2Y2MjFjZDJkODVjMGMyMjggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jcmVkZW50aWFscyA9IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0Q3JlZGVudGlhbHNbYXJnMV07XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfaGVhZGVyc182OTI2ZGEyMzhjZDMyZWU0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuaGVhZGVycyA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9pbnRlZ3JpdHlfNjJhNDZmYzc5MjgzMmY0MSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmludGVncml0eSA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9tZXRob2RfYzAyZDhjYmJlMjA0YWMyZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLm1ldGhvZCA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9tb2RlXzUyZWY3M2NmYTc5NjM5Y2IgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5tb2RlID0gX193YmluZGdlbl9lbnVtX1JlcXVlc3RNb2RlW2FyZzFdO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X3JlZGlyZWN0X2RmMDI4NTQ5NmVjNDVmZjggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5yZWRpcmVjdCA9IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0UmVkaXJlY3RbYXJnMV07XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfcmVmZXJyZXJfZWM5Y2Y4YThhMzE1ZDUwYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJlZmVycmVyID0gZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0X3JlZmVycmVyX3BvbGljeV85OWMxZjI5OWI0ZTM3NDQ2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkucmVmZXJyZXJQb2xpY3kgPSBfX3diaW5kZ2VuX2VudW1fUmVmZXJyZXJQb2xpY3lbYXJnMV07XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRfc2lnbmFsX2RkYTJjZjdjY2I2YmVlMGYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zaWduYWwgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zaWduYWxfNGRiNWFhMDU1YmY5ZWI5YSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Nsb3RhbmRrZXlzX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2xvdEFuZEtleXMuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfR0xPQkFMXzg5ZTFkOWFjNmExYjI1MGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZ2xvYmFsO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU184YjUzMGYzMjZhOWU0OGFjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBnbG9iYWxUaGlzO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9TRUxGXzZmZGY0YjY0NzEwY2M5MWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHNlbGY7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX1dJTkRPV19iNDViZmM1YTM3ZjZjZmEyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0dXNfZGU3ZWVkNWE3YTViZmQ1ZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN0YXR1cztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0b3JhZ2VzbG90X3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3RvcmFnZVNsb3QuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zeW5jc3VtbWFyeV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFN5bmNTdW1tYXJ5Ll9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RoZW5fNGY0NmY2NTQ0ZTZiNGEyOCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRoZW4oZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RoZW5fNzBkMDVjZjc4MGExOGQ3NyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRoZW4oZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdG9TdHJpbmdfN2RhN2M4ZGJlYzc4ZmNiOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbmlkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gVHJhbnNhY3Rpb25JZC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbmlkX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gVHJhbnNhY3Rpb25JZC5fX3Vud3JhcCh0YWtlT2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zYWN0aW9ucmVjb3JkX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gVHJhbnNhY3Rpb25SZWNvcmQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdHJhbnNhY3Rpb25yZXN1bHRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2FjdGlvblJlc3VsdC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbnNjcmlwdGlucHV0cGFpcl91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyLl9fdW53cmFwKHRha2VPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdHJhbnNhY3Rpb25zdG9yZXVwZGF0ZV9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uU3RvcmVVcGRhdGUuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdW5kb0FjY291bnRTdGF0ZXNfZmU5ZGEzODI5MzcwMzZiZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gdW5kb0FjY291bnRTdGF0ZXModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0QWNjb3VudENvZGVfYzkzZTkxMTFiMmM3MzI3NCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRBY2NvdW50Q29kZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRBY2NvdW50UmVjb3JkXzg4ODQzZWU2YTcxY2M4YjMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3LCBhcmc4LCBhcmc5LCBhcmcxMCwgYXJnMTEsIGFyZzEyLCBhcmcxMywgYXJnMTQpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkM18wO1xuICAgICAgICBsZXQgZGVmZXJyZWQzXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDRfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkNF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQ1XzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDVfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gYXJnMjtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gYXJnMztcbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gYXJnNDtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gYXJnNTtcbiAgICAgICAgICAgIGRlZmVycmVkM18wID0gYXJnNjtcbiAgICAgICAgICAgIGRlZmVycmVkM18xID0gYXJnNztcbiAgICAgICAgICAgIGRlZmVycmVkNF8wID0gYXJnODtcbiAgICAgICAgICAgIGRlZmVycmVkNF8xID0gYXJnOTtcbiAgICAgICAgICAgIGRlZmVycmVkNV8wID0gYXJnMTE7XG4gICAgICAgICAgICBkZWZlcnJlZDVfMSA9IGFyZzEyO1xuICAgICAgICAgICAgbGV0IHY2O1xuICAgICAgICAgICAgaWYgKGFyZzEzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjYgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEzLCBhcmcxNCkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcxMywgYXJnMTQgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydEFjY291bnRSZWNvcmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMiwgYXJnMyksIGdldFN0cmluZ0Zyb21XYXNtMChhcmc0LCBhcmc1KSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzYsIGFyZzcpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnOCwgYXJnOSksIGFyZzEwICE9PSAwLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMTEsIGFyZzEyKSwgdjYpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkM18wLCBkZWZlcnJlZDNfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDRfMCwgZGVmZXJyZWQ0XzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQ1XzAsIGRlZmVycmVkNV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0QWNjb3VudFN0b3JhZ2VfNzFhZWE5ODNkOGU0NTI1MyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0QWNjb3VudFN0b3JhZ2UodjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0Rm9yZWlnbkFjY291bnRDb2RlX2EyZmZkZDBkZWI4N2MwNjMgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gYXJnNDtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gYXJnNTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydEZvcmVpZ25BY2NvdW50Q29kZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNCwgYXJnNSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDJfMCwgZGVmZXJyZWQyXzEsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ191cHNlcnRJbnB1dE5vdGVfNzczMzcwMmM0OGUyYWUxNyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcsIGFyZzgsIGFyZzksIGFyZzEwLCBhcmcxMSwgYXJnMTIsIGFyZzEzLCBhcmcxNCwgYXJnMTUsIGFyZzE2LCBhcmcxNywgYXJnMTgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDRfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkNF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQ2XzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDZfMTtcbiAgICAgICAgbGV0IGRlZmVycmVkN18wO1xuICAgICAgICBsZXQgZGVmZXJyZWQ3XzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzIsIGFyZzMpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcyLCBhcmczICogMSwgMSk7XG4gICAgICAgICAgICB2YXIgdjIgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzQsIGFyZzUpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc0LCBhcmc1ICogMSwgMSk7XG4gICAgICAgICAgICB2YXIgdjMgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzYsIGFyZzcpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0Myhhcmc2LCBhcmc3ICogMSwgMSk7XG4gICAgICAgICAgICBkZWZlcnJlZDRfMCA9IGFyZzg7XG4gICAgICAgICAgICBkZWZlcnJlZDRfMSA9IGFyZzk7XG4gICAgICAgICAgICB2YXIgdjUgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzEwLCBhcmcxMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzEwLCBhcmcxMSAqIDEsIDEpO1xuICAgICAgICAgICAgZGVmZXJyZWQ2XzAgPSBhcmcxMjtcbiAgICAgICAgICAgIGRlZmVycmVkNl8xID0gYXJnMTM7XG4gICAgICAgICAgICBkZWZlcnJlZDdfMCA9IGFyZzE0O1xuICAgICAgICAgICAgZGVmZXJyZWQ3XzEgPSBhcmcxNTtcbiAgICAgICAgICAgIHZhciB2OCA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMTcsIGFyZzE4KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMTcsIGFyZzE4ICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRJbnB1dE5vdGUoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSwgdjIsIHYzLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnOCwgYXJnOSksIHY1LCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMTIsIGFyZzEzKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzE0LCBhcmcxNSksIGFyZzE2LCB2OCk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkNF8wLCBkZWZlcnJlZDRfMSwgMSk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDZfMCwgZGVmZXJyZWQ2XzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQ3XzAsIGRlZmVycmVkN18xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0Tm90ZVNjcmlwdF8zYzU2OWE2NzNlZmYyMWM5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVwc2VydE5vdGVTY3JpcHQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCB2MSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0T3V0cHV0Tm90ZV8xYTljNmI4MGJjM2IyOTc5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNywgYXJnOCwgYXJnOSwgYXJnMTAsIGFyZzExLCBhcmcxMiwgYXJnMTMpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMl8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWQwXzAgPSBhcmcwO1xuICAgICAgICAgICAgZGVmZXJyZWQwXzEgPSBhcmcxO1xuICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcyLCBhcmczKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMiwgYXJnMyAqIDEsIDEpO1xuICAgICAgICAgICAgZGVmZXJyZWQyXzAgPSBhcmc0O1xuICAgICAgICAgICAgZGVmZXJyZWQyXzEgPSBhcmc1O1xuICAgICAgICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmc2LCBhcmc3KS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnNiwgYXJnNyAqIDEsIDEpO1xuICAgICAgICAgICAgbGV0IHY0O1xuICAgICAgICAgICAgaWYgKGFyZzggIT09IDApIHtcbiAgICAgICAgICAgICAgICB2NCA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmc4LCBhcmc5KS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzgsIGFyZzkgKiAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2NSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMTIsIGFyZzEzKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMTIsIGFyZzEzICogMSwgMSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRPdXRwdXROb3RlKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSwgdjEsIGdldFN0cmluZ0Zyb21XYXNtMChhcmc0LCBhcmc1KSwgdjMsIHY0LCBhcmcxMCA+Pj4gMCwgYXJnMTEsIHY1KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhkZWZlcnJlZDBfMCwgZGVmZXJyZWQwXzEsIDEpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQyXzAsIGRlZmVycmVkMl8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0U3RvcmFnZU1hcEVudHJpZXNfNTdkYTczNGNiZWU0NDhiZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgY29uc3QgcmV0ID0gdXBzZXJ0U3RvcmFnZU1hcEVudHJpZXModjApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdXBzZXJ0VHJhbnNhY3Rpb25SZWNvcmRfZTRhOGIwNWYxYjM3MTRlYSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcsIGFyZzgsIGFyZzksIGFyZzEwKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8xO1xuICAgICAgICBsZXQgZGVmZXJyZWQyXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDJfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnMiwgYXJnMykuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzIsIGFyZzMgKiAxLCAxKTtcbiAgICAgICAgICAgIGRlZmVycmVkMl8wID0gYXJnNDtcbiAgICAgICAgICAgIGRlZmVycmVkMl8xID0gYXJnNTtcbiAgICAgICAgICAgIHZhciB2MyA9IGdldEFycmF5VThGcm9tV2FzbTAoYXJnNywgYXJnOCkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzcsIGFyZzggKiAxLCAxKTtcbiAgICAgICAgICAgIGxldCB2NDtcbiAgICAgICAgICAgIGlmIChhcmc5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdjQgPSBnZXRBcnJheVU4RnJvbVdhc20wKGFyZzksIGFyZzEwKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzksIGFyZzEwICogMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXQgPSB1cHNlcnRUcmFuc2FjdGlvblJlY29yZChnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSksIHYxLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnNCwgYXJnNSksIGFyZzYsIHYzLCB2NCk7XG4gICAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGRlZmVycmVkMl8wLCBkZWZlcnJlZDJfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Vwc2VydFZhdWx0QXNzZXRzX2NlNTQ5ZWRlNDQ1N2RmNmUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHVwc2VydFZhdWx0QXNzZXRzKHYwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZhbHVlXzY5MjYyNzMwOTgxNGJiOGMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3ZpZXdfZjZjMTVhYzlmZWQ2M2JiZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnZpZXc7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfd29yZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFdvcmQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfd29yZF91bndyYXAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFdvcmQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfMWZmMzBjODlmOGMxM2Q0YiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoTmFtZWRFeHRlcm5yZWYoXCJUcmFuc2FjdGlvblJlY29yZFwiKSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfMjI0MWI2YWY0YzRiMjk0MSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBSZWYoU3RyaW5nKSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfMjVhMGE4NDQ0MzdkMGU5MiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlKc1ZhbHVlRnJvbVdhc20wKGFyZzAsIGFyZzEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnQzKGFyZzAsIGFyZzEgKiA0LCA0KTtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBWZWN0b3IoTmFtZWRFeHRlcm5yZWYoXCJzdHJpbmdcIikpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzI5OGRmZDk5OTk4ZjFiYmYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKE5hbWVkRXh0ZXJucmVmKFwiQ29uc3VtYWJsZU5vdGVSZWNvcmRcIikpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzMxODYxNDRmMzAxNGE2ZTkgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKE5hbWVkRXh0ZXJucmVmKFwiRmV0Y2hlZE5vdGVcIikpIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IHYwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzM1NmE2NDljNzZlYTNkNGEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgQ2xvc3VyZShDbG9zdXJlIHsgZHRvcl9pZHg6IDUxNiwgZnVuY3Rpb246IEZ1bmN0aW9uIHsgYXJndW1lbnRzOiBbXSwgc2hpbV9pZHg6IDUxNywgcmV0OiBVbml0LCBpbm5lcl9yZXQ6IFNvbWUoVW5pdCkgfSwgbXV0YWJsZTogdHJ1ZSB9KSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCB3YXNtLl9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85MzA4LCBfX3dhc21fYmluZGdlbl9mdW5jX2VsZW1fOTMwOSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfNDYyNWM1NzdhYjJlYzllZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBVNjQgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gQmlnSW50LmFzVWludE4oNjQsIGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYXN0XzYxMTgwY2YyZGE1NTgwZGMgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHZhciB2MCA9IGdldEFycmF5SnNWYWx1ZUZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogNCwgNCk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKE5hbWVkRXh0ZXJucmVmKFwiQWNjb3VudEhlYWRlclwiKSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfNzdiYzNlOTI3NDVlOWEzNSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgdmFyIHYwID0gZ2V0QXJyYXlVOEZyb21XYXNtMChhcmcwLCBhcmcxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0MyhhcmcwLCBhcmcxICogMSwgMSk7XG4gICAgICAgIC8vIENhc3QgaW50cmluc2ljIGZvciBgVmVjdG9yKFU4KSAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSB2MDtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF9hMGM5Yzk3OTkzODUxNjcyID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdjAgPSBnZXRBcnJheUpzVmFsdWVGcm9tV2FzbTAoYXJnMCwgYXJnMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydDMoYXJnMCwgYXJnMSAqIDQsIDQpO1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYFZlY3RvcihOYW1lZEV4dGVybnJlZihcIklucHV0Tm90ZVJlY29yZFwiKSkgLT4gRXh0ZXJucmVmYC5cbiAgICAgICAgY29uc3QgcmV0ID0gdjA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2Nhc3RfYzg4NzM4NzE2NjM4MjlkZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgLy8gQ2FzdCBpbnRyaW5zaWMgZm9yIGBDbG9zdXJlKENsb3N1cmUgeyBkdG9yX2lkeDogNTE2LCBmdW5jdGlvbjogRnVuY3Rpb24geyBhcmd1bWVudHM6IFtFeHRlcm5yZWZdLCBzaGltX2lkeDogNTIxLCByZXQ6IFVuaXQsIGlubmVyX3JldDogU29tZShVbml0KSB9LCBtdXRhYmxlOiB0cnVlIH0pIC0+IEV4dGVybnJlZmAuXG4gICAgICAgIGNvbnN0IHJldCA9IG1ha2VNdXRDbG9zdXJlKGFyZzAsIGFyZzEsIHdhc20uX193YXNtX2JpbmRnZW5fZnVuY19lbGVtXzkzMDgsIF9fd2FzbV9iaW5kZ2VuX2Z1bmNfZWxlbV85Mzc1KTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fY2FzdF9kNmNkMTliODE1NjBmZDZlID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICAvLyBDYXN0IGludHJpbnNpYyBmb3IgYEY2NCAtPiBFeHRlcm5yZWZgLlxuICAgICAgICBjb25zdCByZXQgPSBhcmcwO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgdGFrZU9iamVjdChhcmcwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgIF9fd2JnX2luaXQuX193YmluZGdlbl93YXNtX21vZHVsZSA9IG1vZHVsZTtcbiAgICBjYWNoZWRCaWdVaW50NjRBcnJheU1lbW9yeTAgPSBudWxsO1xuICAgIGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9IG51bGw7XG4gICAgY2FjaGVkVWludDMyQXJyYXlNZW1vcnkwID0gbnVsbDtcbiAgICBjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9IG51bGw7XG5cblxuXG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAoe21vZHVsZX0gPSBtb2R1bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd1c2luZyBkZXByZWNhdGVkIHBhcmFtZXRlcnMgZm9yIGBpbml0U3luYygpYDsgcGFzcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW1wb3J0cyA9IF9fd2JnX2dldF9pbXBvcnRzKCk7XG5cbiAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpKSB7XG4gICAgICAgIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9fd2JnX2luaXQobW9kdWxlX29yX3BhdGgpIHtcbiAgICBpZiAod2FzbSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gd2FzbTtcblxuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGVfb3JfcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfb3JfcGF0aCkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICh7bW9kdWxlX29yX3BhdGh9ID0gbW9kdWxlX29yX3BhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd1c2luZyBkZXByZWNhdGVkIHBhcmFtZXRlcnMgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBmdW5jdGlvbjsgcGFzcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBjb25zdCBpbXBvcnRzID0gX193YmdfZ2V0X2ltcG9ydHMoKTtcblxuICAgIGlmICh0eXBlb2YgbW9kdWxlX29yX3BhdGggPT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGVfb3JfcGF0aCBpbnN0YW5jZW9mIFJlcXVlc3QpIHx8ICh0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZV9vcl9wYXRoIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBtb2R1bGVfb3JfcGF0aCA9IGZldGNoKG1vZHVsZV9vcl9wYXRoKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IF9fd2JnX2xvYWQoYXdhaXQgbW9kdWxlX29yX3BhdGgsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmNvbnN0IG1vZHVsZSA9IG5ldyBVUkwoXCJhc3NldHMvbWlkZW5fY2xpZW50X3dlYi53YXNtXCIsIGltcG9ydC5tZXRhLnVybCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IF9fd2JnX2luaXQoeyBtb2R1bGVfb3JfcGF0aDogbW9kdWxlIH0pO1xuXG5leHBvcnQgeyBBY2NvdW50LCBBY2NvdW50QXJyYXksIEFjY291bnRCdWlsZGVyLCBBY2NvdW50QnVpbGRlclJlc3VsdCwgQWNjb3VudENvZGUsIEFjY291bnRDb21wb25lbnQsIEFjY291bnREZWx0YSwgQWNjb3VudEZpbGUsIEFjY291bnRIZWFkZXIsIEFjY291bnRJZCwgQWNjb3VudElkQXJyYXksIEFjY291bnRJbnRlcmZhY2UsIEFjY291bnRTdG9yYWdlLCBBY2NvdW50U3RvcmFnZURlbHRhLCBBY2NvdW50U3RvcmFnZU1vZGUsIEFjY291bnRTdG9yYWdlUmVxdWlyZW1lbnRzLCBBY2NvdW50VHlwZSwgQWNjb3VudFZhdWx0RGVsdGEsIEFkZHJlc3MsIEFkdmljZUlucHV0cywgQWR2aWNlTWFwLCBBc3NldFZhdWx0LCBBdXRoU2VjcmV0S2V5LCBCYXNpY0Z1bmdpYmxlRmF1Y2V0Q29tcG9uZW50LCBCbG9ja0hlYWRlciwgQ29uc3VtYWJsZU5vdGVSZWNvcmQsIEVuZHBvaW50LCBFeGVjdXRlZFRyYW5zYWN0aW9uLCBGZWx0LCBGZWx0QXJyYXksIEZldGNoZWROb3RlLCBGbGF0dGVuZWRVOFZlYywgRm9yZWlnbkFjY291bnQsIEZvcmVpZ25BY2NvdW50QXJyYXksIEZ1bmdpYmxlQXNzZXQsIEZ1bmdpYmxlQXNzZXREZWx0YSwgRnVuZ2libGVBc3NldERlbHRhSXRlbSwgR2V0UHJvY2VkdXJlc1Jlc3VsdEl0ZW0sIElucHV0Tm90ZSwgSW5wdXROb3RlUmVjb3JkLCBJbnB1dE5vdGVTdGF0ZSwgSW5wdXROb3RlcywgSW50b1VuZGVybHlpbmdCeXRlU291cmNlLCBJbnRvVW5kZXJseWluZ1NpbmssIEludG9VbmRlcmx5aW5nU291cmNlLCBKc0FjY291bnRVcGRhdGUsIEpzU3RhdGVTeW5jVXBkYXRlLCBKc1N0b3JhZ2VNYXBFbnRyeSwgSnNTdG9yYWdlU2xvdCwgSnNWYXVsdEFzc2V0LCBMaWJyYXJ5LCBNZXJrbGVQYXRoLCBOZXR3b3JrSWQsIE5vdGUsIE5vdGVBbmRBcmdzLCBOb3RlQW5kQXJnc0FycmF5LCBOb3RlQXNzZXRzLCBOb3RlQ29uc3VtYWJpbGl0eSwgTm90ZURldGFpbHMsIE5vdGVEZXRhaWxzQW5kVGFnLCBOb3RlRGV0YWlsc0FuZFRhZ0FycmF5LCBOb3RlRXhlY3V0aW9uSGludCwgTm90ZUV4ZWN1dGlvbk1vZGUsIE5vdGVGaWxlLCBOb3RlRmlsdGVyLCBOb3RlRmlsdGVyVHlwZXMsIE5vdGVIZWFkZXIsIE5vdGVJZCwgTm90ZUlkQW5kQXJncywgTm90ZUlkQW5kQXJnc0FycmF5LCBOb3RlSW5jbHVzaW9uUHJvb2YsIE5vdGVJbnB1dHMsIE5vdGVMb2NhdGlvbiwgTm90ZU1ldGFkYXRhLCBOb3RlUmVjaXBpZW50LCBOb3RlUmVjaXBpZW50QXJyYXksIE5vdGVTY3JpcHQsIE5vdGVUYWcsIE5vdGVUeXBlLCBPdXRwdXROb3RlLCBPdXRwdXROb3RlQXJyYXksIE91dHB1dE5vdGVzLCBPdXRwdXROb3Rlc0FycmF5LCBQYWNrYWdlLCBQYXJ0aWFsTm90ZSwgUHJvdmVuVHJhbnNhY3Rpb24sIFB1YmxpY0tleSwgUnBjQ2xpZW50LCBScG8yNTYsIFNjcmlwdEJ1aWxkZXIsIFNlY3JldEtleSwgU2VyaWFsaXplZElucHV0Tm90ZURhdGEsIFNlcmlhbGl6ZWRPdXRwdXROb3RlRGF0YSwgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YSwgU2lnbmF0dXJlLCBTaWduaW5nSW5wdXRzLCBTaWduaW5nSW5wdXRzVHlwZSwgU2xvdEFuZEtleXMsIFN0b3JhZ2VNYXAsIFN0b3JhZ2VTbG90LCBTdG9yYWdlU2xvdEFycmF5LCBTeW5jU3VtbWFyeSwgVGVzdFV0aWxzLCBUb2tlblN5bWJvbCwgVHJhbnNhY3Rpb25BcmdzLCBUcmFuc2FjdGlvbkZpbHRlciwgVHJhbnNhY3Rpb25JZCwgVHJhbnNhY3Rpb25Qcm92ZXIsIFRyYW5zYWN0aW9uUmVjb3JkLCBUcmFuc2FjdGlvblJlcXVlc3QsIFRyYW5zYWN0aW9uUmVxdWVzdEJ1aWxkZXIsIFRyYW5zYWN0aW9uUmVzdWx0LCBUcmFuc2FjdGlvblNjcmlwdCwgVHJhbnNhY3Rpb25TY3JpcHRJbnB1dFBhaXIsIFRyYW5zYWN0aW9uU2NyaXB0SW5wdXRQYWlyQXJyYXksIFRyYW5zYWN0aW9uU3RhdHVzLCBUcmFuc2FjdGlvblN0b3JlVXBkYXRlLCBUcmFuc2FjdGlvblN1bW1hcnksIFdlYkNsaWVudCwgV29yZCwgaW5pdFN5bmMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhcmdvLWFjYmQ4YWM1LWFjYmQ4YWM1LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/workers/Cargo-acbd8ac5-acbd8ac5.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@demox-labs/miden-sdk/dist/workers/assets/miden_client_web.wasm":
/*!**************************************************************************************!*\
  !*** ./node_modules/@demox-labs/miden-sdk/dist/workers/assets/miden_client_web.wasm ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/miden_client_web.1c58f26d.wasm";

/***/ })

}]);